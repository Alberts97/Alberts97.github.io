<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python练习——Codeforces题目]]></title>
    <url>%2Fpython-practice%2F</url>
    <content type="text"><![CDATA[A. Way Too Long Words链接：http://codeforces.com/contest/71/problem/A 题意：将长度超过10的字符串进行缩写，缩写规则是保留头尾两字符，中间部分用它的长度来代替。 代码： 12345678n = int(input())while n &gt; 0: n -= 1 s = input() if len(s) &lt;= 10: print(s) else: print(s[0] + str(len(s) - 2) + s[-1]) B. Next Round链接：http://codeforces.com/contest/158/problem/A 题意：以非递增的顺序给出$n$个选手的得分，求得分$\ge$第$k$个选手且得分为正整数的选手数量。 代码：新学会使用列表存取数据 123456789n, k = map(int, input().split())a = list(map(int, input().split()))cnt = 0for i in range(len(a)): if a[i] &gt;= a[k - 1] and a[i] &gt; 0: cnt += 1 else: breakprint(cnt) C. String Task链接：http://codeforces.com/contest/118/problem/A 题意：给出一个字符串，将其中的”A”, “O”, “Y”, “E”, “U”, “I”删除，将剩余字母变为小写，在每个字母前加一个”.”。 代码：Amazing！ input.lower()：将输入的字符串中的大写字母转化为小写。 .join()： 连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串。语法：str.join(sequence)，返回通过指定字符连接序列中元素后生成的新字符串。 123str = '-'seq = ('a', 'b', 'c')print(str.join(seq)) not in：判断是否不在集合中。 1print(''.join('.' + i for i in input().lower() if i not in 'aoyeui')) D. Team链接：http://codeforces.com/contest/231/problem/A 题意：$n$组数字，每组有$3$个，只包含$0$或$1$。求出现数字$\ge2$个$1$的数字组数。 代码： 1234567891011n = int(input())res = 0for _ in range(n): c = list(map(int, input().split())) t = 0 for i in c: if i == 1: t += 1 if t &gt;= 2: res += 1print(res) E. Domino piling链接：http://codeforces.com/contest/50/problem/A 题意：在一个$N \times M$的棋盘上放大小为$2 \times 1$的牌，牌可以横着放，但不允许有重叠。问这个棋盘上最多可以放多少牌。 代码： 12n, m = map(int, input().split())print(n * m // 2) F. Bit++链接：http://codeforces.com/contest/282/problem/A 题意：给出$n$个长度为$3$的表达式，表达式中只包含++、--和x，初始时$x$值为$0$，求经过$n$个操作后结果是多少。 代码： 123456789res = 0n = int(input())for i in range(n): s = input() if '+' in s: res += 1 else: res -= 1print(res) G. Petya and Strings链接：http://codeforces.com/contest/112/problem/A 题意：给出两个字符串，忽略他们的大小进行比较。 代码： 12345678a = input().lower()b = input().lower()if a &gt; b: print(1)elif a &lt; b: print(-1)else: print(0) H. Football链接：http://codeforces.com/contest/96/problem/A 题意：检查给出的字符串中是否包含连续的$7$个$0$或$7$个$1$。 代码： 12t = input()print(['YES', 'NO'][7 * '0' not in t and 7 * '1' not in t]) I. Helpful Maths链接：http://codeforces.com/contest/339/problem/A 题意：给出一个只包含数字1、2、3和+号的表达式，将它重新表示为数字升序的加法。 代码：input()[::2]：以增量为$2$读取数据。 1print('+'.join(sorted(input()[::2]))) J. Beautiful Matrix链接：http://codeforces.com/contest/263/problem/A 题意：在一个$5 \times 5$的矩阵中有$24$个$0$和$1$个$1$，每次操作都可以将$1$与周围相邻的$0$交换位置，问最少经过多少次交换可以使$1$到中间。 代码： 12345for i in range(5): t = input().split() for j in range(5): if t[j] == '1': print(abs(i - 2) + abs(j - 2)) K. Word Capitalization链接：http://codeforces.com/contest/281/problem/A 题意：将给出的字母首字母变为大写。 代码： 12t = input()print(t[0].upper() + t[1:]) L. Stones on the Table链接：http://codeforces.com/contest/266/problem/A 题意：找出字符串总相邻字符相同的个数。 代码： 1234567n = int(input())t = input()res = 0for i in range(n - 1): if t[i] == t[i + 1]: res += 1print(res) M. Boy or Girl链接：http://codeforces.com/contest/236/problem/A 题意：判断字符串中不同单词的数量是偶数还是奇数。 代码：set去重。 1print('IGNORE HIM!' if len(set(input())) % 2 else 'CHAT WITH HER!') N. Young Physicist链接：http://codeforces.com/contest/69/problem/A 题意：判断$n$个三元组的每一元的和是否都是$0$。 代码：太棒了，学到好多！ any()：用于判断给定的可迭代参数iterable是否全部为False，如果有一个为True，则返回True。语法：any(iterable)，返回True或False。 1234567print(any(['a', 'b', 'c', 'd']))print(any(['a', 'b', '', 'd']))print(any([0, '', False]))print(any(('a', 'b', 'c', 'd')))print(any(('a', 'b', '', 'd')))print(any((0, '', False)))print(any([])) zip()：用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。如果各个迭代器的的元素个数不一致，则返回列表长度与最短的对象相同，利用*号操作符可以将元组解压为列表。语法：zip([iterable, ...])，返回元组列表。 123456a = [1, 2, 3]b = [4, 5, 6]c = [4, 5, 6, 7, 8]zipped1 = zip(a, b) # [(1, 4), (2, 5), (3, 6)] 打包为元组的列表zipped2 = zip(a, c) # [(1, 4), (2, 5), (3, 6)] 元素个数与最短的列表一致zip(*zipped1) # [(1, 2, 3), (4, 5, 6)] *zip可理解为解压，返回二维矩阵式 map()：根据提供的函数对指定序列做映射，第一个参数function以参数序列中的每一个元素调用function函数，返回包含每次function函数返回值的新列表。语法：map(function, iterable, ...)，返回迭代器。 12map(int, input().split())map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用lambda匿名函数计算列表各元素的平方 1print('NO' if any(map(sum, zip(*[map(int, input().split()) for i in range(int(input()))]))) else 'YES') O. Chat room链接：http://codeforces.com/contest/58/problem/A 题意：判断给出的字符串是否可以通过删除部分字符得到hello。 代码： iter()：用来生成迭代器。语法：iter(object[, sentinel])，返回迭代器对象。 all()：用于判定给定的可迭代参数iterable中的所有元素是否否为True，如果是返回True，否则返回False。元素除了0、空、None、False外都算True。语法：all(iterable)，返回True或False。 12s = iter(input())print('YES' if all([c in s for c in 'hello']) else 'NO') P. Lucky Division链接：http://codeforces.com/contest/122/problem/A 题意：判断$n$能否被只包含$4$和$7$构成的数字整除。 代码： 12n = int(input())print('YES' if any(n % i == 0 for i in [4, 7, 47, 74, 444, 447, 474, 477, 744, 747, 774, 777]) else 'NO') Q. Taxi链接：http://codeforces.com/contest/158/problem/B 题意：一辆车最多乘$4$人，现有$n$队人，每队人有$1/2/3/4$个人，同队的人要坐同一辆车，同一辆车可以同时坐多队人。问最少需要多少辆车。 代码：count()：用于统计字符串里某个字符出现的次数。语法：str.count(sub, start = 0, end = len(string))，返回子字符串在字符串中出现的次数。 123input()a, b, c, d = map(input().count, ('1', '2', '3', '4'))print(c + d + (b * 2 + max(0, a - c) + 3) // 4) R. Little Artem链接：https://codeforces.com/contest/1333/problem/A 题意：在一个$n \times m$的画板上，将一部分块涂黑，另一部分涂白，要求至少有一个边与白块相邻的黑块个数恰好比至少有一个边与黑块相邻的白块的个数多一个。 代码： 1234567t = int(input())for _ in range(t): n, m = map(int, input().split()) print('W', end = '') print('B' * (m - 1)) for i in range(n - 1): print('B' * m) S. Erasing Zeroes链接：https://codeforces.com/contest/1303/problem/A 题意：删除一个$01$字符串中最少个数的$0$，使得$1$连续。 代码：strip()：用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。语法“str.strip([chars])，只可删除开头或是结尾的字符，不能删除中间部分的字符。 12for i in range(int(input())): print(input().strip('0').count('0'))]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Competition Between SDNU_ICPC and MMSys_Laboratory(06-24)【解题报告】]]></title>
    <url>%2Fsdnu-2020-1%2F</url>
    <content type="text"><![CDATA[前言：由于OJ服务器时间比北京时间快了9min50s，导致比赛正式开始前已经可以看题目了，在队员发现时部分人已经AC了第一道签到题。 重新出题已经来不及了，只好将比赛隐藏又重新开了一场，题目不变，开始时间改回了北京时间19:00。（由此明白了考试备用试卷存在的原因？ 没想到比赛还没正式开始就出锅了，对于造成的不便深表歉意。 题解：说明：比赛题目已在OJ公开，PIDs为1591~1598。 这场比赛整体来看难度不大，在中场的时候所有题目就都有人AC了，最终还有一人AK。 下面每道题的“题解”都是按照题目被拿走FB的顺序写的，由于题面并不难懂，且数据都会发送给大家，所以下列“题解”省去题目大意和解题思路，只保留实况记录和AC代码，如果发现一切相关问题可及时与我联系。 1591、Welcome to SDNU【签到】【输出字符串】直接打印字符串的签到题，00:00:27被QLUmahongru拿走一血。 AcCode：（Python） 1print("Hello SDNU!") 1592、easy problem【线性基】【裸题】线性基模板题，没什么好说的，00:03:56被2018lihaoran拿走一血。 AcCode： 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; int n; ll p[60],a[100000]; void insert(ll v) &#123; for(int i=52;i&gt;=0;--i) &#123; if((1ll&lt;&lt;i)&amp;v) &#123; if(p[i]) v^=p[i]; else &#123; p[i]=v; return; &#125; &#125; &#125;&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%lld",&amp;a[i]),insert(a[i]); ll ans=0; for(int i=52;i&gt;=0;--i) &#123; if(p[i]) ans=max(ans,ans^p[i]); &#125; printf("%lld\n",ans); return 0; &#125; 1594、a - b【签到】【大数】计算大数幂之差，00:08:04被20WangChuntao拿走一血。 AcCode：（Python） 1234567while 1: try: a, b = input().split() a, b = int(a), int(b) print(pow(a, b) - pow(b, a)) except: break 1595、矩阵链乘【栈】【表达式解析】考察用栈模拟表达式，为了简化题目，已经保证表达式中的字母均在第一部分出现过，进行相乘的矩阵已用括号括起来，且括号符合匹配规则。00:22:08被sunchenxi_QLU2019拿走一血。 AcCode： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;stack&gt;using namespace std;string ex;char op[6];int n, x, y, k;struct Matrix&#123; int a, b; Matrix(int a = 0, int b = 0) : a(a), b(b) &#123;&#125;&#125; m[26];stack&lt;Matrix&gt; s;int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", op); k = op[0] - 'A'; scanf("%d%d", &amp;m[k].a, &amp;m[k].b); &#125; while(cin &gt;&gt; ex) &#123; int len = ex.size(); bool f = false; int ans = 0; for(int i = 0; i &lt; len; ++i) &#123; if(isalpha(ex[i])) s.push(m[ex[i]-'A']); else if(ex[i] == ')') &#123; Matrix m2 = s.top(); s.pop(); Matrix m1 = s.top(); s.pop(); if(m1.b != m2.a) &#123; f = true; break; &#125; ans += m1.a * m1.b * m2.b; s.push(Matrix(m1.a, m2.b)); &#125; &#125; if(f) puts("error"); else printf("%d\n", ans); &#125; return 0;&#125; 1593、No one knows ACM better than me【签到】【打印图形】模拟签到题，00:33:50被2018lihaoran拿走一血。两个一血了啊，不愧是你，浩然！ AcCode: 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = (int)1e3;const int inf = 0x3f3f3f3f;const ll mod = (ll)1e9 + 7;const double eps = 1e-6;char s[200][10000];void work(int n)&#123; for(int i = 0; i &lt;= n; ++i) for(int j = 0; j &lt; 50 * n; ++j) s[i][j] = ' '; for(int i = 1; i &lt;= n; ++i) s[i][n - i] = '/'; for(int i = 1; i &lt;= n - 2; ++i) s[n / 2][n - n / 2 + i] = '_'; for(int i = 1; i &lt;= n; ++i) s[i][n + i - 1] = '\\'; for(int i = 1; i &lt;= n; ++i) s[0][2 * n + 2 + i] = '_'; s[0][2 * n + 2 + n + 1] = '\0'; for(int i = 1; i &lt;= n; ++i) s[i][2 * n + 2] = '|'; for(int i = 1; i &lt;= n; ++i) s[n][2 * n + 2 + i] = '_'; for(int i = 1; i &lt;= n; ++i) s[i][3 * n + 5] = '|'; for(int i = 1; i &lt;= n; ++i) s[i][3 * n + 5 + i] = '\\'; for(int i = 1; i &lt;= n; ++i) s[i][5 * n + 6 - i] = '/'; for(int i = 1; i &lt;= n; ++i) s[i][5 * n + 6] = '|', s[i][5 * n + 7] = '\0';&#125;int main()&#123; int n; while(~scanf("%d", &amp;n)) &#123; work(n); for(int i = 0; i &lt;= n; ++i) printf("%s\n", s[i]); &#125; return 0;&#125; 1596、有手就行【模拟】【26进制】恶心模拟题，再次被2018lihaoran于01:23:12拿走一血。 AcCode： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 100020;const int Q = 1e9 + 7;int n, L;int num[26][N];int power[N], sum[N];bool ban[26];char str[N];int a[26];bool cmp(int A, int B)&#123; for (int i = L - 1 ; i &gt;= 0 ; -- i) &#123; if (num[A][i] != num[B][i]) &#123; return num[A][i] &lt; num[B][i]; &#125; &#125; return 0;&#125;void work()&#123; memset(num, 0, sizeof(num)); memset(ban, 0, sizeof(ban)); memset(sum, 0, sizeof(sum)); L = 0; for (int i = 0 ; i &lt; n ; ++ i) &#123; scanf("%s", str); int len = strlen(str); if (len &gt; 1) &#123; ban[str[0] - 'a'] = 1; &#125; reverse(str, str + len); for (int j = 0 ; j &lt; len ; ++ j) &#123; ++ num[str[j] - 'a'][j]; sum[str[j] - 'a'] += power[j]; if (sum[str[j] - 'a'] &gt;= Q) &#123; sum[str[j] - 'a'] -= Q; &#125; &#125; L = max(L, len); &#125; for (int i = 0 ; i &lt; 26 ; ++ i) &#123; for (int j = 0 ; j &lt; L ; ++ j) &#123; num[i][j + 1] += num[i][j] / 26; num[i][j] %= 26; &#125; while (num[i][L]) &#123; num[i][L + 1] += num[i][L] / 26; num[i][L ++] %= 26; &#125; a[i] = i; &#125; sort(a, a + 26, cmp); int zero = -1; for (int i = 0 ; i &lt; 26 ; ++ i) &#123; if (!ban[a[i]]) &#123; zero = a[i]; break; &#125; &#125; int res = 0, x = 25; for (int i = 25 ; i &gt;= 0 ; -- i) &#123; if (a[i] != zero) &#123; res += (LL)(x --) * sum[a[i]] % Q; res %= Q; &#125; &#125; static int ca = 0; printf("Case #%d: %d\n", ++ ca, res);&#125;int main()&#123; power[0] = 1; for (int i = 1 ; i &lt; N ; ++ i) &#123; power[i] = (LL)power[i - 1] * 26 % Q; &#125; while (~scanf("%d", &amp;n)) &#123; work(); &#125; return 0;&#125; 1598、多人运动【组合数学】【快速幂】再次出锅，题面把B组和C组描述反了，对不起！最后被浩然发现，浩然还是强啊。 虽然题面出锅，但并不影响老将对题目的理解凭借丰厚的参赛经验，这道题在01:32:15被2017liuyidi拿走一血，闷声发大财，知道题目有问题也不和我反馈一下（记仇.jpg）。 AcCode： 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = (int)1e5;const int inf = 0x3f3f3f3f;const ll mod = (ll)998244353;const double eps = 1e-6;ll quick(ll a, ll b, ll c = mod)&#123; ll s = 1; while(b) &#123; if(b &amp; 1) s = s * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return s;&#125;int main()&#123;// freopen("input.txt", "r", stdin); int T; scanf("%d", &amp;T); while(T--) &#123; int a, b, c, d; scanf("%d %d %d %d", &amp;a, &amp;b, &amp;c, &amp;d); swap(b, c); ll s = (((c + d + 1) * quick(2, a + b) % mod + quick(2, a + c) - (c + 1) * quick(2, a) % mod) % mod + mod) % mod; printf("%lld\n", s); &#125; return 0;&#125; 1597、神秘监考【规律】【循环节】找规律的题目，01:34:53又又又被2018lihaoran拿走一血！下面代码的注释中包含了浩然的解题思路。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = (int)1e5;const int inf = 0x3f3f3f3f;const ll mod = (ll)1e9 + 7;const double eps = 1e-6;/**未监控： 1 2 3 5已监控： 4监控序列：1 2 3 4 5 1 2 3 4 1 2 3 5 1 2 3 4n = 4: 1 2 3 4 [1 2 3 1 2 4]n = 5: 1 2 3 4 5 [1 2 3 4 1 2 3 5]**/int main()&#123;// freopen("input.txt", "r", stdin); int ca = 0; ll n, k; while(~scanf("%lld %lld", &amp;n, &amp;k)) &#123; printf("Case #%d: ", ++ca); if(k &lt;= n) printf("%lld\n", k); else &#123; k = (k - n - 1) % (2 * n - 2); if(k &lt;= n - 2) printf("%lld\n", k + 1); else if(k == 2 * n - 3) printf("%lld\n", n); else printf("%lld\n", k - n + 2); &#125; &#125; return 0;&#125; 总结：一周前教练说题目不用太难，于是办了这场几乎不需要算法的“模拟题大赛”。 在写这个解题报告时也觉得没啥好写的，就把优秀的AC代码公布一下作为参考吧。 看到自己带过的师弟实力已碾压两年前的自己，内心深感欣慰，感谢教练的辛勤付出和队员们的共同努力。希望能早日见到集训队队员拿到区域赛金牌，有生之年能见到集训队队员打进WF。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 21. 合并两个有序链表]]></title>
    <url>%2Fleetcode-21%2F</url>
    <content type="text"><![CDATA[题意将两个有序链表合并为一个新的有序链表。 思路直接写。时间复杂度：$O(n+m)$，其中$n$、$m$分别为两个链表的长度。空间复杂度：$O(1)$。 代码12345678910111213141516171819202122232425class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode res(0), *t = &amp;res; while(l1 &amp;&amp; l2) &#123; if(l1 -&gt; val &lt; l2 -&gt; val) &#123; t -&gt; next = l1; l1 = l1 -&gt; next; &#125; else &#123; t -&gt; next = l2; l2 = l2 -&gt; next; &#125; t = t -&gt; next; &#125; t -&gt; next = l1 == NULL ? l2 : l1; return res.next; &#125;&#125;; 总结啦啦啦。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 20. 有效的括号]]></title>
    <url>%2Fleetcode-20%2F</url>
    <content type="text"><![CDATA[题意给定一个只包括{}()[]的字符串，判断字符串是否能够成合法的括号序列。 思路直接用栈模拟，时间复杂度$O(n)$，但一共就这三种类型，我可以直接三个变量标记就可以了，这样空间复杂度$O(1)$。我看错了，原来括号不可以这样嵌套：([)]，所以只好用栈了（实际上用数组模拟了栈）。 代码12345678910111213141516171819202122232425262728class Solution &#123;public: bool isValid(string s) &#123; char ok[128]; ok[')'] = '('; ok[']'] = '['; ok['&#125;'] = '&#123;'; char a[11111]; int len = s.size(), idx = 0; for(int i = 0; i &lt; len; ++i) &#123;// cout &lt;&lt; s[i] &lt;&lt; ' '; if(s[i] == '(' || s[i] == '&#123;' || s[i] == '[') a[idx++] = s[i]; else &#123; if(idx &gt; 0 &amp;&amp; ok[s[i]] == a[idx - 1]) --idx; else return false; &#125;// printf("%c %d\n", s[i], idx); &#125;// cout &lt;&lt; idx &lt;&lt; endl; return idx == 0; &#125;&#125;; 总结我爱水题。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 19. 删除链表的倒数第N个节点]]></title>
    <url>%2Fleetcode-19%2F</url>
    <content type="text"><![CDATA[题意删除链表的倒数第$n$个结点，返回链表的头结点。 思路 想法1：一趟扫描确定表长，第二趟删除第len - n个元素。时间复杂度：$O(n)$。 想法2：题目中问能否尝试使用一次扫描实现，思考一下。用两个指针就可以了，当前面的指针指向第$n$个元素时，后面的指针开始移动，这样他俩之间始终差$n$个元素，前面的指针指向最后的位置时，后面的指针正好指向倒数第$n$个元素。 代码 代码1： 12345678910111213141516171819class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; int len = 0; ListNode *t = head; while(t != NULL) &#123; ++len; t = t -&gt; next; &#125; ListNode res(0); res.next = head; t = &amp;res; for(int i = 0; i &lt; len - n; ++i) t = t -&gt; next; t -&gt; next = t -&gt; next -&gt; next; return res.next; &#125;&#125;; 代码2： 123456789101112131415161718192021class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode res(0); res.next = head; ListNode *fast = &amp;res, *slow = &amp;res; while(fast -&gt; next) &#123; if(n) --n; else slow = slow -&gt; next; fast = fast -&gt; next; &#125; slow -&gt; next = slow -&gt; next -&gt; next; return res.next; &#125;&#125;; 总结好多“思维”题都要用到双指针的思想呢。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 18. 四数之和]]></title>
    <url>%2Fleetcode-18%2F</url>
    <content type="text"><![CDATA[题意从数组中找出满足和为target的四元组。 思路 想法1：暴力，$O(n^4)$。 想法2：排序 + 指针。思路类似前面的三数之和，只不过这里的指针多了一个，后两个指针相遇时第二个指针后移一个单位。时间复杂度：$O(n^3)$，空间复杂度：$O(1)$。 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); if(len &lt; 4) return &#123;&#125;; int L, R; vector&lt;vector&lt;int&gt; &gt; res; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; len; ++i) &#123; if(i &amp;&amp; nums[i - 1] == nums[i]) continue; for(int j = i + 1; j &lt; len; ++j) &#123; if(j &gt; i + 1 &amp; nums[j] == nums[j - 1]) continue; L = j + 1; R = len - 1; while(L &lt; R) &#123; int sum = nums[i] + nums[j] + nums[L] + nums[R]; if(sum &lt; target) ++L; else if(sum &gt; target) --R; else &#123; res.push_back(&#123;nums[i], nums[j], nums[L], nums[R]&#125;); while(L + 1 &lt; len &amp;&amp; nums[L + 1] == nums[L]) ++L; while(R - 1 &gt; 0 &amp;&amp; nums[R - 1] == nums[R]) --R; ++L; --R; &#125; &#125; &#125; &#125; return res; &#125;&#125;; 总结排序 + 指针！]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 17. 电话号码的字母组合]]></title>
    <url>%2Fleetcode-17%2F</url>
    <content type="text"><![CDATA[题意给出一个包含数字2-9的字符串，返回其能表示的字母组合。每个数字到字母的映射参照电话按键。 思路 想法1：直接把各种组合写出来，$O(3^{n} \times 4^m)$，其中$n$为对应3个字母的按键的个数，$m$为对应4个字母的按键的个数，且$n + m = len$。 想法2：原来只有上面的做法啊…… 代码12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; if(digits == "") return &#123;&#125;; string MP[11] = &#123;"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; int len = digits.size(); vector&lt;string&gt; res = &#123;""&#125;, tem; for(int i = 0; i &lt; len; ++i) &#123; tem.clear(); for(int j = 0; j &lt; res.size(); ++j) &#123;// cout &lt;&lt; "j = " &lt;&lt; j &lt;&lt; endl; for(int k = 0; k &lt; MP[digits[i] - '0'].size(); ++k) &#123;// cout &lt;&lt; MP[digits[i] - '0'][k] &lt;&lt; endl;// cout &lt;&lt; res[j] + MP[digits[i] - '0'][k] &lt;&lt; endl; tem.push_back(res[j] + MP[digits[i] - '0'][k]); &#125; &#125; res = tem; &#125; return res; &#125;&#125;; 总结大力出奇迹。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 16. 最接近的三数之和]]></title>
    <url>%2Fleetcode-16%2F</url>
    <content type="text"><![CDATA[题意从给定的数组中选出三个数，使得三个数的和最接近目标值。 思路 想法1：暴力，$O(n^3)$。 想法2：排序 + 双指针。上题中的想法可直接拿过来用，改一下返回的结果就可以了。时间复杂度：$O(n^2)$，空间复杂度：$O(n)$。 代码1234567891011121314151617181920212223242526272829class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); sort(nums.begin(), nums.end()); int L, R; int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; len; ++i) &#123; L = i + 1; R = len - 1; while(L &lt; R) &#123; int sum = nums[i] + nums[L] + nums[R]; if(sum == target) return target; if(abs(sum - target) &lt; abs(res - target)) res = sum; if(sum &gt; target) --R; else ++L; &#125; &#125; return res; &#125;&#125;; 总结排序 + 指针。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 15. 三数之和]]></title>
    <url>%2Fleetcode-15%2F</url>
    <content type="text"><![CDATA[题意定义一个三元组为$a+b+c = 0$，从包含$n$个整数的数组中，找出所有满足条件的不重复三元组。 思路 想法1：暴力，$O(n^3)$。 想法2：用“桶”记录下每个数值出现的次数，遍历前两个数，判断第三个数是否存在。时间复杂度：$O(n^2)$，空间复杂度：$O(n)$。 想法3：排序 + 双指针。排序后从小到大遍历数组，具体判断情况如下： nums[i] &gt; 0，后面不可能有三个数之和为0，结束循环。 重复元素跳过，避免重复解。 令左指针L = i + 1，右指针R = n - 1，当$L \lt R$时，执行如下循环： nums[i] + nums[L] + nums[R] ==0，判断边界位置是否和下一位置重复，若重复则去重。记录答案，将$L、R$移到下一位置。 三数之和大于0，R左移。 三数之和小于0，L右移。 时间复杂度：$O(n^2)$，空间复杂度：$O(n)$。 代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if(len &lt; 3) return &#123;&#125;; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; int L, R; for(int i = 0; i &lt; len; ++i) &#123; if(nums[i] &gt; 0) break; if(i &amp;&amp; nums[i] == nums[i - 1]) continue; L = i + 1; R = len - 1; while(L &lt; R) &#123; if(nums[i] + nums[L] + nums[R] == 0) &#123; res.push_back(&#123;nums[i], nums[L],nums[R]&#125;); while(L + 1 &lt; len &amp;&amp; nums[L + 1] == nums[L]) ++L; while(R - 1 &gt; 0 &amp;&amp; nums[R - 1] == nums[R]) --R; ++L; --R; &#125; else if(nums[i] + nums[L] + nums[R] &gt; 0) --R; else ++L;// cout &lt;&lt; L &lt;&lt; ' ' &lt;&lt; R &lt;&lt; endl; &#125; &#125; return res; &#125;&#125;; 总结这种找数字的很多都涉及到了排序，利用有序可以加快查找速度。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 14. 最长公共前缀]]></title>
    <url>%2Fleetcode-14%2F</url>
    <content type="text"><![CDATA[题意输出字符串数组中所有字符串的最长公共前缀。 思路直接判断就好了，时间复杂度$O(len \times n)$，$n$为字符串的数量，$len$为所有字符串中最短的字符串的长度。 代码1234567891011121314151617181920212223242526class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size() == 0) return ""; int tot = strs.size(); int len = strs[0].size(); for(int i = 1; i &lt; tot; ++i) len = min(len, (int)strs[i].size()); string res = ""; bool flag = true; for(int i = 0; i &lt; len; ++i) &#123; for(int j = 1; j &lt; tot; ++j) if(strs[j][i] != strs[0][i]) flag = false; if(flag) res += strs[0][i]; else break; &#125; return res; &#125;&#125;; 总结战胜95%，头一回。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 13. 罗马数字转整数]]></title>
    <url>%2Fleetcode-13%2F</url>
    <content type="text"><![CDATA[题意输入罗马数字，输出对应的整数。具体规则间题面。 思路直接写。 由于两个字母结合的优先级高于一个字母的优先级，故我们可以把所有可能的情况存下来，然后遍历字符串时优先考虑两个字母的情况。时间复杂度$O(n)$。 代码123456789101112131415161718192021222324252627class Solution &#123;public: int romanToInt(string s) &#123; string tmp; int res = 0, len = s.size(); map&lt;string, int&gt; MP = &#123;&#123;"I",1&#125;,&#123;"IV",4&#125;,&#123;"V",5&#125;,&#123;"IX",9&#125;,&#123;"X",10&#125;,&#123;"XL",40&#125;,&#123;"L",50&#125;,&#123;"XC",90&#125;,&#123;"C",100&#125;,&#123;"CD",400&#125;,&#123;"D",500&#125;,&#123;"CM",900&#125;,&#123;"M",1000&#125; &#125;; for(int i = 0; i &lt; len; ++i) &#123; tmp = s.substr(i, 2);// cout &lt;&lt; tmp &lt;&lt; ' ' &lt;&lt; MP[tmp] &lt;&lt; endl; if(MP[tmp]) &#123; res += MP[tmp]; ++i; &#125; else &#123; tmp = s.substr(i, 1); res += MP[tmp]; &#125;// cout &lt;&lt; res &lt;&lt; endl; &#125; return res; &#125;&#125;; 总结借助map是慢了点（在所有运行时间中垫底的存在），但做法就这么个做法，可以直接多个if判断，没必要再写一遍了。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 12. 整数转罗马数字]]></title>
    <url>%2Fleetcode-12%2F</url>
    <content type="text"><![CDATA[题意输入整数，转化为罗马数字输出。具体转化规则见题面。 思路直接做。 可以把所有可选的数值列出来，然后从大到小选取数字。有点像给出固定面值的硬币，用贪心法凑固定数值所需要的最小个数的意思。时间复杂度：很低。 代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string intToRoman(int num) &#123; struct node &#123; int num; string ch; &#125; table[15] = &#123; 1000, "M", 900, "CM", 500, "D", 400, "CD", 100, "C", 90, "XC", 50, "L", 40, "XL", 10, "X", 9, "IX", 5, "V", 4, "IV", 1, "I", &#125;; int i = 0; string res = ""; while(num) &#123; if(num &gt;= table[i].num) &#123; num -= table[i].num; res += table[i].ch; &#125; else ++i;// cout &lt;&lt; num &lt;&lt; ' ' &lt;&lt; i &lt;&lt; endl; &#125; return res; &#125;&#125;; 总结打表！打表！！打表！！！]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 11. 盛最多水的容器]]></title>
    <url>%2Fleetcode-11%2F</url>
    <content type="text"><![CDATA[题意给出$n$个垂直线段，相邻两线段之间的距离是$1$，选出一个区间，使得区间两端线段中较短的那根长度乘区间长度最大。 思路 想法1：枚举没对线段作为区间端点的情况。时间复杂度$O(n^2)$，太暴力。 想法2：双指针法。 思想依据：因为两段之间形成的区域总会受到其中较短的那条长度的限制，此外，两线段距离越远，得到的面积越大。 具体做法：在线段长度构成的数组中使用两个指针，分别指向开始和末尾，每一步都计算出指针所指向的线段形成的区域的最大值，用一个变量来保存更新最大值。指针向较长的那端移动。 代码12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int res = 0, l = 0, r = height.size() - 1; while(l &lt; r) &#123; res = max(res, min(height[l], height[r]) * (r - l)); if(height[l] &lt; height[r]) ++l; else --r; &#125; return res; &#125;&#125;; 总结女少口阝可！]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 10. 正则表达式匹配]]></title>
    <url>%2Fleetcode-10%2F</url>
    <content type="text"><![CDATA[题意实现一个支持.和*的正则表达式匹配。其中.匹配任意单个字符，*匹配0或多个前面的那一个元素。 给出两个字符串s和p，前者只包含从a-z的小写字母，后者只包含从a-z的小写字母和两个匹配字符，问是否匹配。 思路 想法0： 直接return regex_match(s, regex(p)); 想法1： 如果没有*，那直接写就可以了。其实多的*这个符号，无非就是将前一个字符变为了0道多个，通过递归枚举每种情况，轻松解决。时间复杂度：很大。 想法2： 因为想法1的实现出现了重叠子问题，所以可以通过DP来进行优化。具体操作：用p[i][j]表示s串[0,i]与p串[0,j]匹配的结果。 s[i] == p[j] || p[j] == &#39;.&#39;时，dp[i][j] = dp[i-1][j-1]。 s[i] != p[j]时，可能发生匹配的情况只有p[j] == &#39;*&#39;，此时所有可能如下： *前的字符与对应位置字符无法匹配，此时只能使其出现0次才可继续匹配，即dp[i][j] = dp[i][j - 2]。 *前的字符与对应位置字符可匹配，此时*可以匹配多个、1个或0个，即dp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i][j - 2]。 无法匹配时的情况不用再讨论了，因一开始dp数组就都初始化为了0。 代码 代码0： 123456class Solution &#123;public: bool isMatch(string s, string p) &#123; return regex_match(s, regex(p)); &#125;&#125;; 代码1： 1234567891011121314class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.size() == 0) return s.size() == 0; bool first = (s.size() &amp;&amp; (s[0] == p[0] || p[0] == '.')); if(p.size() &gt;= 2 &amp;&amp; p[1] == '*') return isMatch(s, p.substr(2)) || (first &amp;&amp; isMatch(s.substr(1), p)); else return first &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; 代码2： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool isMatch(string s, string p) &#123; int lens = s.size(), lenp = p.size(); bool dp[lens + 1][lenp + 1]; for(int i = 0; i &lt;= lens; ++i) for(int j = 0; j &lt;= lenp; ++j) dp[i][j] = 0; dp[0][0] = 1; if(lenp &gt; 1) &#123; for(int i = 1; i &lt; lenp; i += 2) if(p[i] == '*') dp[0][i + 1] = dp[0][i - 1]; &#125; for(int i = 1; i &lt;= lens; ++i) &#123; for(int j = 1; j &lt;= lenp; ++j) &#123; if(s[i - 1] == p[j - 1] || p[j - 1] == '.') dp[i][j] = dp[i - 1][j - 1]; else if(j &gt; 1 &amp;&amp; p[j - 1] == '*') &#123; if(p[j - 2] != s[i - 1] &amp;&amp; p[j - 2] != '.') dp[i][j] = dp[i][j - 2]; else dp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i][j - 2]; &#125; &#125; &#125; return dp[lens][lenp]; &#125;&#125;; 总结DP是很优美的思路，关键在于建立状态转移方程，多加练习可培养。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 9. 回文数]]></title>
    <url>%2Fleetcode-9%2F</url>
    <content type="text"><![CDATA[题意判断一个数是否为回文数。 思路 想法1：直接翻转数字，判断翻转后的数字和之前的是否相同。时间复杂度$O(log_{10}(n))$,要注意负数和爆int的问题。但这种做法只击败了37%的提交，考虑优化。 想法2：参考官方题解后发现可以翻转一半的数字，秒啊。时间复杂度$O(log_{10}(n))$。 代码 代码1： 12345678910111213141516171819class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0) return false; int tem = x; long revx = 0; while(tem) &#123; revx = revx * 10; revx += tem % 10; tem /= 10; &#125; if(revx == x) return true; else return false; &#125;&#125;; 代码2： 12345678910111213141516class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) return false; int revx = 0; while(x &gt; revx) &#123; revx = revx * 10 + x % 10; x /= 10; &#125; return x == revx || x == revx / 10; &#125;&#125;; 总结优化！优化！优化！！]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 8. 字符串转换整数 (atoi)]]></title>
    <url>%2Fleetcode-8%2F</url>
    <content type="text"><![CDATA[题意实现一个atoi函数，具体功能如下： 丢弃开头无用的空格，直到找到第一个非空格的字符为止。 当寻找到的第一个非空字符为正负号时或数字时，将其与后面尽可能多的连续数字组合起来形成整数。剩余的部分忽略。 如果第一个字符非上面三种情况时，则返回0。 如果数值超过了int的范围则返回INT_MAX或INT_MIN。 思路 直接模拟，注意细节就好了。时间复杂度$O(n)$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: int myAtoi(string str) &#123; int len = str.size(), st = 0; for(int i = 0; i &lt; len; ++i) if(str[i] != ' ') &#123; st = i; break; &#125; //cout &lt;&lt; st &lt;&lt; ' ' &lt;&lt; str[st] &lt;&lt; endl; bool flag = true; if(str[st] == '+') ++st; else if(str[st] == '-') &#123; flag = false; ++st; &#125; //cout &lt;&lt; flag &lt;&lt; endl; int res = 0; if(isdigit(str[st])) &#123; while(st &lt; len &amp;&amp; isdigit(str[st])) &#123; //cout &lt;&lt; "res = " &lt;&lt; res &lt;&lt; endl; int add = str[st++] - '0'; if( flag &amp;&amp; ( res &gt; INT_MAX / 10 || ( res == INT_MAX / 10 &amp;&amp; add &gt;= 7))) return INT_MAX; if(!flag &amp;&amp; (-res &lt; INT_MIN / 10 || (-res == INT_MIN / 10 &amp;&amp; add &gt;= 8))) return INT_MIN; res = res * 10 + add; //cout &lt;&lt; res &lt;&lt; ' ' &lt;&lt; add &lt;&lt; ' ' &lt;&lt; st &lt;&lt; endl; &#125; //cout &lt;&lt; res &lt;&lt; endl; if(!flag) res = -res; return res; &#125; else return 0; &#125;&#125;; 总结运行时间只击败了60%的用户。。看了下最快的代码，思路没啥区别，就是少了几个判断，没必要再“优化”了。 如：中间的存储答案的变量是用的long（我一开始也打算用long的）、判断符号位直接用的int（符号和正号的ASSIC码正好差2——用44 - str[i] 正好等于1或-1）。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 7. 整数反转]]></title>
    <url>%2Fleetcode-7%2F</url>
    <content type="text"><![CDATA[题意给出一个 32 位的有符号整数，将这个整数中每位上的数字进行反转。 思路 想法：保留符号直接翻转，注意防止爆int。时间复杂度$O(log_{10}(n))$。 吐槽：官方给的结果是如果爆了int则返回0。（是我瞎了，题目中最下面的注意里写了。） 代码12345678910111213141516class Solution &#123;public: int reverse(int x) &#123; int revx = 0; while(x) &#123; int add = x % 10; if(revx &gt; INT_MAX / 10 || (revx == INT_MAX / 10 &amp;&amp; add &gt; 7)) return 0; if(revx &lt; INT_MIN / 10 || (revx == INT_MIN / 10 &amp;&amp; add &lt; -8)) return 0; x /= 10; revx = revx * 10 + add; &#125; return revx; &#125;&#125;; 总结我爱水题。嗯。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 6. Z 字形变换]]></title>
    <url>%2Fleetcode-6%2F</url>
    <content type="text"><![CDATA[题意根据给定的行数，将字符串从上到下、从左到右进行Z字形排列，详见样例。 思路 想法1：直接模拟，时间复杂度$O(n)$。为什么运行时间只击败了21%的用户，内存消耗却击败了83%的用户？难道有什么空间换时间的方法？ 想法2：看了官方题解，并没有。但是，可以通过计算每个位置的数学关系来解答。时间复杂度也是$O(n)$。 代码 代码1（二维数组直接模拟）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows == 1) return s; int len = s.size(); char res[numRows][len]; memset(res, 0, sizeof(res)); bool flag = true; int col = 0, row = 0; for(int i = 0; i &lt; len; ++i) &#123; if(flag) //down &#123; res[row++][col] = s[i]; if(row == numRows) &#123; flag = false; --row; //back &#125; &#125; else //up &#123; res[--row][++col] = s[i]; if(row == 0) &#123; flag = true; --i; &#125; &#125; &#125; /* for(int i = 0; i &lt; numRows; ++i, puts("")) for(int j = 0; j &lt;= col; ++j) cout &lt;&lt; res[i][j]; */ string ans = ""; for(int i = 0; i &lt; numRows; ++i) for(int j = 0; j &lt;= col; ++j) if(res[i][j] != 0) ans.push_back(res[i][j]); return ans; &#125;&#125;; 代码2（数学关系）： 12345678910111213141516171819202122class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows == 1) return s; string res; int len = s.size(); int cycleLen = 2 * numRows - 2; for(int i = 0; i &lt; numRows; ++i) &#123; for(int j = 0; j + i &lt; len; j += cycleLen) &#123; res.push_back(s[i + j]); if(i &gt; 0 &amp;&amp; i &lt; numRows - 1 &amp;&amp; j + cycleLen - i &lt; len) res.push_back(s[j + cycleLen - i]); &#125; &#125; return res; &#125;&#125;; 总结这种关系的一般都会和数学（找关系式？）有关系的，如以前遇到过的“蛇形填数”。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5. 最长回文子串]]></title>
    <url>%2Fleetcode-5%2F</url>
    <content type="text"><![CDATA[题意求给定子串的最长回文子串。 思路 想法1：枚举每个位置作为回文中心时的情况，往两边扩展看能扩展到什么位置，同时记录长度。时间复杂度$O(n^2)$。 想法2：以前当模板直接用的Manacher算法就是直接用来解决回文串的相关问题的，时间复杂度$O(n)$。（实际上这才是第一眼见到这题想到的想法） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: string longestPalindrome(string s) &#123; if(s.size() == 0) return ""; char Ma[2020]; int l = 0, len = s.size(), Mp[2020]; memset(Ma, 0, sizeof(Ma)); memset(Mp, 0, sizeof(Mp)); Ma[l++] = '$'; Ma[l++] = '#'; for(int i = 0; i &lt; len; ++i) &#123; Ma[l++] = s[i]; Ma[l++] = '#'; &#125; Ma[l] = '0'; int mx = 0, id = 0; for(int i = 0; i &lt; l; ++i) &#123; Mp[i] = mx &gt; i ? min(Mp[id * 2 - i], mx - i) : 1; if(i - Mp[i] &lt; 0) continue; while(Ma[i + Mp[i]] == Ma[i - Mp[i]]) Mp[i]++; if(i + Mp[i] &gt; mx) &#123; mx = i + Mp[i]; id = i; &#125; &#125; int res = 0, c; for(int i = 0; i &lt; 2 * len + 2; ++i) &#123; if(Mp[i] - 1 &gt; res) &#123; res = Mp[i] - 1; c = i; &#125; &#125; string ans = ""; for(int i = c - res; i &lt;= c + res; ++i) if(Ma[i] != '#') ans.push_back(Ma[i]); return ans; &#125;&#125;; 总结Manacher算法 步骤： 字符串的转换。 方法：添加字符串中原本不存在的符号，如$、#。转换后字符串的长度变为2n + 2。 目的：统一奇数长度和偶数长度的回文，给所有子串一个中心。 举例：abaaba经转换后在Ma里的情况如下表所示。 注意：其中在最开头的位置添加的$免去了字符串是否到达了最左边的判断，减少了代码量。结尾不用加是因为末尾自动有个&#39;\0&#39;。 回文半径的扩展。 定义：以当前位置字符为中心向两边扩展，最长的回文串的半径的长度。 举例：abaaba对应的回文半径的长度在Mp里的情况如下表所示。 注意：Mp[i] - 1对应了原串的回文子串长度，Ma[i - Mp[i] ~ i + Mp[i]]是回文串。 核心如何在$O(n)$时间内求出Mp数组？ 符号表示：mx表示i + Mp[i]的最大值，id表示mx的下标。 算法过程：从前往后求Mp数组，同时更新mx和id的值。 ​ 假设已经知道了0 ~ i - 1位置上的Mp的值，如何求i位置的Mp的值？ Case 1，mx &gt; i j = 2 * id - i是i关于id的对称点，此时i位置的回文半径就可以根据j位置的回文半径与mx的关系直接得出，为min(Mp[j], mx - i)。 Case2， mx ≤ i 此时无法用前面已经得到的关系求i位置上的回文半径长度，故设置为1，再以此位置为中心进行扩展得出答案。 代码123456789101112131415161718192021222324void Manacher(char s[], int len)&#123; int l = 0; Ma[l++] = '$'; Ma[l++] = '#'; for(int i = 0; i &lt; len; ++i) &#123; Ma[l++] = s[i]; Ma[l++] = '#'; &#125; Ma[l] = 0; int mx = 0, id = 0; for(int i = 0; i &lt; l; ++i) &#123; Mp[i] = mx &gt; i ? min(Mp[2 * id − i], mx − i) : 1; while(Ma[i + Mp[i]] == Ma[i - Mp[i]]) Mp[i]++; if(i + Mp[i] &gt; mx) &#123; mx = i + Mp[i]; id = i; &#125; &#125;&#125; 复杂度分析 时间复杂度：$O(n)$。 空间复杂度：$O(n)$。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4. 寻找两个有序数组的中位数]]></title>
    <url>%2Fleetcode-4%2F</url>
    <content type="text"><![CDATA[题意给出两个有序数组，在时间复杂度$O(log(m + n))$内求出这两个数组的中位数。 思路 这个题目印象深刻，我在王道数据结构上做过，感觉是比每章给出的思维拓展题都要好的一道题目。与那道题不同的是，这道题两组数据给出的元素个数是可以不一样的。 根据数组有序 + 对复杂度的要求，很明显是要通过二分查找来实现。具体操作如下： 为了方便讨论，我们记num1数组为A，num2数组为B，并假设A.size() $\leq $ B.size()。 假设通过划分使得A分为了leftA和rightA，B分为了leftB和rightB，则满足题意的情况就是len(leftA) + len(leftB) == len(rightA) + len(rightB) &amp;&amp; max(leftA) $\leq$ min(rightB) &amp;&amp; max(leftB) $\leq$ min(rightA)。 我们通过对A数组二分查找来划分数组，并不断判断条件是否满足。记i为当前访问的A的位置，j为当前访问的B的位置，则由上述关系可知，$j = \frac{m+n+1}{2} - i$。 最后处理一下边界情况 &amp; n + m的奇偶情况。前者是通过设置最大值最小值来完成的，后者是特殊判断了一下。 代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; if(nums1.size() &gt; nums2.size()) return findMedianSortedArrays(nums2, nums1); int m = nums1.size(); int n = nums2.size(); int low = 0, high = m; while(low &lt;= high) &#123; int i = low + high &gt;&gt; 1; int j = (m + n + 1) / 2 - i; int maxleftA = i == 0 ? INT_MIN : nums1[i - 1]; int minrightA = i == m ? INT_MAX : nums1[i]; int maxleftB = j == 0 ? INT_MIN : nums2[j - 1]; int minrightB = j == n ? INT_MAX : nums2[j]; if(maxleftA &lt;= minrightB &amp;&amp; maxleftB &lt;= minrightA) &#123; if((m + n) &amp; 1) return 1.0 * max(maxleftA, maxleftB); else return (max(maxleftA, maxleftB) + min(minrightA, minrightB)) / 2.0; &#125; else if(maxleftA &gt; minrightB) high = i - 1; else low = i + 1; &#125; return 0.0; &#125;&#125;; 总结一直觉得有好多细节要考虑，于是迟迟没动键盘(难道这就是你咕了一年的原因？)。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3. 无重复字符的最长子串]]></title>
    <url>%2Fleetcode-3%2F</url>
    <content type="text"><![CDATA[题意输出给定子串中最长的子序列的长度。 思路 想法1：直接遍历同时记录这个是否已算在了最大长度内，如果它重复出现了就更新最大值，然后把记录用的变量初始化一下，时间复杂度$O(n)$。但这是错误的，给出个反例abac。 想法2：其实这不就是滑动窗口吗！时间复杂度$O(n)$。写完后感觉那个while很刺眼，于是考虑能否把它去掉。 想法3：可以记录每个对应的s[i]上次出现的位置的下一个位置，这样当更新到这个字符时直接“跳”到对应位置就可以了，时间复杂度也为$O(n)$，但是比较次数应该比上面的少。但是！提交后发现这样竟然比上面的做法慢！是因为数据的问题使每次更新最大值导致运算次数比上面的多了吗？ 代码 代码1： 1234567891011121314151617181920212223class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int res = 0, tem = 0, now = 0, cnt[128]; memset(cnt, 0, sizeof(cnt)); for(int i = 0; i &lt; s.length(); ++i) &#123; if(cnt[s[i]]) &#123; res = max(res, tem); while(cnt[s[i]]) &#123; --tem; --cnt[s[now++]]; &#125; &#125; ++tem; cnt[s[i]] = 1; &#125; res = max(res, tem); return res; &#125;&#125;; 代码2： 1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int res = 0, now = 0, idx[128]; memset(idx, 0, sizeof(idx)); for(int i = 0; i &lt; s.length(); ++i) &#123; now = max(idx[s[i]], now); res = max(res, i - now + 1); idx[s[i]] = i + 1; &#125; return res; &#125;&#125;; 总结太久没写，手生了啊。尽快捡起来吧。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2. 两数相加]]></title>
    <url>%2Fleetcode-2%2F</url>
    <content type="text"><![CDATA[题意给出两个非空的链表用来表示两个非负的整数，他们的位数是按照逆序存储的，每个结点存储一位数字。求他们相加后的结果（用链表表示）。 思路 直接模拟。因为是逆序给出的所以直接遍历一遍按位相加就好了，实现过程中用一个变量记录进位情况。时间复杂度$O(max(m, n))$。 代码1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode res(0), *p = &amp;res, *newp; int sum, carry = 0; while(l1 != NULL || l2 != NULL || carry) &#123; sum = 0; if(l1 != NULL) sum += l1 -&gt; val; if(l2 != NULL) sum += l2 -&gt; val; sum += carry; carry = sum / 10; newp = new ListNode(sum % 10); p-&gt;next = newp; p = newp; l1 = l1 ? l1 -&gt; next : NULL; l2 = l2 ? l2 -&gt; next : NULL; &#125; return res.next; &#125;&#125;; 总结关于访问ListNode里的成员时，是用.直接访问还是用-&gt;呢？答：当当前变量是一个实体成员(如上面代码中定义的res)时用.，因为它包含了成员；当是一个指针时，用-&gt;，因为它只是指向一个指向地址的指针，并没有实体。 自己的联想——如果给出的是从高位到低位存的呢？可以先将两个链表都逆置一下，然后再进行上面的操作。写到这又想到了备战考研期间看的王道数据结构这本书上的问题，之前打ACM时解决的问题和书上给出的考试要考的内容有挺大差别的，一开始有些不适应，觉得这么简单还用写？。不过后来习惯后觉得还挺巧妙的，其中印象较为深刻的就有对链表的逆置操作（将前一半元素和后一半元素交换位置转化为了先整体逆置、再对前半部分逆置、再对后半部分逆置）。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1. 两数之和]]></title>
    <url>%2Fleetcode-1%2F</url>
    <content type="text"><![CDATA[题意从数组中找出两个不同的整数，使得他们的和恰好为要求得到的数。输出他们的下标。 思路 想法1：最直观的思路——二重循环遍历，时间复杂度$O(n^2)$。太暴力了，考虑优化。 想法2：如果序列是有序的话，可固定x然后从数组中二分查找target - x。时间复杂度$O(n*logn)$。 想法3：利用桶排序的思想，存储每个数出现的次数，当遍历到x时看桶中是否存在target - x。时间复杂度$O(n)$。数据范围不知道，数组没法开，所以这个“桶”可用map实现。 代码12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; MP; for(int i = 0; i &lt; nums.size(); ++i) &#123; if(MP.count(target - nums[i])) return &#123;i, MP[target - nums[i]]&#125;; MP[nums[i]] = i; &#125; return &#123;-1, -1&#125;; &#125;&#125;; 总结这是第一次使用LeetCode，所以有些生疏。 首先是要提交的代码格式，给出了Solution的大体框架，像是做填空题一般要把自己的解法填上，这是和之前刷其他OJ最明显的不同点。 其次是这道题返回的值，返回的是个二元组，一开始没反应过来该怎么写。 最后是对规范性的要求，以为给定的数据一定会满足条件，所以没加找不到时返回{-1, -1};，但这样编译也通过不了。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3864 Quiz for EXO-L【BFS】【模拟】]]></title>
    <url>%2Fzoj-3864%2F</url>
    <content type="text"><![CDATA[题意：给出数字，求出数字转化为01矩阵后代表的图案的类型。 思路：和 UVa 1103 Ancient Messages 类似，这些图案的区别在于黑白连通块的数量不同，根据这一关系能判断出除样例外的所有图案，最后样例中的这两个图案根据根据黑块的最大团和其他团的数量关系确定。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int N = 999;typedef pair&lt;int, int&gt; pii;int a[N][N];bool vis[N][N];double cnt[11];int dir[][2] = &#123;0,1,1,0,-1,0,0,-1,1,1,-1,1,1,-1,-1,-1&#125;;int T, n, m, t, w, b;void BFS(int x, int y, int tar)&#123; queue&lt;pii&gt; Q; Q.push(&#123;x, y&#125;); while(!Q.empty()) &#123; pii now = Q.front(); Q.pop(); for(int i = 0; i &lt; 8; ++i) &#123; int xx = now.first + dir[i][0]; int yy = now.second + dir[i][1]; if(xx &lt; 0 || xx &gt;= n || yy &lt; 0 || yy &gt;= n) continue; if(vis[xx][yy] || a[xx][yy] != tar) continue; if(!tar) ++cnt[b]; vis[xx][yy] = 1; Q.push(&#123;xx, yy&#125;); &#125; &#125;&#125;void outmap()&#123; for(int i = 0; i &lt; n; ++i, puts("")) for(int j = 0; j &lt; n; ++j) cout &lt;&lt; a[i][j];&#125;void outvis()&#123; for(int i = 0; i &lt; n; ++i, puts("")) for(int j = 0; j &lt; n; ++j) cout &lt;&lt; vis[i][j];&#125;int main()&#123;// freopen("in.txt", "r", stdin); scanf("%d", &amp;T); while(T--) &#123; w = b = 0; int now = 1, idx = 0; memset(a, 0, sizeof(a)); memset(cnt, 0, sizeof(cnt)); memset(vis, 0, sizeof(vis)); scanf("%d%d", &amp;n,&amp;m); while(m--) &#123; scanf("%d", &amp;t); for(int i = 0; i &lt; t; ++i) &#123; a[(idx + i) / n][(idx + i) % n] = now; &#125; idx = idx + t; now ^= 1; &#125; BFS(0, 0, 1); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) if(!vis[i][j]) &#123; if(a[i][j] == 1) &#123; BFS(i, j, 1); ++w; &#125; else &#123; BFS(i, j, 0); ++b; &#125; &#125; if(w == 1 &amp;&amp; b == 9) puts("Baekhyun"); if(w == 0 &amp;&amp; b == 5) puts("Chanyeol"); if(w == 2 &amp;&amp; b == 1) puts("Chen"); if(w == 1 &amp;&amp; b == 1) puts("D.O"); if(w == 12&amp;&amp; b == 2) puts("Kai"); if(w == 0 &amp;&amp; b == 3) puts("Kris"); if(w == 1 &amp;&amp; b == 6) puts("Lay"); if(w == 7 &amp;&amp; b == 5) puts("Luhan"); if(w == 7 &amp;&amp; b == 2) puts("Suho"); if(w == 3 &amp;&amp; b == 2) puts("Tao"); if(w == 1 &amp;&amp; b == 5) &#123; sort(cnt, cnt + 5); double res = (cnt[0] + cnt[1] + cnt[2] + cnt[3]) / cnt[4]; puts(res &lt; 0.4 ? "Sehun" : "Xiumin"); &#125; &#125; return 0;&#125;/***name w bBaekhyun 1 9Chanyeol 0 5Chen 2 1D.O 1 1Kai 12 2Kris 0 3Lay 1 6Luhan 7 5Sehun 1 5Suho 7 2Tao 3 2Xiumin 1 5***/]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>BFS</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 SDNU ACM-ICPC Provincial Team Selection Round 2【完结】]]></title>
    <url>%2Fsdnu-2019-12%2F</url>
    <content type="text"><![CDATA[A - Arc of Dream【矩阵快速幂】题意：给出表达式，求第$n$项的值是多少。 思路：矩阵快速幂，注意特判$n = 0$和$n = 1$的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;const ll mod = 1e9+7;const int maxn = 6;struct Matrix &#123; ll mp[maxn][maxn];&#125;;Matrix E, O;Matrix matrix_multi (Matrix A, Matrix B, int a, int b, int c) &#123; Matrix tmp = O; for (int i = 1; i &lt;= a; ++i) &#123; for (int j = 1; j &lt;= c; ++j) &#123; for (int k = 1; k &lt;= b; ++k) &#123; tmp.mp[i][j] += A.mp[i][k]*B.mp[k][j]%mod; tmp.mp[i][j] %= mod; &#125; &#125; &#125; return tmp;&#125;Matrix matrix_qm (Matrix A, ll b, int dr) &#123; Matrix ans = E; while (b) &#123; if (b&amp;1) &#123; ans = matrix_multi(ans, A, dr, dr, dr); &#125; b &gt;&gt;= 1; A = matrix_multi(A, A, dr, dr, dr); &#125; return ans;&#125;void init () &#123; memset(E.mp, 0, sizeof(E.mp)); memset(O.mp, 0, sizeof(O.mp)); for (int i = 1; i &lt;= 5; ++i) &#123; E.mp[i][i] = 1; &#125;&#125;int main () &#123; init(); ll n, a0, ax, ay, b0, bx, by; while (scanf("%lld %lld %lld %lld %lld %lld %lld", &amp;n, &amp;a0, &amp;ax, &amp;ay, &amp;b0, &amp;bx, &amp;by) != EOF) &#123; Matrix T = O; T.mp[1][1] = 1, T.mp[1][2] = 1; T.mp[2][2] = ax*bx%mod, T.mp[2][3] = ax*by%mod, T.mp[2][4] = ay*bx%mod, T.mp[2][5] = ay*by%mod; T.mp[3][3] = ax%mod, T.mp[3][5] = ay%mod; T.mp[4][4] = bx%mod, T.mp[4][5] = by%mod; T.mp[5][5] = 1; if (n == 0) &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; continue; &#125; else if (n == 1) &#123; cout &lt;&lt; a0*b0%mod &lt;&lt; '\n'; continue; &#125; else &#123; Matrix A = O; A.mp[1][1] = 0, A.mp[2][1] = a0*b0%mod, A.mp[3][1] = a0%mod, A.mp[4][1] = b0%mod, A.mp[5][1] = 1; T = matrix_qm(T, n, 5); A = matrix_multi(T, A, 5, 5, 1); cout &lt;&lt; A.mp[1][1]%mod &lt;&lt; '\n'; &#125; &#125; return 0;&#125; B - Bear and Friendship Condition【并查集||DFS】https://alberts97.github.io/cf-771a/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int MAX = 150010;bool vis[MAX];int n, m, x, y;vector&lt;int&gt; G[MAX];void DFS(int t, int &amp; v, int &amp; e)&#123; vis[t] = true; ++v; e += G[t].size(); for(int i = 0; i &lt; G[t].size(); ++i) if(!vis[G[t][i]]) DFS(G[t][i], v, e);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; scanf("%d%d",&amp;x,&amp;y); G[x].push_back(y); G[y].push_back(x); &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(!vis[i]) &#123; int e = 0, v = 0; DFS(i, v, e); if(e != 1ll * v * (v - 1)) &#123; puts("NO"); return 0; &#125; &#125; &#125; puts("YES"); return 0;&#125; C - Code shortening【字典树】【启发式合并】https://alberts97.github.io/cf-965e/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int MAX = 1e5 + 5;char str[MAX];multiset&lt;int&gt; st[MAX];int n, tot, now, nex[MAX][26], dep[MAX], res;void add()&#123; now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) &#123; nex[now][str[i]-'a'] = ++tot; dep[tot] = dep[now] + 1; &#125; now = nex[now][str[i]-'a']; &#125; st[now].insert(dep[now]);&#125;void DFS(int u = 1)&#123; bool emp = (u &gt; 1 &amp;&amp; st[u].empty()); for(int i = 0; i &lt; 26; ++i) &#123; int v = nex[u][i]; if(!v) continue; DFS(v); for(auto t : st[v]) st[u].insert(t); st[v].clear(); &#125; if(emp) &#123; st[u].erase(--st[u].end()); st[u].insert(dep[u]); &#125;&#125;int main()&#123; tot = 1; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", str); add(); &#125; DFS(); for(auto t : st[1]) res += t; printf("%d\n", res); return 0;&#125; D - Design a navigation【签到】题意：告诉你一个数字显示的方法，要求输出按这个方法显示的情况。 思路：直接写就可以，但很容易写复杂了，下面是比较简洁的代码。 12345678910111213141516#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, p, k;int main()&#123; scanf("%d%d%d", &amp;n, &amp;p, &amp;k); if(p - k &gt; 1) printf("&lt;&lt; "); for(int i = p - k; i &lt;= p + k; i++) if(1 &lt;= i &amp;&amp; i &lt;= n) printf((i == p) ? "(%d) " : "%d ", i); if(p + k &lt; n) printf("&gt;&gt; "); return 0;&#125; E - Excting Secret Chamber at Mount Rushmore【Floyd】题意：给出$n$组字母，每组有两个，意味着前者可以转化为后者。在转化过程中遵循传递性，即如果$a$可以转换为$b$，$b$可以转化为$c$，那么$a$也可以转换为$c$。 给出$m$组单词，问前者是否可以通过若干次转换转换为后者。 思路：只有$26$个字母，可以直接Floyd判断单词间是否联通。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 26;bool a[N][N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; N; ++i) a[i][i] = true; char aa, bb; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; aa &gt;&gt; bb; a[aa-'a'][bb-'a'] = true; &#125; for(int k = 0; k &lt; N; ++k) for(int i = 0; i &lt; N; ++i) for(int j = 0; j &lt; N; ++j) a[i][j] |= a[i][k] &amp; a[k][j]; string s, l; for(int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; s &gt;&gt; l; bool flag = s.length()==l.length(); if(flag) &#123; for(int j = 0; j &lt; s.length(); ++j) if(!a[s[j]-'a'][l[j]-'a']) &#123; flag = false; break; &#125; &#125; puts(flag ? "yes" : "no"); &#125; return 0;&#125; F - From Y to Y【构造】两年前做的，具体什么操作记不清了。不过两年前能做出来说明不难。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int n, tot, t;string ans = "";char ss[] = &#123;'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q'&#125;;int main()&#123; while(cin &gt;&gt; n) &#123; ans = ""; int now = 16; for(int i = 0; i &lt; now; ++i) &#123; ans.push_back(ss[i]); tot = t = 1; while(tot &lt;= n) &#123; ans.push_back(ss[i]); t++; tot = t*(t+1)/2; &#125; n -= (t-1)*t/2; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; G - Godsend【规律】两年前做的，具体什么操作记不清了。不过两年前能做出来说明不难。 PS：这一题卡了cin。 1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, t;bool flag;int main()&#123; scanf("%d",&amp;n); while(n--) &#123; scanf("%d",&amp;t); if(t &amp; 1) flag = true; &#125; puts(flag ? "First" : "Second"); return 0;&#125; H - How to do that【数据结构】题意：有两种操作，一是将某个数字加入栈中(add$x$)，另一种是取栈顶数字(remove`)，要求取出的数字的顺序按照$1$ ~ $n$的顺序，给你一系列操作，你可以在任何一次操作之后将栈内的数字重排，问你最少重排多少次。 思路：重排可以理解为将栈内元素全部按照顺序排好，这个操作不需要直接模拟，直接清空栈内元素就可以。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;stack&gt;using namespace std;char op[11];stack&lt;int&gt; st;int n, x, now, res;int main()&#123; now = 1; scanf("%d",&amp;n); for(int i = 1; i &lt;= 2 * n; ++i) &#123; scanf("%s", op); if(op[0] == 'a') &#123; scanf("%d", &amp;x); st.push(x); &#125; else &#123; if(!st.empty()) &#123; if(st.top() == now) st.pop(); else &#123; while(!st.empty()) st.pop(); ++res; &#125; &#125; ++now; &#125; &#125; printf("%d\n", res); return 0;&#125; I - Interesting Yang Hui Triangle【Lucas定理应用】题意：杨辉三角第$n$行的$n+1$个数有多少个数可以被$p$整除。 思路：Lucas定理的应用，自己搜一下。 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;ll p, n;int main () &#123; int cas = 0; while (scanf("%lld %lld", &amp;p, &amp;n) != EOF &amp;&amp; p+n) &#123; ll ans = 1; while (n) &#123; ans = ans*(n%p+1)%10000; n /= p; &#125; printf("Case %d: %04lld\n", ++cas, ans); &#125; return 0;&#125; J - Judge Fake or Leak【模拟】题意：模拟ICPC规则下封榜后队伍排名变化情况，即给出封榜前的和封榜后的排名，判断是否合法。 思路：因为答案非Fake即Leak，所以我们采用交随机数的方法。模拟。 K - King_jy and Cities【最短路】题意：$n$个城市，$m$条双向路和$k$条单向路，问$k$条单向路中有多少条是可以关闭后不影响从$1$到其余$n - 1$个城市的最短长度的。 思路：建图统计。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200005;const int maxm = 1000005;const long long inf = 0x3f3f3f3f3f3f3f3f;struct edge &#123; int u, v, w, ne, hc;&#125;ed[maxm];int head[maxn], cnt, tot; long long dis[maxn], sum;int vis[maxn], times[maxn]; int change[maxn], id[maxn];int n, m;void init() &#123; cnt = 0; for (int i = 0; i &lt;= n; i++) &#123; dis[i] = inf, times[i] = 0, vis[i] = 0, head[i] = -1, change[i] = 0; &#125;&#125;void addedge(int u, int v, int w, int t) &#123; ed[cnt].u = u; ed[cnt].v = v; ed[cnt].w = w; ed[cnt].hc = t; ed[cnt].ne = head[u]; head[u] = cnt++;&#125;struct cmp &#123; bool operator()(int a, int b) &#123; return dis[a] &gt; dis[b]; &#125;&#125;;bool spfa(int st) &#123; priority_queue&lt;int, vector&lt;int&gt;, cmp&gt;q; dis[st] = 0; vis[st] = 1; q.push(st); while (!q.empty()) &#123; int u = q.top(); q.pop(); vis[u] = 0; for (int i = head[u]; ~i; i = ed[i].ne) &#123; int v = ed[i].v; if (dis[v] &gt; dis[u] + ed[i].w || (dis[v] == dis[u] + ed[i].w&amp;&amp;change[v] == 1)) &#123; dis[v] = dis[u] + ed[i].w; change[v] = ed[i].hc; if (!vis[v]) &#123; vis[v] = 1; q.push(v); if (++times[v] &gt; n) &#123; return 0; &#125; &#125; &#125; &#125; &#125; return 1;&#125;int main() &#123; int k; ios::sync_with_stdio(0); while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) &#123; init(); while (m--) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; addedge(a, b, c, 0); addedge(b, a, c, 0); &#125; int ans = 0; for (int i = 0; i &lt; k; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; addedge(1, a, b, 1); &#125; spfa(1); for (int i = 2; i &lt;= n; i++) &#123; if (change[i] == 1) &#123; ans++; &#125; &#125; cout &lt;&lt; k - ans &lt;&lt; "\n"; &#125; return 0;&#125; L - Lucky Numbers【签到】题意：幸运数字定义为只包含7和8的数字，求不超过$n$位数的幸运数字的个数。 思路：写一下就发现是$\sum_1^{n} 2^i$。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int maxn = 56;ll C[maxn][maxn];ll ans[maxn];void init () &#123; C[0][0] = C[1][0] = C[1][1] = 1; for (int i = 2; i &lt; maxn; ++i) &#123; C[i][0] = C[i][i] = 1; for (int j = 1; j &lt; i; ++j) &#123; C[i][j] = C[i-1][j-1]+C[i-1][j]; &#125; &#125; ans[1] = 2; for (int i = 2; i &lt; maxn; ++i) &#123; for (int j = i; j &gt;= 0; --j) &#123; ans[i] += C[i][j]; &#125; &#125; for (int i = 1; i &lt; maxn; ++i) &#123; ans[i] += ans[i-1]; &#125;&#125;int main () &#123; init(); int n; scanf("%d", &amp;n); cout &lt;&lt; ans[n] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 SDNU ACM-ICPC Provincial Team Selection Round 1【完结】]]></title>
    <url>%2Fsdnu-2019-11%2F</url>
    <content type="text"><![CDATA[A - Albert_s and Chocolate【签到】题意：超市搞活动，每买$a$个巧克力棒就会赠给你$b$个，现在你有$s$元，每个巧克力棒花费$c$元，问你最多能获得多少巧克力棒。 思路：直接做。注意乘除关系以及long long。 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;int t;ll s, a, b, c;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%lld%lld%lld%lld", &amp;s,&amp;a,&amp;b,&amp;c); ll tmp = s / c; ll res = tmp + tmp / a * b; printf("%lld\n", res); &#125; return 0;&#125; B - Birthday Tears【暴力】题意：略。 思路：直接做。如果觉得不优美，可以随便加点东西，我做的⽐较繁琐，⽤了⼀个带log的处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std; const int MAXN = 100000 + 10;const int MAXC = 20; char s[MAXN];int f[MAXN][MAXC];int log2[MAXN]; bool check(int x, int y)&#123; int k = log2[y - x + 1]; if (f[x][k] == f[y - (1 &lt;&lt; k) + 1][k] &amp;&amp; f[x][k] &gt; -1) return true; else return false;&#125; int main()&#123; int testCase; scanf("%d", &amp;testCase); for (int j = 0; (1 &lt;&lt; j) &lt; MAXN; ++j) for (int i = 1 &lt;&lt; j; i &lt; min(MAXN, (1 &lt;&lt; (j + 1))); ++i) log2[i] = j; while (testCase--) &#123; scanf("%s", s); int n = strlen(s); for (int i = 0; i &lt; n; ++i) f[i][0] = s[i] - 'a'; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; ++i) if (f[i][j - 1] == f[i + (1 &lt;&lt; (j - 1))][j - 1]) f[i][j] = f[i][j - 1]; else f[i][j] = -1; int ans = -1; for (int len = n, tear = 0; len &gt; 0; tear++, len /= 2) &#123; for (int i = 0; i &lt; n; i += len) if (check(i, i + len - 1)) &#123; ans = tear; break; &#125; if (ans != -1) break; if (len % 2 != 0) break; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; C - Cheat in the Game【博弈】【DP】http://www.hankcs.com/program/algorithm/poj-3688-cheat-in-the-game.html 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 10010;const int M = 100010;int n, m, res, a[N], dp[M][2];int main()&#123; while(scanf("%d%d", &amp;n,&amp;m) &amp;&amp; (n || m)) &#123; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = m; j &gt; a[i]; --j) &#123; if(dp[j - a[i]][0]) dp[j][1] = 1; if(dp[j - a[i]][1]) dp[j][0] = 1; &#125; dp[a[i]][1] = 1; &#125;// for(int i = 1; i &lt;= m; ++i)// cout &lt;&lt; dp[i][0] &lt;&lt; ' ' &lt;&lt; dp[i][1] &lt;&lt; endl; res = 0; for(int i = 1; i &lt;= m; ++i) if(dp[i][1] &amp;&amp; !dp[i][0]) ++res; printf("%d\n", res); &#125; return 0;&#125; D - Decompressing Of Matrix【最大流】题意：略。 思路：略。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;int id[25][25];const int maxn = 115;const int maxm = 10010;const int inf = 0x3f3f3f3f;struct fuck &#123; int v, w, ne, u;&#125;ed[maxm];int n, m, cnt;int head[maxn], dis[maxn], cur[maxn];void init() &#123; cnt = 0; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w) &#123; ed[cnt].v = v; ed[cnt].w = w; ed[cnt].u = u; ed[cnt].ne = head[u]; head[u] = cnt++; ed[cnt].v = u, ed[cnt].w = 0; ed[cnt].u = v; ed[cnt].ne = head[v]; head[v] = cnt++;&#125;int bfs(int st, int en) &#123; queue&lt;int&gt;q; memset(dis, 0, sizeof(dis)); dis[st] = 1; q.push(st); while (!q.empty()) &#123; int u = q.front(); q.pop(); if (u == en)return 1; for (int s = head[u]; ~s; s = ed[s].ne) &#123; int v = ed[s].v; if (dis[v] == 0 &amp;&amp; ed[s].w &gt; 0) &#123; dis[v] = dis[u] + 1; q.push(v); &#125; &#125; &#125; return dis[en] != 0;&#125;int dfs(int st, int en, int flow) &#123; int ret = flow, a; if (st == en || flow == 0)return flow; for (int &amp;s = cur[st]; ~s; s = ed[s].ne) &#123; int v = ed[s].v; if (dis[v] == dis[st] + 1 &amp;&amp; (a = dfs(v, en, min(ret, ed[s].w)))) &#123; ed[s].w -= a; ed[s ^ 1].w += a; ret -= a; if (!ret)break; &#125; &#125; if (ret == flow)dis[st] = 0; return flow - ret;&#125;int dinic(int st, int en) &#123; int ans = 0; while (bfs(st, en)) &#123; for (int s = 0; s &lt;= en; s++) //这里！！ cur[s] = head[s]; ans += dfs(st, en, inf); &#125; return ans;&#125;int main() &#123; int te, cas = 1; ios::sync_with_stdio(0); cin &gt;&gt; te; while (te--) &#123; init(); cin &gt;&gt; n &gt;&gt; m; int last = 0; int st = 0; for (int i = 1; i &lt;= n; i++) &#123; int d; cin &gt;&gt; d; add(st, i, d - last - m); last = d; for (int j = 1; j &lt;= m; j++)&#123; id[i][j] = cnt; add(i, j + n, 19); &#125; &#125; last = 0; int en = 105; for (int i = 1; i &lt;= m; i++) &#123; int d; cin &gt;&gt; d; add(n + i, en, d - n - last); last = d; &#125; dinic(st, en); cout &lt;&lt; "Matrix " &lt;&lt; cas++ &lt;&lt; "\n"; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; ed[id[i][1] ^ 1].w + 1; for (int j = 2; j &lt;= m; j++) &#123; cout &lt;&lt; " " &lt;&lt; ed[id[i][j] ^ 1].w + 1; &#125; cout &lt;&lt; "\n"; &#125; &#125; return 0;&#125; E - Easy Basic remains【大数】题意：求$b$进制下的$p$ mod $m$的结果 思路：模拟 || 开上Java直接做。 123456789101112131415161718192021import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner cin = new Scanner(System.in); int base; BigInteger n, m, res; while(cin.hasNext()) &#123; base = cin.nextInt(); if(base == 0) break; n = cin.nextBigInteger(base); m = cin.nextBigInteger(base); res = n.mod(m); System.out.println(res.toString(base)); &#125; &#125;&#125; F - Fast Matrix Operations【线段树】题意：略。 思路：开上20颗线段树直接搞。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1const int maxn = 1e6 + 10;struct fuck &#123; int sum, maxn, minn;&#125;c[maxn * 3][21];int add[maxn * 3][21], chan[maxn * 2][21];int l[maxn * 3][21], r[maxn * 3][21];void pushup(int x, int rt) &#123; c[rt][x].sum = c[rt &lt;&lt; 1][x].sum + c[rt &lt;&lt; 1 | 1][x].sum; c[rt][x].maxn = max(c[rt &lt;&lt; 1][x].maxn, c[rt &lt;&lt; 1 | 1][x].maxn); c[rt][x].minn = min(c[rt &lt;&lt; 1][x].minn, c[rt &lt;&lt; 1 | 1][x].minn);&#125;void pushdown(int x, int rt, int len) &#123; if (chan[rt][x] != -1) &#123; c[rt &lt;&lt; 1][x].maxn = chan[rt][x]; c[rt &lt;&lt; 1][x].minn = chan[rt][x]; c[rt &lt;&lt; 1][x].sum = (len + 1) / 2 * chan[rt][x]; add[rt &lt;&lt; 1][x] = 0; chan[rt &lt;&lt; 1][x] = chan[rt][x]; c[rt &lt;&lt; 1 | 1][x].maxn = chan[rt][x]; c[rt &lt;&lt; 1 | 1][x].minn = chan[rt][x]; c[rt &lt;&lt; 1 | 1][x].sum = (len) / 2 * chan[rt][x]; add[rt &lt;&lt; 1 | 1][x] = 0; chan[rt &lt;&lt; 1 | 1][x] = chan[rt][x]; &#125; if (add[rt][x] != 0) &#123; c[rt &lt;&lt; 1][x].maxn += add[rt][x]; c[rt &lt;&lt; 1][x].minn += add[rt][x]; c[rt &lt;&lt; 1][x].sum += (len + 1) / 2 * add[rt][x]; add[rt &lt;&lt; 1][x] += add[rt][x]; c[rt &lt;&lt; 1 | 1][x].maxn += add[rt][x]; c[rt &lt;&lt; 1 | 1][x].minn += add[rt][x]; c[rt &lt;&lt; 1 | 1][x].sum += (len) / 2 * add[rt][x]; add[rt &lt;&lt; 1 | 1][x] += add[rt][x]; &#125; chan[rt][x] = -1; add[rt][x] = 0;&#125;void build(int x, int l, int r, int rt) &#123; add[rt][x] = 0; chan[rt][x] = -1; if (l == r) &#123; c[rt][x].sum = 0; c[rt][x].minn = 0; c[rt][x].maxn = 0; return; &#125; int m = (l + r) &gt;&gt; 1; build(x, lson); build(x, rson); pushup(x, rt);&#125;void change(int x, int L, int R, int l, int r, int rt, int k) &#123; if (L &lt;= l&amp;&amp;r &lt;= R) &#123; c[rt][x].sum = (r - l + 1)*k; c[rt][x].maxn = c[rt][x].minn = k; add[rt][x] = 0; chan[rt][x] = k; return; &#125; int m = (l + r) &gt;&gt; 1; int len = (r - l + 1); pushdown(x, rt, len); if (L &lt;= m) change(x, L, R, lson, k); if (R &gt; m) change(x, L, R, rson, k); pushup(x, rt);&#125;void addnum(int x, int L, int R, int l, int r, int rt, int k) &#123; if (L &lt;= l&amp;&amp;r &lt;= R) &#123; c[rt][x].sum += (r - l + 1)*k; c[rt][x].maxn += k; c[rt][x].minn += k; add[rt][x] += k; return; &#125; int m = (l + r) &gt;&gt; 1; int len = (r - l + 1); pushdown(x, rt, len); if (L &lt;= m) addnum(x, L, R, lson, k); if (R &gt; m) addnum(x, L, R, rson, k); pushup(x, rt);&#125;int query(int x, int L, int R, int l, int r, int rt, int &amp;maxn, int &amp;minn) &#123; if (L &lt;= l&amp;&amp;r &lt;= R) &#123; maxn = max(maxn, c[rt][x].maxn); minn = min(minn, c[rt][x].minn); return c[rt][x].sum; &#125; int m = (l + r) &gt;&gt; 1, len = (r - l + 1); int sum = 0; pushdown(x, rt, len); if (L &lt;= m) &#123; sum += query(x, L, R, lson, maxn, minn); &#125; if (R &gt; m) &#123; sum += query(x, L, R, rson, maxn, minn); &#125; pushup(x, rt); return sum;&#125;int main() &#123; int n, m, q; ios::sync_with_stdio(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= n; i++) build(i, 1, m, 1); while (q--) &#123; int a; cin &gt;&gt; a; int b, c, d, e, f; if (a == 1) &#123; cin &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f; if (b &gt; d)swap(b, d); if (c &gt; e)swap(c, e); for (int i = b; i &lt;= d; i++) &#123; addnum(i, c, e, 1, m, 1, f); &#125; &#125; else if (a == 2) &#123; cin &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f; if (b &gt; d)swap(b, d); if (c &gt; e)swap(c, e); for (int i = b; i &lt;= d; i++) &#123; change(i, c, e, 1, m, 1, f); &#125; &#125; else &#123; cin &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e; if (b &gt; d)swap(b, d); if (c &gt; e)swap(c, e); int ans = 0, maxn = -1, minn = 2147483647; for (int i = b; i &lt;= d; i++) &#123; ans += query(i, c, e, 1, m, 1, maxn, minn); &#125; cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; minn &lt;&lt; " " &lt;&lt; maxn &lt;&lt; "\n"; &#125; &#125; return 0;&#125; G. Game of Stones【优先队列】题意：略。 思路：模拟。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int t, n, p, d, res;struct node&#123; int p, d;&#125; now;struct cmp&#123; bool operator() (const node &amp;u, const node &amp;v) &#123; if(u.p == v.p) return u.d &gt; v.d; return u.p &gt; v.p; &#125;&#125;;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; Q; res = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d", &amp;p,&amp;d); //感觉这里需要加上才更完善，但没加也过了。 //res = max(res, p); now.p = p, now.d = d; Q.push(now); &#125; bool flag = 0; while(1) &#123; flag = !flag; now = Q.top(); Q.pop(); if(flag) &#123; if(Q.empty()) &#123; //res = max(res, now.p + now.d); res = now.p + now.d; break; &#125; now.p = now.p + now.d; Q.push(now); &#125; else continue; &#125; printf("%d\n", res); &#125; return 0;&#125; H - Hacker, pack your bags!【贪心】题意&amp;思路：见https://alberts97.github.io/cf-822c/ 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int N = 200010;const int oo = 2e9+7;int n, x, l, r, c, res, tem;vector&lt; pair&lt;int, int&gt; &gt; G[N];int main()&#123; scanf("%d%d", &amp;n, &amp;x); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d%d", &amp;l, &amp;r, &amp;c); G[r - l + 1].push_back(&#123;l, c&#125;); &#125; for(int i = 1; i &lt; x; ++i) sort(G[i].begin(), G[i].end()); res = oo; for(int cost = 1; cost &lt; x; ++cost) &#123; tem = oo; auto &amp;u = G[cost], &amp;v = G[x - cost]; for(int i = 0, j = 0; i &lt; v.size(); ++i) &#123; while(j &lt; u.size() &amp;&amp; u[j].first + cost - 1 &lt; v[i].first) &#123; tem = min(tem, u[j].second); ++j; &#125; if(tem != oo) res = min(res, tem + v[i].second); &#125; &#125; printf("%d\n", res == oo ? -1 : res); return 0;&#125; I - Interesting String【Manacher模板】题意：求最长回文子串的长度。 思路：无。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXN=1000010;char Ma[MAXN*2];int Mp[MAXN*2];void Manacher(char s[],int len)&#123; int l=0; Ma[l++]='$'; Ma[l++]='#'; for(int i=0; i&lt;len; i++) &#123; Ma[l++]=s[i]; Ma[l++]='#'; &#125; Ma[l]=0; int mx=0,id=0; for(int i=0; i&lt;l; i++) &#123; Mp[i]=mx&gt;i?min(Mp[2*id-i],mx-i):1; while(Ma[i+Mp[i]]==Ma[i-Mp[i]]) Mp[i]++; if(i+Mp[i]&gt;mx) &#123; mx=i+Mp[i]; id=i; &#125; &#125;&#125;char s[MAXN];int main()&#123; for(int cas = 1; scanf("%s",s)==1; ++cas) &#123; if(s[0] == 'E') break; int len=strlen(s); Manacher(s,len); int ans=0; for(int i=0; i&lt;2*len+2; i++) ans=max(ans,Mp[i]-1); printf("Case %d: %d\n",cas, ans); &#125; return 0;&#125; J - Joseph【数据结构】题意：略。 思路：但是什么都不管暴⼒模拟也是可以的，⽤任意⼀个带 log 的数据结构。中档题的原因是因为优美做法需要想⼀下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std; const int MAXN = 1000000 + 10; int c[MAXN];int N, K; void add(int x, int y)&#123; for (; x &lt;= N; x += x &amp; -x) c[x] += y;&#125; int get(int x)&#123; int res = 0; for (; x; x -= x &amp; -x) res += c[x]; return res;&#125; int findk(int K)&#123; int k = 1; int p = 0; while ((k &gt;&gt; 1) &lt;= N) &#123; ++p; k &lt;&lt;= 1; &#125; int ans = 0; int res = 0; for (int i = p; i &gt;= 0; --i) &#123; if (ans + k &lt;= N &amp;&amp; res + c[ans + k] &lt; K) &#123; res += c[ans + k]; ans += k; &#125; k &gt;&gt;= 1; &#125; return ans + 1;&#125; int main()&#123; int testCase; scanf("%d", &amp;testCase); while (testCase--) &#123; scanf("%d%d", &amp;N, &amp;K); fill_n(c, N + 1, 0); for (int i = 1; i &lt;= N; ++i) add(i, 1); bool inverse = false; if (K &lt; 0) &#123; K = -K; inverse = true; &#125; long long cnt = K; int now = K % N; if (now == 0) now = N; int d = 1; for (int n = N; n &gt; 1; --n) &#123; int pos = findk(now); add(pos, -1); //cout &lt;&lt; "pos = " &lt;&lt; pos &lt;&lt; endl; //cout &lt;&lt; "now = " &lt;&lt; now &lt;&lt; endl; d = -d; cnt = cnt + K; int cnm = (cnt - 1) % (n - 1); if (d &lt; 0) now--; if (d &gt; 0) &#123; now = (now + cnm) % (n - 1); if (now == 0) now = n - 1; &#125; else &#123; now = (now - cnm + n - 1 + n - 1) % (n - 1); if (now == 0) now = n - 1; &#125; &#125; int ans = findk(1); if (inverse) if (ans &gt; 1) ans = N - 1 - (ans - 1) + 2; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; K - K-th Power【拉格朗日插值】题意：求$\sum_{i=1}^n i^k = 1^k + 2^k +\ldots + n^k $ % $10^9 + 7$的值 思路：嗯。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1e6+15;const ll mod = 1e9+7;int tot;ll pri[maxn];bool is[maxn];ll f[maxn];ll jc[maxn];ll ijc[maxn];int n, k;ll qm (ll a, ll b)&#123; ll ans = 1; a %= mod; while (b) &#123; if (b&amp;1) &#123; ans = a*ans%mod; &#125; a = a*a%mod; b &gt;&gt;= 1; &#125; return ans%mod;&#125;ll inv (ll k)&#123; return qm(k, mod-2)%mod;&#125;void init (int maxn)&#123; f[0] = 0; f[1] = 1; is[0] = is[1] = 1; for (int i = 2; i &lt; maxn; ++i) &#123; if (!is[i]) &#123; pri[++tot] = i; f[i] = qm(i, k); &#125; for (int j = 1; j &lt;= tot &amp;&amp; 1ll*i*pri[j] &lt; maxn; ++j) &#123; is[i*pri[j]] = 1; f[i*pri[j]] = f[i]*f[pri[j]]%mod; if (i % pri[j] == 0) &#123; break; &#125; &#125; &#125; for (int i = 0; i &lt; maxn; ++i) &#123; f[i] = f[i]+f[i-1]; f[i] %= mod; &#125; ijc[0] = ijc[1] = jc[0] = jc[1] = 1; for (int i = 2; i &lt; maxn; ++i) &#123; jc[i] = jc[i-1]*i%mod; ijc[i] = inv(jc[i]); &#125;&#125;int main ()&#123; cin &gt;&gt; n &gt;&gt; k; init(k+15); if (n &lt;= k+2) &#123; cout &lt;&lt; f[n] &lt;&lt; '\n'; return 0; &#125; k += 2; ll ans = 0; ll tmp = 1; for(int i = 1; i&lt;= k; i++) &#123; tmp = (tmp*(n-i))%mod; &#125; for (int i = 1; i &lt;= k; ++i) &#123; if ((k-i)%2 == 0) &#123; ans += f[i]*inv(n-i)%mod*ijc[i-1]%mod*ijc[k-i]%mod*tmp%mod; ans = (ans%mod+mod)%mod; &#125; else &#123; ans -= f[i]*inv(n-i)%mod*ijc[i-1]%mod*ijc[k-i]%mod*tmp%mod; ans = (ans%mod+mod)%mod; &#125; &#125; cout &lt;&lt; (ans%mod+mod)%mod &lt;&lt; '\n'; return 0;&#125; L - Let‘s Find The Biggest Out【暴力】题意：略。 思路：答案是倒数第⼆⼤的数，或者暴⼒模拟最⼤的数模其他的数。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; int main()&#123; int testCase; cin &gt;&gt; testCase; while (testCase--) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a; for (int i = 0; i &lt; n; ++i) &#123; int t; cin &gt;&gt; t; a.push_back(t); &#125; sort(a.begin(), a.end()); n = unique(a.begin(), a.end()) - a.begin(); int ans = 0; if (n &gt; 1) ans = a[n - 2]; for (int i = 0; i &lt; n; ++i) ans = max(ans, a[n - 1] % a[i]); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2975 Nim【nim博弈的理解】]]></title>
    <url>%2Fpoj-2975%2F</url>
    <content type="text"><![CDATA[题意：$n$堆石子，两人进行nim博弈，问可以从哪堆石子开始先取能保证先手必胜。 思路：nim博弈中先手必胜的条件是所有石子个数异或值不为0，原因是先手总可以通过取一些石子使得现有石子达到平衡态，平衡态之后通过模仿前者的操作就能必胜。 那么第一步就能使当前状态达到平衡态的条件又是什么呢？很容易想到就是剩余石子堆个数的异或值小于这一堆的石子数(即通过取走一定数量使得总堆数达到平衡态)。 MyCode：12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1111;int n, res, cnt, a[N];int main()&#123; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; res = cnt = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;a[i]); res ^= a[i]; &#125; for(int i = 0; i &lt; n; ++i) &#123; if(a[i] &gt; (a[i] ^ res)) ++cnt; &#125; printf("%d\n", cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>nim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识点】博弈之SG函数]]></title>
    <url>%2Fgame-sg%2F</url>
    <content type="text"><![CDATA[学习参考文章： https://www.cnblogs.com/ECJTUACM-873284962/p/6921829.html https://www.cnblogs.com/aiguona/p/9126324.html 模板递推版：12345678910111213141516171819202122232425262728293031//全部都算出来const int N = 22;const int M = 1111;bool vis[M];int f[N], SG[M];void init() //初始化f数组&#123; //f数组的初始化&#125;void getSG(int n) //得到SG值&#123; memset(SG, 0, sizeof(SG)); for(int i = 1; i &lt;= n; ++i) &#123; //为下一步的运算进行标记 memset(vis, 0, sizeof(vis)); for(int j = 0; i &gt;= f[j] &amp;&amp; j &lt; N; ++j) vis[SG[i - f[j]]] = 1; //得到mex的值 for(int j = 0; ; ++j) if(!vis[j]) &#123; SG[i] = j; break; &#125; &#125;&#125; 递归版:123456789101112131415161718192021222324252627282930//用到哪个计算哪个const int N = 111;const int M = 11111;int f[N], SG[M];void init()&#123; memset(SG, -1, sizeof(SG)); //f数组的初始化&#125;int dfsSG(int x) //得到SG值&#123; if(SG[x] != -1) return SG[x]; //为下一步的运算进行标记 bool vis[N] = &#123;0&#125;; for(int i = 0; x &gt;= f[i] &amp;&amp; i &lt; n; ++i) &#123; dfsSG(x - f[i]); vis[SG[x - f[i]]] = 1; &#125; //得到mex的值 for(int i = 0; ; ++i) if(!vis[i]) return SG[x] = i;&#125; 简单题目练习：HDU 1847 最基本的应用题意：$n$张牌，每次只能抓$2$的倍数张牌，先抓完胜，kiki先抓。 Code1： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 11;const int M = 1111;bool vis[M];int f[N], SG[M];void init() //初始化f数组&#123; f[0] = 1; for(int i = 1; i &lt; N; ++i) f[i] = f[i - 1] &lt;&lt; 1;&#125;void getSG(int n) //得到SG值&#123; memset(SG, 0, sizeof(SG)); for(int i = 1; i &lt;= n; ++i) &#123; //为下一步的运算进行标记 memset(vis, 0, sizeof(vis)); for(int j = 0; i &gt;= f[j] &amp;&amp; j &lt; N; ++j) vis[SG[i - f[j]]] = 1; //得到mex的值 for(int j = 0; ; ++j) if(!vis[j]) &#123; SG[i] = j; break; &#125; &#125;&#125;int n;int main()&#123; init(); getSG(1000); while(~scanf("%d",&amp;n)) &#123; puts(SG[n] ? "Kiki" : "Cici"); &#125; return 0;&#125; Code2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 111;const int M = 11111;int f[N], SG[M];void init()&#123; memset(SG, -1, sizeof(SG)); f[0] = 1; for(int i = 1; i &lt;= 10; ++i) f[i] = f[i - 1] &lt;&lt; 1;&#125;int dfsSG(int x) //得到SG值&#123; if(SG[x] != -1) return SG[x]; //为下一步的运算进行标记 bool vis[N] = &#123;0&#125;; for(int i = 0; x &gt;= f[i] &amp;&amp; i &lt; N; ++i) &#123; dfsSG(x - f[i]); vis[SG[x - f[i]]] = 1; &#125; //得到mex的值 for(int i = 0; ; ++i) if(!vis[i]) return SG[x] = i;&#125;int n;int main()&#123; init(); while(~scanf("%d", &amp;n)) puts(dfsSG(n) ? "Kiki" : "Cici"); return 0;&#125; HDU 1848 划分子游戏-分别求-合并题意：$3$堆石子分别$n$、$m$、$k$个，每次取fibonacci数个石子，fibo先取。 Code1： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 22;const int M = 1111;bool vis[M];int f[N], SG[M];void init() //初始化f数组&#123; f[0] = f[1] = 1; for(int i = 2; i &lt; N; ++i) f[i] = f[i - 1] + f[i - 2];&#125;void getSG(int n) //得到SG值&#123; memset(SG, 0, sizeof(SG)); for(int i = 1; i &lt;= n; ++i) &#123; //为下一步的运算进行标记 memset(vis, 0, sizeof(vis)); for(int j = 0; i &gt;= f[j] &amp;&amp; j &lt; N; ++j) vis[SG[i - f[j]]] = 1; //得到mex的值 for(int j = 0; ; ++j) if(!vis[j]) &#123; SG[i] = j; break; &#125; &#125;&#125;int n, m, k;int main()&#123; init(); getSG(1000); while(scanf("%d%d%d",&amp;n,&amp;m,&amp;k) &amp;&amp; (n || m || k)) &#123; puts((SG[n] ^ SG[m] ^ SG[k]) ? "Fibo" : "Nacci"); &#125; return 0;&#125; Code2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 111;const int M = 11111;int f[N], SG[M];void init()&#123; memset(SG, -1, sizeof(SG)); f[0] = f[1] = 1; for(int i = 2; i &lt;= 17; ++i) f[i] = f[i - 1] + f[i - 2];&#125;int dfsSG(int x) //得到SG值&#123; if(SG[x] != -1) return SG[x]; //为下一步的运算进行标记 bool vis[N] = &#123;0&#125;; for(int i = 0; x &gt;= f[i] &amp;&amp; i &lt; N; ++i) &#123; dfsSG(x - f[i]); vis[SG[x - f[i]]] = 1; &#125; //得到mex的值 for(int i = 0; ; ++i) if(!vis[i]) return SG[x] = i;&#125;int n, m, k;int main()&#123; init(); while(scanf("%d%d%d", &amp;n,&amp;m,&amp;k) &amp;&amp; (n || m || k)) puts((dfsSG(n) ^ dfsSG(m) ^ dfsSG(k)) ? "Fibo" : "Nacci"); return 0;&#125; HDU 1536 划分&amp;合并在$Nim$博弈的条件下加上限制：每次只能移走给定的$n$个数的个数的石子。$m$次询问，每次给出$k$堆石子的个数，问先手是否能赢。 Code1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int N = 111;const int M = 11111;bool vis[M];int f[N], SG[M];int n, m, k, t, res;void init() //初始化f数组&#123; for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;f[i]); sort(f, f + n);&#125;void getSG() //得到SG值&#123; memset(SG, 0, sizeof(SG)); for(int i = 1; i &lt; M; ++i) &#123; //为下一步的运算进行标记 memset(vis, 0, sizeof(vis)); for(int j = 0; i &gt;= f[j] &amp;&amp; j &lt; n; ++j) vis[SG[i - f[j]]] = 1; //得到mex的值 for(int j = 0; ; ++j) if(!vis[j]) &#123; SG[i] = j; break; &#125; &#125;&#125;int main()&#123; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; init(); getSG(); //预处理出所有的SG值来，不用每次都求一遍 scanf("%d", &amp;m); while(m--) &#123; res = 0; scanf("%d", &amp;k); for(int i = 0; i &lt; k; ++i) &#123; scanf("%d", &amp;t); res ^= SG[t]; &#125; putchar(res ? 'W' : 'L'); &#125; puts(""); &#125; return 0;&#125; Code2： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 111;const int M = 11111;int f[N], SG[M];int n, m, k, t, res;void init()&#123; memset(SG, -1, sizeof(SG)); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;f[i]); sort(f, f + n);&#125;int dfsSG(int x)&#123; if(SG[x] != -1) return SG[x]; bool vis[N] = &#123;0&#125;; for(int i = 0; x &gt;= f[i] &amp;&amp; i &lt; n; ++i) &#123; dfsSG(x - f[i]); vis[SG[x - f[i]]] = 1; &#125; for(int i = 0; ; ++i) if(!vis[i]) return SG[x] = i;&#125;int main()&#123; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; init(); scanf("%d", &amp;m); while(m--) &#123; res = 0; scanf("%d", &amp;k); for(int i = 0; i &lt; k; ++i) &#123; scanf("%d", &amp;t); res ^= dfsSG(t); &#125; putchar(res ? 'W' : 'L'); &#125; puts(""); &#125; return 0;&#125; 为了AC这一题学的SG函数LightOJ 1315 Game of Hyper Knights题意：棋盘上有$n$个棋子，告诉你棋子的初始位置，两人轮流按照规定的移动方向移动棋子，每次只能移动一个棋子，两个棋子可以重合在一个位置。谁无法移动棋子时谁就输了。 思路：求出每个棋子的SG函数，划分后再合并。 MyCode： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 111;const int M = 1111;int dir[][2] = &#123;-3,-1,-2,-1,-2,1,-1,-3,-1,-2,1,-2&#125;;int SG[M][M];void init()&#123; memset(SG, -1, sizeof(SG));&#125;int dfsSG(int x, int y) //得到SG值&#123; if(SG[x][y] != -1) return SG[x][y]; //为下一步的运算进行标记 bool vis[N] = &#123;0&#125;; for(int i = 0; i &lt; 6; ++i) &#123; int xx = x + dir[i][0]; int yy = y + dir[i][1]; if(xx &lt; 0 || yy &lt; 0) continue; dfsSG(xx, yy); vis[SG[xx][yy]] = 1; &#125; //得到mex的值 for(int i = 0; ; ++i) if(!vis[i]) return SG[x][y] = i;&#125;int t, n, x, y, res;int main()&#123; init(); scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; res = 0; scanf("%d", &amp;n); while(n--) &#123; scanf("%d%d", &amp;x, &amp;y); res ^= dfsSG(x, y); &#125; printf("Case %d: %s\n", cas, res ? "Alice" : "Bob"); &#125; return 0;&#125; 其他的一些练习POJ 2425 A Chess Game【树形博弈】【SG函数】题意：给定一个有向无环图，上面有一些棋子，棋子可以重合，两人依次对这些石子进行操作，每次操作可以将一个棋子从一个位置移动到相邻的位置，无法移动着输。问先手是否必胜。 思路：把每个棋子单独看作一个游戏，所有棋子的SG值就是这些棋子的SG值的异或和。 MyCode： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int N = 1111;int SG[N];int n, m, t;vector&lt;int&gt; G[N];void init()&#123; memset(SG, -1, sizeof(SG)); for(int i = 0; i &lt; n; ++i) G[i].clear();&#125;int dfsSG(int x) //得到SG值&#123; if(SG[x] != -1) return SG[x]; //为下一步的运算进行标记 bool vis[N] = &#123;0&#125;; for(int i = 0; i &lt; G[x].size(); ++i) &#123; dfsSG(G[x][i]); vis[SG[G[x][i]]] = 1; &#125; //得到mex的值 for(int i = 0; ; ++i) if(!vis[i]) return SG[x] = i;&#125;int main()&#123; while(~scanf("%d", &amp;n)) &#123; init(); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;m); while(m--) &#123; scanf("%d", &amp;t); G[i].push_back(t); &#125; &#125; while(scanf("%d", &amp;m) &amp;&amp; m) &#123; int res = 0; for(int i = 0; i &lt; m; ++i) &#123; scanf("%d", &amp;t); res ^= dfsSG(t); &#125; puts(res ? "WIN" : "LOSE"); &#125; &#125; return 0;&#125; POJ 1704 Georgia and Bob【阶梯博弈】题意：一行方格中，放置着$n$个棋子，每个棋子占据着唯一的一个方格。两人轮流移动棋子，每次选择一个向左移动至少一个方格，移动过程中不可跨越其他棋子或者越过棋盘。问谁赢。 思路：将相邻两堆一起看(如果是奇数堆则第一堆和0一起看)。前一对进行移动操作后后一对总能移动相应的位置恢复到之前的状态所以相邻两对之间的空格数对结果是没有影响的，因此只需考虑一对之间的空格数就可以了，这样将相邻一对的空格数记录一下后就成了阶梯博弈。 阶梯博弈：https://blog.csdn.net/kk303/article/details/6692506 MyCode： 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1111;int t, n, a[N];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); sort(a + 1, a + n + 1); int res = 0; for(int i = n; i &gt; 0; i -= 2) res ^= a[i] - a[i - 1] - 1; puts(res ? "Georgia will win" : "Bob will win"); &#125; return 0;&#125; HDU 4315 Climbing the Hill【阶梯博弈】题意：有$N$个人爬山，山顶坐标为$0$，其他人的坐标按升序给出。除山顶外，不同的坐标只能容纳一个人，Alice和Bob轮流选择一个人让他移动任意步，但不能越过前面那个人。谁能将给出ID的人移动到山顶就算谁赢。 Hint：与上一题的不同之处在于这题有$0$这个坐标。 思路：https://www.cnblogs.com/fightfordream/p/6194612.html 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1111;int n, k, a[N];int main()&#123; while(~scanf("%d%d", &amp;n,&amp;k)) &#123; for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); if(k == 1) puts("Alice"); else &#123; if(k == 2) a[0] = 0; else a[0] = -1; int res = 0; for(int i = n; i &gt; 0; i -= 2) res ^= a[i] - a[i - 1] - 1; puts(res ? "Alice" : "Bob"); &#125; &#125; return 0;&#125; HDU 3389 Game【阶梯博弈】题意：$n$堆石子，每回合可选择两堆石子A和B，满足条件：B &lt; A &amp;&amp; (A+B)%2 == 1 &amp;&amp; (A+B)%3 == 0​，将A堆中石子任意颗移动到B堆里。 思路：很容易得知1,3,4这三个位置的石子无法移动，然后%6==0,2,5的位置只能移动奇数步，其余位置为偶数步。为奇数步的位置符合阶梯博弈。 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, x, res;int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; res = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;x); if(i % 6 == 0 || i % 6 == 2 || i % 6 == 5) res ^= x; &#125; printf("Case %d: %s\n", cas, res ? "Alice" : "Bob"); &#125; return 0;&#125; ZOJ 3057 Beans Game【三维威佐夫博弈】【递推打表】题意：在威佐夫博弈的限制下，将石子堆数改变为3堆。 思路：范围很小，可直接将所有结果计算出来。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 301;int x, y, z;bool dp[N][N][N];void init()&#123; for(int i = 0; i &lt; N; ++i) for(int j = 0; j &lt; N; ++j) for(int k = 0; k &lt; N; ++k) if(!dp[i][j][k]) &#123; for(int t = 1; t + i &lt; N; ++t) dp[i + t][j][k] = 1; for(int t = 1; t + j &lt; N; ++t) dp[i][j + t][k] = 1; for(int t = 1; t + k &lt; N; ++t) dp[i][j][k + t] = 1; for(int t = 1; t + i &lt; N &amp;&amp; t + j &lt; N; ++t) dp[i + t][j + t][k] = 1; for(int t = 1; t + i &lt; N &amp;&amp; t + k &lt; N; ++t) dp[i + t][j][k + t] = 1; for(int t = 1; t + k &lt; N &amp;&amp; t + j &lt; N; ++t) dp[i][j + t][k + t] = 1; &#125;&#125;int main()&#123; init(); while(~scanf("%d%d%d", &amp;x,&amp;y,&amp;z)) cout &lt;&lt; dp[x][y][z] &lt;&lt; '\n'; return 0;&#125; POJ 2348 Euclid’s Game【博弈】题意：两人玩游戏，每次选一个为两个数中较小的那个数的倍数，让较大的那个数减去选的这个数(做差后就过不能为负)，谁不能进行操作谁就输了。 思路：规定$n$为两者中较大的那个数，当$n \% m == 0$时当前操作者必胜；对于$n - m$ ＜ $m$的情况，此时的操作者只能进行唯一的操作；当$n - m$ &gt; $m$时，当前操作者可控制整个局面，必胜。 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, m;int main()&#123; while(scanf("%d%d", &amp;n,&amp;m) &amp;&amp; (n + m)) &#123; bool fir = 1; while(true) &#123; if(n &lt; m) swap(n, m); if(n % m == 0) break; if(n - m &gt; m) break; fir = !fir; n -= m; &#125; puts(fir ? "Stan wins" : "Ollie wins"); &#125; return 0;&#125; HDU 3404 Switch lights【Nim积】题意：在一个平面图形中有无穷多的灯，初始时有$n$盏灯亮着。两个玩家每次可选择四个点使这四个点的灯改变状态，要求是这四个点构成一个长方形且右下角的灯要亮着，无法进行操作的输。 思路：Nim积，先存个代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int m[2][2]= &#123;0,0,0,1&#125;;int Nim_Multi_Power(int x,int y)&#123; if(x&lt;2) return m[x][y]; int a=0; for(;; a++) if(x&gt;=(1&lt;&lt;(1&lt;&lt;a))&amp;&amp;x&lt;(1&lt;&lt;(1&lt;&lt;(a+1)))) break; int m=1&lt;&lt;(1&lt;&lt;a); int p=x/m,s=y/m,t=y%m; int d1=Nim_Multi_Power(p,s); int d2=Nim_Multi_Power(p,t); return (m*(d1^d2))^Nim_Multi_Power(m/2,d1);&#125;int Nim_Multi(int x,int y)&#123; if(x&lt;y) return Nim_Multi(y,x); if(x&lt;2) return m[x][y]; int a=0; for(;; a++) if(x&gt;=(1&lt;&lt;(1&lt;&lt;a))&amp;&amp;x&lt;(1&lt;&lt;(1&lt;&lt;(a+1)))) break; int m=1&lt;&lt;(1&lt;&lt;a); int p=x/m,q=x%m,s=y/m,t=y%m; int c1=Nim_Multi(p,s); int c2=Nim_Multi(p,t)^Nim_Multi(q,s); int c3=Nim_Multi(q,t); return (m*(c1^c2))^c3^Nim_Multi_Power(m/2,c1);&#125;int t, n, x, y, res;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; res = 0; scanf("%d", &amp;n); while(n--) &#123; scanf("%d%d", &amp;x,&amp;y); res ^= Nim_Multi(x, y); &#125; puts(res ? "Have a try, lxhgww." : "Don't waste your time."); &#125; return 0;&#125; POJ 3533 Light Switching Game【三维Nim积】题意：上一题的由二维变成了三维。 思路：三维Nim积。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int m[2][2]= &#123;0,0,0,1&#125;;int Nim_Multi_Power(int x,int y)&#123; if(x&lt;2) return m[x][y]; int a=0; for(;; a++) if(x&gt;=(1&lt;&lt;(1&lt;&lt;a))&amp;&amp;x&lt;(1&lt;&lt;(1&lt;&lt;(a+1)))) break; int m=1&lt;&lt;(1&lt;&lt;a); int p=x/m,s=y/m,t=y%m; int d1=Nim_Multi_Power(p,s); int d2=Nim_Multi_Power(p,t); return (m*(d1^d2))^Nim_Multi_Power(m/2,d1);&#125;int Nim_Multi(int x,int y)&#123; if(x&lt;y) return Nim_Multi(y,x); if(x&lt;2) return m[x][y]; int a=0; for(;; a++) if(x&gt;=(1&lt;&lt;(1&lt;&lt;a))&amp;&amp;x&lt;(1&lt;&lt;(1&lt;&lt;(a+1)))) break; int m=1&lt;&lt;(1&lt;&lt;a); int p=x/m,q=x%m,s=y/m,t=y%m; int c1=Nim_Multi(p,s); int c2=Nim_Multi(p,t)^Nim_Multi(q,s); int c3=Nim_Multi(q,t); return (m*(c1^c2))^c3^Nim_Multi_Power(m/2,c1);&#125;int n, x, y, z, res;int main()&#123; while(~scanf("%d", &amp;n)) &#123; res = 0; while(n--) &#123; scanf("%d%d%d", &amp;x,&amp;y,&amp;z); res ^= Nim_Multi(Nim_Multi(x, y), z); &#125; puts(res ? "No" : "Yes"); &#125; return 0;&#125; ZOJ 3599 Game【K倍动态减法】题意：两人轮流取石子，第一个人可以随意取不超过总数的石子，后面的人取不超过第一个人$k$倍的石子，最后一个取到的人赢，问石子数在$1$ ~ $n$中有多少种先手必胜的局面。 思路：$k$倍动态减法，存一下。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 3000000;typedef long long ll;int t, n, k;ll a[N], b[N];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;k, &amp;n); a[0] = b[0] = 1; int i = 0, j = 0; while(n &gt; a[i]) &#123; ++i; a[i] = b[i - 1] + 1; while(a[j + 1] * k &lt; a[i]) ++j; if(k * a[j] &lt; a[i]) b[i] = b[j] + a[i]; else b[i] = a[i]; &#125; printf("%d\n", n - i - (n == a[i])); &#125; return 0;&#125; HDU 2486 A simple stone game【K倍动态减法】题意：游戏规则同上，如果必胜则输出先手第一轮先取的最小的数目的石子，否则输出lose。 思路：找最小的石子就是在凑$n$的过程中所用到的最小的数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 3000000;typedef long long ll;int t, n, k;ll a[N], b[N];int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d%d", &amp;n, &amp;k); a[0] = b[0] = 1; int i = 0, j = 0; while(n &gt; a[i]) &#123; ++i; a[i] = b[i - 1] + 1; while(a[j + 1] * k &lt; a[i]) ++j; if(k * a[j] &lt; a[i]) b[i] = b[j] + a[i]; else b[i] = a[i]; &#125; printf("Case %d: ", cas); if(n == a[i]) printf("lose\n"); else &#123; int res; while(n) &#123; if(n &gt;= a[i]) &#123; n -= a[i]; res = a[i]; &#125; --i; &#125; printf("%d\n", res); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5945 Fxx and game【BFS】]]></title>
    <url>%2Fhdu-5945%2F</url>
    <content type="text"><![CDATA[题意：给出一个数$n$，有两种操作可进行选择，问最少经过多少次操作能使$n$变为1。 操作1：n = n / k (n % k == 0). 操作2：n = n - x (0 ≤ x ≤ t). 思路：从$n$开始往1搜，利用vis数组减少重复访问操作。 【注】看似从1开始往$n​$搜结果好像是一样的，但其实并不是这样子，从1开始会有很多访问到的无用的数。 MyCode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int N = 1000010;typedef pair&lt;int, int&gt; pii;bool vis[N];int t, n, x, k;int BFS()&#123; vis[x] = 1; for(int i = 1; i &lt; x; ++i) vis[i] = 0; pii now; queue&lt;pii&gt; Q; Q.push(&#123;x, 0&#125;); while(!Q.empty()) &#123; now = Q.front(); if(now.first == 1) return now.second; Q.pop(); if(now.first % k == 0 &amp;&amp; !vis[now.first / k]) &#123; vis[now.first / k] = 1; Q.push(&#123;now.first / k, now.second + 1&#125;); &#125; for(int i = min(t, now.first - 1); i &gt;= 1 &amp;&amp; !vis[now.first - i]; --i) &#123; vis[now.first - i] = 1; Q.push(&#123;now.first - i, now.second + 1&#125;); &#125; &#125;&#125;int main()&#123; scanf("%d", &amp;n); while(n--) &#123; scanf("%d%d%d", &amp;x, &amp;k, &amp;t); printf("%d\n", BFS()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5944 Fxx and string【题意】【枚举】]]></title>
    <url>%2Fhdu-5944%2F</url>
    <content type="text"><![CDATA[题目大意：给出一个字符串$S$($|S| &lt; 10000$)，问你能找出多少个下标三元组$(i, j, k)$，使得他们同时满足下列条件： $i,j,k$ are adjacent into a geometric sequence.($i, j, k$成等比数列) $Si=’y’,Sj=’r’,Sk=’x’. $ Either $j|i$ or $j|k$ .(i % j == 0 || k % j == 0) 解题思路：知道i,j,k是等比数列后就可以直接做了。 固定住j的位置，枚举i和k的取值情况。 MyCode：12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 11111;int t;char s[N];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%s", s); int len = strlen(s), res = 0; for(int i = 1; i &lt;= len; ++i) &#123; if(s[i - 1] == 'r') &#123; for(int j = 2; i * j &lt;= len; ++j) &#123; if(i % j == 0) &#123; int pre = i / j, nex = i * j;// printf("%d %d %d %d\n", i, j, pre, nex); if(s[pre - 1] == 'x' &amp;&amp; s[nex - 1] == 'y') ++res; if(s[nex - 1] == 'x' &amp;&amp; s[pre - 1] == 'y') ++res; &#125; &#125; &#125; &#125; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>HDU</tag>
        <tag>题意</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LightOJ 1253 Misere Nim【Nim博弈变形】]]></title>
    <url>%2Flightoj-1253%2F</url>
    <content type="text"><![CDATA[题意：有k堆石子，Alice先手，每个人每次可以任选一堆石子取$1$ ~ $a_i$个石子。取到最后一个石子的输。 思路：先考虑一种特殊情况，就是所有石子都是1的时候，这种情况下谁赢谁输已经确定了。 剩下的情况，如果改为取到最后一个石子的获胜的情况的话，就是典型的尼姆博弈了。然而这里很巧的是Nim博弈的结论对这题同样适用，因为Nim博弈的获胜方总能将一个石子留给另外一个人。 MyCode：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, tem, res, flag;int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; flag = res = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;tem); res ^= tem; if(tem != 1) flag = 1; &#125; printf("Case %d: ", cas); if(flag) puts(res ? "Alice" : "Bob"); else puts((n &amp; 1) ? "Bob" : "Alice"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>LightOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 950C Zebras【贪心】【思维】【构造】]]></title>
    <url>%2Fcf-950c%2F</url>
    <content type="text"><![CDATA[题目大意：给你一个01串，问其是否能拆成若干形如0101010的子串，若能，输出所有子串的0，1 的位置。 解题思路：其实就是模拟这个选取的过程就行了，就看怎么选比较方便了。 在经过while(true)的暴力、分别存取0和1的下标来进行二分查找的不断尝(失)试(败)后，找到了一个神奇的写法。 具体操作：开上N个vector，用一个指向所有的待用存储空间的指针不断移动，遇到0就填到这个空间里然后指针向下走，遇到1了就返回到上个位置将1填进去，反复进行这个操作，$O(n)$时间内完美解决。 MyCode：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int N = 200010;char s[N];vector&lt;int&gt; G[N];int maxx, now, len;int main()&#123; scanf("%s", s); len = strlen(s); for(int i = 0; i &lt; len; ++i) &#123; if(s[i] == '1') &#123; if(now == 0) return puts("-1") &amp; 0; G[--now].push_back(i); &#125; else G[now++].push_back(i); maxx = max(maxx, now); &#125; if(now != maxx) return puts("-1") &amp; 0; printf("%d\n", maxx); for(int i = 0; i &lt; maxx; ++i) &#123; printf("%d", G[i].size()); for(int j = 0; j &lt; G[i].size(); ++j) printf(" %d", G[i][j] + 1); puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 1029F Multicolored Markers【思维】【枚举】]]></title>
    <url>%2Fcf-1029f%2F</url>
    <content type="text"><![CDATA[题目大意：给出$n$个红色的小正方形和$m$个蓝色的小正方形，问拼成满足下列两个条件的矩形时，矩形的最小周长是多少。 构成的整个图形是矩形。 至少有一种颜色的小正方形拼成的图形是矩形。 解题思路：因为面积固定时，矩形越靠近正方形周长越小。所以我们可以枚举大矩形的边长，在枚举这个的过程中同时记录当前可以凑成红||蓝矩形所需的最小边长，当大矩形的两条边长都大于等于前两者中的一个时，我们就可以更新答案了。 MyCode：123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll a, b, c, x, tc, res;int main()&#123; cin &gt;&gt; a &gt;&gt; b; x = c = a + b; tc = sqrt(c); for(int i = 1; i &lt;= tc; ++i) //枚举大矩形的边长 &#123; if(a % i == 0) x = min(x, a / i); if(b % i == 0) x = min(x, b / i); if(c % i == 0 &amp;&amp; c / i &gt;= x)//另一条边也可以容纳小矩形的另一条边 res = 2 * (i + c / i); &#125; cout &lt;&lt; res; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>思维</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[山东省第七届ACM大学生程序设计竞赛解题报告【8/12】]]></title>
    <url>%2Fshandong-acm-7%2F</url>
    <content type="text"><![CDATA[A.Julyed【签到】题意：寻找最小的 $k$使得$ k × M ≥ N$。 思路：输出$\lceil \frac{N}{M} \rceil$。 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t, a, b; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (a/b)+((a%b) != 0) &lt;&lt; endl; &#125; return 0;&#125; B.Fibonacci【模拟】题意：将一个正整数表示为若干个不连续的 Fibonacci 数之和。 思路：对于正整数 $N$, 每次选择不超过它的最大的 Fibonacci数$x$，之后转为$ N − x$的子问题。可以证明如果不选择最大的 Fibonacci 数$x$，以后所选择的 Fibonacci数的和是小于$x$的，所以必须选择$x$。 Zeckendorf 定理: 任何正整数可以表示为若干个不连续的 Fibonacci 数之和。 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int N = 55;int t, n, a[N];void init()&#123; a[0] = 1; a[1] = 2; for(int i = 2; i &lt; 44; ++i) a[i] = a[i - 1] + a[i - 2];&#125;int main()&#123; init(); scanf("%d", &amp;t); while(t--) &#123; vector&lt;int&gt; G; scanf("%d", &amp;n); printf("%d=", n); while(n) &#123; int pos = upper_bound(a, a + 44, n) - a; G.push_back(a[pos-1]); n -= a[pos-1]; &#125; for(int i = G.size() - 1; i &gt;= 0; --i) printf("%d%c", G[i], i == 0 ? '\n' : '+'); &#125; return 0;&#125; C.Proxy【最短路】题意：给定一个有向图$G$和起点$S$、终点$T$。输出最短路上除起点外的第一个点，同时使得这个点的标号最小。 思路： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int maxn =10010;const int maxm =100010;const int inf = 0x3f3f3f3f;int n,m;struct node&#123; int v,ne,len;&#125;ed[maxm];int head[maxn],cnt;int vis[maxn];struct fucker&#123; int dis,num;&#125;d[maxn];void init()&#123; memset(vis,0,sizeof vis); memset(head,-1,sizeof head); cnt=0;&#125;void add(int u,int v,int len)&#123; ed[cnt].len=len; ed[cnt].v=v;ed[cnt].ne=head[u];head[u]=cnt++;&#125;void spfa()&#123; for(int i=0;i&lt;=n+1;i++)&#123; d[i].dis=inf; &#125; d[0].dis=0;d[0].num=0; queue&lt;int&gt;q; vis[0]=1; q.push(0); while(!q.empty())&#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];~i;i=ed[i].ne)&#123; int v=ed[i].v; if(d[v].dis&gt;d[u].dis+ed[i].len)&#123; d[v].dis=d[u].dis+ed[i].len; if(d[u].num==0)d[v].num=v; else d[v].num=d[u].num; if(!vis[v])&#123; q.push(v); vis[v]=1; &#125; &#125; else if(d[v].dis==d[u].dis+ed[i].len)&#123; int pos=d[u].num; if(pos==0)pos=v; if(pos&lt;d[v].num)&#123; d[v].num=pos; if(!vis[v])&#123; q.push(v); vis[v]=1; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; int te; ios::sync_with_stdio(0); cin&gt;&gt;te; while(te--)&#123; cin&gt;&gt;n&gt;&gt;m; init(); while(m--)&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,b,c); &#125; spfa(); if(d[n+1].dis==inf)&#123; cout&lt;&lt;-1&lt;&lt;"\n"; &#125; else if(d[n+1].num==n+1)&#123; cout&lt;&lt;0&lt;&lt;"\n"; &#125; else&#123; cout&lt;&lt;d[n+1].num&lt;&lt;"\n"; &#125; &#125; return 0;&#125; D.Swiss-system tournament题意： 思路：归并排序的模拟？ E.The Binding of Isaac【模拟】题意：给定一个$N × M$的01矩阵。统计只和1个1元素共享边的0的个数。 思路：直接做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 105;char mapa[MAX][MAX];int main()&#123; int t; int n, m; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; ++i) scanf("%s",mapa[i]); int ans = 0; for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; if(mapa[i][j] == '#') continue; int num = 0; if(i &gt; 0 &amp;&amp; mapa[i-1][j] == '#') num++; if(j &gt; 0 &amp;&amp; mapa[i][j-1] == '#') num++; if(i &lt; n-1 &amp;&amp; mapa[i+1][j] =='#') num++; if(j &lt; m-1 &amp;&amp; mapa[i][j+1] == '#') num++; if(num == 1) ans++; &#125; &#125; for(int i = 0; i&lt;m; i++) &#123; if(mapa[0][i] == '#') ans++; if(mapa[n-1][i] == '#') ans++; &#125; for(int i = 0; i&lt;n; i++) &#123; if(mapa[i][0] == '#') ans++; if(mapa[i][m-1] == '#') ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; F.Feed the monkey题意：统计长度为$N$的含有$3$个元素的排列个数。其中1最多连续出现$D1$次，2最多连续出现$D2$次，3最多连续出现$D3$次。 思路：DP？ G.Triple Nim【规律】【二进制】题意：将$n$块石子分为三堆，问能有多少种情况满足分完后先手必败。 思路： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n;long long res[44];void init()&#123; res[0] = 1; for(int i = 1; i &lt; 28; ++i) res[i] = res[i - 1] * 3 + 1;&#125;int main()&#123; init(); scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;n); if(n &amp; 1) &#123; puts("0"); continue; &#125; int tem = n, cnt = 0; while(tem) &#123; if(tem &amp; 1) ++cnt; tem &gt;&gt;= 1; &#125; if(cnt == 1) puts("0"); else printf("%lld\n", res[cnt-2]); &#125; return 0;&#125; H.Memory Leak【模拟】题意：内存泄漏是指当输入的字符串的长度≥数组的大小时出现的一种bug，这时超出长度的部分不会被存储而且在输出时会一直输出下去知道碰到’\0’。给出一些列的定义语句，问输出时的结果是什么。 思路：存储每个内存块的内容 &amp;&amp; 标记每个内存块是否泄漏就完成任务了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;const int N = 10010;int T, tem;string s, t, c;map&lt;string, int&gt; id;map&lt;int, string&gt; co;bool leak[N];int len[N], idx;int main()&#123; scanf("%d", &amp;T); getchar(); while(T--) &#123; idx = 0; id.clear(); co.clear(); memset(leak, 0, sizeof(leak)); memset(len, 0, sizeof(len)); while(getline(cin, s) &amp;&amp; s[0] != 'r') &#123; if(s[1] == 'h') &#123; for(int i = 0; i &lt; s.size(); ++i) &#123; if(s[i] == ' ') &#123; t = ""; ++i; while(s[i] != '[') &#123; t += s[i]; ++i; &#125; id[t] = idx; tem = 0; ++i; while(s[i] != ']') &#123; tem = tem * 10 + (s[i] - '0'); ++i; &#125; len[idx] = tem; ++idx; &#125; &#125; &#125; /* for(int i = 0; i &lt; idx; ++i) cout &lt;&lt; len[i] &lt;&lt; '\n'; for(auto it = id.begin(); it != id.end(); ++it) cout &lt;&lt; it -&gt; first &lt;&lt; '\n'; */ else if(s[1] == 'e') &#123; t = c = ""; int i; for(i = 5; s[i] != ' '; ++i) &#123; t += s[i]; &#125; ++i; c = s.substr(i);// cout &lt;&lt; t &lt;&lt; ' ' &lt;&lt; c &lt;&lt; endl;// for(; i &lt; s.size(); ++i)// &#123;// c += s[i];// &#125; tem = id[t]; if(c.size() &gt;= len[tem]) leak[tem] = 1; else leak[tem] = 0;// cout &lt;&lt; c.size() &lt;&lt; ' ' &lt;&lt; len[tem] &lt;&lt; endl; co[tem] = c; &#125; else &#123; t = s.substr(5); tem = id[t]; for(int j = 0; j &lt; min(len[tem], (int)co[tem].size()); ++j) cout &lt;&lt; co[tem][j]; if(leak[tem]) &#123; for(int i = tem + 1; i &lt; idx; ++i) &#123; if(leak[i - 1]) &#123; for(int j = 0; j &lt; min(len[i], (int)co[i].size()); ++j) cout &lt;&lt; co[i][j]; &#125; else break; &#125; &#125; cout &lt;&lt; '\n';// cout &lt;&lt; t &lt;&lt; '\n'; &#125;// for(auto it = co.begin(); it != co.end(); ++it)// cout &lt;&lt; it -&gt; first &lt;&lt; '\n'; &#125; &#125; return 0;&#125; I.Rock Paper Scissors题意： 思路： J.Execution of Paladin【贪心】题意：炉石传说的背景，队友做的，据说是个简单的贪心。 思路：贪心。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int te,n,m; ios::sync_with_stdio(0); cin&gt;&gt;te; while(te--)&#123; cin&gt;&gt;n&gt;&gt;m; int zf=0,cfsum=0,cfsh=0; for(int i=0;i&lt;n;i++)&#123; string m; cin&gt;&gt;m&gt;&gt;m; if(m=="Warleader")&#123; zf++; &#125; if(m=="Warrior")&#123; cfsum++; &#125; if(m=="Murk-Eye")&#123; cfsh+=n-1; cfsum++; &#125; &#125; cfsh+=2*cfsum*zf; cfsh+=2*cfsum; if(cfsh&gt;=m)&#123; cout&lt;&lt;"Mrghllghghllghg!"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;"Tell you a joke, the execution of Paladin."&lt;&lt;endl; &#125; &#125; return 0;&#125; K.Reversed Words【签到】题意：反转字符串。 思路：做就行了。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1005;int main()&#123; int t; string s, tem; cin &gt;&gt; t; getchar(); while(t--) &#123; getline(cin, s); stringstream ss(s); int cou = 0; while(ss &gt;&gt; tem) &#123; if(cou) cout &lt;&lt; " "; reverse(tem.begin(),tem.end()); cout &lt;&lt; tem; cou++; &#125; puts(""); &#125; return 0;&#125; L.Password题意： 思路：]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDUT</tag>
        <tag>山东省赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[山东省第六届ACM大学生程序设计竞赛解题报告【9/12】]]></title>
    <url>%2Fshandong-acm-6%2F</url>
    <content type="text"><![CDATA[A.Nias and Tug-of-War【签到】题意：给出$n$个人的身高和体重，按身高从低到高排序后从前往后轮流报数(1,2,1,2…)，报1的为红队，其余为蓝队，问两队队员体重总和哪队的大。 思路：结构体排序。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n;struct node&#123; double h, w;&#125; a[111];bool cmp(node u, node v)&#123; return u.h &lt; v.h;&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; double sum = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) scanf("%lf%lf", &amp;a[i].h, &amp;a[i].w); sort(a, a + n, cmp); for(int i = 0; i &lt; n; ++i) &#123; if(i &amp; 1) sum += a[i].w; else sum -= a[i].w; &#125; if(sum == 0) puts("fair"); else puts(sum &gt; 0 ? "blue" : "red"); &#125; return 0;&#125; B.Lowest Unique Price【线段树】题意：对一个集合进行三种操作。b x向集合中添加一个$x$，c x将集合中的$x$删掉一个，q查询集合中只出现一次的最小值。 思路： 踩坑：建树及更新时应建最大的值的树而非$n$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000020;int sum[maxn], c[maxn * 4];#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1const int no = 1000005;void build(int l, int r, int rt) &#123; c[rt] = no; if (l == r) &#123; sum[l] = 0; return; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson);&#125;void pushup(int rt) &#123; c[rt] = min(c[rt &lt;&lt; 1], c[rt &lt;&lt; 1 | 1]);&#125;void update(int l, int r, int rt, int x,int y) &#123; if (l == r) &#123; sum[l] += y; if (sum[l] == 1) c[rt] = l; else c[rt] = no; return; &#125; int m = (l + r) &gt;&gt; 1; if (x &lt;= m) update(lson, x, y); else update(rson, x, y); pushup(rt);&#125;int main() &#123; int te; ios::sync_with_stdio(0); cin &gt;&gt; te; while (te--) &#123; int n; cin &gt;&gt; n; build(1, no, 1); for(int i=0;i&lt;n;i++) &#123; char a; int b; cin &gt;&gt; a; if (a == 'b') &#123; cin &gt;&gt; b; update(1, no, 1, b, 1); &#125; else if (a == 'c') &#123; cin &gt;&gt; b; update(1, no, 1, b, -1); &#125; else &#123; int t = c[1]; if (t == no) cout &lt;&lt; "none\n"; else cout &lt;&lt; t &lt;&lt; "\n"; &#125; &#125; &#125; return 0;&#125; C.Game!【博弈】题意：$n$个石子围成一圈，每次每个玩家可以取走任意一个石子或者相邻的两个石子，问谁会赢。 思路：$n \leq 2$时先手可一次全部取走，其余情况后手都可以通过“模仿”操作控制局面从而得以取胜。 同一个题目：POJ 2484 12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t;long long n;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%lld", &amp;n); puts(n &gt; 2 ? "blankcqk" : "zbybr"); &#125; return 0;&#125; D.Stars题意：有$n$个星星在空中，每个星星的坐标$(x, y)$都是独一无二的，现在要你选择一个矩形区域使得矩形的边长为整数且边分别平行于$x$轴或$y$轴，问覆盖至少$k$个星星的时候最小的矩形面积是多少，星星恰好在矩形的边长上的时候不计入总数。 思路：根据题意可想到：若矩形边上的点计入总数的话，此矩形的实际面积就是$(h + 1) \times (w + 1)$。赛中有个想法是二分长和宽+枚举起点坐标，但是需要二维树状数组维护一下，觉得有些麻烦就没写。 12 E.BIGZHUGOD and His Friends I题意：现在有一副不完整的扑克牌，$A$的面值为$1$，$2$ ~ $10$的面值为$2$ ~ $10$，$J$、$Q$、$K$、小王、大王的面值都为$10$。游戏规则为每次从牌中随机抽$5$张，将这$5$张分为两组，一组两张，一组三张。问两组的和都是$10$的倍数的概率是多少。 思路：DP？ 12 F.BIGZHUGOD and His Friends II【数学】【塞瓦定理】题意：$123$初始分别在$\triangle ABC$的$ABC$三顶点处，他们以相同的速度分别向$BCA$移动，问是否存在这么一个时刻使得$1C$、$2A$、$3B$交于一条直线。 思路：有个神奇的数学定理叫做塞瓦定理，运用这个定理，此问题轻易解决。 假设在$t$时刻达到题目所说要求，则有$\frac{a-x}{t} \times \frac{b-x}{t} \times \frac{c-x}{t} = 1$，对于此式子左边，若$t$增大，则整体是减小的，反之亦然。因此我们只需要不断比较他和1的大小关系来得到最优解就好了。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const double eps = 1e-8;int t;double a, b, c, res;bool check(double x)&#123; return (a - x) * (b - x) * (c - x) &gt;= x * x * x;&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%lf%lf%lf", &amp;a,&amp;b,&amp;c); double l = 0.0, r = min(a, min(b, c)), m; while(r - l &gt; eps) &#123; m = (l + r) / 2.0; if(check(m)) l = m; else r = m; &#125; printf("YES %.4f\n", l); &#125; return 0;&#125; G.Cube Number【数学】题意：给出一个包含不同数字的集合，求可以从这里面挑出多少对数字使得它们的乘积为立方数。 思路： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1000050;int n, m;int ar[maxn];int br[maxn];int cr[maxn];int cnt;int pri[maxn];bool is[maxn];void init () &#123; is[0] = is[1] = 1; for (int i = 2; i &lt; maxn; ++i) &#123; if (is[i] == 0) &#123; pri[++cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; 1ll*i*pri[j] &lt; maxn; ++j) &#123; is[i*pri[j]] = 1; if (i % pri[j] == 0) &#123; break; &#125; &#125; &#125;&#125;int main () &#123; int t; init(); scanf("%d", &amp;t); while (t--) &#123; m = 0; memset(ar, 0, sizeof(ar)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int v; scanf("%d", &amp;v); ll tmp = 1, ttmp = 1; for (int j = 1; j &lt;= cnt &amp;&amp; 1ll*pri[j]*pri[j] &lt;= v; ++j) &#123; if (v % pri[j] == 0) &#123; int k = 0; while (v % pri[j] == 0) &#123; v /= pri[j]; ++k; &#125; k %= 3; if (k == 1) &#123; tmp *= 1ll*pri[j]; ttmp *= 1ll*pri[j]*pri[j]; &#125; else if (k == 2) &#123; tmp *= 1ll*pri[j]*pri[j]; ttmp *= 1ll*pri[j]; &#125; &#125; &#125; if (v != 1) &#123; tmp *= 1ll*v; ttmp *= 1ll*v*v; &#125; if (tmp &gt;= 1ll*maxn || ttmp &gt;= 1ll*maxn) &#123; continue; &#125; if (ar[tmp] == 0) &#123; br[++m] = tmp; cr[m] = ttmp; &#125; ++ar[tmp]; &#125; ll res1 = 0, res2 = 0; for (int i = 1; i &lt;= m; ++i) &#123; if (br[i] == cr[i]) res1 += 1ll*ar[br[i]]*(ar[br[i]]-1)/2; else res2 += 1ll*ar[br[i]]*ar[cr[i]]; &#125; cout &lt;&lt; res1+res2/2 &lt;&lt; '\n'; &#125; return 0;&#125; H.Square Number【数学】题意：给出一个包含不同数字的集合，求可以从这里面挑出多少对数字使得它们的乘积为平方数。 思路： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1000050;int n, m;int ar[maxn];int br[maxn];int cr[maxn];int cnt;int pri[maxn];bool is[maxn];void init () &#123; is[0] = is[1] = 1; for (int i = 2; i &lt; maxn; ++i) &#123; if (is[i] == 0) &#123; pri[++cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; 1ll*i*pri[j] &lt; maxn; ++j) &#123; is[i*pri[j]] = 1; if (i % pri[j] == 0) &#123; break; &#125; &#125; &#125;&#125;int main () &#123; int t; init(); scanf("%d", &amp;t); while (t--) &#123; m = 0; memset(ar, 0, sizeof(ar)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int v; scanf("%d", &amp;v); ll tmp = 1; for (int j = 1; j &lt;= cnt &amp;&amp; 1ll*pri[j]*pri[j] &lt;= v; ++j) &#123; if (v % pri[j] == 0) &#123; int k = 0; while (v % pri[j] == 0) &#123; v /= pri[j]; ++k; &#125; k %= 2; if (k == 1) &#123; tmp *= 1ll*pri[j]; &#125; &#125; &#125; if (v != 1) &#123; tmp *= 1ll*v; &#125; if (tmp &gt;= 1ll*maxn) &#123; continue; &#125; if (ar[tmp] == 0) &#123; br[++m] = tmp; &#125; ++ar[tmp]; &#125; ll res1 = 0; for (int i = 1; i &lt;= m; ++i) res1 += 1ll*ar[br[i]]*(ar[br[i]]-1)/2; cout &lt;&lt; res1&lt;&lt; '\n'; &#125; return 0;&#125; I.Routing Table【字典树】题意：给出一个路由表，表中包含$n$条传输路径，每条此传输路径包括$ip$地址，子网掩码的位数以及端口号。给出$m$个目标$ip$地址，问他们最适合传输的路径的端口号是多少。判断标准为：先看网络号，网络号相同的直接传输；如果有多个网络号可以匹配则传输子网掩码位数最长的那个；如果依旧相同则传输端口号最小的那个。否则使用默认端口号65535。 思路：网络号为$ip$地址与子网掩码进行AND运算得出的结果，子网掩码位数的意思的32位的子网掩码从前往后数有多少位为1。算出这个后就是将$m$个目标$ip$地址匹配的问题了，这里的匹配类似于字符串的匹配，建好字典树直接查就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 100010;string tem;int b[] = &#123;128,64,32,16,8,4,2,1&#125;;int t, n, m, pro, a[5];void getTEM()&#123; tem.clear(); for(int i = 0; i &lt; 4; ++i) &#123; for(int j = 0; j &lt; 8; ++j) &#123; if(a[i] &amp; b[j]) tem.push_back('1'); else tem.push_back('0'); &#125; &#125;&#125;struct Trie&#123; int nex[N * 32][2], tot; int pre[N * 32]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, -1, sizeof(pre)); &#125; void add() &#123; int now = 1; getTEM(); int dep = min((int)tem.size(), a[4]); for(int i = 0; i &lt; dep; ++i) &#123; if(nex[now][tem[i] - '0'] == 0) nex[now][tem[i] - '0'] = ++tot; now = nex[now][tem[i] - '0']; &#125; if(pre[now] == -1) pre[now] = pro; else pre[now] = min(pre[now], pro); &#125; int query() &#123; int now = 1, res = -1; getTEM(); for(int i = 0; i &lt; 32; ++i) &#123; if(pre[now] != -1) res = pre[now]; if(nex[now][tem[i] - '0'] == 0) break; else now = nex[now][tem[i] - '0']; &#125; if(res == -1) res = 65535; return res; &#125;&#125; trie;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; trie.init(); scanf("%d%d", &amp;n,&amp;m); for(int o = 1; o &lt;= n; ++o) &#123; scanf("%d.%d.%d.%d/%d %d",&amp;a[0],&amp;a[1],&amp;a[2],&amp;a[3],&amp;a[4], &amp;pro); trie.add(); &#125; for(int o = 1; o &lt;= m; ++o) &#123; scanf("%d.%d.%d.%d",&amp;a[0],&amp;a[1],&amp;a[2],&amp;a[3]); printf("%d\n", trie.query()); &#125; &#125; return 0;&#125; J.Single Round Math【大数】题意：给出两个数$n$、$m$，问它们是否相等且都是$11$的倍数。 思路：开上Java直接写(好像没必要)直接大数取模模拟就行了。 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 10010;bool flag;int t, len, sum;char a[N], s[N];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; flag = 1; scanf("%s%s", a, s); if(strcmp(a, s)) flag = 0; else &#123; sum = 0; len = strlen(s); for(int i = 0; i &lt; len; ++i) &#123; sum = sum * 10 + s[i] - '0'; sum %= 11; &#125; if(sum) flag = 0; &#125; puts(flag ? "YES" : "NO"); &#125; return 0;&#125; K.Last Hit题意：$n$个小兵在塔下，塔会按照从$1$ ~ $n$的顺序挨个攻击每个小兵，每次给单个小兵造成$x$点伤害。你每次可选择任意一个小兵进行攻击并且对它造成$y$点伤害。当你攻击完小兵后，小兵的$HP \leq 0$你就补刀成功一次，塔先攻击然后再你选择攻击或不攻击，问你最多补多少兵。 思路：？？？ 12 L.Circle of Friends【强连通分量】【缩点】题意：先说一下朋友圈的定义：A认为和B是朋友，B也认为A是朋友，那他们就是真正的朋友，这是A和B互相帮助是不需要请吃饭的；A认为和B是朋友，B认为和C是朋友，C认为和A是朋友，那么他们仨之间也是真正的朋友。A认为和B是朋友，而B不认为和A是朋友，那么A向B寻求帮助是要请B吃饭的。 现在给出$n$个人的朋友关系，问$0$号向$n-1$寻求帮助最少需要请多少顿饭，注：每个人只会向自己认为是自己朋友的人寻求帮助。 思路： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100005;const int maxm = 100005;const int inf = 0x3f3f3f3f;struct fuck &#123; int u, v, ne;&#125;ed[maxm];int head[maxn], cnt;int low[maxn], dfn[maxn], Stack[maxn], belong[maxn];int kkdex, top; int scc;bool instack[maxn]; int sum[maxn];void add(int u, int v) &#123; ed[cnt].v = v; ed[cnt].ne = head[u]; ed[cnt].u = u; head[u] = cnt++;&#125;void tarjan(int u) &#123; int v; low[u] = dfn[u] = ++kkdex; Stack[top++] = u; instack[u] = 1; for (int i = head[u]; ~i; i = ed[i].ne) &#123; v = ed[i].v; if (!dfn[v]) &#123; tarjan(v); if (low[u] &gt; low[v])low[u] = low[v]; &#125; else if (instack[v] &amp;&amp; low[u] &gt; dfn[v]) &#123; low[u] = dfn[v]; &#125; &#125; if (low[u] == dfn[u]) &#123; scc++; do &#123; v = Stack[--top]; instack[v] = 0; belong[v] = scc; sum[scc]++; &#125; while (v != u); &#125;&#125;void solve(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; dfn[i] = 0; instack[i] = 0; sum[i] = 0; &#125; kkdex = scc = top = 0; for (int i = 0; i &lt; n; i++) &#123; if (!dfn[i]) tarjan(i); &#125;&#125;void init() &#123; cnt = 0; memset(head, -1, sizeof head);&#125;vector&lt;int&gt;G[maxn];int dis[maxn];int bfs(int x, int y) &#123; queue&lt;int&gt;q; q.push(x); dis[x] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); // cout &lt;&lt; "go: " &lt;&lt; u &lt;&lt; endl; if (u == y)return dis[u]; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (dis[v] &gt; dis[u] + 1) &#123; dis[v] = dis[u] + 1; q.push(v); &#125; &#125; &#125; return -1;&#125;int main() &#123; int te; scanf("%d", &amp;te); while (te--) &#123; init(); int n, m; scanf("%d%d", &amp;n, &amp;m); while (m--) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); add(a, b); &#125; solve(n); for (int i = 0; i &lt;= scc; i++) G[i].clear(), dis[i] = inf; for (int i = 0; i &lt; cnt; i ++) &#123; int v = ed[i].v; int u = ed[i].u; if (belong[u] != belong[v]) &#123; G[belong[u]].push_back(belong[v]); // cout &lt;&lt; belong[u] &lt;&lt; " ? " &lt;&lt; belong[v] &lt;&lt; endl; &#125; &#125; cout &lt;&lt; bfs(belong[0], belong[n - 1]) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDUT</tag>
        <tag>山东省赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[山东省第四届ACM大学生程序设计竞赛解题报告【6/10】]]></title>
    <url>%2Fshandong-acm-4%2F</url>
    <content type="text"><![CDATA[A.Rescue The Princess【计算几何】题意：给出A、B坐标，要你找出一个点C，使得△ABC是正三角形，且点C在AB点的逆时针方向上。 思路：根据角的关系进行计算，“广义化”的思想省去了很多判断的麻烦。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1e5+5;const double PI = acos(-1.0);const double six = PI/3;int main()&#123; int T; double x1, y1, x2, y2; cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; double d = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)); double si = (y2-y1) / d; double co = (x2-x1) / d; double y = (sin(six)*co + cos(six)*si)*d; double x = (cos(six)*co - sin(six)*si)*d; printf("(%.2lf,%.2lf)\n", x1+x, y1+y); &#125; return 0;&#125; B.Thrall’s DreamC.A^X mod PD.Mountain Subsequences【思维】队友AC 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 30;const int mod = 2012;long long sum1[maxn],sum2[maxn],sum3[maxn];int m[100010];int main()&#123; int n; ios::sync_with_stdio(0); while(cin&gt;&gt;n)&#123; memset(sum1,0,sizeof sum1); memset(sum2,0,sizeof sum2); memset(sum3,0,sizeof sum3); for(int i=0;i&lt;n;i++)&#123; char a;cin&gt;&gt;a; m[i]=a-'a'+1; &#125; long long ans=0; for(int i=0;i&lt;n;i++)&#123; long long s1=0,s2=0,s3=0; int now=m[i]; for(int i=0;i&lt;now;i++)&#123; s1+=sum1[i]; s2+=sum2[i]; &#125; for(int i=maxn-1;i&gt;now;i--)&#123; s3+=sum3[i]+sum2[i]; &#125; ans+=s3; sum3[now]+=s3; sum2[now]+=s1+s2; sum1[now]+=1; ans%=mod;sum3[now]%=mod; sum2[now]%=mod;sum1[now]%=mod; &#125; cout&lt;&lt;ans&lt;&lt;"\n"; &#125; return 0;&#125; E.Alice and Bob【规律】【二进制】题意：给出一个多项式，求出指数为P的x的系数。 思路：写出几项就会发现，对应指数为P的x的系数就是二进制下的P为1的那些部分的系数乘积。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int N = 55;ll p, res;int t, n, q, a[N];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; memset(a, 0, sizeof(a)); scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); scanf("%d", &amp;q); while(q--) &#123; res = 1; scanf("%lld", &amp;p); int idx = 0; while(p) &#123; if(p &amp; 1) res = res * a[idx] % 2012; ++idx; p /= 2; &#125; printf("%lld\n", res); &#125; &#125; return 0;&#125; F.Boring Counting【主席树】题意：给出包含$n$个数的序列$a$，问区间$l_i$到$r_i$里面的数大小在$x_i$到$y_i$间的数有多少个。 思路：主席树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 50050;int a[maxn], t[maxn];int n, q, tot, m;int lson[maxn * 20], rson[maxn * 20], T[maxn], c[maxn * 20];void initHash() &#123; for (int i = 1; i &lt;= n; i++) t[i] = a[i]; sort(t + 1, t + 1 + n); m = unique(t + 1, t + 1 + n) - t - 1;&#125;int build(int l, int r) &#123; int root = tot++; c[root] = 0; if (l != r) &#123; int mid = (l + r) &gt;&gt; 1; lson[root] = build(l, mid); rson[root] = build(mid + 1, r); &#125; return root;&#125;int Hash(int x) &#123; return lower_bound(t + 1, t + 1 + m, x) - t;&#125;int update(int root, int pos, int val) &#123; int newroot = tot++; int tmp = newroot; c[newroot] = c[root] + val; int l = 0, r = m + 1; while (l&lt;r) &#123; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) &#123; lson[newroot] = tot++; rson[newroot] = rson[root]; newroot = lson[newroot]; root = lson[root]; r = mid; &#125; else &#123; rson[newroot] = tot++; lson[newroot] = lson[root]; newroot = rson[newroot]; root = rson[root]; l = mid + 1; &#125; c[newroot] = c[root] + 1; &#125; return tmp;&#125;int query(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l&amp;&amp;r &lt;= R) &#123; return c[rt]; &#125; int ans = 0, mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) &#123; ans += query(L, R, l, mid, lson[rt]); &#125; if (R &gt; mid) &#123; ans += query(L, R, mid + 1, r, rson[rt]); &#125; return ans;&#125;int main()&#123; int te, cas = 1; scanf("%d", &amp;te); while (te--) &#123; tot = 0; printf("Case #%d:\n", cas++); scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; initHash(); T[0] = build(0, m + 1); for (int i = 1; i &lt;= n; i++) &#123; int pos = Hash(a[i]); T[i] = update(T[i - 1], pos, 1); &#125; while (q--) &#123; int l, r, a, b; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;l, &amp;r); l = Hash(l); int pos = Hash(r); if (pos == m + 1)r = pos; else if (t[pos] != r)r = pos - 1; else r = pos; int ans1 = query(l, r, 0, m+1, T[b]); int ans2 = query(l, r, 0, m+1, T[a - 1]); printf("%d\n", ans1 - ans2); &#125; &#125; return 0;&#125; G.Rubik’s cubeH.A-Number and B-Number数位DP？ I.The number of steps【期望】题意：现在你在房间的最顶端，每次可以往左下右下或者左边走，给出走向各方向的概率，问走到最左下角的步数期望是多少。只能往左走时往左走的概率是1；只能往左下和右下走时概率分别是a和b；能往三个方向走时各方向概率分别是c、d和e。 思路：从前往后推就可以了。 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n;double a, b, c, d, e;double dp[50][50];int main()&#123; while (scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; scanf("%lf %lf %lf %lf %lf", &amp;a, &amp;b, &amp;c, &amp;d, &amp;e); dp[n][1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; dp[n][i] = dp[n][i-1]+1; &#125; for (int i = n-1; i &gt;= 1; --i) &#123; dp[i][1] = a*(dp[i+1][1]+1)+b*(dp[i+1][2]+1); for (int j = 2; j &lt;= i; ++j) &#123; dp[i][j] = c*(1+dp[i+1][j])+d*(1+dp[i+1][j+1])+e*(1+dp[i][j-1]); &#125; &#125; printf("%.2f\n", dp[1][1]); &#125; return 0;&#125; J.Contest Print Server【模拟】123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 111;int t, n, s, x, y, m;struct node&#123; char name[22]; int req;&#125; a[N];int main()&#123; int cas = 0; scanf("%d", &amp;t); while(t--) &#123; if(cas++) puts(""); scanf("%d%d%d%d%d", &amp;n,&amp;s,&amp;x,&amp;y,&amp;m); for(int i = 1; i &lt;= n; ++i) scanf("%s %*s %d %*s", a[i].name, &amp;a[i].req); int now = 0; for(int i = 1; i &lt;= n; ) &#123; if(now + a[i].req &lt;= s) &#123; ++i; now += a[i].req; printf("%d pages for %s\n", a[i].req, a[i].name); &#125; else &#123; printf("%d pages for %s\n", s - now, a[i].name); now = 0; s = s * x + y; s %= m; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDUT</tag>
        <tag>山东省赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[山东省第二届ACM大学生程序设计竞赛解题报告【7/10】]]></title>
    <url>%2Fshandong-acm-2%2F</url>
    <content type="text"><![CDATA[A.Simple Game【NimK博弈】题意：给出n堆石子，每次可以从其种任选不超过3堆，从每堆中取走任意数量的石子。无法取的输。 思路：NimK博弈。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 10010;int u[N][32];int t, n, x, idx, res, tem;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; memset(u, 0, sizeof(u)); scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;x); idx = 0; while(x) &#123; u[i][idx++] = x &amp; 1; x &gt;&gt;= 1; &#125; &#125; res = 0; for(int i = 0; i &lt; 32; ++i) &#123; tem = 0; for(int j = 1; j &lt;= n; ++j) &#123; if(u[j][i]) ++tem; &#125; if(tem % 4) &#123; res = 1; break; &#125; &#125; puts(res ? "Yes" : "No"); &#125; return 0;&#125; B.The Android University ACM Team Selection Contest【结构体排序】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 10010;int t, n, m, tem;struct node&#123; char name[33]; bool girl, sel; int solve, pentl, idx;&#125; a[N];bool cmp(node u, node v)&#123; if(u.solve != v.solve) return u.solve &gt; v.solve; return u.pentl &lt; v.pentl;&#125;bool cmp2(node u, node v)&#123; return u.idx &lt; v.idx;&#125;int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; if(cas &gt; 1) puts(""); int cnt = 0; memset(a, 0, sizeof(a)); scanf("%d%d", &amp;n,&amp;m); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s%d%d%d", a[i].name, &amp;tem, &amp;a[i].solve, &amp;a[i].pentl); a[i].idx = i; a[i].girl = tem ? true : false; if(a[i].solve) ++cnt; &#125; if(cnt &lt; m) &#123; for(int i = 1; i &lt;= n; ++i) printf("%s\n", a[i].name); continue; &#125; sort(a + 1, a + n + 1, cmp); bool ok = 0; printf("Case %d:\n", cas); for(int i = 1; i &lt;= m; ++i) &#123; if(a[i].solve == 0) break; if(a[i].girl) ok = 1; a[i].sel = 1; &#125; if(!ok) &#123; for(int i = m + 1; i &lt;= n; ++i) &#123; if(a[i].solve == 0) break; if(a[i].girl) &#123; a[i].sel = 1; break; &#125; &#125; &#125; sort(a + 1, a + 1 + n, cmp2); for(int i = 1; i &lt;= n; ++i) &#123; if(a[i].sel) printf("%s\n", a[i].name); &#125; &#125; return 0;&#125; C.Identifiers【签到】123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;bool f;int t, len;char s[111];bool legal(char ch)&#123; if(!isalpha(ch) &amp;&amp; ch != '_' &amp;&amp; !isdigit(ch)) return false; return true;&#125;int main()&#123; scanf("%d", &amp;t); getchar(); while(t--) &#123; gets(s); len = strlen(s); f = (isalpha(s[0]) | s[0] == '_'); if(f) for(int i = 1; i &lt; len; ++i) if(!legal(s[i])) &#123; f = false; break; &#125; puts(f ? "Yes" : "No"); &#125; return 0;&#125; D.Binomial Coeffcients【组合数】12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const ll mod = 1e7+3;const int maxn = 1e3+5;ll c[maxn][maxn];void init ()&#123; c[0][0] = c[1][0] = c[1][1] = 1; for (int i = 2; i &lt; maxn; ++i) &#123; c[i][0] = c[i][i] = 1; for (int j = 1; j &lt; i; ++j) &#123; c[i][j] = c[i-1][j-1]+c[i-1][j]; c[i][j] %= mod; &#125; &#125;&#125;int main()&#123; init(); int t; scanf("%d", &amp;t); while (t--) &#123; int a, b; scanf("%d %d", &amp;a, &amp;b); cout &lt;&lt; c[a][b] &lt;&lt; '\n'; &#125; return 0;&#125; E.Crack Mathmen【快速幂】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;const int mod = 997;int n;char str[maxn];int ar[1000];char br[1000];char ans[maxn];int qm (int a, int b)&#123; int ans = 1; while (b) &#123; if (b&amp;1) ans = ans*a%mod; a = a*a%mod; b &gt;&gt;= 1; &#125; return ans;&#125;void cal ()&#123; memset(ar, 0, sizeof(ar)); for (int i = (int)'A'; i &lt;= (int)'Z'; ++i) &#123; int t1 = qm(i, n); int t2 = qm(i+32, n); ++ar[t1]; ++ar[t2]; br[t1] = (char)i; br[t2] = (char)(i+32); &#125; for (int i = (int)'0'; i &lt;= (int)'9'; ++i) &#123; int t1 = qm(i, n); ++ar[t1]; br[t1] = (char)i; &#125;&#125;int main()&#123; int t; scanf("%d", &amp;t); while (t--) &#123; scanf("%d", &amp;n); scanf("%s", str); cal(); int len = strlen(str); if (len % 3 != 0) &#123; cout &lt;&lt; "No Solution" &lt;&lt; '\n'; continue; &#125; bool bul = 1; int j = 0; for (int i = 0; i &lt; len; i += 3) &#123; int tmp = 100*(str[i]-'0')+10*(str[i+1]-'0')+1*(str[i+2]-'0'); if (ar[tmp] != 1) &#123; bul = 0; break; &#125; else &#123; ans[j++] = br[tmp]; &#125; &#125; if (bul) &#123; for (int i = 0; i &lt; j; ++i) cout &lt;&lt; ans[i]; cout &lt;&lt; '\n'; &#125; else cout &lt;&lt; "No Solution" &lt;&lt; '\n'; &#125; return 0;&#125; F.Manhattan送命题 G.Mathman Bank【模拟】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; acc;map&lt;string, bool&gt; exi;map&lt;string, string&gt; pass;char op;int n, tem;string s1, s2, s3;int main()&#123; scanf("%d", &amp;n); while(n--) &#123; cin &gt;&gt; op; if(op == 'O') &#123; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; tem; if(exi[s1]) puts("Account exists."); else &#123; puts("Successfully opened an account."); exi[s1] = 1; pass[s1] = s2; acc[s1] = tem; &#125; &#125; else if(op == 'D') &#123; cin &gt;&gt; s1 &gt;&gt; tem; if(!exi[s1]) puts("Account does not exist."); else &#123; puts("Successfully deposited money."); acc[s1] += tem; &#125; &#125; else if(op == 'W') &#123; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; tem; if(!exi[s1]) puts("Account does not exist."); else if(s2 != pass[s1]) puts("Wrong password."); else if(tem &gt; acc[s1]) puts("Money not enough."); else &#123; acc[s1] -= tem; puts("Successfully withdrew money."); &#125; &#125; else if(op == 'T') &#123; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3 &gt;&gt; tem; if(!exi[s1] || !exi[s3]) puts("Account does not exist."); else if(s2 != pass[s1]) puts("Wrong password."); else if(tem &gt; acc[s1]) puts("Money not enough."); else &#123; puts("Successfully transfered money."); acc[s1] -= tem; acc[s3] += tem; &#125; &#125; else if(op == 'C') &#123; cin &gt;&gt; s1 &gt;&gt; s2; if(!exi[s1]) puts("Account does not exist."); else if(s2 != pass[s1]) puts("Wrong password."); else printf("%d\n", acc[s1]); &#125; else &#123; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3; if(!exi[s1]) puts("Account does not exist."); else if(s2 != pass[s1]) puts("Wrong password."); else &#123; puts("Successfully changed password."); pass[s1] = s3; &#125; &#125; &#125; return 0;&#125; H.MathmenI.SequenceDP? J.The Largest SCC【强连通分量】https://blog.csdn.net/chenshibo17/article/details/88829368]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDUT</tag>
        <tag>山东省赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[山东省第一届ACM大学生程序设计竞赛解题报告【7/10】]]></title>
    <url>%2Fshandong-acm-1%2F</url>
    <content type="text"><![CDATA[A.Phone Number【签到】【string】直接做。 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1111;int n;string s[N];int main()&#123; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; bool flag = false; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; s[i]; sort(s, s + n); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; if(i == j) continue; if(s[i].find(s[j]) == 0) &#123; flag = true; break; &#125; &#125; &#125; puts(flag ? "NO" : "YES"); &#125; return 0;&#125; B.Balloons【DFS】DFS。有更优美的写法，但是懒得动了，直接复制后改了改。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 111;int dir1[][2] = &#123;1,0,0,1,-1,0,0,-1&#125;;int dir2[][2] = &#123;1,0,0,1,-1,0,0,-1,1,1,1,-1,-1,1,-1,-1&#125;;int n, res1, res2;char map1[N][N], map2[N][N];void DFS1(int x, int y)&#123; map1[x][y] = '0'; for(int i = 0; i &lt; 4; ++i) &#123; int xx = x + dir1[i][0]; int yy = y + dir1[i][1]; if(xx &lt; 1 || xx &gt; n || yy &lt; 1 || yy &gt; n) continue; if(map1[xx][yy] == '1') DFS1(xx, yy); &#125;&#125;void DFS2(int x, int y)&#123; map2[x][y] = '0'; for(int i = 0; i &lt; 8; ++i) &#123; int xx = x + dir2[i][0]; int yy = y + dir2[i][1]; if(xx &lt; 1 || xx &gt; n || yy &lt; 1 || yy &gt; n) continue; if(map2[xx][yy] == '1') DFS2(xx, yy); &#125;&#125;int main()&#123; for(int cas = 1; scanf("%d", &amp;n) &amp;&amp; n; ++cas) &#123; res1 = res2 = 0; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", map1[i] + 1); for(int j = 1; j &lt;= n; ++j) &#123; map2[i][j] = map1[i][j]; &#125; &#125;// for(int i = 1; i &lt;= n; ++i, puts(""))// for(int j = 1; j &lt;= n; ++j)// printf("%c", map1[i][j]);//// for(int i = 1; i &lt;= n; ++i, puts(""))// for(int j = 1; j &lt;= n; ++j)// printf("%c", map2[i][j]); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; if(map1[i][j] == '1') &#123; DFS1(i, j); ++res1; &#125; &#125; &#125; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; if(map2[i][j] == '1') &#123; DFS2(i, j); ++res2; &#125; &#125; &#125; printf("Case %d: %d %d\n\n", cas, res1, res2); &#125; return 0;&#125; C.ClockwiseD.Shopping【签到】找出最大值最小值做差就完了。 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;int n;ll t, maxx, minn;int main()&#123; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; scanf("%lld", &amp;t); maxx = minn = t; for(int i = 1; i &lt; n; ++i) &#123; scanf("%lld", &amp;t); maxx = max(maxx, t); minn = min(minn, t); &#125; printf("%lld\n", (maxx - minn) * 2); &#125; return 0;&#125; E.Emergency【最短路】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int inf = 0x3f3f3f3f;int vis[305],dis[305][305];int m,n,q,te=1;void init()&#123; for(int i=0;i&lt;n;i++)&#123; vis[i]=0; for(int j=0;j&lt;n;j++)&#123; dis[i][j]=inf; &#125; dis[i][i]=0; &#125;&#125;void go(int x)&#123; //0-&gt;n-1; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; dis[i][j]=min(dis[i][j],dis[i][x]+dis[x][j]); &#125; &#125;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;q)&amp;&amp;n&amp;&amp;m&amp;&amp;q)&#123; printf("Case %d:\n",te++); init(); while(m--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); dis[a][b]=min(dis[a][b],c); &#125; while(q--)&#123; int ask,a,b; scanf("%d",&amp;ask); if(ask==1)&#123; scanf("%d%d",&amp;a,&amp;b); if(vis[a]==0||vis[b]==0)&#123; printf("City %d or %d is not available.\n",a,b); &#125; else&#123; if(dis[a][b]==inf)&#123; printf("No such path.\n"); &#125; else printf("%d\n",dis[a][b]); &#125; &#125; else&#123; scanf("%d",&amp;a); if(vis[a]==1)&#123; printf("City %d is already recaptured.\n",a); &#125; else &#123; vis[a]=1; go(a); &#125; &#125; &#125; printf("\n"); &#125; return 0;&#125; F.Fairy taleG.Greatest Number【二分】题意：从n个数中选4个数，它们的和在不超过M的前提下，最大是多少。 思路：将n个数的两两之和保存下来，排序后对每一个b[i]，查找出最接近M - b[i]的数，不断枚举并更新。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1e3+5;int n, m, cnt;int ar[maxn];int br[maxn*maxn];int main()&#123; int cas = 0; while (scanf("%d %d", &amp;n, &amp;m) != EOF &amp;&amp; n+m) &#123; cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;ar[i]); &#125; for (int i = 0; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= n; ++j) &#123; br[++cnt] = ar[i]+ar[j]; &#125; &#125; sort(br+1, br+1+cnt); br[cnt+1] = 2e9; int ans = 0; for (int i = 1; i &lt;= cnt; ++i) &#123; int pos = upper_bound(br+1, br+1+cnt, m-br[i])-br; if (br[i]+br[pos-1] &lt;= m) &#123; ans = max(ans, br[i]+br[pos-1]); &#125; &#125; printf("Case %d: %d\n\n", ++cas, ans); &#125; return 0;&#125; H.Hello World!【结构体排序】给出n个点，对这n个点的每一个点，找出横纵坐标都比它大的点中的横纵坐标最小的点，没有的话输出-1 -1. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;struct node&#123; int aa, bb;&#125;;bool cmp(node a, node b)&#123; if(a.aa == b.aa) return a.bb &lt; b.bb; return a.aa &lt; b.aa;&#125;int main()&#123; int n; bool flag; int cou = 0; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; if(cou) puts(""); printf("Case %d:\n",++cou); node p[MAX], q[MAX]; for(int k = 0; k &lt; n; ++k) &#123; scanf("%d%d",&amp;p[k].aa,&amp;p[k].bb); q[k].aa = p[k].aa; q[k].bb = p[k].bb; &#125; sort(q, q+n, cmp); for(int k = 0; k &lt; n; ++k) &#123; flag = true; for(int i = 0; i &lt; n; ++i) &#123; if(q[i].aa &gt; p[k].aa &amp;&amp; q[i].bb &gt; p[k].bb) &#123; printf("%d %d\n",q[i].aa,q[i].bb); flag = false; break; &#125; &#125; if(flag) printf("-1 -1\n"); &#125; &#125; return 0;&#125; I.Ivan comes again!【set】上一题的加强版。这里将所有点存到一个容器中，通过二分查到第一个横坐标大于他的点，再遍历纵坐标。 如果这题极限数据的话算了下复杂度这样写应该是过不了的，搜了一下有通过线段树维护最大值什么的，有空再学(咕咕咕)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;#define pii pair&lt;int, int&gt;using namespace std;char s[11];int n, x, y, cas;int main()&#123; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; printf("Case %d:\n", ++cas); set&lt;pii&gt; S; for(int i = 0; i &lt; n; ++i) &#123; scanf("%s%d%d", s, &amp;x,&amp;y); if(s[0] == 'a') S.insert(&#123;x, y&#125;); else if(s[0] == 'r') S.erase(&#123;x, y&#125;); else &#123; auto it = S.upper_bound(&#123;x, y&#125;); while(1) &#123; if(it == S.end()) &#123; puts("-1"); break; &#125; if(it -&gt; first &gt; x &amp;&amp; it -&gt; second &gt; y) &#123; printf("%d %d\n", it -&gt; first, it -&gt; second); break; &#125; ++it; &#125; &#125; &#125; puts(""); &#125; return 0;&#125; J.Jerry Mouse不可做题。。。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDUT</tag>
        <tag>山东省赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU_ACM_ICPC_2019_Winter_Practice_10th【解题报告】]]></title>
    <url>%2Fsdnu-2019-10%2F</url>
    <content type="text"><![CDATA[寒假的十场集训完结撒花~ 祝大家开学快乐QAQ 最后这一场的解题报告由我们的柳总提供，点击打开真正的题解。 凡是新的事情在起头总是这样，起初热心的人很多，而不久就冷淡下去，撒手不做了。因为他已经明白，不经过一番苦工是做不成的，而只有想做的人，才忍得过这番痛苦。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>素数</tag>
        <tag>map</tag>
        <tag>解题报告</tag>
        <tag>stack</tag>
        <tag>SDNU</tag>
        <tag>寒假集训</tag>
        <tag>priority_queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU_ACM_ICPC_2019_Winter_Practice_9th【解题报告】]]></title>
    <url>%2Fsdnu-2019-9%2F</url>
    <content type="text"><![CDATA[让大家体验了一下真正赛场上的比赛的难度，提前有点心理准备。 题目来自：2016CCPC东北地区大学生程序设计竞赛 - 重现赛 题解请戳：ltrbless的博客。点击打开真正的题解。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
        <tag>寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU_ACM_ICPC_2019_Winter_Practice_8th【解题报告】]]></title>
    <url>%2Fsdnu-2019-8%2F</url>
    <content type="text"><![CDATA[本场比赛的题目 &amp;&amp; 题解均由我们的老朋友A_Wanderer提供，点击打开真正的解题报告。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
        <tag>寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU_ACM_ICPC_2019_Winter_Practice_7th【解题报告】]]></title>
    <url>%2Fsdnu-2019-7%2F</url>
    <content type="text"><![CDATA[本场比赛的题目 &amp;&amp; 题解均由我们的老朋友Forsaken提供，点击打开真正的解题报告。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
        <tag>寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU_ACM_ICPC_2019_Winter_Practice_6th【解题报告】]]></title>
    <url>%2Fsdnu-2019-6%2F</url>
    <content type="text"><![CDATA[此次题解由water_zero_saber提供，点击打开真正的解题报告。 本想开个大模拟专场，恢复一下大家的码力，然而找好的模拟类型的题都在POJ上，而不巧的是POJ炸了，于是就从其他地方搜刮了几道模拟后把准备的二分啥的都整上了。下面这些题，有余力的可以做做恢复一下码力。 然后果然好多人几天不写代码就手生了。下面是两个比较关键的时间点：1. 19年省赛在5月11、12进行；2. 校内选拔赛要在4月前后完成，预计进行三场，所以3月中旬应该就开始进行。大家自己要有自己的规划哦。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>二分</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
        <tag>寒假集训</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU_ACM_ICPC_2019_Winter_Practice_5th【解题报告】]]></title>
    <url>%2Fsdnu-2019-5%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-RKzLqYyf"), narrow: false, autoplay: false, showlrc: false, music: { title: "骄傲的少年", author: "南征北战nzbz", url: "http://music.163.com/song/media/outer/url?id=408332757.mp3", pic: "http://p1.music.126.net/Brn39jwEDNPVV6pNWcv_rA==/1391981724588577.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); Happy New Year!!! 祝大家新的一年里AC++,RP++； 此次比赛的题解由The___flash提供，点击打开真正的解题报告。 关于这场比赛的几点说明： 这场比赛是送给大家的新年礼物，看打的tags就知道了，全是简单题。 原本预计的是至少会有50%的选手AK，100%的选手AC6题以上。 值得一提的是AC人数最少的E题，是裸的拓扑排序题，在第三场的比赛中已经出现过类似的题目了，而且上传的课件中还把这题当做例题来讲的，标题“MyCode”还添加了这道题的代码超链接。还有J题，绝大多数人使用了模拟来判断各种情况，实际上这题可以通过数学方法来解决，具体可参考这里(此中真意我还未参透)，水哥运用了求两日期到同一日期的天数然后做差求绝对值的方法，也是差不多的。 新年快乐！ 愿所有为梦想付出的努力都不会被辜负。新的一年，大家继续努力呀！]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>暴力</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
        <tag>寒假集训</tag>
        <tag>水题</tag>
        <tag>签到</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU_ACM_ICPC_2019_Winter_Practice_4th【解题报告】]]></title>
    <url>%2Fsdnu-2019-4%2F</url>
    <content type="text"><![CDATA[这是两场比较简单的Div3合集，让大家体验一下做套题的感觉。 当然，因为是Div3所以难度并不大。 如果做出的题目数 &lt; 4的话说明省赛赛场上签到都签到不了。 ≥6道为18选手期望水平。 ≥8道为17选手期望水平。 难度排序： Codeforces Round #521：ABCDELM Codeforces Round #529：JIHGFK 此次题解由Create_miracles提供，点击打开真正的解题报告。 最后有两点情况提一下： 最近旷训现象比较严重，为还在一直刷题的小伙伴点赞o(￣▽￣)ｄ 参加下午重现赛的队员就不要看上午的榜单了，因为正式比赛是没法提前预知结果的。你可能提前看榜单重现赛跟榜一时爽，但相应的也少了真枪实战的经验，对个人成长不利。这里只能是提醒一下吧，毕竟也没法盯着你。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>DFS</tag>
        <tag>思维</tag>
        <tag>二分</tag>
        <tag>vector</tag>
        <tag>二进制</tag>
        <tag>map</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
        <tag>寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU_ACM_ICPC_2019_Winter_Practice_3rd【解题报告】]]></title>
    <url>%2Fsdnu-2019-3%2F</url>
    <content type="text"><![CDATA[嗯，还是比较简单的一场，好几个AK的。 这场题解给Wanderer写了虽然他代码比较丑。点击打开真正的题解。 以下是我个人的几点看法。 A用栈模拟就好了，我又读错了题写到怀疑人生，提醒大家认真读题哦。 B贪心做就行了。 这场的C是不是好多用DFS写的？给大家介绍个用来枚举全排列的函数next_permutation，具体用法可自行百度或参考紫书第七章第二节，还是比较好用的。相关例题：SDNUOJ_1169，记得OJ上还有几个的，暂时想不起来&amp;&amp;没找到，就不贴了。 DGJ二分。D和J是将数组合并后再处理；G是枚举方程的解，类似题目，SDNUOJ_1416。 关于签到题F，实际上有更优美的写法，运用的DP思想，只需四个变量就可解决，下附代码，其中的真意自行品味具体代码可直接看上面的题解。 I开上对应的数据结构进行模拟，算是对所学的数据结构进行再一次的复习吧。 E和H是拓扑排序裸题，其实不知道拓扑排序单纯的统计入度出度然后一通操作也能A掉，又可以学到新知识了，真开心。 寒假过去 1 / 5 多了，大家要继续努力呀。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>map</tag>
        <tag>DP</tag>
        <tag>解题报告</tag>
        <tag>拓扑排序</tag>
        <tag>SDNU</tag>
        <tag>寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU_ACM_ICPC_2019_Winter_Practice_2nd【解题报告】]]></title>
    <url>%2Fsdnu-2019-2%2F</url>
    <content type="text"><![CDATA[嗯？F怎么没人做？我看一下吧。 ？？？这是什么东西？？？ 妈耶添加题目后忘记改题号了。打扰了。。。 这次题解给Forsaken写了，还是都很基础的题目，除了F都可以做哦。 (UPD:真正的题解已写完，点击打开对应网址) 哦还有，大家可以趁此机会学习一下逆元，多么充实的寒假呀，加油ヾ(◍°∇°◍)ﾉﾞ。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>DFS</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>map</tag>
        <tag>DP</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
        <tag>寒假集训</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU_ACM_ICPC_2019_Winter_Practice_1st【解题报告】]]></title>
    <url>%2Fsdnu-2019-1%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-wCdImmSk"), narrow: false, autoplay: false, showlrc: false, music: { title: "可能否", author: "木小雅", url: "http://music.163.com/song/media/outer/url?id=569214126.mp3", pic: "http://p1.music.126.net/SJYnDay7wgewU3O7tPfmOQ==/109951163322541581.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); A - The kth great number【模拟】【vector】[HDU - 4006 ] 一看这个题，求第k大数，以为是主席树呢。仔细一看，哦，用vector模拟一下就行了。 后来看其他队员也有用multiset和priority_queue的，嗯，可以趁这个机会学习一下它们的用法。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;char op;int n, k, t;int main()&#123; while(~scanf("%d%d", &amp;n,&amp;k)) &#123; vector&lt;int&gt; G; while(n--) &#123; cin &gt;&gt; op; if(op == 'I') &#123; scanf("%d", &amp;t); int pos = lower_bound(G.begin(), G.end(), t) - G.begin(); G.insert(G.begin() + pos, t); &#125; else &#123; printf("%d\n", G[G.size() - k]); &#125; /* for(int i = 0; i &lt; G.size(); ++i) cout &lt;&lt; G[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; */ &#125; &#125; return 0;&#125; B - A Trivial Problem【数学】CodeForces - 633B 题意：给出一个数m，求阶乘末尾有m个0的数的个数及这些数。 思路：一眼望去，以为是这个题，又读了一遍发现这个是“反着求”。 以为是规律，然后写几项看看吧，写了m = 30多时的答案还是没看出什么来。 休息了一会想到还是用上面那个题的代码，因为要求的序列和m的关系是单调的，所以或许可以通过二分枚举答案，接着试了试上界，序列中的数最大到400009，好了可以二分了。最后只要把符合要求的存一下，问题就解决了。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int n;int solve(int t)&#123; int cnt = 0; while(t) &#123; t /= 5; cnt += t; &#125; return cnt;&#125;int main()&#123; scanf("%d", &amp;n); int r = 400010, l = 0, m; int idx = 0; while(l &lt;= r) &#123; m = (r + l) &gt;&gt; 1; if(solve(m) &lt; n) &#123; idx = m; l = m + 1; &#125; else r = m - 1; &#125; vector&lt;int&gt; res; for(int i = idx; ; ++i) &#123; if(solve(i) == n) res.push_back(i); else if(solve(i) &gt; n) break; &#125; printf("%d\n", res.size()); for(int i = 0; i &lt; res.size(); ++i) printf("%d ", res[i]); return 0;&#125; C - New Skateboard【模拟】【分类讨论】CodeForces - 628B 题意：给出一个字符串，求出其中的连续&amp;&amp;满足“数值”为4的倍数的子序列的数量。 思路：纸上写一写，然后分类讨论一下就行了。 MyCode：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 300010;int len;char s[N];long long res;int main()&#123; scanf("%s", s); len = strlen(s); for(int i = len - 1; i &gt;= 0; --i) &#123; if((s[i] - '0') % 4 == 0) //0、4、8 &#123; ++res; if(i &gt; 0) &#123; res += ((s[i-1] - '0') % 2 == 0) ? i : 0; &#125; &#125; else if((s[i] - '0') % 2 == 0) //2、6 &#123; if(i &gt; 0) &#123; res += ((s[i-1] - '0') % 2 != 0) ? i : 0; &#125; &#125; &#125; printf("%lld\n", res); return 0;&#125; D - Color the ball【前缀和或线段树】HDU - 1556 一眼望去线段树。观察选手代码长度，自信$n^2​$莽了一发，收获TLE。老老实实上线段树AC。 AC后发觉事情不太对，这个前缀和应该也可以的，但一时没想起来怎么写。赛后搜了一下不由感叹：秒啊秒啊。 具体一点就是在增加数字的区间两端进行标记，左端点+1右端点的右边坐标-1，这样某个区间的次数就是从1坐标到这个位置的数值之和了。 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 100010;int n, x, y, a[N];int main()&#123; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; memset(a, 0, sizeof(a)); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d", &amp;x,&amp;y); ++a[x]; --a[y + 1]; &#125; for(int i = 1; i &lt;= n; ++i) &#123; a[i] += a[i-1]; printf("%d%c", a[i], i == n ? '\n' : ' '); &#125; &#125; return 0;&#125; E - 非常可乐【BFS或数学】HDU - 1495 kuangbin专题一做过，当时BFS过的，看选手代码发现怎有如此短的代码？打开一看用了gcd什么的，不太懂，等督促数学选手水哥写完博客后大家可直接去访问他的博客(UPD:已更新，点击打开对应文章链接)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int N = 111;int s, n, m, rq[5];bool vis[N][N][N];struct node&#123; int num[3], out;&#125; now, nex;void BFS(int s, int n, int m)&#123; memset(vis, 0, sizeof(vis)); queue&lt;node&gt; Q; now.num[0] = s; now.num[1] = n; now.num[2] = m; now.out = 0; Q.push(now); vis[s][n][m] = 1; while(!Q.empty()) &#123; now = Q.front(); Q.pop(); for(int i = 0; i &lt; 2; ++i) for(int j = 0; j &lt; 3; ++j) &#123; if(i == j) continue; if(now.num[i] == now.num[j] &amp;&amp; now.num[3-i-j] == 0) &#123; printf("%d\n", now.out); return ; &#125; &#125; for(int i = 0; i &lt; 3; ++i) &#123; for(int j = 0; j &lt; 3; ++j) &#123; if(i == j) continue; if(now.num[i] + now.num[j] &lt;= rq[j]) &#123; nex.num[j] = now.num[j] + now.num[i]; nex.num[i] = 0; &#125; else &#123; nex.num[i] = now.num[i] - (rq[j] - now.num[j]); nex.num[j] = rq[j]; &#125; for(int k = 0; k &lt; 3; ++k) &#123; if(k == i || k == j) continue; nex.num[k] = now.num[k]; &#125; nex.out = now.out + 1; if(vis[nex.num[0]][nex.num[1]][nex.num[2]] == 0) &#123; vis[nex.num[0]][nex.num[1]][nex.num[2]] = 1; Q.push(nex); &#125; &#125; &#125; &#125; puts("NO");&#125;int main()&#123; int s, n, m; while(scanf("%d%d%d", &amp;s,&amp;n,&amp;m) &amp;&amp; s) &#123; rq[0] = s, rq[1] = n, rq[2] = m; BFS(s, 0, 0); &#125; return 0;&#125; F - 今夕何夕【模拟】HDU - 6112 2017百度之星初赛签到题。。其实并不难的，就是模拟一下日期，注意一下闰年就完了，不知道为啥做的人这么少。 记得有个公式(蔡勒公式)直接算日期的，找之前的板子没找到，然后直接按百度百科的抄上了，结果姿势有点不太对TLE了两次，最后老老实实模拟了。 哦对了，这题的输入格式，还有大爷直接字符串 + gets然后再转化为int变量，为啥不直接格式读入。。？？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, yy, mm, dd, res;bool leap(int year)&#123; if(year % 400 == 0) return 1; if(year % 100 == 0) return 0; return year % 4 == 0;&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d-%d-%d", &amp;yy,&amp;mm,&amp;dd); int sum = 0; if(mm == 2 &amp;&amp; dd == 29) &#123; for(int i = yy + 1; ; ++i) &#123; sum += 365; if(leap(i)) ++sum; sum %= 7; if(leap(i) &amp;&amp; !sum) &#123; res = i; break; &#125; &#125; &#125; else if(mm &lt; 3) &#123; for(int i = yy + 1; ; ++i) &#123; sum += 365; if(leap(i - 1)) ++sum; sum %= 7; if(!sum) &#123; res = i; break; &#125; &#125; &#125; else &#123; for(int i = yy + 1; ; ++i) &#123; sum += 365; if(leap(i)) ++sum; sum %= 7; if(!sum) &#123; res = i; break; &#125; &#125; &#125; printf("%d\n", res); &#125; return 0;&#125; G - 第几天？【模拟】HDU - 2005 签到题，判断闰年。简单提一点，还是上面说的，注意格式读入。。 等会，有人写了好几kb的代码，打开一看十几个if-else，我哭了。。你们通过这种写法A掉的，再按照下面的重新写一遍吧。。 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int yy, mm, dd, res;int a[] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;bool leap(int year)&#123; if(year % 400 == 0) return 1; if(year % 100 == 0) return 0; return year % 4 == 0;&#125;int main()&#123; while(~scanf("%d/%d/%d", &amp;yy,&amp;mm,&amp;dd)) &#123; res = dd; for(int i = 1; i &lt; mm; ++i) res += a[i]; if(mm &gt; 2 &amp;&amp; leap(yy)) ++res; printf("%d\n", res); &#125; return 0;&#125; H - 最大子矩阵【二维前缀和】HDU - 1559 典型的动态规划问题，也是利用前缀和进行求解。 用$sum[i][j]$表示起点为矩形左上角这个点为右下角的矩阵的元素之和，最后枚举大小为$x \times y$的矩阵时枚举左上角位置后，右下角的位置就是$(i+x-1,j+x-1)$，自己画图减一下就能看出来，最后的答案就是： $sum[i+x-1][j+y-1] - sum[i+x-1][j-1] - sum[i-1][j+y-1] + sum[i-1][j-1]$， 为了避免数组下标出现负数的情况，我存图用的下标是从1开始的。 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1111;int t, n, m, x, y, a[N][N], sum[N][N];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d%d%d", &amp;n,&amp;m,&amp;x,&amp;y); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) scanf("%d", &amp;a[i][j]); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) sum[i][j] = a[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]; int res = -1; for(int i = 1; i + x &lt;= n; ++i) for(int j = 1; j + y &lt;= m; ++j) res = max(res, sum[i+x-1][j+y-1] - sum[i+x-1][j-1] - sum[i-1][j+y-1] + sum[i-1][j-1]); printf("%d\n", res); &#125; return 0;&#125; I - Help is needed for Dexter【规律】UVA - 11384 不知道如此简单的一道题为啥没人做。。 题目大意：这里有1~n共n个数，你每次可以选取其中的若干数个让他们减去一个你指定的数(中途不得出现负数)，问最少经过多少次操作能使得所有的数变为0。 解题思路：找了几个数写出来看了看，很显然的规律题。 具体过程： 1 1次 1 2 经过一次变换可以转化为1 1 共需要2次 1 2 3 经过一次变换可以转化为1 0 1 共需要2次 1 2 3 4 经过一次变换可以转化为1 2 1 2 共需要3次 1 2 3 4 5 经过一次变换可以转化为1 2 0 1 2 共需要3次 ………… 就是经过尽量少次数的变换让他们变成前面出现过的就行了，就提示到这，一定要自己推出来并AC掉呀。 MyCode：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n;int res[33] = &#123;1, 2&#125;;void init()&#123; for(int i = 2; i &lt;= 32; ++i) res[i] = res[i - 1] * 2;&#125;int main()&#123; init(); while(~scanf("%d", &amp;n)) &#123; for(int i = 1; ; ++i) &#123; if(res[i] &gt; n) &#123; printf("%d\n", i); break; &#125; &#125; &#125; return 0;&#125; J - find your present (2)【二进制】HDU - 2095 签到题，可以直接stl容器存，也可以直接利用异或的性质进行求解。 这个题开场4分钟就被A掉，看来确实是有人对学过的知识还有印象。 代码还是不够精简啊，根本不需要数组，直接三个变量就能A掉，精简代码也是挺重要的。。 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, res, tem;int main()&#123; while(scanf("%d", &amp;t) &amp;&amp; t) &#123; res = 0; for(int i = 0; i &lt; t; ++i) &#123; scanf("%d", &amp;tem); res ^= tem; &#125; printf("%d\n", res); &#125; return 0;&#125; END：这里面大部分是QDU去年算法协会给17级的出的题目，所以并不难，大家做成这样emmm。总之还差得远呢，好好利用寒假吧，开学后各种事又会忙起来，争取这个假期能有质的飞跃。 自己还感受到好久不打比赛后，这样一做还真有些吃力，这个东西，还是不要放下太久，不然要重新捡起来又要费好大劲。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>线段树</tag>
        <tag>vector</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
        <tag>寒假集训</tag>
        <tag>前缀和</tag>
        <tag>位运算</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNUOJ题目分类【Overview】]]></title>
    <url>%2Fsdnuoj-problem-categories%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-DMWnPOka"), narrow: false, autoplay: false, showlrc: false, music: { title: "我的天空", author: "南征北战nzbz", url: "http://music.163.com/song/media/outer/url?id=28892408.mp3", pic: "http://p1.music.126.net/09FsXnIw8EmAqkb7LwiCOw==/1410673435521373.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 写在前面：About：这是一篇关于SDNUOJ题目分类的文章，内容是各题目的难度标记及题目分类。以下是几个关于对这篇文章的疑问，大家有什么疑问可以在文章最下面留言或者直接联系我，我会一一解答(如果看到的话)。 Q&amp;A：Q：为什么要写这样一篇文章？ A：自己刚入坑时不会的太多而且一直找不到合适的做题顺序，如无头苍蝇一般，其中尝试各种道路便浪费了好多时间。入坑入得很难受。所以现在要写这样一篇文章，主要是帮助刚入坑的萌新，能让你们有个良好的入坑体验。至于入坑成功后的路，就需要你们自己走了。 Q：啊啊啊，为什么不早写呢？我大一上学期都结束了。 A：其实自己在大一省赛结束后就想写了，因为那时简单题目就已经被solve的差不多了，然后由于感觉这事并不紧急，就一拖再拖，加上有SDNU作弊码的存在，感觉自己再整理一遍有些“抢生意”的感觉，再加上后面作弊码的完善，这件事就搁浅了。 Q：那为什么现在要写了？ A：因为感觉作弊码写的不好，而且作弊码的作者码风…… &amp;&amp; 部分题解并不好，不适合作为教程。咳咳，这个嘛，一方面是兑现去年9月份(捂脸)对教练的承诺，为SDNU-ACM的发展贡献一份自己的力量——帮助萌新入门；另一方面自己期末考完试早早结束暂时没做其他事，后面也没课了，整理这个的同时也可以回忆一下自己的大学生活。 Q：感觉好棒(×)，会不会写关于其他OJ的类似文章呢？ A：不会。。自己太菜了，也就能水水本校OJ。不过已经有了很多其他OJ的类似文章了，如POJ的题目分类，kuangbin专题一览，BZOJ一句话题解，Codeforces自带的分类功能…… Q：阳神你真帅 A：废话，还用你说 最后附自拍一张 正文：几点注意事项： 这里按照题目顺序进行整理，格式为题目序号、【难度】 题目类型 (特别标记) 难度针对萌新分级为【入门】、【初级】、【中等】、【困难】对柳总这样的dalao来说都是【入门】QAQ。 这以后你就可以根据自己的需求Ctrl + F搜索你想要的难度 || 类型的题目进行AC了。 因为是个人整理嘛，所以可能在题目难度的感觉上及tags的标记上不是很准确，有疑问的欢迎与我交流，希望这篇文章在大家的共同努力下越来越完善（づ￣3￣）づ╭❤～。 第一页：1000 ~ 1009、【入门】 输入输出练习 + 循环语句 + 读到文件结束 1010、【入门】 打印图形 (初学者的第一个槛，一定要自己写出来) 1011、【中等】 排列组合 (第二类stirling数) 1012、【初级】 结构体排序 1013、【初级】 贪心 1014、【入门】 数组 + 循环语句 1015、【中等】 DFS 1016、【中等】 思维 || 并查集 1017、【入门】 贪心 1018、【入门】 模拟 1019、【初级】 模拟 1020、【入门】 选择语句 1021、【入门】 模拟 1022、【困难】 DFS 1023、【入门】 贪心 1024、【入门】 模拟 (1014简化版) 1025、【初级】 DFS || BFS 1026、【中等】 贪心 (仔细读题) 1027、【中等】 BFS (1025升级版) 1028、【初级】 结构体排序 1029、【中等】 动态规划 1030、【困难】 最短路 1031、【困难】 拓扑排序 1032、【中等】 双线程DP 1033、【初级】 背包 1034、【入门】 同1020 1035、【入门】 模拟 || 规律 1036、【入门】 浮点数处理 1037、【入门】 模拟 1038、【初级】 递推 1039、【入门】 递推 1040、【初级】 DP之LIS 1041 ~ 1042、【入门】 模拟 1043、【初级】 背包 1044、【中等】 DP 1045、【中等】 DP 1046、【入门】 模拟 1047、【中等】 模拟 1048、【中等】 DP 1049 ~ 1055、【入门】 模拟 1056、【初级】 快速幂 1057、【初级】 模拟 (可练习vector用法) 1058、【初级】 模拟 (可练习map用法) 1059、【入门】 模拟 1060、【入门】 模拟 || 排序 1061、【初级】 背包 1062、【中等】 矩阵快速幂 (模板题) 1063、【困难】 模拟 + LCA 1064、【入门】 模拟 1065、【入门】 模拟 1066、【入门】 排序 1067 ~ 1070、【入门】 模拟 1071 ~ 1074、【入门】 递归 1076、【初级】 并查集 1077、【初级】 背包 1078、【中等】 并查集应用 1079、【入门】 模拟 1080、【入门】 数学 1081、【初级】 快速幂(模板) 1082、【初级】 规律 1083、【入门】 规律 (递归即可AC) 1084、【初级】 规律 (需递推才可AC) 1085、【中等】 规律 (需矩阵快速幂) 1086、【中等】 BFS 1087、【中等】 离散化 + DP 1088、【初级】 欧拉路 1089、【初级】 直接判断度数 || 拓扑排序 1090、【入门】 模拟 1091、【初级】 贪心 1092、【入门】 模拟 1093 ~ 1094、【初级】 结构体排序 1095 ~ 1096、【入门】 模拟 1097、【初级】 LCM 1098 ~ 1101、【初级】 字符串 第二页：1102、【初级】 模拟 1103、【初级】 排列组合 1104、【初级】 结构体排序 1105、【入门】 数学 1106、【入门】 模拟 1107、【初级】 贪心 1108 ~ 1109、【入门】 模拟 1110 ~ 1111、【中等】 模拟 1112、【入门】 同1020 1113、【初级】 模拟 (高精度) 1114 ~ 1115、【初级】 模拟 1116、【中等】 AC自动机(模板题) 1117、【困难】 高精度 1118、【困难】 AC自动机 (模板题)，可用Java水过 1119、【初级】 模拟 1120、【入门】 模拟 1121 ~ 1127、【初级】 模拟 1128 ~ 1130、【困难】 SDNU ACM-ICPC 2013省队选拔赛 1134、【困难】 Floyd闭包 1135 ~ 1144、【初级 + 中等 + 困难】 山东省第一届ACM大学生程序设计竞赛 1145 ~ 1152、【初级 + 中等 + 困难】 Mid-Central USA 2012 1153 ~ 1160、【初级 + 中等 + 困难】 Mid-Central USA 2011 1161 ~ 1162、【中等】 模拟 1163、【入门】 模拟 1164 ~ 1165、【困难】 思维 模拟 1166 ~ 1169、【入门 + 中等】 NOIP 2004 普及组 1170 ~ 1171、【入门 + 中等 + 困难】 NOIP 2004 提高组 1174 ~ 1177、【入门 + 初级 + 中等 + 困难】 NOIP 2006 普及组 1178 ~ 1181、【中等 + 困难】 NOIP 2006 提高组 1182 ~ 1184、【初级 + 中等】 NOIP 2007 普及组 1185 ~ 1188、【初级 + 困难】 NOIP 2007 提高组 1189 ~ 1191、【初级 + 困难】 NOIP 2008 普及组 1192 ~ 1195、【初级 + 中等 + 困难】 NOIP 2008 提高组 1196、【困难】 矩阵快速幂 1197、【困难】 思维 1198、【困难】 DP 1199、【入门】 数学 第三页：1200、【中等】 模拟 || 中缀转后缀 1201、【初级】 模拟 1202、【初级】 规律 1203、【初级】 模拟 1204、【初级】 规律 1205、【入门】 递推 1206、【初级】 思维 1207 ~ 1208、【中等】 模拟 1209、【初级】 排序 + 去重 (可练习set用法) 1210、【初级】 排序 (可练习stack用法) 1211、【初级】 进制转换 1212、【入门】 判断升序 1213、【中等】 模拟 1214 ~ 1216、【入门】 模拟 1217、【初级】 并查集 (模板题) 1218、【初级】 最小生成树 (模板题) 1219、【入门】 输入输出练习 1220、【中等】 BFS记录路径 1221、【初级】 DP (LIS模板题) 1222、【困难】 KMP 1223 ~ 1224、【中等】 最短路 1225、【中等】 数学 1226、【困难】 数学 (扩展欧几里得) 1227 ~ 1228、【中等】 数学 1229、【中等】 最小生成树 (稠密图用Prim) 1230、【困难】 并查集 1231、【入门】 输出 1232、【初级】 模拟 1233、【???】 隐藏题目 1234、【中等】 贪心 1235 ~ 1238、【???】 隐藏题目 1239、【中等】 数学 (线性筛) 1240 ~ 1244、【中等 + 困难】 17新生期末赛部分题目 1245、【初级】 快速幂 1246 ~ 1252、【初级 + 中等 + 困难】 山东省第九届acm大学程序设计竞赛山师选拔赛第一场部分题目 (题解) 1253 ~ 1261、【初级 + 中等 + 困难】 山东省第九届acm大学程序设计竞赛山师选拔赛第二场部分题目 (题解) 1262 ~ 1266、【???】 隐藏题目 1267、【初级】 模拟 1268、【初级】 链表 || 结构体排序 1269、【入门】 模拟 1270、【中等】 思维 1271、【初级】 模拟 1272、【初级】 思维 1273、【中等】 DP 1274 ~ 1277、【入门】 模拟 1278、【初级】 排序 1279、【入门】 模拟 1280 ~ 1281、【初级】 模拟 1282、【中等】 数学 1283、【初级】 规律 1284、【中等】 模拟 1285、【初级】 规律 1286、【初级】 数学 (素数) 1287、【初级】 数学 (欧拉函数) 1288 ~ 1289、【困难】 ??? 1290、【中等】 模拟 1291、【困难】 ??? 1292、【初级】 DP (LIS) 1293 ~ 1294、【中等】 规律 1295、【困难】 ??? 1296、【困难】 模拟 1297 ~ 1299、【困难】 ??? 第四页：1300、【中等】 规律 1301、【初级】 模拟 (高精度) 1302、【初级】 规律 1303、【初级】 模拟 (高精度) 1304、【中等】 规律 1305、【中等】 模拟 1306、【初级】 模拟 1307 ~ 1308、【困难】 ??? 1309、【入门】 数学 1310、【初级】 线段合并 1311、【初级】 计算组合数 1312、【初级】 模拟 (摩斯密码转换) 1313、【困难】 规律 + 矩阵快速幂 1314、【初级】 规律 1315、【???】 隐藏题目 1316、【初级】 DFS || 打表 1317、【初级】 模拟 1318、【初级】 直接做 || 数位DP 1319 ~ 1320、【中等】 数学 概率期望 1321、【入门】 C语言 1322、【初级】 数学 概率 1323 ~ 1329、【困难】 数学 1330、【初级+】 DP 1331、【初级+】 二分 1332、【初级】 模拟 1333 ~ 1340、【中等 + 困难】 某场选拔赛题目 1341、【初级】 模拟 日期转换 1342 ~ 1348【???】 隐藏题目 1349、【初级】 快速幂 1350、【初级】 区间覆盖 1351、【初级】 并查集 1352、【困难】 ??? 1353、【入门】 简单计算 1354、【初级】 gcd 1355、【???】 隐藏题目 1356 ~ 1363、【入门 + 初级】 新生周赛题目 1364 ~ 1369、【初级 + 中等 + 困难】 NOIP2014提高组 1370 ~ 1374、【中等 + 困难】 Waterloo local 2000.09.23 1375 ~ 1379、【初级 + 困难】 Waterloo local 2000.09.30 1380 ~ 1384、【初级 + 困难】 Waterloo local 2001.01.27 1385 ~ 1389、【中等 + 困难】 ??? 1390 ~ 1403、【困难】 ??? 第五页：1401 ~ 1482、【入门 + 初级 + 中等 + 困难】 蓝桥杯往年试题 1483 ~ 1490、【初级 + 中等 + 困难】 山东省第八届acm大学程序设计竞赛山师选拔赛第一场 题解 1491、【困难】 DP 1492 ~ 1501、【初级 + 中等 + 困难】 山东省第八届acm大学程序设计竞赛山师选拔赛第二场 题解 第六页：1502、【中等】 DP (状压DP模板) 1503 ~ 1514、【初级 + 中等 + 困难】 山东省第七届acm大学程序设计竞赛 1515 ~ 1518、【入门 + 初级】 山东省第八届acm大学程序设计竞赛赛前娱乐 1520、【初级】 背包 (多重背包) 1521、【入门】 排序 1522、【中等】 数学 (线性筛) 1523、【初级】 快速幂 || for循环 1524、【???】 隐藏题目 1525、【初级】 次小生成树模板 1526、【困难】 贪心 1527、【中等】 打表 1528、【初级】 DFS枚举答案 || 手推 1529、【困难】 数学 (容斥) 1530、【入门】 return 0; 1531、【困难】 FFT 1532、【困难】 NNT 1533、【初级】 模拟 1534 ~ 1543、【入门 + 初级 + 中等 + 困难】 18期末总结赛部分题目 (题解) END：回首大学里已经过去的两年半的时间，自己的大一过的还是很满意的，虽然那时的付出没能得到即时的反馈，但我可以毫不客气的说，后面的惊喜几乎都是那一年的付出所埋下的铺垫。从大二开始，迷茫犹豫的次数太多，在反复试错的过程中失去了很多本可以变得更好的机会。大三的这一学期尝试着弥补，虽然有所收获，但想想大二废掉的一年总是觉得很遗憾。 有时也总想着如果能回到过去重来一遍该多好，可是就算时光可以倒流，自己也还是会犯同样的错误，到最后还是过着和现在一样的生活，不是吗？ 如果你看到了这里，那恭喜你，你将获得我最想和两年前的我说的一句话——“不要等没机会搞acm的时候，再后悔没有全身心的投入。” 最后，就以泰戈尔诗句作为结尾好了——“只管走过去，不必逗留着采了花朵来保存，因为一路上花朵自会继续开放的。”]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>SDNU</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU ACM-ICPC 2018 Final Summary Contest(12-16)【解题报告】]]></title>
    <url>%2Fsdnu-2018-4%2F</url>
    <content type="text"><![CDATA[前言：激动人心(×)的期末总结赛终于来了！经过断断续续的三周的准备，这套题目终于完整(×)的出现在了大家面前。虽然此次13道题全是英文题面，但命题组尽可能的保证了题目的通俗易懂……如果还是有读不懂的地方的话就来喷我吧，我太菜了o(╥﹏╥)o。 另外，感觉到了造数据的不易，找的两个验题人一直忙着各种事咕咕咕，终于在昨晚把他们骗到集训室帮忙验了下题，改了些题面描述的语法错误，果然有道题数据出问题了。原来自己随机程序写的有问题，emmm。抓紧修锅，最终赶在封楼前修完，安心回宿舍了(要是今天现场出锅就刺激了)。 UPD：MD，今天果然还是出锅了。 题解：说明：以下内容为现场赛时写的，一边看榜，一边写，所以是按照每道题被拿走FB的顺序写的。 1231.Why choose ACM?【签到】最后加的签到题，没想到00:03:09被QLU的抢了一血(By:QLUZhouXiang)，以为这个签到题伪装的挺好的了。 另外，感觉自己已经描述的够详细了，所以WA了的…emmm，求轻喷吧。 MyCode: 1234567891011121314#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; string s = "always challenge miracles"; s[0] = toupper(s[0]); cout &lt;&lt; s &lt;&lt; '\n'; return 0;&#125; 1536.How many users on SDNU OJ【签到】【stl】一血时间00:05:30，By:songjian。肯定是发现了这个题题面的提示(签到成功.jpg)。 也没啥好说的，就是直接map|set标记，然后输出就好了。 另外：输出Case这样的比较恶心的&amp;无用的东西的时候，直接按照下面的写法比较方便，可以学习一下。 MyCode： 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;int t, n;string s;map&lt;string, bool&gt; MP;int main()&#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d", &amp;n); MP.clear(); while(n--) &#123; cin &gt;&gt; s; MP[s] = 1; &#125; printf("Case #%d: %d\n", cas, MP.size()); &#125; return 0;&#125; 1534.Single Dog【签到】签到题，再次被QLU参赛选手发现，00:19:38FB诞生，By: QLUZhouXiang。 这个恶意卡了一下int，n的最大范围是INT_MAX + 1(果然卡了很多人)，其他没什么好说的。 MyCode： 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t;long long n;char name[111];int main()&#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%s%lld", name, &amp;n); printf("Case #%d: %s is %s.\n", cas, name, (n &gt;= 10000) ? "Life Winner" : "Single Dog"); &#125; return 0;&#125; 1541.Your Code Is Awesome【二进制异或】【思维】00:33:42FB诞生，By:18XiWenjuan。 看到她AC后，心里一阵窃喜，原来我讲过的异或的性质她认真学了啊，打开AC代码一看，笑容渐渐消失。 WTF？排了个序，然后相邻两个查了一下，过了？本着赛中不能把AC过的进行重判的原则，就勉强让她AC吧。But，这不是正解，这次卡过去了就卡过去吧，连夜修锅最后还是输了。赛后再加强数据嘻嘻。 ？？？怎么都知道用排序水过去？不行不行，忍不了，现场加强数据，rejudge，尽情的喷我吧，告辞。 UPD：03:06:02这道题又被卡过去了，打开AC代码看了一下，原来是加上了读入挂，心态爆炸。不想再改了，我二十几岁，我好累。对于卡过去的柳总，如果你看到这里，我要送你下面这句话： AC代码： 参考https://blog.csdn.net/ccutyear/article/details/53456571 1537.Tiger Eat People【组合数学】【大数或模拟】00:34:38FB诞生，By:2017luoxingcheng。 没想到这道题在所有签到题没签完的前提下被秒了，这样很容易歪榜啊喂(#`O′)(其实如果不是卡高精度了这题也是道水题)。 解析：这道题相当于6进制下选数，很容易看出答案就是$2^n(C_n^0 + C_n^1 + C_n^2 + \ldots + C_n^n)$，因为最后答案比较大，所以可以用c++模拟或者直接上Java(还有人用的Python？tql)。 MyCode(Java)： 1234567891011121314151617181920import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int t = cin.nextInt(); BigInteger TWO = BigInteger.valueOf(2); while((t--) &gt; 0) &#123; int n = cin.nextInt(); BigInteger res = BigInteger.ONE; for(int i = 0; i &lt; n; ++i) &#123; res = res.multiply(TWO); &#125; System.out.println(res); &#125; &#125;&#125; 1539.Do you like Hot Dog ?【01背包】【W超大】00:38:37 QLU抢走一血，By:QLUzhengzehao。 就是01背包问题，小白书上写的很详细，这个价值范围小，所以用DP针对不同的价值计算最小重量。详见P61。 MyCode： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 10010;const int INF = 0x3f3f3f3f;int n, limit;int we[500 + 5];int vi[500 + 5];int dp[505][5005];void solve()&#123; fill(dp[0], dp[0] + 5005, INF); dp[0][0] = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt;= 5001; ++j) &#123; if(j &lt; vi[i]) dp[i+1][j] = dp[i][j]; else dp[i+1][j] = min(dp[i][j], dp[i][j-vi[i]]+we[i]); &#125; int res = 0; for(int i = 0; i &lt;= 5001; ++i) if(dp[n][i] &lt;= limit) res = i; printf("%d\n",res);&#125;int main()&#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); int nCase; scanf("%d", &amp;nCase); while(nCase--) &#123; memset(we, 0, sizeof we); memset(vi, 0, sizeof vi);// memset(dp, 0, sizeof dp); scanf("%d %d", &amp;n, &amp;limit); for(int q = 0; q &lt; n; ++q) &#123; scanf("%d %d", &amp;we[q], &amp;vi[q]); &#125; solve();// cout &lt;&lt; "limit=" &lt;&lt; limit &lt;&lt;endl; //cout &lt;&lt; rec(0, limit) &lt;&lt; endl; &#125; return 0;&#125; 1331.Kick Veges’ Ass【二分】01:55:50FB诞生，By:2017luoxingcheng 题意：n个菜鸟站一排，我要按顺序虐他们。虐第i个菜鸟需要花费掉A[i]点RP，现在我打算分k天虐完这些菜鸟。我每天的RP总数是固定的，为了使RP最低的时候不会过低导致杯具，我希望这k天中虐菜花费RP最多的一天，花费的RP尽量少。求我在花费RP最多那天花费了多少RP。 思路：二分枚举答案就好了，最基础的二分。 MyCode：(一年半前写的，比较丑陋，不要参考) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 100005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, k;int l, r, mid, sum;int a[MAX];bool judge(int rp)&#123; int tot = 1; //全部虐完需要的天数 int now = 0; //现在已经花费的RP for(int i = 0; i &lt; n; ++i) &#123; now += a[i]; if(now &gt; rp) &#123; now = a[i]; ++tot; &#125; &#125;// cout &lt;&lt; "tot=" &lt;&lt; tot &lt;&lt; endl; return tot &gt; k;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i]; l = max(l, a[i]); r += a[i]; &#125; while(l &lt; r) &#123; int mid = (l + r) / 2; if(judge(mid)) l = mid + 1; else r = mid;// cout &lt;&lt; l &lt;&lt; "--" &lt;&lt; r &lt;&lt; "--" &lt;&lt; mid &lt;&lt; endl; &#125; cout &lt;&lt; r &lt;&lt;endl; return 0;&#125; 1220.Look for homework【BFS记录路径】01:56:02FB诞生，By:2018lihaoran BFS + 记录路径。确实还是没啥好说的。。。 MyCode(两年前的，现在看起来很丑陋，不要参考)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, m;int fir, las;int dir[4][2] = &#123;&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0, 1&#125;,&#123;-1, 0&#125; &#125;;//D,L,R,Uchar T[4] = &#123;'D', 'L', 'R', 'U'&#125;;int mapa[15][15];string str[105];char c[105];struct node&#123; int x, y; int pre; char ch;&#125; q[105];void print(int i, int j)&#123; int tem, tot = 0; c[tot] = q[j].ch; tot++; tem = i; while(q[tem].pre != -1) &#123; c[tot] = q[tem].ch; tot++; tem = q[tem].pre; &#125; cout &lt;&lt; tot &lt;&lt; endl; for(tem = tot-1; tem &gt;= 0; --tem) cout &lt;&lt; c[tem]; cout &lt;&lt; endl;&#125;void bfs(int x, int y)&#123; int x1, y1; fir = 0; las = 1; q[fir].x = x; q[fir].y = y; q[fir].pre = -1; mapa[x][y] = 1; while(fir &lt; las) &#123; for(int i = 0; i &lt; 4; ++i) &#123; x1 = q[fir].x + dir[i][0]; y1 = q[fir].y + dir[i][1]; if(x1 &lt; 0 || x1 &gt;= n || y1 &lt; 0 || y1 &gt;= m || mapa[x1][y1]) continue; mapa[x1][y1] = 1; q[las].pre = fir; q[las].x = x1; q[las].y = y1; q[las].ch = T[i]; las++; if(x1 == n-1 &amp;&amp; y1 == m-1) &#123; print(fir, las-1); return ; &#125; &#125; fir++; &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;n, &amp;m)) &#123; for(int i = 0; i &lt; n; ++i) &#123; cin&gt;&gt;str[i]; for(int j=0; j&lt;=m-1; j++) &#123; if(str[i][j]=='1') mapa[i][j]=1; else mapa[i][j]=0; &#125; &#125; bfs(0, 0); &#125; return 0;&#125; 1542.Liu Yuxin was insulted【状压DP】02:16:51 FB诞生，By:18LiuJunxiang 出题人说是状压DP，但是状态太少，直接枚举也能过，看了一下柳总的AC代码，近3kb，真猛啊。。 ACCode(By LiuYuxin): 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;int m[1005][10], n;int main() &#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); memset(m, inf, sizeof m); scanf("%d", &amp;n); m[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; 8; j++) m[i][j] = m[i - 1][j]; int v, kind = 0, len; char r[100]; scanf("%d", &amp;v);scanf("%s", r); len = strlen(r); int now = 0; while (now &lt; len) &#123; if (r[now] == 'O') &#123; kind |= (1 &lt;&lt; 0); now += 4; &#125; else if (r[now] == 'G') &#123; kind |= (1 &lt;&lt; 1); now += 9; &#125; else if (r[now] == 'P') &#123; kind |= (1 &lt;&lt; 2); now += 10; &#125; &#125; for (int j = 0; j &lt; 8; j++) &#123; int t = (kind | j); m[i][t] = min(m[i][t], m[i - 1][j] + v); &#125; &#125; if (m[n][7] &lt; inf) printf("%d\n", m[n][7]); else cout &lt;&lt; "Where are you? My beloved." &lt;&lt; endl; return 0;&#125; 1543.Happy Salted Fish Every Day【签到】【模拟】02:36:19 FB诞生，By:2017liruoshui 2个半小时了，签到题终于全被签完了，不知道是不是我暗示了一下的原因(我说其实还有好多题可以做的)。。另外，不明白为啥昌写了1600+b代码而且还WA了。 题意：告诉你一个序列的生成方式，问这个序列的第n项是几。 思路：直接模拟，还原序列后，$O(1)$输出。 ACCode(From 多校std)： 123456789101112131415//17多校 第七场K题#include &lt;cstdio&gt;int k[10000005],a,i,j,ii,T,n;int main()&#123; k[1]=a=1;k[2]=k[3]=2;i=3;j=4; while(j&lt;=10000000)&#123; for(ii=1;ii&lt;=k[i];ii++) k[j++]=a; i++;a=3-a; &#125; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); printf("%d\n",k[n]); &#125;&#125; 1535.Math【质因数分解】【贪心】Codeforces Round #520 (Div. 2) B题。 这都做不出来，我真是无话可说。。可能是被题面里出现的YC给吓到了？其实还是菜。 题意：给你一个数$n$，要你输出经过若干次操作能得到最小的值和操作的最少次数。 一共有两种操作：1. 让$n = n \times x$，$x$必须是正数。 2. 让$n = \sqrt{n}$，$n$必须是个平方数。 思路：最后能得到的最小的数一定是将$n$进行质因数分解后各质因子的乘积(通过操作2使他们的幂次都降为1)。为了使操作次数最小，我们可以一次乘上个很大的数，使得所有质因子都可以不断进行开方操作直到开到幂次为1，而能开直接到1的前提是让幂次变为$2^n$，具体细节见代码吧。 MyCode： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 111;int n, p[N], num[N];int main()&#123; while(~scanf("%d", &amp;n)) &#123; if(n == 1) &#123; puts("1 0"); continue; &#125; memset(p, 0, sizeof(p)); memset(num, 0, sizeof(num)); int cou = 0; for(int i = 2; i &lt;= sqrt(n); ++i) &#123; if(n % i == 0) &#123; ++cou; p[cou] = i; num[cou] = 0; while(n % i ==0) &#123; num[cou]++; n /= i; &#125; &#125; &#125; if(n &gt; 1) &#123; p[++cou] = n; num[cou] = 1; &#125; int maxx = num[1], res1 = p[1], res2 = 0; for(int i = 2; i &lt;= cou; ++i) &#123; maxx = max(maxx, num[i]); res1 = res1 * p[i]; &#125; if(maxx == 1) res2 = 0; else &#123; bool f = 0; for(int i = 2, j = 1; ; i *= 2, ++j) &#123; if(maxx &lt;= i) &#123; res2 = j; if(maxx &lt; i) &#123; f = 1; ++res2; &#125; break; &#125; &#125;// cout &lt;&lt; maxx &lt;&lt; ' ' &lt;&lt; res2 &lt;&lt; '\n'; if(!f) for(int i = 1; i &lt;= cou; ++i) if(num[i] != maxx) &#123; ++res2; break; &#125; &#125; printf("%d %d\n", res1, res2); &#125; return 0;&#125; 1538.GTMDDLY【贪心】【模拟】 ACCode(出题人提供)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Created by SWT#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int x,n; freopen("input.txt","r",stdin); freopen("output.txt","w",stdout); while(~scanf("%d %d",&amp;x,&amp;n)) &#123; int part1 = n*3,my_lose = 0,her_lose = 0; her_lose += (1 + 2*part1) * part1 - 3*part1; my_lose += (1 + part1) * part1 / 2; my_lose += 3*(1 + n) * n / 2; int flag = 0; if(x &gt; max(my_lose,her_lose)) &#123; int my_hurt = part1 + 1; int her_hurt = 2 * part1 - 1; while (1) &#123; my_lose += my_hurt; if(my_lose &gt;= x) &#123; flag = -1; break; &#125; her_lose += her_hurt; if(her_lose &gt;= x) &#123; flag = 1; break; &#125; my_hurt++; her_hurt++; &#125; &#125; else &#123; int attack = n,her_hurt = 1; my_lose = her_lose = 0; for (int i = 1; i &lt;= 3*n; i++) &#123; if(i != 1 &amp;&amp; i % 3 == 0)attack--; my_lose += i; if(my_lose &gt;= x) &#123; flag = -1;break; &#125; her_lose += her_hurt; her_hurt++; if(her_lose &gt;= x) &#123; flag = 1;break; &#125; her_lose += her_hurt; her_hurt++; if(her_lose &gt;= x) &#123; flag = 1;break; &#125; my_lose += attack; her_lose -= 3; if(my_lose &gt;= x) &#123; flag = -1;break; &#125; &#125; &#125; if(flag &gt; 0)printf("skirt!\n"); else printf("Damn it!\n"); &#125;&#125; 1540.A list generated by a wrong list【思维+NNT+二分】【防AK】0提交，太真实了。 以下内容由出题人(Forsaken)提供：考察范围：欧拉筛的深入理解、二分、NTT 题意：题目中告知我们运行的欧拉筛中的内层循环由于少了一个等号导致每次枚举都会少枚举已经得到的数，注意“少了一个等号会导致每次都少枚举已经得到的数字”，由缺少一个等号可以自然想到每次都少枚举了最后一个已经得到的数字，那么就是外层循环刚刚得到的最新的这个素数！因此整个欧拉筛误判了所有的素数的平方并把它们当成了素数，因此筛出1e6以内的所有素数并取平方就得到了LIST！对于给出的n和m，利用二分查找找到位置即可，然后的操作进行NTT对于998244353取模（原根为3）就得到了答案。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mann = 1e7+5;int tot;ll pri[mann];bool is[mann];void init () &#123; is[0] = is[1] = 1; for (int i = 2; i &lt; mann; ++i) &#123; if (!is[i]) &#123; pri[++tot] = i; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i*pri[j] &lt; mann; ++j) &#123; is[i*pri[j]] = 1; if (i % pri[j] == 0) &#123; break; &#125; &#125; &#125; for (int i = 1; i &lt;= tot; ++i) &#123; pri[i] *= pri[i]; &#125;&#125;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return; &#125; ll x0, y0; exgcd(b, a % b, x0, y0); x = y0; y = x0 - (ll)(a / b) * y0;&#125;ll Inv(ll a, ll p) &#123; ll x, y; exgcd(a, p, x, y); x %= p; while (x &lt; 0) &#123; x += p; &#125; return x;&#125;ll qpow(ll a, ll b, ll p) &#123; if (b &lt; 0) &#123; b = -b; a = Inv(a, p); &#125; ll ans = 1, mul = a % p; while (b) &#123; if (b &amp; 1) &#123; ans = ans * mul % p; &#125; mul = mul * mul % p; b &gt;&gt;= 1; &#125; return ans;&#125;#define maxn (65537*2)const int MOD = 998244353, G = 3;ll rev[maxn];void get_rev(ll bit) &#123; for (ll i = 0; i &lt; (1 &lt;&lt; bit); i++) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (bit - 1)); &#125;&#125;ll ar[maxn], br[maxn];void ntt(ll *a, ll n, ll dft) &#123; for (ll i = 0; i &lt; n; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; for (ll step = 1; step &lt; n; step &lt;&lt;= 1) &#123; ll wn; wn = qpow(G, dft * (MOD - 1) / (step*2), MOD); for (ll j = 0; j &lt; n; j += (step&lt;&lt;1)) &#123; ll wnk = 1; for (ll k = j; k &lt; j + step; k++) &#123; ll x = a[k] % MOD, y = (wnk * a[k + step]) % MOD; a[k] = (x + y) % MOD; a[k + step] = ((x - y) % MOD + MOD) % MOD; wnk = (wnk * wn) % MOD; &#125; &#125; &#125; if (dft == -1) &#123; ll nI = Inv(n, MOD); for (ll i = 0; i &lt; n; i++) &#123; a[i] = a[i] * nI % MOD; &#125; &#125;&#125;int main() &#123; init(); ll n, m; while (scanf("%lld %lld", &amp;n, &amp;m) != EOF) &#123; memset(ar, 0, sizeof(ar)); memset(br, 0, sizeof(br)); memset(rev, 0, sizeof(rev)); int pos1 = lower_bound(pri+1, pri+1+tot, n)-pri; int pos2 = upper_bound(pri+1, pri+1+tot, m)-pri-1; int len = pos2-pos1+1; for (int i = 0; i &lt; len; ++i) &#123; ar[i] = br[i] = pri[pos2-i]; &#125; ll bit, s = 2; for (bit = 1; (1 &lt;&lt; bit) &lt; 2*len-1; ++bit) &#123; s &lt;&lt;= 1; &#125; get_rev(bit); ntt(ar, s, 1); ntt(br, s, 1); for (ll i = 0; i &lt; s; i++) &#123; ar[i] = ar[i] * br[i] % MOD; &#125; ntt(ar, s, -1); for (int i = 0; i &lt; 2*len-2; ++i) &#123; cout &lt;&lt; ar[i] &lt;&lt; ' '; &#125; cout &lt;&lt; ar[2*len-2] &lt;&lt; '\n'; &#125; return 0;&#125; 吐槽： 办比赛真麻烦，以后不想搞了。。 这些人怎么回事？学了这么久，除了暴力啥也不会？这样子别说区域赛了，省赛都打不了 头真铁啊，最后一题都加强数据rejudge了还想着莽过去。。 大家好像都很喜欢排序？异或的题我排序，二分的题我排序，模拟的题我也排序…… 这次17的整体表现令人害怕，这样下去怕要被18踩爆；18也就前几各成绩还行，不过也合乎常理，毕竟走到最后的大概率都是这些人中的吧；柳总还是强啊；李浩然这小伙子不错.jpg，虽然这次比赛打的和狗屎一样，李浩然怎么起伏这么大.jpg。 这学期的训练就此结束了，总的来说确实比之前累了不少，不过同时也是有收获的吧。所谓“欲戴王冠，必承其重”，大概也能懂得一些了。 END：所以说，知道自己的真实实力最重要，不要因为一时的失败就觉得自己不行。 一定要多试几次你才会知道，自己真的不行。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QLU ACM-ICPC大学生程序设计迎新赛-正式赛【解题报告】]]></title>
    <url>%2Fqlu-2018-2%2F</url>
    <content type="text"><![CDATA[前言：再次作为吃瓜群众围观4小时，之前一直作为参赛选手参加比赛，从来没想到边缘ob也可以如此精彩。这次还和swt一起“解说”了这场比赛，感觉好有意思，解说真好玩.jpg 因为赛中L题数据出了问题，所以最后一直没人能AK，赛后rejudge时发现崔健聪其实早就在比赛过去$\frac{3}{4}$时AK了，而柳总是第一个过L的，宋健、刘陶然也都1A了。 此次比赛共13题，去掉最后一道直接输出答案的，还剩12道，正好请3位现场AK的队员分工写了下题解，这样我只需要整理一下，不用亲自去做每个题了hhhhh，在此表示一下感谢（づ￣3￣）づ╭❤～。 题解：崔健聪：A、B、C、DA、约数个数题目大意：输入$n$和$g$，$g$是一个质数，输入$n$行表示$n$个质数$p_1 \ldots p_n$，输入$n$行表示$n$个质数的幂次$ a_1 \ldots a_n$，构成一个$num = p_1^{a_1} \times p_2 ^ {a_2} \ldots p_n^{a_n}$，问你$num$的约数中有多少可以被$g$整除。 解题思路：因为$g$是质数，所以如果所给的$p$没有$g$那么就不会存在能被$g$整除的$num$的约数，有$g$的话，就是一个排列组合问题。除了$p_i == g$的那个质数外，其余被分解出来的质数都可以取$0$ ~ $a_i$个，所以最后的结果就是： $a_i（p_i == g）\times (a_1 + 1) \times (a_2+1) \times \ldots \times(a_{i-1} + 1) \times (a_{i+1} + 1) \times \ldots \times (a_{n}+1)$。 Code：12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 1e2;int p[maxn];int a[maxn];int cnt[maxn];int main()&#123; int n,g; scanf("%d%d",&amp;n,&amp;g); for(int i = 1;i &lt;= n;++i) scanf("%d",&amp;p[i]); memset(cnt,0,sizeof(cnt)); for(int i = 1;i &lt;= n;++i) &#123; scanf("%d",&amp;a[i]); cnt[p[i]] = a[i]; &#125; if(cnt[g] == 0) printf("0\n"); else &#123; ll ret = cnt[g]; for(int i = 1;i &lt;= n;++i) &#123; if(p[i] == g)continue; ret *= (ll)(a[i] + 1); &#125; printf("%lld\n",ret); &#125; return 0;&#125; B、Alice and Bob题目大意：输入n表示有n堆数，输入n个数，表示数的大小。 游戏规则，Alice先手，Bob后手，先手后手轮流取，一次只能拿光一堆数，最后所得到的数的和最大者获胜。 解题思路：为了获胜，Alice和Bob肯定都从当前所有数中拿最大的。 所以排序，Alice拿偶数位，Bob拿奇数位，计算sum1，sum2，比较输出即可。 局面只有平局和Alice胜利。 Code：1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 1e2;int cnt[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;++i) scanf("%d",&amp;cnt[i]); ll sum1 = 0,sum2 = 0; sort(cnt+1,cnt + n + 1); for(int i = n;i &gt;= 0;--i) &#123; if((n - i) % 2 == 0) &#123; sum1 += cnt[i]; &#125; else &#123; sum2 += cnt[i]; &#125; &#125; if(sum1 == sum2) printf("again\n"); else printf("A\n"); return 0;&#125; C、黑白黑题目大意：两种选择，少数为败，存在平局。 输出平局aha或者失败的名字。 解题思路：if判断就好吧。 Code：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;#define read(n) scanf("%d",&amp;n);#define readll(n) sacnf("%lld",&amp;n);const int maxn = 1e4 + 1e3;int main()&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(a == b &amp;&amp; b == c)&#123; printf("aha\n"); &#125; else if(a == b) &#123; printf("C\n"); &#125; else if(a == c) &#123; printf("B\n"); &#125; else if(b == c) &#123; printf("A\n"); &#125; return 0;&#125; D、GPA题目大意：输入7门成绩和对应的学分，给你平均绩点的计算方法，根据该方法进行计算即可。 解题思路：浮点运算，输出两位小数。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;#define read(n) scanf("%d",&amp;n);#define readll(n) sacnf("%lld",&amp;n);const int maxn = 1e4 + 1e3;int cost[100];int fen[100];double getfen(int x)&#123; double ret; if(x &gt;= 91)ret = 4.0; else if(x &gt;= 86)ret = 3.5; else if(x &gt;= 81)ret = 3.0; else if(x &gt;= 76)ret = 2.5; else if(x &gt;= 71)ret = 2.0; else if(x &gt;= 66)ret = 1.5; else if(x &gt;= 60)ret = 1.0; else ret = 0; return ret;&#125;int main()&#123; for(int i = 1;i &lt;= 7;i++) &#123; scanf("%d",&amp;cost[i]); &#125; int sum = 0; for(int i = 1;i &lt;= 7;i++) &#123; scanf("%d",&amp;fen[i]); sum += fen[i]; &#125; double ret = 0; for(int i = 1;i &lt;= 7;i++) &#123; ret += getfen(cost[i]) * 1.0 * fen[i]; &#125; ret = ret / (sum * 1.0); printf("%.2lf\n",ret); return 0;&#125; 刘陶然：E、F、G、HE、are you ok?题目大意：给你一个数据的数目大小 n ($2 &lt;= n &lt;= 100$)，然后给你两行数据，每行有n个，第一行每个数据是字符串（长度不超过10），第二行是对应字符串的个数，拿样例来说，代表apple这个字符串有0个，milk这个字符串有2个。 当所有的字符串的个数为0时就输出are you ok?，否者就出数目不为0 的字符串与其对应的数目。 解题思路：可以用两个数组分别保存字符串还有相应字符串对应的数字，先特判一下是否都为0，是就输出are you ok?否者就按顺序输出字符串的数目不为0的那些。 Code： F、折纸达人题目大意：先输入一个数代表有几组样例($1&lt;= t &lt;= 100$)，对于每组样例，第一行是有几个操作数($1&lt;=n&lt;=10^5$)（L,R,T,B L表示从左向右折……）一个字幕为一次操作，第二行就是给你说具体的操作了，第三行是询问，共四种询问LR, RL, TB, BT，LR表示从左向右剪,依次类推。（Left，Right ，Top ，Bottom）。 解题思路：​ 你可以先拿一张纸出来，你会发现往左与往右折是一回事，同样往上往下也是，就是左右对折一下或者上下对折一下。从左往右还有从右往左剪开也是一样的，同理上下减也一样。所以问题就是说：左右折几下，上下折几下，然后问你上下剪，或者左右剪开之后有几张纸。 ​ 可以再想一下，咱们先就针对上下剪的情况进行讨论一下： ​ 仅上下对折的情况：你会发现你上下对折无数次，剪开仅剩下两张纸。（其实想明白了上下对折对上下剪，没有任何影响,想不明白没关系，继续看）。 ​ 仅仅左右对折的情况：你会发现对折0次的时候剪开是$1+1$张，对折1次剪开是$2+1$张，对折3次剪开是$4+1$张，对折4次是$8+1$张，……（大家可以动手试一下）对折n次是$2^n + 1$张。 ​ 即上下对折也左右对折的情况：你会发现只要是你是上下剪开的和你上下对折多少次都没有关系（你可以试一下，你会发现你上下对折影响的其实就是，你还是折下看下把，试一下都明白了）。 ​ 所以总结规律当你上下剪的时候只需要看左右对折的次数，$剪开纸的数目==2^n + 1$ 张。 同理当你左右剪的时候，只需要看上下对折的次数，规律一样。 Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#define INF 0x3f3f3f3f//大家设置int类型最大值的时候可以设置为这个数，将近int类型最大数的一半，而且乘2还不会爆int//(这里好像用不到，习惯了，一般都会打上)using namespace std;typedef long long ll;int T;ll lr, tb;//这里用快速幂写了一下，算帮大家复习一下了。//其实for循环也可以过，因为n最大10^5，所以不会超时。//但是最好不要用c/c++自带的pow(a, b),他会损失精度，int类型的也会损失导致结果错误。ll power(ll a, ll b) &#123; ll ans = 1, base = a; while(b != 0)&#123; if(b&amp;1 != 0)&#123; ans = base * ans % 1000000007; &#125; base = base * base % 1000000007; b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; lr = 0; tb = 0; ll n; scanf("%lld", &amp;n); string c; cin&gt;&gt;c; for(int i = 0; i &lt; n; i++)&#123; //统计一下左右折 与 上下折的次数 if(c[i] == 'B' || c[i] == 'T') tb++; else lr++; &#125; string s; cin&gt;&gt;s; if(s == "TB" || s == "BT" )&#123; printf("%lld\n", ( power(2, lr) + 1 )% 1000000007 ); //结果输出之前记得再模一下，有可能加1正好等于1000000007，那就尴尬了。 &#125; else&#123; printf("%lld\n", ( power(2, tb) + 1 )% 1000000007 ); &#125; &#125; return 0;&#125; G、数数题目大意： 题意题目描述说的比较清楚了，这里就不在赘述了，简单说就是给你一个串，按照规则翻译成一个别的串，规则题目说的很清楚。 解题思路： 把这个串存起来，然后从头往后找，看有几个连续的，如果就它自己连续，那么输出1x，x就是对应的字符，如果连续n个为它就输出nx。 Code： H、神奇老虎机题目大意：先给你一个样例的个数，然后对于每一个样例，第一行轮子的个数n（$1&lt;=n &lt;=1000$），第二行为n个整数（$1 &lt;= 每个数大小 &lt;= 100$），他让你每组输入对应一行输出，输出字典序最小时老虎机滚轮上显示的数字 解题思路：​ 贪心，你让每个轮子的字典序都最小，那么整个字典序不就最小么？其实不是这样的，如果让每个轮子的字典序最小，那么又因为每个轮子上数据的范围都是大于等于1的，所以让所有的轮子都直接是1就可以了吗？​ 你会发现假设给你3个数：​ 2 20 9 这三个数对应是每个轮子上面最大的数，那么由这三个轮子组成的最小字典序是 1 1 1 吗？ 1 10 1 是不是比 1 1 1 这个字典序更小了，所以呢。除了最后一个轮子，前面的轮子，如果:​ 当$1 &lt;= a_i &lt;= 9$时，那么该轮子字典序应取1。​ 当$10 &lt;= a_i &lt;= 99$时 那么该轮子字典序应取10​ 当$a_i == 100​$时 那么该轮子字典序应取100​ 但是要注意最后一个轮子，由于它规定了(220的字典序比22的大，因为22是220的一个前缀)所以最后一个轮子一定要是1，才可以保证字典序最小。 举个栗子：样例输入： 162 9 11 59 100 63 那么其最小字典序应该对应为： 1 1 10 10 100 1 你可以试一下，不会有比这个更小的了，如果不理解可以找找看有没有比它更小的，找一下，你就理解了。 Code： 宋健：I、J、K、LI、五环题目大意：输入一个串，输出一个串； 解题思路：可以用if else 暴力来做，或者采用Map； map&lt;string,string&gt;_map; Code：123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;map&lt;string,string&gt;T;int main()&#123; T["Blue"]="Europe"; T["Europe"]="Blue"; //// T["Yellow"]="Asia"; T["Asia"]="Yellow"; //// T["Black"]="Africa"; T["Africa"]="Black"; //// T["Green"]="Oceania"; T["Oceania"]="Green"; //// T["Red"]="America"; T["America"]="Red"; string sh;cin&gt;&gt;sh; cout&lt;&lt;T[sh]&lt;&lt;endl;&#125; J、开挂的小洋题目大意：给你N个地鼠出现的时间，在一秒钟最多砸死两个地鼠。求在m时间内最多可以砸死多少只地鼠； 解题思路：可以定义一个vis数组记录第i秒内出现的地鼠的数量，ans记录最后的结果。 Code：1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define maxn (int)1e5+100int vis[maxn];int main()&#123; int n,m;cin&gt;&gt;n&gt;&gt;m; long long ans=0; for(int i=0;i&lt;n;i++) &#123; int x;scanf("%d",&amp;x); if(vis[x]&lt;2) &#123; vis[x]++; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; K、数字匹配题目大意：给你一个长度为n的a数组和长度为n的b数组，求两者匹配之后求和的最大和最小； 解题思路：先对两者进行排序，a最大的乘以b最大的为最大； maxx=sum(a[i]*b[i])，a,b都是从小到大排序，a最小的乘以b最大的为最小； Minn=sum(a[i]*b[i])，a从小到大排序，b从大到小排序。 下证： 强强联合，弱弱联合 负数的时候也符合此规律 可以参考白皮书P126页、 Code：123456789101112131415161718#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000+100int a[maxn];int b[maxn];int main()&#123; int n;cin&gt;&gt;n; for(int i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(int i=0;i&lt;n;i++)scanf("%d",&amp;b[i]); sort(a,a+n);sort(b,b+n); int ans1=0,ans2=0; for(int i=0;i&lt;n;i++)ans1+=a[i]*b[i]; for(int i=0;i&lt;n;i++)ans2+=a[i]*b[n-1-i]; printf("%d %d\n",ans1,ans2);&#125; L、寄蒜几盒题目大意：输入一个n;然后输入n段距离，表示第1个点与第2个点之间圆弧的长度、第2个点与第3个点之间圆弧的长度······第n个点与第1个点之间圆弧的长度。 解：转化问题求在n条线段，分成三段完全相等的线段。 解题思路一：参考白皮书P146。 开2倍的数组，能够实现以任意点为起点的一个环。 尺取：定义c为环的长度/3。 以1为起点开始尺取，取s为头，t为结尾后的第一个节点。 定义sum为第一段的长度，因为环的长度为3*c，若尺取的第一段长度等于c,这时特判从t（t为第一段之后的第一个节点）向后加一直到大于等于c，若有等于c的情况，说明第一段和第二段都满足c，此时可以输出yes； 若此时的第一段长度大于c，则sum减去s的长度，s++; 若s&gt;n，则表示以1到n的节点为头指针的每一段，都不满足情况，输出no; Code1：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;int a[(int)1e7+1000];int main()&#123; int n;scanf("%d",&amp;n); int sum=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); sum+=a[i]; a[n+i]=a[i]; &#125; if(sum%3!=0)puts("No"); else &#123; int c=sum/3; int s=1,t=1,sum=0; bool flg=0; while(1) &#123; while(sum&lt;c) sum+=a[t++]; if(sum==c) &#123; int temp=t; int ff=0; while(ff&lt;c)ff+=a[temp++]; if(ff==c) &#123; flg=1; break; &#125; &#125; sum-=a[s++]; if(s&gt;n) break; &#125; if(flg==1)puts("Yes"); else puts("No"); &#125;&#125; 解题思路二：n的数据范围为1e6 ，每个数据从(1，1000)相乘不会爆int，可以用set集合存数据，二分来取数据（三个点），看是否成立。 可以把环看出一条循环的线，从坐标0出发，第一个点的坐标为0+a[1],第二个坐标为0+a[1]+a[2]…… 因为是循环的一个环，所以要增加一倍的坐标放入set容器里，然后用set容器的find函数进行查找； 定义c为环长度的1/3； 从每一个点开始，例如d坐标 ,查找d+c ,d+2*c的坐标是否存在。 若存在，则输出yes,否则以下一个点为起点继续查找，一直找不到输出no; Code2： 某不愿透露姓名的帅哥：MM、签到题题目大意：略。 解题思路：略。 Mycode：略。 碎碎念：三位队员都给我发的word文档！！而且仅有一位主动附了代码。。Markdown这么好用为啥不用啊喂，好多公式还要手动调整(╯‵□′)╯︵┻━┻(没想到整理出来也用了1h+)。用word就用word吧，代码还以图片的形式放到里面…emmm…后面是不是该安利一波Markdown了。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>QLU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QLU ACM-ICPC大学生程序设计迎新赛-热身赛【解题报告】]]></title>
    <url>%2Fqlu-2018-1%2F</url>
    <content type="text"><![CDATA[前言：作为吃瓜群众围观两小时，见证了昌38s1A猜数题(太欧了吧)，中途lzw登顶，柳总封榜前7秒AK等精彩刺激的环节，感觉2小时也并不漫长。 赛后和大家一起讨论了下题目，感觉都是可做的，预备队员最低要求为4题(D和F可能费点事)，正式队员应该AK。 可能之前有没接触过猜答案的题目的，权当娱乐吧。 题解说明仅附代码，因为题面都是中文且思路都很明显。 题目序号 问题 A: 寻找欧皇123456789101112#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; printf("7\n"); return 0;&#125; 问题 B: 人类的本质1234567891011121314151617#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n;string s;int main()&#123; while(cin &gt;&gt; s &gt;&gt; n) &#123; while(n--) cout &lt;&lt; s &lt;&lt; '\n'; &#125; return 0;&#125; 问题 C: 数的价值1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;string s;long long res;int main()&#123; while(cin &gt;&gt; s) &#123; res = 1; for(int i = 0; i &lt; s.size(); ++i) if(s[i] != '0') res = res * (s[i] - '0'); if(s == "0") res = 0; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125; 问题 D: 方格填充1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, x, y;int res[7][7] =&#123; &#123;1, 1, 1, 2, 2, 2, 3&#125;, &#123;1, 2, 2, 2, 3, 4, 4&#125;, &#123;1, 2, 3, 4, 4, 5, 6&#125;, &#123;2, 2, 4, 4, 6, 6, 8&#125;, &#123;2, 3, 4, 6, 7, 8, 9&#125;, &#123;2, 4, 5, 6, 8, 10, 11&#125;, &#123;3, 4, 6, 8, 9, 11, 13&#125;,&#125;;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", res[x-1][y-1]); &#125; return 0;&#125; 问题 E: 买铅笔12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, num, price, res[3];int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; 3; ++i) &#123; scanf("%d%d", &amp;num, &amp;price); int need = n / num + ((n % num) ? 1 : 0); res[i] = need * price; &#125; res[0] = min(res[0], res[1]); res[0] = min(res[0], res[2]); printf("%d\n", res[0]); return 0;&#125; 问题 F: 图书管理员12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1010;int n, t, x, q, a[N];int len[] = &#123;0,10,100,1000,10000,100000,1000000,10000000&#125;;int main()&#123; scanf("%d%d", &amp;n,&amp;q); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); sort(a, a + n); while(q--) &#123; bool flag = 0; scanf("%d%d", &amp;t, &amp;x); for(int i = 0; i &lt; n; ++i) &#123; if(a[i] % len[t] == x) &#123; flag = 1; printf("%d\n", a[i]); break; &#125; &#125; if(!flag) puts("-1"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>QLU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU ACM-ICPC 2018 Training Weekly Contest(Freshman/11-11)【解题报告】]]></title>
    <url>%2Fsdnu-2018-3%2F</url>
    <content type="text"><![CDATA[题目难度分析及考察内容：easy：1004(C语言)1001(快速幂模板，周五晚刚讲的)1005(简单字符串处理)1006(模拟 + 细节)medium：1002(规律||直接做&lt;数组开全局就能开的下了&gt;)1003(中等字符串处理)1008(结构体排序&lt;课上没讲吗?那就趁这个机会学一下&gt;)1007(题意理解)hard：1009(map + 题意)发现的问题： 乱加getchar()。(王某) 数组不开全局，导致RE。(孙某) 8102年了，不知道递推，求fibonacci数列还用递归(第二题没做出来的xxxxxxx) 不跟榜，在一个题上从开场WA到结束。 对罚时还没概念，这个慢慢培养吧，身处弱校 + 自身菜鸡很多时候都靠罚时蹭个牌。。 说明：这些题目一周内完全可以补完，下周一至周四尽量补完。 充分思考后再看思路，最后再看代码。AC过也最好看看，说不定就学到新知识了呢。 一定要保证最后能自己写出来并AC掉。 题解1349.快速幂入门快速幂模板题，签到 Code:无。 1356.Fibonacci题意：给出一个序列，序列的定义为 $\operatorname{F[i]}=\begin{cases}7 &amp; \text{i = 0 } \\text 11 &amp; \text{i = 1}\ F[n-1] + F[n-2] &amp; \text{i $\geq$ 2 } \\end{cases}$ 问F[n] % 3 是否等于 0 思路： 直接做(怎么还有人用递归？这种可以递推的别递归啊，看一下n的范围，递归这不明摆着过不了吗) 可以直接做的原因是 $(a + b) \% m = ((a \% m) + (b \% m)) \% m$。 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1000010;int f[N], n;void init()&#123; f[0] = 7, f[1] = 11; for(int i = 2; i &lt; N; ++i) f[i] = (f[i - 1] + f[i - 2]) % 3;&#125;int main()&#123; init(); while(~scanf("%d", &amp;n)) puts(f[n] ? "no" : "yes"); return 0;&#125; 找规律(写出几项来就发现了) 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;//int f[111];int main()&#123; /* f[0] = 7, f[1] = 11; for(int i = 2; i &lt;= 20; ++i) f[i] = f[i - 1] + f[i - 2]; for(int i = 0; i &lt;= 20; ++i) cout &lt;&lt; f[i] % 3 &lt;&lt; ' '; cout &lt;&lt; '\n'; */ int n; while(~scanf("%d", &amp;n)) puts((n - 2) % 4 ? "no" : "yes"); return 0;&#125; 1357.Text Reverse题意：将输入的每个字符进行翻转。 思路：直接做 代码：用string的reverse函数可以简单快速的实现 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int t;string a, s;int main()&#123; scanf("%d", &amp;t); getchar(); while(t--) &#123; getline(cin, s); //读取一行 stringstream ss(s); //创建一个“字符串流” bool flag = 0; //控制空格 while(ss &gt;&gt; a) &#123; if(flag) cout &lt;&lt; ' '; flag = 1; reverse(a.begin(), a.end()); cout &lt;&lt; a; &#125; cout &lt;&lt; '\n'; &#125; return 0;&#125; 1358.Buildings题意：记录只有0和1构成的$N \times M$的矩阵中有多少个1。 思路：直接做(疑问：用数组干啥啊？)。 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, m, tem, res;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; res = 0; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; n * m; ++i) &#123; scanf("%d", &amp;tem); res += tem; &#125; printf("%d\n", res); &#125; return 0;&#125; 1359.GPA题意：自己翻译。 思路：直接做。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;bool flag;int val[256];char s[1111];int cnt, len, sum;void init()&#123; memset(val, -1, sizeof(val)); val['A'] = 4; val['B'] = 3; val['C'] = 2; val['D'] = 1; val['F'] = 0;&#125;int main()&#123; init(); while(gets(s)) &#123; flag = 1; sum = cnt = 0; len = strlen(s); for(int i = 0; i &lt; len; ++i) &#123; if(s[i] == ' ') continue; if(val[s[i]] == -1) &#123; flag = 0; break; &#125; ++cnt; sum += val[s[i]]; &#125; if(!flag) puts("Unknown letter grade in input"); else printf("%.2f\n", (double)sum / cnt); &#125; return 0;&#125; 1361.Grasshopper And the String题意：找出一个字符串的两个相邻的元音字母(‘A’, ‘E’, ‘I’, ‘O’, ‘U’ and ‘Y’)的最大位置。 思路：直接做。记得初始位置和结束位置特判。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char s[111];bool judge(char ch)&#123; if(ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' || ch =='Y') return true; return false;&#125;int main()&#123; while(~scanf("%s", s)) &#123; int len = strlen(s); int res = 0, tmp = -1; for(int i = 0; i &lt; len; ++i) &#123; if(judge(s[i])) &#123; res = max(res, i - tmp); tmp = i; &#125; &#125; res = max(res, len - tmp); printf("%d\n", res); &#125; return 0;&#125; 1362.Parade题意：阅读理解题，这里不写了，自己细细品味。 思路：嗯。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 100010;int n, res, sum1, sum2, a[N], b[N];int t1, t2, best;int main()&#123; while(~scanf("%d", &amp;n)) &#123; sum1 = sum2 = 0; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d", &amp;a[i], &amp;b[i]); sum1 += a[i]; sum2 += b[i]; &#125; res = 0; best = abs(sum1 - sum2); for(int i = 1; i &lt;= n; ++i) &#123; t1 = sum1 - a[i] + b[i]; t2 = sum2 - b[i] + a[i]; if(abs(t1 - t2) &gt; best) &#123; best = abs(t1 - t2); res = i; &#125; &#125; printf("%d\n", res); &#125; return 0;&#125; 1363.Solving Order题意：嗯。 思路：结构体排序。 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, m;struct node&#123; int cnt; char color[11];&#125; a[11];bool cmp(node u, node v)&#123; return u.cnt &gt; v.cnt;&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%s%d", &amp;a[i].color, &amp;a[i].cnt); sort(a + 1, a + n + 1, cmp); for(int i = 1; i &lt;= n; ++i) printf("%s%c", a[i].color, i == n ? '\n' : ' '); &#125; return 0;&#125; 1533.寻找复读机题意：中文题面。 思路：map标记，直接找。 坑点： 1. 卡PE 2. `找出所有可能是复读机的群友`(我们只能确定出明确不是复读机的群友，剩下的不确定的都可能是)。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;const int N = 1111;string s[N];int n, m, a[N];map&lt;int, bool&gt; MP;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m) &#123; for(int i = 1; i &lt;= m; ++i) cin &gt;&gt; a[i] &gt;&gt; s[i]; for(int i = 1; i &lt;= n; ++i) MP[i] = 1; MP[a[1]] = 0; for(int i = 2; i &lt;= m; ++i) if(s[i] != s[i - 1]) MP[a[i]] = 0; bool flag = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(!MP[i]) continue; if(flag) cout &lt;&lt; ' '; flag = 1; cout &lt;&lt; i; &#125; cout &lt;&lt; '\n'; &#125; return 0;&#125; END： 每当在书中读及那些卑微的努力，都觉得感动且受震撼。也许每个人在发出属于自己的光芒之前，都经历了无数的煎熬，漫长的黑夜，无尽的孤独，甚至不断的嘲讽和否定，但好在那些踮脚的少年，最后都得到了自己想要的一切。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第八章习题】【7/28】]]></title>
    <url>%2Flrj-ch8-1%2F</url>
    <content type="text"><![CDATA[UVa 1149 Bin Packing【贪心】题目大意：给定$N$个物品的重量$L_i$，背包的容量$M$，同时要求每个背包最多装两个物品，求至少需要多少个背包才能装下所有物品。 解题思路：典型的贪心问题求解，排序后从两头取就可以了。 MyCode：1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e5+5;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int a[MAX];int t, n, m, tot;int main()&#123; cin &gt;&gt; t; while(t--) &#123; tot = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; sort(a, a+n); int l = 0, r = n-1; while(l &lt;= r) &#123; if(l == r) &#123;++tot; break;&#125; if(a[l] + a[r] &lt;= m) ++l; ++tot; --r; &#125; cout &lt;&lt; tot &lt;&lt; endl; if(t) puts(""); &#125; return 0;&#125; UVa 1610 Party Games【贪心】题目大意：给出$n$($n$为偶数)个字符串，要求你构造一个字符串，使得它的字典序恰好大于等于其中的一半，小于另一半，找到满足条件的长度最短的。 解题思路：题意简化一下就是排序后，找出中间那两个字符串，对它们进行操作就可以了。 因为要求尽量短，所以首先想到的是从前往后遍历，找到第一个字母不同的位置，若两者差距 &gt; $1$则可直接输出前 + $1$然后跳出。这个思路总体方向是正确的，但是是有漏洞的，比如此位置正好是小的那个字符串的最后一个位置？此位置正好是大的那个字符串的最后一个位置？处理完这两种情况后再考虑差距等于$1$的时候，这时直接输出小的字符串+$1$，同样的这时候也考虑当前位置是否为两字符串的末尾位置。 还有种思路是考虑两者的长度关系，设小的字符串为$u$，大的字符串为$v$。当u.size() &lt;= v.size()的时候从前往后找，找到第一个不同的位置，当此位置==u.size()时直接输出$u$，否则输出$u[i] + 1$。剩下的一种情况时，也需要从前往后找到第一个不同的位置，当此位置==v.size()且v[i] - u[i] == 1时继续向后遍历$u$，直到找到$u$的结尾或者u[j] != &#39;Z&#39;的位置，否则输出$u[i] + 1$。 MyCode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n;string s[MAX];string fr, en, ans;string solve(string a, string b)&#123; string res = ""; int en = a.size() - 1; int len = min(a.size(), b.size()); for(int i = 0; i &lt; len; ++i) &#123; if(a[i] == b[i]) res += a[i]; else &#123; if(i == en) res += a[i]; else if(i != b.size() - 1 || b[i] - a[i] &gt; 1) res += a[i]+1; else &#123; res += a[i]; for(int j = i+1; j &lt; a.size(); ++j) &#123; if(j == en) &#123; res += a[j]; break; &#125; if(a[j] != 'Z') &#123; res += a[j]+1; break; &#125; res += 'Z'; &#125; &#125; break; &#125; &#125; return res;&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n) &#123; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; s[i]; sort(s, s+n); fr = s[n/2-1]; en = s[n/2]; ans = solve(fr, en); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; UVa 12545 Bits Equalizer【贪心】题目大意：给出两个等长的字符串S和T，S包括0、1和?，T只包括0和1，要求你通过对S下列变换，经过尽量少的次数将S转换为T。 操作共有3种：1. 把0变为1。 2. 把?变为0或1。 3. 将任意两个字符交换位置。 解题思路： 先看变不成的情况：$1_s &gt; 1_t$，因为$1$是无法改变的。 其余情况看如何变化使得操作数最小：由变换规则知，先把匹配位置的? -&gt; 1再把0 -&gt; 1是最优的。之后再把?变为0，不匹配的位置统计一下进行交换就好了。 MyCode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;string s, t;int _, res, now;int main()&#123; scanf("%d",&amp;_); for(int cas = 1; cas &lt;= _; ++cas) &#123; res = 0; cin &gt;&gt; s &gt;&gt; t; for(int i = 0; i &lt; s.size(); ++i) if(s[i] == t[i]) s[i] = t[i] = '*';// cout &lt;&lt; s &lt;&lt; endl &lt;&lt; t &lt;&lt; endl; int ones = 0, onet = 0; for(int i = 0; i &lt; s.size(); ++i) &#123; if(s[i] == '1') ++ones; if(t[i] == '1') ++onet; &#125; bool flag = ones &gt; onet; //s中的1比t中的1多 if(flag) res = -1; else &#123; int o = onet - ones; res += o;// cout &lt;&lt; o &lt;&lt; endl; now = 0; //优先让? -&gt; 1 for(int i = 0; i &lt; s.size(); ++i) &#123; if(now == o) break; if(t[i] == '1' &amp;&amp; s[i] == '?') &#123; s[i] = t[i] = '*'; ++now; &#125; &#125; //再考虑让 0 -&gt; 1 for(int i = 0; i &lt; s.size(); ++i) &#123; if(now == o) break; if(t[i] == '1') &#123; s[i] = t[i] = '*'; ++now; &#125; &#125;// cout &lt;&lt; s &lt;&lt; endl &lt;&lt; t &lt;&lt;endl; for(int i = 0; i &lt; s.size(); ++i) &#123; if(s[i] == '?') &#123; s[i] = '0'; ++res; &#125; &#125; now = 0; for(int i = 0; i &lt; s.size(); ++i) if(s[i] != t[i]) ++now;// cout &lt;&lt; s &lt;&lt; endl &lt;&lt; t &lt;&lt;endl;// cout &lt;&lt; "now=" &lt;&lt; now &lt;&lt; endl; res += now / 2; &#125; printf("Case %d: %d\n", cas, res); &#125; return 0;&#125; UVa 11491 Erasing and Winning【贪心】题目大意：给出一个$n$位整数，要求从中删除$d$位后得到的数的值尽量大。 解题思路：每次删的时候都看一下删掉此位置的数后是否使得整体变大了，如果变大了就删了继续看，否则就往后找。当整个序列都是降序时就把最后几位删了。 MyCode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, d;string s;void solve()&#123; int now = 0; while(s.size() &gt; n) &#123; bool f = 1; for(int i = now; i &lt; s.size(); ++i) &#123; if(s[i] &lt; s[i + 1]) &#123; s.erase(s.begin() + i); now = i - 1 &gt; 0 ? i - 1 : 0; f = 0; break; &#125; &#125; if(f) &#123; s.erase(n, s.size() - n); break; &#125; &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; d &amp;&amp; (n + d)) &#123; cin &gt;&gt; s; n -= d; solve(); cout &lt;&lt; s &lt;&lt; '\n'; &#125; return 0;&#125; UVa 177 Paper Folding【模拟】【规律】【未完成】题目大意：将一张纸从右向左进行对折$n$次，每次都打开“一半”，即把每个痕迹做成一个直角，输出打开后的图案。 解题思路：写出前几种情况后观察发现，每次对折展开后比上次对了恰好一倍的线段数。而且多的那部分前一半刚好与原有的一半相反，后一半与原有的一半相同。然后根据这个规律可将所有的步数计算出来，然后选个中心按照步骤模拟就好了。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char stp[1&lt;&lt;13 + 5]; /// 1 ~ 2^13 为每步走的位置char mapa[1&lt;&lt;13][1&lt;&lt;13];char opp(char ch)&#123; if(ch == 'r') return 'l'; if(ch == 'l') return 'r'; if(ch == 'u') return 'd'; if(ch == 'd') return 'u';&#125;void init()&#123; int idx = 3; stp[1] = 'r'; stp[2] = 'u'; for(int i = 1; i &lt; 13; ++i) &#123; ///要增加的位数 int tot = 1 &lt;&lt; i; ///改变的位数 for(int j = 1; j &lt;= tot / 2; ++j) &#123; stp[idx] = opp(stp[idx - tot]); ++idx; &#125; ///不变的位数 for(int j = 1; j &lt;= tot / 2; ++j) &#123; stp[idx] = stp[idx - tot]; ++idx; &#125; &#125; /* cout &lt;&lt; idx &lt;&lt; ' ' &lt;&lt; (1 &lt;&lt; 13) &lt;&lt; '\n'; for(int i = 1; i &lt;= 16; ++i) cout &lt;&lt; stp[i]; cout &lt;&lt; '\n'; */&#125;void draw()&#123;&#125;int n;void pint()&#123;&#125;int main()&#123; init(); draw(); while(scanf("%d", &amp;n) &amp;&amp; n) pint(); return 0;&#125; UVa 1611 Crane【构造】【贪心】题目大意：输入一个$1$ ~ $n$的排列，用不超过$9^6$次操作把它变成升序。每次操作可以选择一个长度为偶数的连续区间，将它的前一半和后一半进行交换。 解题思路：看到提示说只要$2n$次操作就够了，也就是说每个元素最多交换两次就可以到达它应到的位置。 具体操作是从一个方向开始，对于每一个位置找此位置的元素所在位置并将其交换过来，交换过来后就不用考虑这个位置了，继续往后看。这是还面临一个问题，就是区间长度为奇数时，这时需要多一次交换操作，将其交换到偶数位置处。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int a[MAX], b[MAX&lt;&lt;1], c[MAX&lt;&lt;1];int t, n, idx, res, now, tem, tot;void mmove(int st, int en) //起点和终点&#123; int mid = (st + en + 1) / 2; int i, j; for(i = st, j = mid; j &lt;= en; ++i, ++j) swap(a[i], a[j]); b[tot] = st; c[tot] = en; ++tot;&#125;void movee(int st1, int st2) //起点和起点&#123; int i, j; for(i = st1, j = st2; i &lt; st2; ++i, ++j) swap(a[i], a[j]); int mid = st2 - st1 - 1; b[tot] = st1; c[tot] = st2 + mid; ++tot;&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; tot = 0; scanf("%d",&amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d",&amp;a[i]); for(int i = 1; i &lt;= n; ++i) &#123; while(a[i] != i) &#123; for(int j = i+1; ; ++j) if(a[j] == i) &#123;idx = j; break;&#125; if(idx - i &gt; n - idx &amp;&amp; idx - i != 1) &#123; if((idx - i) &amp; 1) mmove(i, idx); else mmove(i+1, idx); movee(i, i + (idx-i)/2); &#125; else movee(i, idx); &#125; &#125; printf("%d\n", tot); for(int i = 0; i &lt; tot; ++i) printf("%d %d\n", b[i], c[i]); &#125; return 0;&#125; UVa 11925 Generating Permutations【】题目大意：给出一个$1$ ~ $n$的排列，用不到$2n^2$次操作把它$1$ ~ $n$的排列变为给出的排列。操作只有两种：交换前两个元素(操作1)；把第一个元素移动到最后(操作2)。 解题思路：这题直接做不太好想，可以反着看，即将给的排列通过若干次操作转化为$1$ ~ $n$的排列。这样答案就是转换后的次序的逆转。 MyCode：12 UVa 1612 【】题目大意：解题思路：MyCode：12 UVa 1613 【】题目大意：解题思路：MyCode：12 UVa 1614 Hell on the Markets【结论】【贪心】题目大意：输入一个长度为$n$的序列$a$，满足$1$ ≤ $a_i$ ≤ $i$，要求确定每个数的正负号，使得所有的数的总和为$0$。 解题思路：结论：序列中的$a_i$满足$1 \leq a_i \leq i$，所以$1$ ~ $sum[i]$中的每个数都可用序列中的若干个数的和表示。 做法：将所有数从大到小排序，然后挨个取，同时记录当前取的数的和，当和$\leq 0$时就加上此位置的数，否则则减去。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 100010;int n, sum;bool res[N];struct node&#123; int val, idx;&#125; a[N];bool cmp(node u, node v)&#123; return u.val &gt; v.val;&#125;int main()&#123; while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; ++i) &#123; a[i].idx = i; scanf("%d", &amp;a[i].val); &#125; sort(a + 1, a + 1 + n, cmp); sum = a[1].val; res[a[1].idx] = 0; for(int i = 2; i &lt;= n; ++i) &#123; if(sum &gt; 0) &#123; sum -= a[i].val; res[a[i].idx] = 1; &#125; else &#123; sum += a[i].val; res[a[i].idx] = 0; &#125; &#125; if(sum == 0) &#123; puts("Yes"); for(int i = 1; i &lt;= n; ++i) printf("%d%c", res[i] ? -1 : 1, i == n ? '\n': ' '); &#125; else puts("No"); &#125; return 0;&#125; UVa 1615【】题目大意：解题思路：MyCode：12 UVa 1153 Keep the Customer Satisfied【贪心】【优先队列】题目大意：给出$n$个工作的需要时间和截止时间，问串行完成工作时最多能完成多少工作。 解题思路：先按照截止日期从小到大排序，再按照需要时间从小到大排序，这样从前往后遍历，如果在规定时间内可以完成此任务，则将其存起来，否则和之前存的任务相比，如果之前的任务存在花费时间大于此任务的话，则删掉那个任务并替换为这个任务。不断进行此过程可以保证解是最优的。 MyCode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 800000+5;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t, n;struct node&#123; int ned, date;&#125;a[MAX];bool cmp(node u, node v)&#123; return u.date == v.date ? u.ned &lt; v.ned : u.date &lt; v.date;&#125;int main()&#123; cin &gt;&gt; t; for(int cas = 0; cas &lt; t; ++cas) &#123; if(cas) puts(""); cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i].ned &gt;&gt; a[i].date; sort(a, a+n, cmp); int t = 0; priority_queue &lt;int&gt; Q; //大的在前 for(int i = 0; i &lt; n; ++i) &#123; if(t + a[i].ned &lt;= a[i].date) &#123; t += a[i].ned; Q.push(a[i].ned); &#125; else if(Q.size()) &#123; if((a[i].ned &lt; Q.top()) &amp;&amp; (t + a[i].ned - Q.top() &lt;= a[i].date)) &#123; t -= Q.top(); Q.pop(); t += a[i].ned; Q.push(a[i].ned); &#125; &#125; &#125; cout &lt;&lt; Q.size() &lt;&lt; endl; &#125; return 0;&#125; UVa 10570 Meeting with Aliens【】题目大意：给出$1$ ~ $n$的一个环状排列，每次可以交换两个整数，用最少的次数将排列变成$1$ ~ $n$。输出最小次数。 解题思路：MyCode：12 UVa 1616【】题目大意：解题思路：MyCode：12 UVa 【】题目大意：解题思路：MyCode：12 UVa 【】题目大意：解题思路：MyCode：12 UVa 【】题目大意：解题思路：MyCode：12 UVa 1619 Feel Good【单调栈】题目大意：给出一个长为$n$的正整数序列，求出一段连续子序列$a_l, \dots, a_r$，使得$(a_l + \dots + a_r)$ $\times$ $min{a_l, \dots, a_r}$最大。 解题思路：拓展：存在负数情况时：https://nanti.jisuanke.com/t/38228 MyCode：12 UVa 1312 Cricket Field【】题目大意：在一个$W$ * $H(1 \leq W,H \leq 10000)$的网格里有$n(0 \leq n \leq 100)$棵树，要求找一个最大的空正方形。 解题思路：MyCode：12 UVa 【】题目大意：解题思路：MyCode：12 UVa 【】题目大意：解题思路：MyCode：12 UVa 【】题目大意：解题思路：MyCode：12 UVa 【】题目大意：解题思路：MyCode：12 UVa 【】题目大意：解题思路：MyCode：12 UVa 【】题目大意：解题思路：MyCode：12 UVa 【】题目大意：解题思路：MyCode：12 UVa 【】题目大意：解题思路：MyCode：12 UVa 【】题目大意：解题思路：MyCode：12]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第八章例题】【10/19】]]></title>
    <url>%2Flrj-ch8-0%2F</url>
    <content type="text"><![CDATA[UVa 120 Stacks of Flapjacks【构造】题目大意：一叠煎饼等待翻转，每个煎饼上有一个编号代表其大小，每次翻转是选择一个数$k$，将从锅底数第$k$张上面的煎饼全部翻过来，即原来的煎饼现在到了下面。请设计一种方法使得所有煎饼按照从小到大的顺序排列，即最上边的最小。 解题思路：每次查找不满足要求的位置，将它翻转到顶端后再翻转到自己应该在的位置。为了满足无后效性，我们每次都找最大的元素。 MyCode：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e6+7;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;string s;int tot, a[35];void filp(int t)&#123; int i, j; for(i = 1, j = t; i &lt;= j; ++i, --j) &#123; swap(a[i], a[j]); &#125; cout &lt;&lt; tot - t &lt;&lt; " ";&#125;int main()&#123; while(getline(cin, s)) &#123; tot = 1; cout &lt;&lt; s &lt;&lt; endl; stringstream ss(s); while(ss &gt;&gt; a[tot]) &#123; ++tot; &#125; for(int i = tot-1; i &gt;= 1; --i) &#123; int t = max_element(a + 1, a + i + 1) - a; if(t == i) continue; if(t &gt; 1) filp(t); //将它翻到顶端 filp(i); //翻到该在位置 &#125; cout &lt;&lt; 0 &lt;&lt; endl; &#125; return 0;&#125; UVa 1605 Building for UN【构造】题目大意：设计一个包含若干层的大楼，每层都是一个等大的网格，要求给每个格子分配一个字母，使得任意两个不同的字母都有一对相邻的格子。要求设计的大楼不超过$1000000$个格子。 解题思路：因为层数、行数、列数都可以自己选，那我可以直接选择两层，每层都是$n \times n$的，第一层的第$i$行全是国家$i$，第二层的第$j$列全是国家$j$。 MyCode：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e6+7;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n;void country(int i)&#123; if(i &lt;= 26) cout &lt;&lt; char('A' + i - 1); else cout &lt;&lt; char('a' + i - 26 - 1);&#125;int main()&#123; while(cin &gt;&gt; n) &#123; printf("2 %d %d\n", n, n); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; country(i); &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; country(j); &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; UVa 1152 4 Values whose Sum is 0【二分】题目大意：给定$4$个$n$元素的集合$A$、$B$、$C$、$D$，要求分别从里面选出一个元素$a$、$b$、$c$、$d$，使得$a + b + c + d = 0$，问有多少种选法。 解题思路：将$A$、$B$合并，$C$、$D$合并，分别排序然后对其中一个数组的元素进行遍历$x_i$，从另一个数组中找是否存在$y = -x_i$就可以了。 MyCode：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 4005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int a[MAX], b[MAX], c[MAX], d[MAX];int A[MAX * MAX], B[MAX * MAX];int main()&#123; int t, n, tot; scanf("%d", &amp; t); while(t--) &#123; tot = 0; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d%d%d%d",&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) &#123; A[i*n + j] = a[i] + b[j]; B[i*n + j] = c[i] + d[j]; &#125; sort(A, A + n*n); sort(B, B + n*n); int tt = n*n - 1; for(int i = 0; i &lt; n*n; ++i) &#123; while(A[i] + B[tt] &gt; 0 &amp;&amp; tt &gt;= 0) --tt; if(tt &lt; 0) break; int tem = tt; while(A[i] + B[tem] == 0 &amp;&amp; tem &gt;= 0) &#123; ++tot; --tem; &#125; &#125; printf("%d\n", tot); if(t) puts(""); &#125; return 0;&#125; UVa 11134 Fabled Rooks【问题分解】【贪心】题目大意：在一个$n \times n$的棋盘上放置$n$枚棋子，使得任意两者之间既不同行也不同列，并且每个棋子都在规定的范围$(xl_i, yl_i) - (xr_i, yr_i)$内。 解题思路：互相攻击的条件为在同一行或者同一列，则不互相攻击的情况就是既不在同一行也不在同一列，又因为行和列是无关的，那我们就可以把这个问题分解为两个一维的问题来解决了。 对于$x$坐标来说，我们要做的就是在将$n$个点分配完毕后，每个区间都至少包含一个点。而分配是采用贪心的策略——即对所有可分配的区间找到右边界最小的区间进行分配。$y$坐标同理。 MyCode(参考LRJ’s code)：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5010;int n, xl[N], yl[N], xr[N], yr[N], x[N], y[N];bool solve(int *l, int *r, int *res)&#123; fill(res, res + n, -1); for(int col = 1; col &lt;= n; ++col) &#123; int idx = -1, minr = n + 1; for(int i = 0; i &lt; n; ++i) if(res[i] &lt; 0 &amp;&amp; r[i] &lt; minr &amp;&amp; col &gt;= l[i]) &#123; idx = i; minr = r[i]; &#125; if(idx &lt; 0 || col &gt; minr) return false; res[idx] = col; &#125; return true;&#125;int main()&#123; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; for(int i = 0; i &lt; n; ++i) scanf("%d%d%d%d", &amp;xl[i], &amp;yl[i], &amp;xr[i], &amp;yr[i]); if(solve(xl, xr, x) &amp;&amp; solve(yl, yr, y)) for(int i = 0; i &lt; n; ++i) printf("%d %d\n", x[i], y[i]); else puts("IMPOSSIBLE"); &#125; return 0;&#125; UVa 11054 Wine trading in Gergovia【等价转换】题目大意：直线上有$n$个村庄，每个村庄要么买酒要么卖酒，设第$i$个村庄的需求为$a_i$，$\sum_{i = 1}^{i = n} a_i = 0$。 把$k$个单位的酒从村庄运到相邻村庄需要$k$个单位的劳动力，计算最少需要多少劳动力可以满足所有村庄的需求。 解题思路：因为最终供需平衡，所以不管你这个酒是从哪来的最终一定会全部抵消。为了使花费的劳动力最小，就是不得不运的时候才运。我们直接从最左边的村庄开始向右边遍历，如果可以卖那就卖掉，无法卖掉就带着继续走。当买的时候也一样，当前需要再买多少先记着，等碰到可以买的村庄时再一块买了，花费的劳动力等同于从这里的酒卖到目的村庄。 感想：这个等价转换的思想让我想起了有道蚂蚁的题目，两者碰到后掉头，可以转化为直接穿了过去。 MyCode：1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;LL ans;int t, tem, last;int main()&#123; while(cin &gt;&gt; t &amp;&amp; t)&#123; ans = 0; last = 0; for(int i = 0; i &lt; t; ++i)&#123; cin &gt;&gt; tem; ans += abs(last); last += tem; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; UVa 1606 Amphiphilic Carbon Molecules【极角排序+扫描】【贪心】题目大意：平面上有$n$个点，每个点不是黑的就是白的，现在要放一个隔板，把它们分成两部分，使得一侧的白点数加上另一侧的黑点数最多。隔板上的点可以看做任意一侧。 解题思路：首先假设直线经过两个点，否则可以移动直线使其经过两个点，并且总数不会减少。 最简单的想法就是枚举两个点，然后输出两侧的黑白点的个数。 跟进一步的做法是先找一个基准点，让隔板绕该点旋转。每当隔板扫过一个点就动态修改两侧的点数。在此之前，需对所有点相对于基准点（即将基准点看做(0,0))进行极角排序。 小技巧：如果将所有的黑点以基点为中心做一个中心对称，则符合要求的点的个数就变成了直线一侧的点的个数。 LRJ’s Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// UVa1606 Amphiphilic Carbon Molecules// Rujia Liu// To make life a bit easier, we change each color 1 point into color 0.// Then we only need to find an angle interval with most points. See code for details.#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1000 + 5;struct Point&#123; int x, y; double rad; // with respect to current point bool operator&lt;(const Point &amp;rhs) const &#123; return rad &lt; rhs.rad; &#125;&#125; op[maxn], p[maxn];int n, color[maxn];// from O-A to O-B, is it a left turn?bool Left(Point A, Point B)&#123; return A.x * B.y - A.y * B.x &gt;= 0;&#125;int solve()&#123; if(n &lt;= 2) return 2; int ans = 0; // pivot point for(int i = 0; i &lt; n; i++) &#123; int k = 0; // the list of other point, sorted in increasing order of rad for(int j = 0; j &lt; n; j++) if(j != i) &#123; p[k].x = op[j].x - op[i].x; p[k].y = op[j].y - op[i].y; if(color[j]) &#123; p[k].x = -p[k].x; p[k].y = -p[k].y; &#125; p[k].rad = atan2(p[k].y, p[k].x); k++; &#125; sort(p, p+k); // sweeping. cnt is the number of points whose rad is between p[L] and p[R] int L = 0, R = 0, cnt = 2; while(L &lt; k) &#123; if(R == L) &#123; R = (R+1)%k; // empty interval cnt++; &#125; while(R != L &amp;&amp; Left(p[L], p[R])) &#123; R = (R+1)%k; // stop when [L,R] spans across &gt; 180 degrees cnt++; &#125; cnt--; L++; ans = max(ans, cnt); &#125; &#125; return ans;&#125;int main()&#123; while(scanf("%d", &amp;n) == 1 &amp;&amp; n) &#123; for(int i = 0; i &lt; n; i++) scanf("%d%d%d", &amp;op[i].x, &amp;op[i].y, &amp;color[i]); printf("%d\n", solve()); &#125; return 0;&#125; UVa 11572 Unique Snowflakes【滑动窗口】题目大意：输入一个长度为$n$的序列，找一个尽量长的连续子序列，使得该序列中没有相同的元素。 解题思路：对元素下标进行存储，向前延伸的过程中更新答案。 MyCode：123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e6+5;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t, n, ans, l, r;int a[MAX];int main()&#123; cin &gt;&gt; t; while(t--) &#123; ans = -1; l = r = 1; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; map&lt;int, int&gt; idx; idx[a[1]] = 1; for(int i = 2; i &lt;= n; ++i) &#123; if(idx.count(a[i])) &#123; ans = max(ans, r - l); l = max(l, idx[a[i]] + 1); &#125; r = i; idx[a[i]] = i; &#125; ans = max(ans, r-l); cout &lt;&lt; ans + 1 &lt;&lt; endl; &#125; return 0;&#125; UVa 1471 Defense Lines【】题目大意：解题思路：MyCode：12 UVa 1451题目大意：解题思路：MyCode：12 UVa 714 Copying Books【二分】【最小化最大值】题目大意：将包含$m$个整数的序列划分为$k$段，使得每段的数的和最小。 解题思路：将最优化问题转化为判定性问题，求出最小的区间和之后，按照格式输出。 要求的格式比较恶心，如果有多解要求前面的区间和尽量小。 MyCode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int N = 555;bool ok[N];int t, n, k, a[N];bool judge(ll m)&#123; ll tem = 0; int tot =1; for(int i = 1; i &lt;= n; ++i) &#123; tem += a[i]; if(tem &gt; m) &#123; ++tot; tem = a[i]; &#125; &#125; return tot &lt;= k;&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;n,&amp;k); ll tot = 0; int maxx = 0; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;a[i]); tot += a[i]; maxx = max(maxx, a[i]); &#125; ll l = maxx, r = tot, res = maxx, m; while(l &lt;= r) &#123; m = (l + r) / 2; if(judge(m)) &#123; r = m - 1; res = m; &#125; else l = m + 1; &#125; ll tem = 0; int remain = k; memset(ok, 0, sizeof(ok)); for(int i = n; i &gt;= 1; --i) &#123; if(tem + a[i] &gt; res || remain &gt; i) &#123; tem = a[i]; ok[i] = 1; remain--; &#125; else tem += a[i]; &#125; for(int i = 1; i &lt;= n; ++i) &#123; printf("%d%c", a[i], i == n ? '\n' : ' '); if(ok[i]) printf("/ "); &#125; &#125; return 0;&#125; UVa 10954 Add All【贪心】【Huffman编码】题目大意：给定一个包含$n$个数的集合，每次从中删除两个数并将其和放回集合，直到剩下一个数。每次的代价为两个数的和，求最小代价。 解题思路：这就是Huffman编码的建立过程，数据范围较小，利用priority_queue可轻松解决。 MyCode：123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, t, ans;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; t; q.push(t); &#125; ans = 0; for(int i = 0; i &lt; n-1; ++i) &#123; int x = q.top(); q.pop(); int y = q.top(); q.pop(); ans += x+y; q.push(x+y); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; UVa 12627 Erratic Expansion【】题目大意：有一个红气球，每小时后会变成三个红气球 + 一个蓝气球，一个蓝气球每小时会变成4个蓝气球，分布情况如题中图片所示。 问经过$k$小时后，第$a$ ~ $b$行有多少个红气球。 解题思路：MyCode：12 UVa 11093 Just Finish it up【枚举】题目大意：环形跑道上有$n$个加油站，第$i$个加油站可以加$p_i$单位的汽油，从第i个到下一个加油站需要消耗$q_i$单位的汽油。油桶初始为空，假设油桶无限大，问你能否选择一个加油站作为起始位置，使得汽车可以走完一圈回到起始位置。 解题思路：枚举起始位置就可以。如果当前枚举的位置到达某一个点$x$时汽油不够无法继续前行，则他之前的位置都不可以作为起始位置。根据这个我们可以在$O(n)$时间内解决问题。 PS:懒得通过取余之类的操作特判环形之类的，就直接将数组扩大了一倍，再存一遍。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 200005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;bool flag;int t, n, res;int a[MAX], b[MAX];int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d",&amp;n); flag = false; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;a[i]); a[i+n] = a[i]; &#125; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;b[i]); b[i+n] = b[i]; &#125; int i, j, idx; int now; for(i = 0; i &lt; n; i += idx) //start point &#123; idx = 1; now = 0; for(j = i; j &lt; i+n; ++j) &#123; now += a[j]; now -= b[j]; if(now &lt; 0) break; ++idx; &#125; if(j == i+n) &#123; res = i; break; &#125; &#125; if(i &gt;= n) flag = true; if(flag) printf("Case %d: Not possible\n", cas); else printf("Case %d: Possible from station %d\n", cas, res+1); &#125; return 0;&#125; UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>构造</tag>
        <tag>二分</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5527 Too Rich【思维】【贪心】]]></title>
    <url>%2Fhdu-5527%2F</url>
    <content type="text"><![CDATA[题目大意：给你面值为1，5，10，20，50，100，200，500，1000，2000的钞票$c_1、c_2 \ldots c_{10}$，问你给出的这些钱能否恰好凑出p元来，如果可以，最多的数量是多少。 解题思路：用给出的钱从大到小比较和p的关系凑很容易检查能否凑出p元来，这时是用的最少的数量凑的。 用最多的数量的话就是用tot - (最少的钱数凑的sum - p的数量)，tot是总数量，sum是总面值和。本来以为到这里就结束了，然而满足上面这是最少使用量的前提是小面额是大面额的因子，即任意数量的大面额总能用若干小面额凑出来，而在本题中20、50，200、500不满足。对于这种情况的解法，我们可以将两个50的合成一个100的，两个500的合成一个1000的来算，但是答案可能还有用到1个50/500的情况。好在他们的搭配只有4种，这时我们只要枚举这4种情况就好了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;int t, p, tot, sum;int a[11], b[11], val[11];void init()&#123; val[0] = 1, val[1] = 5, val[2] = 10; val[3] = 20, val[4] = 50, val[5] = 100; val[6] = 200, val[7] = 500, val[8] = 1000; val[9] = 2000;&#125;void init2()&#123; for(int i = 0; i &lt; 10; ++i) b[i] = a[i];&#125;int solve(int num)&#123; int ans = 0, tem; for(int i = 9; i &gt;= 0; --i) &#123; if(i == 4 || i == 7) &#123; tem = min(num / (val[i] * 2), b[i] / 2); num -= tem * val[i] * 2; ans += tem * 2; &#125; else &#123; tem = min(num / val[i], b[i]); num -= tem * val[i]; ans += tem; &#125;// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; tem &lt;&lt; endl; &#125; //cout &lt;&lt; "ans = " &lt;&lt; ans &lt;&lt; '\n'; if(num) return INF; return ans;&#125;int main()&#123; init(); scanf("%d", &amp;t); while(t--) &#123; tot = sum = 0; scanf("%d", &amp;p); for(int i = 0; i &lt; 10; ++i) &#123; scanf("%d", &amp;a[i]); tot += a[i]; sum += a[i] * val[i]; &#125; //cout &lt;&lt; "tot = " &lt;&lt; tot &lt;&lt; " sum = " &lt;&lt; sum &lt;&lt; '\n'; if(sum &lt; p) &#123; puts("-1"); continue; &#125; //凑组成p最多的，就是sum - p最少的，tot - res就是答案 p = sum - p; int res = INF; for(int i = 0; i &lt; 2; ++i) &#123; for(int j = 0; j &lt; 2; ++j) &#123; init2(); int tem = p; if(i &amp;&amp; b[4]) &#123; --b[4]; tem -= 50; &#125; if(j &amp;&amp; b[7]) &#123; --b[7]; tem -= 500; &#125; if(tem &lt; 0) continue;// cout &lt;&lt; "res = " &lt;&lt; res &lt;&lt; endl; res = min(res, solve(tem) + i + j); &#125; &#125; printf("%d\n", (res == INF ? -1 : tot - res)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>HDU</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6435 Problem J.CSGO【思维】【二进制枚举】]]></title>
    <url>%2Fhdu-6435%2F</url>
    <content type="text"><![CDATA[题目大意：现在有n把主武器和m把副武器，每个武器除了有1个固定属性外，还有k个能互相影响的属性，具体体现在当你选择两把武器时，固定属性带给你的加成是两者的固定属性值之和，而这k个属性带给你的加成是两武器的对应各属性差的绝对值之和。 现在要你选择一把主武器和一把副武器，使得两武器配合带来的加成最大。 解题思路：考虑到n和m的范围最大值都是100000，所以直接看搭配方案是不可行的，而属性k最大只有5，我们可以从这里入手。两武器搭配，对应的k个属性要么是加上带来的加成，要么是减去带来的加成，所以我们可以把每一把武器的每一种状态都枚举出来，就是$2^k$种加减组合，枚举的同时更新此状态下的最大值，对于最后的答案就是将主武器的这个集合和副武器的补集求和。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;int t, n, m, k, up;ll v, a[6], MW[44], SW[44];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); up = 1 &lt;&lt; k; memset(MW, -INF, sizeof(MW)); memset(SW, -INF, sizeof(SW)); for(int o = 0; o &lt; n; ++o) &#123; scanf("%lld", &amp;v); for(int i = 0; i &lt; k; ++i) scanf("%lld", &amp;a[i]); for(int i = 0; i &lt; up; ++i) &#123; ll tem = v; for(int j = 0; j &lt; k; ++j) &#123; if(i &amp; (1 &lt;&lt; j)) tem += a[j]; else tem -= a[j]; &#125; MW[i] = max(MW[i], tem); &#125; &#125; /*for(int o = 0; o &lt; up; ++o) cout &lt;&lt; MW[o] &lt;&lt; " "; cout &lt;&lt; '\n';*/ for(int o = 0; o &lt; m; ++o) &#123; scanf("%lld", &amp;v); for(int i = 0; i &lt; k; ++i) scanf("%lld", &amp;a[i]); for(int i = 0; i &lt; up; ++i) &#123; ll tem = v; for(int j = 0; j &lt; k; ++j) &#123; if(i &amp; (1 &lt;&lt; j)) tem += a[j]; else tem -= a[j]; &#125; SW[i] = max(SW[i], tem); &#125; &#125; /*for(int o = 0; o &lt; up; ++o) cout &lt;&lt; SW[o] &lt;&lt; " "; cout &lt;&lt; '\n';*/ ll res = -INF; for(int o = 0; o &lt; up; ++o) res = max(res, MW[o] + SW[up - o - 1]); printf("%lld\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>HDU</tag>
        <tag>多校联合</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6266 Hakase and Nano【规律】]]></title>
    <url>%2Fhdu-6266%2F</url>
    <content type="text"><![CDATA[题目大意：H和N玩取石子游戏，给出n堆石子，每堆$a_i$个，H每回合取两次，N每回合取一次，每次都只能从某一堆石子中取出至少一个石子，取走最后一个(堆)石子的获得胜利。 规定先后手，两者都采取最佳策略，问最后H能否获胜。 解题思路：H先手时，经过手算(?)我们发现当n % 3 == 0 &amp;&amp; n个石子全为1的时候先手必输。所以当H后手的时候，只要先手通过一步操作使当前局面变成上述局面H就输了。 这样只需要记录一下所给石子中不为0的石子堆的数目，根据这个输出答案就可以了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, k, a, o;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d",&amp;n,&amp;k); o = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;a); o += (a &gt; 1); &#125; if(k == 1) &#123; if(n % 3 == 0 &amp;&amp; o == 0) puts("No"); else puts("Yes"); &#125; else &#123; if((n - 1) % 3 == 0 &amp;&amp; o &lt;= 1) puts("No"); else if(n % 3 == 0 &amp;&amp; o == 1) puts("No"); else puts("Yes"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>CCPC</tag>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6418 Rikka with Stone-Paper-Scissors【思维】【期望】]]></title>
    <url>%2Fhdu-6418%2F</url>
    <content type="text"><![CDATA[题目大意：现在A和B进行剪刀石头布的游戏，两者中赢得一方会+1分，输得一方-1分，平局分不变。已知A的剪刀石头布各出的次数为a、b、c，B的为a’、b‘、c’(保证A和B出的总次数相同)，B知道A的牌组组成，求当B按照最优策略出牌时，B最大的得分期望。 解题思路：得分期望 = $\sum_{k=1}^n​$ 得分 * 得分概率。 B要获得最大分数，当A出剪刀时，B要出石头，此时B可以得到A出剪刀的分数，也可以失去A出布的分数，则A出剪刀时，B的得分期望为$ b’ \times \frac{a}{a + b + c} - b’ \times \frac{c}{a + b + c} $，依次类推，可以得出答案为$\frac{a’ \times (c - b) + b’ \times (a - c) + c’ \times (b - a)}{a + b + c}$。 最后注意化简一下就好了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll a, b, c, a1, b1, c1;ll gcd(ll a, ll b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; int t; scanf("%d", &amp;t); while(t--) &#123; scanf("%lld%lld%lld%lld%lld%lld", &amp;a, &amp;b, &amp;c, &amp;a1, &amp;b1, &amp;c1); ll mu = a + b + c; ll zi = a1 * (c - b) + b1 * (a - c) + c1 * (b - a); if(zi == 0) puts("0"); else &#123; bool f = 0; if(zi &lt; 0) &#123; zi = -zi; f = 1; &#125; ll g = gcd(zi, mu); zi /= g; mu /= g; if(f) putchar('-'); if(mu == 1) printf("%lld\n", zi); else printf("%lld/%lld\n", zi, mu); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>HDU</tag>
        <tag>多校联合</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6406 Taotao Picks Apples【思维】【线段树】]]></title>
    <url>%2Fhdu-6406%2F</url>
    <content type="text"><![CDATA[题目大意：现在有一个长度为n的序列，给出m个操作，每次操作都是将第p个位置处的数值替换为q，问每次操作后以第一个元素为起点的LIS的长度是多少。 解题思路：利用线段树维护区间最大值 &amp;&amp; 以区间左端点为起点的LIS的长度，这样答案就是以1为起点的LIS长度。对于每次查询只要替换对应位置上的值和更新树就好了，查询完后记得改回来。 有几点比较巧妙的地方稍微写一下： 区间的LIS长度 = 左子树的LIS长度 + 以左子树最大值为起点的右子树的LIS长度。 计算以某个值为起点的LIS长度时，继续比较这个值和此区间的左子树的最大值，大于等于就查询右子树，否则就返回继续查询左子树的LIS长度 + 用左子树的最大值查询右子树的LIS长度(写的很乱，直接看代码的calc函数和pushup函数好了)。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1e5+5;int t, n, m, pos, val, a[N];struct node&#123; int l, r; int maxx, val;&#125; tree[N&lt;&lt;2];int calc(int val, int rt)&#123; if(tree[rt].l == tree[rt].r) return val &lt; tree[rt].maxx; if(tree[rt&lt;&lt;1].maxx &lt;= val) return calc(val, rt&lt;&lt;1|1); else return calc(val, rt&lt;&lt;1) + (tree[rt].val - tree[rt&lt;&lt;1].val);&#125;void pushup(int rt)&#123; tree[rt].maxx = max(tree[rt&lt;&lt;1].maxx, tree[rt&lt;&lt;1|1].maxx); tree[rt].val = tree[rt&lt;&lt;1].val + calc(tree[rt&lt;&lt;1].maxx, rt&lt;&lt;1|1);&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; if(l == r) &#123; tree[rt].maxx = a[l]; tree[rt].val = 1; return ; &#125; int mid = l + r &gt;&gt; 1; build(l, mid, rt &lt;&lt; 1); build(mid + 1, r, rt &lt;&lt; 1 | 1); pushup(rt);&#125;void update(int pos, int val, int rt)&#123; if(tree[rt].l == tree[rt].r) &#123; tree[rt].maxx = val; return ; &#125; int mid = tree[rt].l + tree[rt].r &gt;&gt; 1; if(pos &lt;= mid) update(pos, val, rt&lt;&lt;1); else update(pos, val, rt&lt;&lt;1|1); pushup(rt);&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); build(1, n, 1); while(m--) &#123; scanf("%d%d", &amp;pos, &amp;val); update(pos, val, 1); printf("%d\n", tree[1].val); update(pos, a[pos], 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>线段树</tag>
        <tag>HDU</tag>
        <tag>多校联合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5071 Chat【模拟】【vector】]]></title>
    <url>%2Fhdu-5071%2F</url>
    <content type="text"><![CDATA[题目大意：现在有一个聊天界面(可以想象为一个队列)，请你模拟以下操作： Add u： 在队列中加入一个优先级为u的窗口。如果已经存在同优先级的窗口，输出”same priority.”，否则输出 “success.”。 Close u：将队列中优先级为u的窗口关闭。如果不存在优先级为u的窗口，输出”invalid priority.” 否则输出”close u with c.”，其中c是和优先级为u的窗口的聊天次数。 Chat w：向当前在最顶端的窗口输入w句话。如果当前队列中没有窗口，输出”empty.” 否则输出”success.”。 Rotate x：将当前排在第x位的窗口翻转到最前面。如果x非法，输出”out of range.” 否则输出”success.”。 Prior：将优先级最高的窗口翻转到最前面。如果当前队列中没有窗口，输出”empty.” 否则输出”success.”。 Choose u：将优先级为u的窗口翻转到最前面。如果当前队列中没有此窗口，输出”invalid priority.” 否则输出”success.”。 Top u：将优先级为u的窗口置顶。如果当前队列中没有此窗口，输出”invalid priority.” 否则输出”success.”。 Untop：取消当前置顶的窗口。如果当前没有置顶的窗口，输出”no such person.” 否则输出 “success.”。 解题思路：我们可以用vector来模拟这个“队列”，里面的元素为记录优先级&amp;聊天次数的pair对，然后直接做就好了(可以通过写一些函数来模块化一些操作来减少代码量)。 PS：对于置顶这个操作，可以直接用一个变量来记录优先级，通过优先级找到它在队列中的原始位置，因为这个值是不变的，对于后续操作十分方便。 PPS：active时不要忘记忽略掉聊天次数为0的那些窗口。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;char op[9];int t, n, x, mx, pos, val;pair&lt;int, long long&gt; p;vector&lt;pair&lt;int, long long&gt; &gt; V;int Find(int v)&#123; for(int i = 0; i &lt; V.size(); ++i) if(V[i].first == v) return i; return -1;&#125;void Erase(int v)&#123; //删除第v个 int idx = 0; for(auto it = V.begin(); it != V.end(); ++it, ++idx) &#123; if(idx == v) &#123; V.erase(it); return ; &#125; &#125;&#125;void Add()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos != -1) puts("same priority."); else &#123; V.push_back(&#123;x, 0&#125;); puts("success."); &#125;&#125;void Close()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else &#123; printf("close %d with %lld.\n", V[pos].first, V[pos].second); Erase(pos); &#125;&#125;void Chat()&#123; scanf("%d", &amp;x); if(V.empty()) puts("empty."); else &#123; if(val) pos = Find(val); else pos = 0; V[pos].second += x; puts("success."); &#125;&#125;void Rotate(int x)&#123; --x; if(x &lt; 0 || x &gt;= V.size()) puts("out of range."); else &#123; p = V[x]; Erase(x); V.insert(V.begin(), p); puts("success."); &#125;&#125;void Prior()&#123; if(V.empty()) puts("empty."); else &#123; mx = -1; for(int i = 0; i &lt; V.size(); ++i) &#123; if(V[i].first &gt; mx) &#123; mx = V[i].first; pos = i; &#125; &#125; Rotate(pos + 1); &#125;&#125;void Choose()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else Rotate(pos + 1);&#125;void Top()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else &#123; val = x; puts("success."); &#125;&#125;void Untop()&#123; if(val) &#123; val = 0; puts("success."); &#125; else puts("no such person.");&#125;void active()&#123; if(val) &#123; pos = Find(val); if(V[pos].second) &#123; printf("Bye %d: %lld\n", V[pos].first, V[pos].second); Erase(pos); &#125; &#125; for(int i = 0; i &lt; V.size(); ++i) if(V[i].second) printf("Bye %d: %lld\n", V[i].first, V[i].second);&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; val = 0; V.clear(); scanf("%d", &amp;n); for(int cas = 1; cas &lt;= n; ++cas) &#123; scanf("%s", op); printf("Operation #%d: ", cas); if(op[0] == 'A') Add(); else if(op[0] == 'R') scanf("%d", &amp;x), Rotate(x); else if(op[0] == 'P') Prior(); else if(op[0] == 'T') Top(); else if(op[0] == 'U') Untop(); else if(op[1] == 'l') Close(); else if(op[2] == 'a') Chat(); else Choose(); &#125; active(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>HDU</tag>
        <tag>ICPC</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5929 Basic Data Structure【模拟】【deque】]]></title>
    <url>%2Fhdu-5929%2F</url>
    <content type="text"><![CDATA[题目大意： 现有一个栈，请你对它做出如下操作： PUSH x：将元素x入栈。 POP：将栈顶元素出栈。 REVERSE：将栈内元素翻转。 QUERY：查询从栈顶元素开始到栈底元素的NAND和。 其中NAND的定义为： 0 nand 0 = 1 0 nand 1 = 1 1 nand 0 = 1 1 nand 1 = 0 解题思路：对于操作1和操作2直接模拟就好了，费时的部分是剩余的两个操作。 考虑到n的范围最大取值为200000，我们可以开个400000的数组，取中间部分为初始起点，当进行操作3的时候直接将头对另一边进行1、2操作就好了。 观察这个nand运算我们发现，只要和0进行运算的，答案都变成了1，利用这一点我们可以记录0出现的位置，就是出现了0就将它存起来。我们可以也像上面那样进行记录，出于好写我这里直接用的deque。这样，每当查询时我们直接看存起来的0的位置，如果没有0那就数1的个数；如果有的话就看从头开始最后一个出现的0之后有多少个1。这里有个细节要注意，就是当只有1个0的时候，要特别判断一下。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;deque&gt;using namespace std;const int N = 200010;char op[11];int t, n, x, rig, lef, a[N&lt;&lt;1];int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; deque&lt;int&gt; Q; rig = 200001; lef = rig - 1; bool flag = true; printf("Case #%d:\n", cas); scanf("%d", &amp;n); while(n--) &#123; scanf("%s", op); if(op[0] == 'P') &#123; if(op[1] == 'U') &#123; scanf("%d", &amp;x); if(flag) &#123; if(!x) Q.push_back(rig); a[rig++] = x; &#125; else &#123; if(!x) Q.push_front(lef); a[lef--] = x; &#125; &#125; else &#123; if(flag) &#123; --rig; if(!a[rig]) Q.pop_back(); &#125; else &#123; ++lef; if(!a[lef]) Q.pop_front(); &#125; &#125; &#125; if(op[0] == 'Q') &#123; if(lef + 1 == rig) puts("Invalid."); else if(Q.empty()) printf("%d\n", (rig - lef - 1) &amp; 1); else &#123; if(flag) &#123; printf("%d\n", ((Q.front() - lef - 1) +(rig - 1 != Q.front())) &amp; 1); &#125; else &#123; printf("%d\n", ((rig - Q.back() - 1) +(lef + 1 != Q.back())) &amp; 1); &#125; &#125; &#125; if(op[0] == 'R') &#123; flag = !flag; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>HDU</tag>
        <tag>CCPC</tag>
        <tag>deque</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 864D Make a Permutation! 【贪心】【模拟】]]></title>
    <url>%2Fcf-864d%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个数，每次可以花费1单位体力来将其中的任意一个数改变为任意一个数。现在他想要将这n个数经过若干次变换，使之包含1-n的所有数字。问他改变完成后花费的最小体力，并输出改变后的序列。如果存在多组解，输出这全排列中字典序最小的哪种方案。 解题思路：既然花费体力最小，那当然要优先考虑将出现过多次的数字替换为未出现的数字了。然后就是稍微困难点的部分了——字典序最小。我们考虑一下替换过程中可能会出现的情况可以发现，当一个数要被替换时，如果替换为的数小于这个数，那就取最靠前的数字来进行替换，否则就取靠后的来替换。（如11123 -&gt; 14523, 23334 -&gt; 21354）接下来的实现，先找一个数组记录这个序列，再找一个来记录每个数字出现的次数。因为最终替换为的是没有出现过的数字，所以还要记录下哪些数字没有出现过，这里可以用set也可以用priority_queue。最后遍历一遍原序列，开始进行替换（即出现次数大于一次的要被没出现过的替换掉）。因为还要比较大小关系，如果被替换的数&gt;要替换的数，直接替换就好了；否则标记下这个数，这里没有替换，以后再遇到不管怎样都要替换掉（再加个vis数组标记一下就好了）。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 200005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, tot;bool vis[MAX];int a[MAX], b[MAX];priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q;int main()&#123; scanf("%d",&amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d",&amp;a[i]); ++b[a[i]]; &#125; for(int i = 1; i &lt;= n; ++i) if(!b[i]) Q.push(i); for(int i = 1; i &lt;= n; ++i) &#123; if(Q.empty()) break; if(b[a[i]] &gt; 1) &#123; if(Q.top() &lt; a[i] || vis[a[i]]) &#123; ++tot; --b[a[i]]; a[i] = Q.top(); Q.pop(); &#125; else vis[a[i]] = true; &#125; &#125; printf("%d\n", tot); for(int i = 1; i &lt;= n; ++i) printf("%d ", a[i]); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第七章习题】【0/18】]]></title>
    <url>%2Flrj-ch7-1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>剪枝</tag>
        <tag>回溯</tag>
        <tag>暴力</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第七章例题】【4/15】]]></title>
    <url>%2Flrj-ch7-0%2F</url>
    <content type="text"><![CDATA[UVa 725 Division【枚举】题目大意：输入$n(2 \leq n \leq 79)$，从小到大输出所有形如$abcde / fghij = n$的表达式，其中a ~ j恰好为数字0 ~ 9的一个排列(可以有前导零)。 解题思路： 枚举每个数的取值？复杂度$O(10!)$，不可以。 观察这个式子我们可以变形为$abcde = n \times fghij$，这时候直接枚举$fghij$的值，就可以计算出$abcde$的值了，然后判断是否0 ~ 9这些数字都出现过。 再根据$n$的取值范围，我们可以缩小$fghij$的取值范围了，下界为1234，上界为98765 / 2，即范围为$1234$~$49382$，实际上还可以更小，不过到这里问题就可以解决了。 MyCode：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n;char num[11] = "0123456789";char tem[11];int main()&#123; int cas = 0; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; if(cas) puts(""); bool flag = 0; for(int fghij = 1234; fghij &lt;= 49382; ++fghij) &#123; int abcde = fghij * n; if(abcde &gt; 98765) break; if(fghij &gt; 10000) sprintf(tem, "%d%d", abcde, fghij); else sprintf(tem, "%d%d%d", abcde, fghij, 0); sort(tem, tem + 10); if(strcmp(tem, num) == 0) &#123; flag = 1; printf("%d / %05d = %d\n", abcde, fghij, n); &#125; &#125; if(!flag) printf("There are no solutions for %d.\n", n); ++cas; &#125; return 0;&#125; UVa 11059 Maximum Product【枚举】题目大意：给出一个序列，求出一个乘积最大的连续子序列，若乘积为负，则答案为0. 解题思路：枚举起点和终点。 MyCode：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, cou, a[18];long long ans, tem;int main()&#123; while(~scanf("%d",&amp;n)) &#123; ans = 0; for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); for(int i = 0; i &lt; n; ++i) &#123; tem = 1; for(int j = i; j &lt; n; ++j) &#123; tem *= a[j]; if(tem &gt; ans) ans = tem; &#125; &#125; printf("Case #%d: The maximum product is %lld.\n\n",++cou,ans); &#125; return 0;&#125; UVa 10976 Fractions Again?!【枚举】题目大意：给出一个数$k$，求出有多少对$(x, y)$，满足$\frac{1}{k} = \frac{1}{x} + \frac{1}{y}$且$x \geq y &gt; 0$。 解题思路：将上述条件联立，对式子变形得，$y \leq 2k \leq x$。这样，在$k+1$ ~ $2k$范围内枚举$y$，然后根据$y$计算出$x$来就可以了($x = \frac{ky}{y-k}$)。 MyCode：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int a[10005][5];int k, tot, tem;int main()&#123; while(~scanf("%d",&amp;k)) &#123; tot = 0; for(int y = k + 1; y &lt;= 2 * k; ++y) &#123; int tem = k * y / (y - k); if(tem * (y - k) == k * y) &#123; a[tot][0] = tem; a[tot][1] = y; tot++; &#125; &#125; cout &lt;&lt; tot &lt;&lt; endl; for(int i = 0; i &lt; tot; ++i) printf("1/%d = 1/%d + 1/%d\n",k,a[i][0],a[i][1]); &#125; return 0;&#125; UVa 524 Prime Ring Problem【回溯】题目大意：输入n个数，将这n个数组成一个环，使得相邻两数之和均为素数。 解题思路：DFS + 剪枝。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, a[22];bool pri[33], used[22];void init()&#123; pri[2] = pri[3] = pri[5] = pri[7] = 1; pri[11] = pri[13] = pri[17] = pri[19] = 1; pri[23] = pri[29] = pri[31] = 1;&#125;void DFS(int cur)&#123; if(cur == n + 1) &#123; if(!pri[a[1] + a[n]]) return ; for(int i = 1; i &lt;= n; ++i) printf("%d%c", a[i], i == n ? '\n' : ' '); return ; &#125; for(int i = 2; i &lt;= n; ++i) &#123; if(!used[i] &amp;&amp; pri[a[cur - 1] + i]) &#123; used[i] = 1; a[cur] = i; DFS(cur + 1); used[i] = 0; &#125; &#125;&#125;int main()&#123; init(); for(int cas = 1; ~scanf("%d", &amp;n); ++cas) &#123; if(cas &gt; 1) puts(""); printf("Case %d:\n", cas); a[1] = 1; used[1] = 1; DFS(2); &#125; return 0;&#125; UVa 129 Krypton Factor【】题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 ###]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>剪枝</tag>
        <tag>回溯</tag>
        <tag>暴力</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 771A Bear and Friendship Condition 【并查集/DFS】]]></title>
    <url>%2Fcf-771a%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个点，m条边构成的一个无向图。问是否图中所有的边都满足：当a和b相连、b和c相连时，a和c也相连。 解题思路：当满足上述条件时就说明这k个点构成了一个无向完全图，这种图的充要条件是：边数 = 点数 * (点数 - 1) / 2。根据这个突破点用DFS搜或者并查集判都可以了。 Mycode(并查集):1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 150010;int f[N];long long t[N], e;void init()&#123; for(int i = 1; i &lt; N; ++i) f[i] = i;&#125;int Find(int v)&#123; if(f[v] != v) f[v] = Find(f[v]); return f[v];&#125;void Union(int u, int v)&#123; int t1 = Find(u); int t2 = Find(v); if(t1 != t2) f[t2] = t1;&#125;int main()&#123; init(); int n, m; scanf("%d%d",&amp;n,&amp;m); for(int i = 0; i &lt; m; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); Union(u, v); &#125; for(int i = 1; i &lt;= n; ++i) &#123; ++t[Find(i)]; &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(t[i]) e += t[i] * (t[i] - 1) / 2; &#125; puts(e == m ? "YES" : "NO"); return 0;&#125; Mycode(DFS):12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int M = 150010;bool vis[M];vector&lt;int&gt; G[M];int n, m, x, y, v, e;void DFS(int t, int &amp; v, int &amp; e)&#123; vis[t] = true; ++v; e += G[t].size(); for(int i = 0; i &lt; G[t].size(); ++i) if(!vis[G[t][i]]) DFS(G[t][i], v, e);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; scanf("%d%d",&amp;x,&amp;y); G[x].push_back(y); G[y].push_back(x); &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(!vis[i]) &#123; v = e = 0; DFS(i, v, e); if(e != 1ll * v * (v - 1)) &#123; puts("NO"); return 0; &#125; &#125; &#125; puts("YES"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>DFS</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5461 Largest Point 【思维】]]></title>
    <url>%2Fhdu-5461%2F</url>
    <content type="text"><![CDATA[题目大意：现在有n个点，给出a和b，从这n个点中选出不同的两个点x、y，使得$ax ^ 2 + by$最大。问最大值是多少。 解题思路：首先想到的是找出最大值和最小值来，分4种情况讨论： a &gt; 0 &amp;&amp; b &gt; 0 a &gt; 0 &amp;&amp; b &lt; 0 a &lt; 0 &amp;&amp; b &gt; 0 a &lt; 0 &amp;&amp; b &lt; 0 分成这样后发现需要找的还有次大值、次小值以及最接近0的那个值。然后当最大值或最小值和最接近0的值是同一个时还要再进行判断。到这里有点晕了。。 后来发现一种很巧妙的思路，就是用两个数组存一下$ax^2$$和$$bx$的值，然后将两者排序，直接取两者的最大值就行了。当两者的最大值用的是同一个x后再加个比较就行了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 5000010;int t, n, x;long long a, b, res;struct node&#123; int idx; long long val;&#125; A[N], B[N];bool cmp(node u, node v)&#123; return u.val &lt; v.val;&#125;int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d%lld%lld", &amp;n, &amp;a, &amp;b); for(int i= 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;x); A[i].val = a * x * x; B[i].val = b * x; A[i].idx = B[i].idx = i; &#125; sort(A + 1, A + 1 + n, cmp); sort(B + 1, B + 1 + n, cmp); if(A[n].idx == B[n].idx) res = max(A[n].val + B[n - 1].val, A[n - 1].val + B[n].val); else res = A[n].val + B[n].val; printf("Case #%d: %lld\n", cas, res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>HDU</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 242E XOR on Segment 【线段树】【异或】]]></title>
    <url>%2Fcf-242e%2F</url>
    <content type="text"><![CDATA[题目大意：给出一个包含n个数的数组，先要对数组中的数进行m次操作，当输入的指令为1时，输出区间l~r的数的和；当输入的指令为2时，将区间l~r的数全部^x。 解题思路：区间更新，区间求和，线段树的典型应用。求和好解决，但是更新呢？如果单点更新肯定超时不用想。考虑异或的性质，是否可以将存的数分解为二进制的形式进行存储呢，答案是可以的。因为$a_i$最大不超过$ 2^{20} $，所以将sum改为大小为20的数组来存取二进制形式的每一位是能实现的。更新时还是延迟标记的思想，查询时再将这些数“合起来”就行了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 100010;int a[MAX];struct node&#123; int l, r; int sum[22], lazy;&#125; tree[MAX&lt;&lt;2];void pushup(int rt)&#123; for(int i = 0; i &lt;= 20; ++i) tree[rt].sum[i] = tree[rt&lt;&lt;1].sum[i] + tree[rt&lt;&lt;1|1].sum[i];&#125;void pushdown(int rt)&#123; int mid = tree[rt].r + tree[rt].l &gt;&gt; 1; for(int i = 0; i &lt;= 20; ++i) &#123; if(tree[rt].lazy &amp; (1 &lt;&lt; i)) &#123; tree[rt&lt;&lt;1].sum[i] = mid - tree[rt].l + 1 - tree[rt&lt;&lt;1].sum[i]; tree[rt&lt;&lt;1|1].sum[i] = tree[rt].r - mid - tree[rt&lt;&lt;1|1].sum[i]; &#125; &#125; tree[rt&lt;&lt;1].lazy ^= tree[rt].lazy; tree[rt&lt;&lt;1|1].lazy ^= tree[rt].lazy; tree[rt].lazy = 0;&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; tree[rt].lazy = 0; if(l == r) &#123; for(int i = 0; i &lt;= 20; ++i) tree[rt].sum[i] = (a[l] &amp; (1 &lt;&lt; i)) &gt; 0; return ; &#125; int mid = l + r &gt;&gt; 1; build(l, mid, rt&lt;&lt;1); build(mid+1, r, rt&lt;&lt;1|1); pushup(rt);&#125;void update(int l, int r, int val, int rt)&#123; if(tree[rt].l == l &amp;&amp; tree[rt].r == r) &#123; tree[rt].lazy ^= val; for(int i = 0; i &lt;= 20; ++i) &#123; //注意这里的更新值 if(val &amp; (1 &lt;&lt; i)) tree[rt].sum[i] = r - l + 1 - tree[rt].sum[i]; &#125; return ; &#125; if(tree[rt].lazy) pushdown(rt); int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(r &lt;= mid) update(l, r, val, rt&lt;&lt;1); else if(l &gt; mid) update(l, r, val, rt&lt;&lt;1|1); else &#123; update(l, mid, val, rt&lt;&lt;1); update(mid+1, r, val, rt&lt;&lt;1|1); &#125; pushup(rt);&#125;long long query(int l, int r, int rt)&#123; long long res = 0; if(tree[rt].l == l &amp;&amp; tree[rt].r == r) &#123; for(int i = 0; i &lt;= 20; ++i) res += (1ll &lt;&lt; i) * tree[rt].sum[i]; return res; &#125; if(tree[rt].lazy) pushdown(rt); int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(r &lt;= mid) res += query(l, r, rt&lt;&lt;1); else if(l &gt; mid) res += query(l, r, rt&lt;&lt;1|1); else res += query(l, mid, rt&lt;&lt;1) + query(mid+1, r, rt&lt;&lt;1|1); return res;&#125;int main()&#123; int n, m, l, r, val, Q; scanf("%d",&amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d",&amp;a[i]); build(1, n, 1); scanf("%d",&amp;m); while(m--) &#123; scanf("%d%d%d",&amp;Q,&amp;l,&amp;r); if(Q == 1) printf("%lld\n", query(l, r, 1)); else &#123; scanf("%d", &amp;val); update(l, r, val, 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>线段树</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 822C Hacker, pack your bags! 【贪心】【模拟】]]></title>
    <url>%2Fcf-822c%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个区间，每个区间有个值$c_i​$。现要你从中选出两个区间，使得它们不相交 &amp;&amp; 区间长度之和恰好为 x。无解时输出-1， 存在多个可行解时输出$c_i + c_j​$ 最小的和。 解题思路：第一感觉是排序后选定一个区间，然后二分找到满足值为$x - c_i$的那个区间，然后写炸了。后来补题时发现可以用个vector将区间的左端点和值存下来，下标就是区间长度，这样查的时候就变得很好查了。然后每个区间按照左端点从小到大排好序，因为区间长度固定，这样遍历时就可以遍历区间长度为i的区间，对于长度为$x - i$的，只遍历在长度为i的区间的左边的区间并同时记录最小值就可以了。详细看代码吧。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int N = 200010;const int oo = 2e9+7;int n, x, l, r, c, res, tem;vector&lt; pair&lt;int, int&gt; &gt; G[N];int main()&#123; scanf("%d%d", &amp;n, &amp;x); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d%d", &amp;l, &amp;r, &amp;c); G[r - l + 1].push_back(&#123;l, c&#125;); &#125; for(int i = 1; i &lt; x; ++i) sort(G[i].begin(), G[i].end()); res = oo; for(int cost = 1; cost &lt; x; ++cost) &#123; tem = oo; auto &amp;u = G[cost], &amp;v = G[x - cost]; for(int i = 0, j = 0; i &lt; v.size(); ++i) &#123; while(j &lt; u.size() &amp;&amp; u[j].first + cost - 1 &lt; v[i].first) &#123; tem = min(tem, u[j].second); ++j; &#125; if(tem != oo) res = min(res, tem + v[i].second); &#125; &#125; printf("%d\n", res == oo ? -1 : res); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6438 Buy and Resell 【思维】【贪心】]]></title>
    <url>%2Fhdu-6348%2F</url>
    <content type="text"><![CDATA[题目大意：现在有n个城市，你依次经过城市$1$ ~ $n$。每个城市都有一个共同的物品，但它们的价格可能会不一样。你经过一个城市时可以选择将这个物品以 $a_i$ 的价格买下来，或者是以 $a_i$的价格卖出去(卖出去的前提是你已经有至少一个此物品)，每个城市最多进行一次买/卖操作。初始时你又无限多的钱，问在走完这n个城市后你的钱最多能变成多少，并输出此时交易的次数。当能通过多种买/卖的方法达到最多钱的时候，输出交易次数最少的那一次。 解题思路：我们可以用一个可以自动排好序的容器存储当前可以买到哪些货，排序是按照最便宜的在前面这样，每次到了可以卖的时候就先卖掉，然后到一个可以赚更多钱的城市的时候，再收回，重新卖一遍。每个输入的x存两次是一次代表着买入一次代表着卖出。当买入时说明一定在最后卖出了，这时买卖次数++。 Mycode：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;long long res;int t, n, cnt, x;pair&lt;int, int&gt; pp;multiset&lt; pair&lt;int, int&gt; &gt; Q;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; Q.clear(); res = cnt = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;x); Q.insert(make_pair(x, 1)); //sell Q.insert(make_pair(x, 2)); //buy pp = *Q.begin(); res += x - pp.first; if(!(pp.second &amp; 1)) ++cnt; Q.erase(Q.begin()); &#125; printf("%lld %d\n", res, cnt &lt;&lt; 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>HDU</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5832 A water problem 【大数取模】]]></title>
    <url>%2Fhdu-5832%2F</url>
    <content type="text"><![CDATA[题目大意：告诉你个长度为$10000000$的数字，问这个数字是否既是73的倍数又是137的倍数。 解题思路：大数取模。c++的大数取模是根据秦九韶公式来的， 举个例子来说$123 = ((1 \times 10 + 2) \times 10) + 3$， 而$(a \times b) \% M = a \% M \times b \% M$， 然后我们就能得到$123 \% M = ((1 \% M \times 10 + 2) \% M \times 10) \% M + 3 \% M$。 Mycode：1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 10000010;const int M1 = 73;const int M2 = 137;char s[N];int main()&#123; for(int cas = 1; ~scanf("%s", s); ++cas) &#123; int len = strlen(s); int sum1 = 0, sum2 = 0; for(int i = 0; i &lt; len; ++i) &#123; sum1 = (sum1 * 10 + s[i] - '0') % M1; sum2 = (sum2 * 10 + s[i] - '0') % M2; &#125; printf("Case #%d: %s\n", cas, (!sum1 &amp;&amp; !sum2) ? "YES" : "NO"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>大数</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6150 Vertex Cover 【构造】]]></title>
    <url>%2Fhdu-6150%2F</url>
    <content type="text"><![CDATA[题目大意：最小顶点覆盖问题是一个传统的NP完全问题，就是多项式复杂程度的非确定性问题。现在告诉你一个此问题的近似解法，算法的主要思想是遍历每个顶点，贪心的选取当前未被选取的点中的与另外的点相连数目最多的顶点，相连数目相同时选序号靠后的那个点。伪代码实现如下： 1234567891011121314151617181920212223for (int i = 1; i &lt;= n; ++i) &#123; use[i] = false; deg[i] = degree of the vertex i;&#125;int ans = 0;while (true) &#123; int mx = -1, u; for (int i = 1; i &lt;= n; ++i) &#123; if (use[i]) continue; if (deg[i] &gt;= mx) &#123; mx = deg[i]; u = i; &#125; &#125; if (mx &lt;= 0) break; ++ans; use[u] = true; for (each vertex v adjacent to u) --deg[v];&#125;return ans; 现在要你找出一组数据来，使得按照他的方法跑出来的结果是最优解的3倍以上。 解题思路：题目中给出的思路显然是不对的，hack掉这个程序的关键就是当数目相同时他去掉的是靠后的那个点。 我们可以构造两组点，使得左边的那一组为正确答案，右边的为按照他的算法得出的答案。正确答案为左边，假设有n个点，先在右边构造n个点，和左边的一一相连；然后再在右边构造$\lfloor \frac{n}{2} \rfloor$个点，使得这些点依次与{1、2}、{3、4}……这些点相连，最后不足以连接的就不连；然后再在右边构造$\lfloor \frac{n}{3} \rfloor$个点，进行连接；……；直至构造了1个与n个点相连的点。 上面的构造方法就是根据前面的漏洞制定的，最后确定一下n为多少就好了。因为要求$3 * n \leq \sum_{i=1}^n{\lfloor \frac{n}{i} \rfloor}$, 所以n = 15就够了。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int L, R, cnt;struct node&#123; int x, y;&#125;a[666];int main()&#123; L = R = 15; //num就是构造的下一个点与左边集合的点相连数目 for(int num = 1; num &lt;= L; ++num) &#123; //st为与左边相连的顶点的起点 for(int st = 1; st &lt;= L; st += num) &#123; //要连的数目超过了左边顶点的数目 if(st + num - 1 &gt; L) break; ++R; //开始将新构造的点与[st,st+num)间的点相连 for(int t = st; t &lt; st + num; ++t) &#123; a[cnt].x = t; a[cnt].y = R; ++cnt; &#125; &#125; &#125; printf("%d %d\n", R, cnt); for(int i = 0; i &lt; cnt; ++i) printf("%d %d\n", a[i].x, a[i].y); printf("%d\n", L); for(int i = 1; i &lt;= L; ++i) printf("%d\n", i); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>HDU</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4825 Xor Sum 【01字典树】]]></title>
    <url>%2Fhdu-4825%2F</url>
    <content type="text"><![CDATA[题目大意：从一个N个数集合中找出一个数K，使得这个数与给出的S异或结果最大。 解题思路：涉及到异或问题，将给的数都用二进制形式表示出来。为了使异或结果最大，即从高位开始选，K的这一位为1时选S的这一位为0的，为0时刚好相反。然后用字典树进行存储分解后的二进制表示就OK了。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX =100010;int t, n, m;long long x;struct Trie&#123; int nex[MAX * 32][2], tot; long long pre[MAX * 32]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); &#125; void add() &#123; int now = 1; for(int i = 32; i &gt;= 0; --i) &#123; if(nex[now][(x &gt;&gt; i) &amp; 1] == 0) nex[now][(x &gt;&gt; i) &amp; 1] = ++tot; now = nex[now][(x &gt;&gt; i) &amp; 1]; &#125; pre[now] = x; &#125; long long query() &#123; int now = 1; for(int i = 32; i &gt;= 0; --i) &#123; if(nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]) now = nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]; else now = nex[now][(x &gt;&gt; i) &amp; 1]; &#125; return pre[now]; &#125;&#125; trie;int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; trie.init(); printf("Case #%d:\n", cas); scanf("%d%d",&amp;n,&amp;m); while(n--) &#123; scanf("%lld", &amp;x); trie.add(); &#125; while(m--) &#123; scanf("%lld", &amp;x); printf("%lld\n", trie.query()); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 979D Kuro and GCD and XOR and SUM 【01字典树】]]></title>
    <url>%2Fcf-979d%2F</url>
    <content type="text"><![CDATA[题目大意：现在要对一个数组执行q次指令，指令有两种类型，分别为”1 x”和”2 x k s”，前一种是向数组中加一个数x，后一种是查询数组中是否存在这样一个v，使得v满足$k \mid \gcd(x, v) , x + v &lt; s$, 若不存在，输出-1，否则输出满足条件的v中值最大的那个。 解题思路：首先观察条件，很明显的当$x \mod k \neq 0$时，答案是-1， 当$s - x \leq 0$时，答案是-1。对于其余情况，因为插入的数在1 ~ $10^5$间，而且用到这个数只要它出现过就可以，与它出现的次数无关。所以我们可以用桶排序的思想，用一个数组标记这个数字是否出现过。对于给出的查询，我们只需从k开始找，到$s - x$为止，每次加k，看枚举的数是否出现过，同时更新记录最大值就OK了。然而这样会T。因为当k = 1时，这样做就和暴力无差了。那么我们怎么办呢？k = 1，就是从1 ~ $s - x$中找出一个数使得这个数与x的异或结果最大。没错，就是区间异或最大值！字典树！前两篇讲的是没有最大值限制的查询，这里有了限制也很简单，我们把之前用的这一位是0|1的pre数组改为到此结点时最小值是多少，然后从根结点开始往下搜索，最后返回叶子结点存的值就好了。为什么这样是对的？因为我们往下找的时候是根据异或结果找的，找到叶子结点时当然就是最大的了。对了，往下找的时候要多加一句判断——是否下面的最小值不大于我们的限制。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;int t, x, k, s, maxx, op, a[MAX];struct Trie&#123; int nex[MAX * 17][2], o[MAX * 17], tot; void init() &#123; tot = 1; memset(o, 0x3f, sizeof(o)); memset(nex, 0, sizeof(nex)); &#125; void add() &#123; int now = 1; o[now] = min(o[now], x); for(int i = 17; i &gt;= 0; --i) &#123; if(nex[now][(x &gt;&gt; i) &amp; 1] == 0) nex[now][(x &gt;&gt; i) &amp; 1] = ++tot; now = nex[now][(x &gt;&gt; i) &amp; 1]; o[now] = min(o[now], x); &#125; &#125; int query() &#123; if(o[1] &gt; maxx) return -1; int now = 1; for(int i = 17; i &gt;= 0; --i) &#123; if(nex[now][((x &gt;&gt; i) &amp; 1) ^ 1] &amp;&amp; o[nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]] &lt;= maxx) now = nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]; else now = nex[now][(x &gt;&gt; i) &amp; 1]; &#125; return o[now]; &#125;&#125;trie;int main()&#123; trie.init(); scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;op); if(op == 1) &#123; scanf("%d", &amp;x); trie.add(); a[x] = true; &#125; else &#123; scanf("%d%d%d",&amp;x,&amp;k,&amp;s); maxx = s - x; if(x % k) puts("-1"); else if(k == 1) printf("%d\n", trie.query()); else &#123; int maxxor = -1, res = -1; for(int i = k; i &lt;= maxx; i += k) &#123; if(a[i] &amp;&amp; (i ^ x) &gt; maxxor) &#123; res = i; maxxor = i ^ x; &#125; &#125; printf("%d\n", res); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 706D Vasiliy's Multiset 【01字典树】]]></title>
    <url>%2Fcf-706d%2F</url>
    <content type="text"><![CDATA[题目大意：现在要对一个multiset执行q次指令，请你根据指令作出相应操作。共有3种指令类型，分别为”+ x”，”- x”和”? x”，他们的要求依次为：向集合中添加一个元素x、删除集合中的一个元素x和查询集合中现已存在的数与x的异或结果最大值。注意：multiset是一个允许相同元素存在于集合中的一个容器。初始时集合中有且仅有0这个元素。 解题思路：全题中最重要的指令就是”? x”这个指令了。异或结果最大，就是分解为二进制后，从高位往低位看，这一位为0时尽量取这一位为1的与他进行异或，为1时同理。到这里就能看出来是很明显的字典树啦。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX =200010;char op;int q, x;struct Trie&#123; int nex[MAX * 30][2], pre[MAX * 30], tot; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); &#125; void add() &#123; int now = 1; for(int i = 30; i &gt;= 0; --i) &#123; if(nex[now][(x &gt;&gt; i) &amp; 1] == 0) nex[now][(x &gt;&gt; i) &amp; 1] = ++tot; now = nex[now][(x &gt;&gt; i) &amp; 1]; ++pre[now]; &#125; &#125; void sub() &#123; int now = 1; for(int i = 30; i &gt;= 0; --i) &#123; now = nex[now][(x &gt;&gt; i) &amp; 1]; --pre[now]; &#125; &#125; int query() &#123; int now = 1, res = 0; for(int i = 30; i &gt;= 0; --i) &#123; //存在此结点 &amp;&amp; 此结点有值 if(nex[now][((x &gt;&gt; i) &amp; 1) ^ 1] &amp;&amp; pre[nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]]) res += (1 &lt;&lt; i), now = nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]; else now = nex[now][(x &gt;&gt; i) &amp; 1]; &#125; return res; &#125;&#125; trie;int main()&#123; trie.init(); trie.add(); scanf("%d", &amp;q); while(q--) &#123; getchar(); scanf("%c%d", &amp;op, &amp;x); if(op == '+') trie.add(); else if(op == '-') trie.sub(); else printf("%d\n", trie.query()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 1011F Mars rover 【模拟】【DFS】]]></title>
    <url>%2Fcf-1011f%2F</url>
    <content type="text"><![CDATA[题目大意：给出一颗根结点为1的树，每个结点最多有两个叶子结点，每个结点的值非0即1。现在给出部分结点的值(0或1)，剩余结点告诉你它们值和子结点值的关系(AND、OR、XOR、NOT)。现在要你求的内容是按照输入顺序依次改变初始时给出的结点的值(0变为1，1变为0)，问每次改变后的根结点的值是多少。 解题思路：首先根据给出的关系我们可以求出每个结点初始状态的值，后面怎么做呢？我们可以挨个枚举每个点变化后的情况如果枚举变化情况的话TLE无疑。观察最后的值发现，答案非0即1，每个结点的值都是这样。那么我们可以不用模拟整个过程，而是记录到某个结点时它的值是否改变了，举个例子的话就是当这个结点是由前面两个结点AND得来的，正好有个结点是0，此时1所在结点的那个分支不论怎么变到这个位置出结果都是0。根据这个思想，我们再对这棵树进行一次DFS做下标记就可以了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int MAX = 1e6+5;int n, m;char s[4];struct node&#123; char op; vector&lt;int&gt; in; bool val, flag;&#125;G[MAX];bool GetVal(int rt)&#123; char c = G[rt].op; if(c == 'A') G[rt].val = GetVal(G[rt].in[0]) &amp; GetVal(G[rt].in[1]); else if(c == 'X') G[rt].val = GetVal(G[rt].in[0]) ^ GetVal(G[rt].in[1]); else if(c == 'O') G[rt].val = GetVal(G[rt].in[0]) | GetVal(G[rt].in[1]); else if(c == 'N') G[rt].val = !GetVal(G[rt].in[0]); return G[rt].val;&#125;void GetFlag(int rt)&#123; if(G[rt].flag == false) for(int i = 0; i &lt; G[rt].in.size(); ++i) G[G[rt].in[i]].flag = false; else &#123; char c = G[rt].op; if(c == 'A') &#123; if(G[rt].val == (!G[G[rt].in[0]].val &amp; G[G[rt].in[1]].val)) G[G[rt].in[0]].flag = false; else G[G[rt].in[0]].flag = true; if(G[rt].val == (!G[G[rt].in[1]].val &amp; G[G[rt].in[0]].val)) G[G[rt].in[1]].flag = false; else G[G[rt].in[1]].flag = true; &#125; else if(c == 'O') &#123; if(G[rt].val == (!G[G[rt].in[0]].val | G[G[rt].in[1]].val)) G[G[rt].in[0]].flag = false; else G[G[rt].in[0]].flag = true; if(G[rt].val == (!G[G[rt].in[1]].val | G[G[rt].in[0]].val)) G[G[rt].in[1]].flag = false; else G[G[rt].in[1]].flag = true; &#125; else if(c == 'X') &#123; if(G[rt].val == (!G[G[rt].in[0]].val ^ G[G[rt].in[1]].val)) G[G[rt].in[0]].flag = false; else G[G[rt].in[0]].flag = true; if(G[rt].val == (!G[G[rt].in[1]].val ^ G[G[rt].in[0]].val)) G[G[rt].in[1]].flag = false; else G[G[rt].in[1]].flag = true; &#125; else if(c == 'N') &#123; if(G[rt].val == (!!G[G[rt].in[0]].val)) G[G[rt].in[0]].flag = false; else G[G[rt].in[0]].flag = true; &#125; &#125; for(int i = 0; i &lt; G[rt].in.size(); ++i) GetFlag(G[rt].in[i]);&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", s); G[i].op = s[0]; scanf("%d", &amp;m); if(s[0] == 'I') G[i].val = m; else &#123; G[i].in.push_back(m); if(s[0] != 'N') &#123; scanf("%d", &amp;m); G[i].in.push_back(m); &#125; &#125; &#125; GetVal(1); /*for(int i = 1; i &lt;= n; ++i) if(G[i].val) cout &lt;&lt; i &lt;&lt; " "; cout &lt;&lt; endl;*/ G[1].flag = true; GetFlag(1); /*for(int i = 1; i &lt;= n; ++i) if(G[i].flag) cout &lt;&lt; i &lt;&lt; " "; cout &lt;&lt; endl;*/ for(int i = 1; i &lt;= n; ++i) if(G[i].op == 'I') printf("%d", G[1].val ^ G[i].flag); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>模拟</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6341 Problem J. Let Sudoku Rotate 【暴力剪枝】]]></title>
    <url>%2Fhdu-6341%2F</url>
    <content type="text"><![CDATA[题目大意：现在有个已经完成的$16 \times 16$的数独(即满足数独的要求)，它的某些部分被逆时针旋转过了。已知每次旋转的角度为90°，问最少经过多少次旋转能将它转回原样。 解题思路：因为数独要求很严格，所以我们可以直接进行搜索 + 剪枝。 PS：给的标程是真的好看，特别是旋转的那一部分，既简洁又优美。Orz。 ACcode:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char s[16];int res, a[16][16], r[16][16], c[16][16], b[4][4];int trans(char ch)&#123; if(isdigit(ch)) return ch - '0'; return ch - 'A' + 10;&#125;void add(int ip, int jp, int val)&#123; for(int i = ip * 4; i &lt; (ip + 1) * 4; ++i) &#123; for(int j = jp * 4; j &lt; (jp + 1) * 4; ++j) &#123; r[i][a[i][j]] += val; c[j][a[i][j]] += val; &#125; &#125;&#125;//进行旋转操作bool rot(int ip, int jp)&#123; for(int i = ip * 4; i &lt; (ip + 1) * 4; ++i) &#123; for(int j = jp * 4; j &lt; (jp + 1) * 4; ++j) &#123; //先把要旋转的部分拿出来 --r[i][a[i][j]]; --c[j][a[i][j]]; b[j - jp * 4][(ip + 1) * 4 - i - 1] = a[i][j]; &#125; &#125; bool flag = true; for(int i = ip * 4; i &lt; (ip + 1) * 4; ++i) &#123; for(int j = jp * 4; j &lt; (jp + 1) * 4; ++j) &#123; //将拿出来的部分进行归位 a[i][j] = b[i - ip * 4][j - jp * 4]; //出现了不符合要求的情况 if((++r[i][a[i][j]] &gt; 1) || (++c[j][a[i][j]] &gt; 1)) flag = false; &#125; &#125; return flag;&#125;void dfs(int ip, int jp, int now)&#123; if(ip == 4 &amp;&amp; jp == 0) &#123; res = min(res, now); return ; &#125; //状态改变 add(ip, jp, 1); if(now &gt;= res) return ; for(int i = 1; i &lt;= 4; ++i) &#123; //旋转i次 if(rot(ip, jp)) dfs(jp == 3 ? ip + 1 : ip, jp == 3 ? 0 : jp + 1, now + (i &amp; 3)); &#125; //状态恢复 add(ip, jp, -1);&#125;int main()&#123; int t; scanf("%d", &amp;t); while(t--) &#123; for(int i = 0; i &lt; 16; ++i) &#123; scanf("%s", s); for(int j = 0; j &lt; 16; ++j) &#123; a[i][j] = trans(s[j]); &#125; &#125; memset(r, 0, sizeof(r)); memset(c, 0, sizeof(c)); res = 16 * 4; dfs(0, 0, 0); printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>多校联合</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6319 Problem A. Ascending Rating 【单调队列】]]></title>
    <url>%2Fhdu-6319%2F</url>
    <content type="text"><![CDATA[题目大意：给定一个序列 a[1..n]，对于每个长度为 m 的连续子区间，求出区间 a 的最大值以及从左往右扫描该区间时 a 的最大值的变化次数。$1 ≤ m ≤ n ≤ 10^7$。 解题思路：求区间最大值，我首先想到的是很经典的滑动窗口求区间最大值问题。对于这个问题，因为还要求最大值的变化次数，所以直接利用滑窗的话变化次数不好求。于是就有题解上说的考虑按照 r 从 n 到 m 的顺序倒着求出每个区间的答案了。此时所维护的值是从大到小的顺序(因为倒着求的嘛)，而对应的变化次数就是队列中元素的个数。考虑到直接上deque挺耗时的，所以直接通过数组模拟就OK了。 【注意】完善a数组时要注意精度问题。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e7+5;int T, n, m, k, P, Q, R, M, t, a[MAX], q[MAX], head, tail;long long A, B;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; A = B = 0; scanf("%d%d%d%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;P,&amp;Q,&amp;R,&amp;M); for(int i = 1; i &lt;= k; ++i) scanf("%d",&amp;a[i]); for(int i = k + 1; i &lt;= n; ++i) a[i] = (1ll * P * a[i-1] + 1ll * Q * i + R) % M; head = 1, tail = 0; for(int i = n; i &gt; 0; --i) &#123; while(tail &gt;= head &amp;&amp; a[q[tail]] &lt;= a[i]) --tail; q[++tail] = i; if(i + m - 1 &lt;= n) &#123; while(q[head] - i &gt;= m) ++head; A += a[q[head]] ^ i; B += tail - head + 1 ^ i; &#125; &#125; printf("%lld %lld\n", A, B); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>多校联合</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 965E Short Code 【Trie】【启发式合并】]]></title>
    <url>%2Fcf-965e%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个不同的仅由小写字母构成的变量名，要求你对其取前缀将其简化，使简化后的变量名各不相同并且最终的总长度最小。 解题思路：对单词建立字典树，记录每个单词的长度。然后从树的叶子结点开始向上进行启发式合并，这个过程用multiset进行维护。启发式合并在这道题中的应用，个人的理解为到达这个结点时，发现这个结点还是空的时候，即可以将一个变量名简化为当前结点代表的变量名的时候，我们要选择它下面的所有变量名中名字最长的那个进行简化，为了便于维护，那就从下往上不断记录到此位置时可以简化的单词长度为多少。在代码中的体现就是DFS中的部分。35-37行为向上传递值，29、39-43行为简化操作。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int MAX = 1e5 + 5;char str[MAX];multiset&lt;int&gt; st[MAX];int n, tot, now, nex[MAX][26], dep[MAX], res;void add()&#123; now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) &#123; nex[now][str[i]-'a'] = ++tot; dep[tot] = dep[now] + 1; &#125; now = nex[now][str[i]-'a']; &#125; st[now].insert(dep[now]);&#125;void DFS(int u = 1)&#123; bool emp = (u &gt; 1 &amp;&amp; st[u].empty()); for(int i = 0; i &lt; 26; ++i) &#123; int v = nex[u][i]; if(!v) continue; DFS(v); for(auto t : st[v]) st[u].insert(t); st[v].clear(); &#125; if(emp) &#123; st[u].erase(--st[u].end()); st[u].insert(dep[u]); &#125;&#125;int main()&#123; tot = 1; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", str); add(); &#125; DFS(); for(auto t : st[1]) res += t; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>Trie</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 967E Big Secret 【异或】【贪心】]]></title>
    <url>%2Fcf-967e%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个数，将它们重新排序，使得排序后的序列满足前n个数的异或值依次递增。 解题思路：考虑这样一个问题，要使$p \bigoplus q &gt; p$并且此时花费的p最小，用x代表p的二进制表示中从最低位往最高位处第一个不为0的位置，那么最小的q即为二进制表示中的x位是1且其余位都是0。对于这个问题，我们以二进制表示中的最高位为区分点，先把所有数用一个容器存起来。取数时先看当前的数第一个为0的低位是否有对应的q满足要求，有的话就取，没有就继续往下找，这样依次取直到取完所有数或者满足不了要求为止。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int MAX = 1e5+5;int n;bool flag;long long t, res[MAX];vector&lt;long long&gt; G[64];int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%I64d", &amp;t); for(int i = 60; i &gt;= 0; --i) &#123; if((t &gt;&gt; i) &amp; 1) &#123; G[i].push_back(t); break; &#125; &#125; &#125; t = 0; for(int idx = 0; idx &lt; n; ++idx) &#123; flag = false; for(int i = 0; i &lt;= 60; ++i) &#123; if((t &amp; (1ll &lt;&lt; i)) == 0 &amp;&amp; G[i].size()) &#123; res[idx] = G[i].back(); t = t ^ G[i].back(); G[i].pop_back(); flag = true; break; &#125; &#125; if(flag == false) break; &#125; if(flag) &#123; puts("Yes"); for(int i = 0; i &lt; n; ++i) printf("%I64d ", res[i]); &#125; else puts("No"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>异或</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 964D Destruction of a Tree 【贪心】]]></title>
    <url>%2Fcf-964d%2F</url>
    <content type="text"><![CDATA[题目大意：给出一个由n个点和n - 1条边构成的树，每次可以摧毁掉一个度数为偶数的点，问是否存在一个摧毁的顺序使得所有点都能被摧毁掉。 解题思路：先说结论：当n为偶数时，总会存在度数为奇数的点无法被摧毁掉(很明显的)。当n为奇数时，答案总是存在的(证明略)。对于答案存在的情况，我们每次都摧毁靠近叶子结点的度数为偶数的结点，因为如果这个点不摧毁，而先摧毁了其父结点，那它的度数就变为奇数，并且叶子结点度数均为1，它们就无法消除了。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int MAX = 200010;bool vis[MAX];stack&lt;int&gt; sta;vector&lt;int&gt; G[MAX], res;int n, t, tem, deg[MAX], f[MAX];void DFS(int x, int p)&#123; sta.push(x); f[x] = p; for(int i = 0; i &lt; G[x].size(); ++i) &#123; if(G[x][i] == p) continue; DFS(G[x][i], x); &#125;&#125;void DFS2(int x)&#123; res.push_back(x); vis[x] = true; for(int i = 0; i &lt; G[x].size(); ++i) &#123; int nex = G[x][i]; --deg[nex]; if(nex == f[x]) continue; if(vis[nex]) continue; if(deg[nex] % 2 == 0) DFS2(nex); &#125;&#125;int main()&#123; scanf("%d", &amp;n); if(n &amp; 1) &#123; puts("YES"); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;t); if(!t) continue; ++deg[t], ++deg[i]; G[t].push_back(i); G[i].push_back(t); &#125; DFS(1, 0); while(!sta.empty()) &#123; tem = sta.top(); sta.pop(); if(deg[tem] % 2 == 0) DFS2(tem); &#125; for(int i = 0; i &lt; res.size(); ++i) printf("%d\n", res[i]); &#125; else puts("NO"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【专题训练】 —字典树【11/16】]]></title>
    <url>%2Ftrie-contest%2F</url>
    <content type="text"><![CDATA[专题链接：https://vjudge.net/contest/50484 A - Shortest Prefixes POJ - 2001 【Easy】题目大意： 将给出的所有单词通过取其前缀来代替此单词进行“简化”，使“简化”后的单词能唯一标识这个单词，在这前提下找到最简的化简结果。例如，给出car、cart、carton“简化”后的单词分别为car、cart、carto。 解题思路： 建立字典树，对于每个要“化简”的单词，我们找到那个到此位置处前缀只有这一种情况的结点，然后输出这条路径上的字符就是要找的最简结果。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 1010;const int MAXL = 1010 * 20;string tem;char s[MAXN][22];struct Tire&#123; int nex[MAXL][26], tot, pre[MAXL]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a']; pre[now]++; &#125; &#125; /*int Find(const char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) return 0; now = nex[now][str[i]-'a']; &#125; return now; &#125;*/ void print(char *str) &#123; printf("%s ", str); int now = 1; for(int i = 0; str[i]; ++i) &#123; now = nex[now][str[i]-'a']; printf("%c", str[i]); if(pre[now] == 1) break; &#125; puts(""); &#125;&#125;tire;int main()&#123; tire.init(); int n; for(n = 1; ~scanf("%s", s[n]); ++n) &#123; tire.add(s[n]); &#125; for(int i = 1; i &lt; n; ++i) &#123; tire.print(s[i]); &#125; return 0;&#125; B - T9 POJ - 1451题目大意： 解题思路： Mycode：12 C - Wild Words POJ - 1816题目大意： 解题思路： Mycode：12 D - Phone List POJ - 3630 【Easy】题目大意： 判断是否有前缀。 解题思路： 建树直接判。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5 + 5;struct Tire&#123; int tot, nex[MAX][11], pre[MAX], cnt[MAX]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre));// memset(cnt, 0, sizeof(cnt)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; &#125;// cnt[now]++; &#125; int Find(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; int t, n; char s[MAX][11]; scanf("%d",&amp;t); while(t--) &#123; tire.init(); scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", s[i]); tire.add(s[i]); &#125; bool flag = true; for(int i = 0; i &lt; n &amp;&amp; flag; ++i) &#123; if(tire.Find(s[i]) &gt; 1) flag = false; &#125; puts(flag ? "YES" : "NO"); &#125; return 0;&#125; E - Colored Sticks POJ - 2513 【Medium】题目大意： 给出一些列颜色，问是否可以将它们前后相连连成一条线。相连的条件是颜色相同。 解题思路： 这就是典型的欧拉回路问题，简单版的可以看 UVa 10129，这里n达到了250000，直接用map是不行了，于是用trie树代替map记录出现的颜色。剩下的就是求欧拉回路啦，这里还是用的并查集判的底图是否联通。 PS：这题里还要考虑一种特殊情况，就是什么输入也没有，此时也是Possible。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXL = 5000010;const int MAXN = 500010;int f[MAXN], deg[MAXN];int nex[MAXL][26], tot;void init()&#123; for(int i = 1; i &lt; MAXN; ++i) f[i] = i;&#125;int Find(int x)&#123; if(x != f[x]) f[x] = Find(f[x]); return f[x];&#125;void Union(int u, int v)&#123; int t1 = Find(u); int t2 = Find(v); if(t1 != t2) f[t1] = t2;&#125;int add(char *str)&#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a']; &#125; return now;&#125;int main()&#123; init(); char s1[11], s2[11]; while(~scanf("%s%s", s1, s2)) &#123; int t1 = add(s1); int t2 = add(s2); ++deg[t1], ++deg[t2]; Union(t1, t2); &#125; int odd = 0, root = 0; for(int i = 1; i &lt;= tot; ++i) &#123; if(deg[i] &amp; 1) ++odd; if(deg[i] &amp;&amp; f[i] == i) ++root; if(odd &gt; 2 || root &gt; 1) break; &#125; if(((odd == 0 || odd == 2) &amp;&amp; root == 1) || (root == 0 &amp;&amp; odd == 0)) puts("Possible"); else puts("Impossible"); return 0;&#125; F - Anagram Groups POJ - 2408题目大意： 解题思路： Mycode：12 G - 统计难题 HDU - 1251 【Easy】题目大意： 给出一系列单词，空行分割后查询接下来给出的单词是前面的多少单词的前缀。 解题思路： 建树直接做。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 4e5+5;struct Tire&#123; int nex[MAX][26], pre[MAX], cnt[MAX], tot; void init() &#123; memset(nex, 0, sizeof(nex)); pre[tot = 1] = 0; //tot = 1, pre[1] = 0; &#125; void add(char* str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a']; pre[now]++; /*for(int j = 0; j &lt;= i; ++j) cout &lt;&lt; str[j]; cout &lt;&lt; " " &lt;&lt; pre[now] &lt;&lt; endl;*/ &#125; cnt[now]++; &#125; int Find(char* str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) return 0; now = nex[now][str[i]-'a']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; char s[11]; tire.init(); while(gets(s)) &#123; if(strlen(s) == 0) break; tire.add(s); &#125; while(gets(s)) &#123; printf("%d\n",tire.Find(s)); &#125; return 0;&#125; H - What Are You Talking About HDU - 1075 【Easy】题目大意： 给出单词代表另一个单词，然后给出一段话输出它代表的话。 解题思路： 记录然后替换就好了，然后就是比较麻烦的模拟了。这里的trie树完全可以用map代替。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int MAX = 1000005;struct Tire&#123; int tot, nex[MAX][26], pre[MAX], cnt[MAX]; char res[MAX][11]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex));// memset(pre, 0, sizeof(pre)); memset(cnt, 0, sizeof(cnt)); memset(res, 0, sizeof(res)); &#125; void add(char *str, char *q) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a'];// pre[now]++; &#125; cnt[now]++; strcpy(res[now], q); &#125; int Find(const char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) return 0; now = nex[now][str[i]-'a']; &#125;// return pre[now]; return now; &#125;&#125; tire;int main()&#123; string trs; char op[3333]; char s[11], t[11]; tire.init(); scanf("%s", s); while(scanf("%s", s) &amp;&amp; s[0] != 'E') &#123; scanf("%s", t); tire.add(t, s); &#125; getchar();gets(s); while(gets(op) &amp;&amp; op[0] != 'E') &#123; int len = strlen(op); for(int i = 0; i &lt; len;) &#123; if(islower(op[i])) &#123; trs = ""; int j; for(j = 0; isalpha(op[i]); ++j, ++i) &#123; trs+=op[i]; &#125; int tt = tire.Find(trs.c_str()); if(tire.cnt[tt]) printf("%s", tire.res[tt]); else cout &lt;&lt; trs; &#125; else &#123; printf("%c", op[i++]); &#125; &#125; puts(""); &#125; return 0;&#125; I - Hat’s Words HDU - 1247 【Easy】题目大意： 给出若干单词，找出可以由其中的两个单词连接后凑成新的单词的单词(就是一个单词可以由已经存在的俩个单词凑成)。这里不用想复杂了，假设有a和aa两个单词，aa也是满足条件的。 解题思路： 建树后，暴力枚举每个单词是否可以被凑成就行了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 50010;int idx;string t1, t2;char s[MAX][1010];struct Tire&#123; int nex[MAX][26], pre[MAX], cnt[MAX], tot; void init() &#123; memset(nex, 0, sizeof(nex));// memset(pre, 0, sizeof(pre)); memset(cnt, 0, sizeof(cnt)); tot = 1; &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a']; &#125; cnt[now]++; &#125; int Find(const char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) return 0; now = nex[now][str[i]-'a']; &#125; return cnt[now]; &#125;&#125;tire;bool judge(const string &amp;p)&#123; if(p.size() == 1) return false; int k1, k2; for(int i = 1; i &lt; p.size(); ++i) &#123; t1 = p.substr(0,i); t2 = p.substr(i, p.size()); k1 = tire.Find(t1.c_str()); k2 = tire.Find(t2.c_str()); //cout &lt;&lt; t1 &lt;&lt; " " &lt;&lt; k1 &lt;&lt; " " &lt;&lt; t2 &lt;&lt; " " &lt;&lt; k2 &lt;&lt; endl; if(k1 &amp;&amp; k2) return true; &#125; return false;&#125;int main()&#123; tire.init(); while(~scanf("%s", s[idx])) tire.add(s[idx++]); /*for(int i = 1; i &lt;= tire.tot; ++i) &#123; cout &lt;&lt; tire.cnt[i] &lt;&lt; endl; &#125;*/ /*for(int i = 0; i &lt; idx; ++i) &#123; cout &lt;&lt; tire.Find(s[i]) &lt;&lt; endl; &#125;*/ for(int i = 0; i &lt; idx; ++i) &#123; if(judge(s[i])) &#123; printf("%s\n", s[i]); &#125; &#125; return 0;&#125; J - Phone List HDU - 1671 【Easy】题目大意： 判断是否有前缀。 解题思路： 建树直接判。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5 + 5;struct Tire&#123; int tot, nex[MAX][11], pre[MAX], cnt[MAX]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre));// memset(cnt, 0, sizeof(cnt)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; &#125;// cnt[now]++; &#125; int Find(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; int t, n; char s[MAX][11]; scanf("%d",&amp;t); while(t--) &#123; tire.init(); scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", s[i]); tire.add(s[i]); &#125; bool flag = true; for(int i = 0; i &lt; n &amp;&amp; flag; ++i) &#123; if(tire.Find(s[i]) &gt; 1) flag = false; &#125; puts(flag ? "YES" : "NO"); &#125; return 0;&#125; K - Immediate Decodability HDU - 1305 【Easy】题目大意： 判断给出的字符串判断是否出现了某个串是另外一个的前缀。 解题思路： 建树直接判。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int MAX = 1e5 + 5;struct Tire&#123; int tot, nex[MAX][11], pre[MAX], cnt[MAX]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); memset(cnt, 0, sizeof(cnt)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; &#125; cnt[now]++; &#125; int Find(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; int cas = 0, idx = 0; char a[11]; char s[11][11]; tire.init(); while(~scanf("%s", a)) &#123; if(a[0] == '9') &#123; /*for(int i = 0; i &lt; idx; ++i) cout &lt;&lt; s[i] &lt;&lt; endl;*/ bool flag = true; for(int i = 0; i &lt; idx; ++i) &#123; if(tire.Find(s[i]) &gt; 1) &#123; //cout &lt;&lt; tire.Find(s[i]) &lt;&lt; " " &lt;&lt; s[i] &lt;&lt; endl; flag = false; break; &#125; &#125; printf("Set %d is ", ++cas); if(flag) puts("immediately decodable"); else puts("not immediately decodable"); tire.init(); idx = 0; memset(s, 0, sizeof(s)); &#125; strcpy(s[idx++], a); tire.add(a); &#125; return 0;&#125; L - 单词数 HDU - 2072 【Easy】题目大意： 给出一篇文章，问文中出现的不同单词的数量。 解题思路： 这个用map就可以，放到这里当做练习了。 PS：这题数据有点恶心，会出现开头空格、连续多个空格、全是空格等很XX的情况，这里我用stringstream处理的——STL大法好！ Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int MAX = 1e5 + 5;struct Tire&#123; int tot, nex[MAX][11], pre[MAX], cnt[MAX]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); memset(cnt, 0, sizeof(cnt)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; &#125; cnt[now]++; &#125; int Find(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; string s; char a[1111]; while(getline(cin, s)) &#123; if(s.size() == 1 &amp;&amp; s[0] == '#') break; tire.init(); stringstream ss(s); while(ss &gt;&gt; a) &#123; tire.add(a); &#125; int res = 0; for(int i = 1; i &lt;= tire.tot; ++i) if(tire.cnt[i]) ++res; cout &lt;&lt; res &lt;&lt; "\n"; &#125; return 0;&#125; M - T9 HDU - 1298题目大意： 解题思路： Mycode：12 N - DNA Prefix LightOJ - 1224 【Medium】题目大意： T组数据，每组有N个由ACGT组成的字符串，定义result为 某个前缀的长度 * 拥有这个前缀的字符串的数量，问最大的result是多少。 解题思路： 直接枚举每个前缀，看结果是多少。 枚举每个字符串的前缀，TLE。 从树上枚举。这里我想到了两种方法，一是在建树时记录答案并不断更新，二是建完树后从根结点向下搜索，答案就是 此时前缀数 * 此时的深度，计算并更新最大值就行了。 有点要注意的是只会出现ACGT四种字母，我们可以直接将他们标记为0123，这样省下了部分空间。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;const int MAX = 1e6+5;int t, n, res;char s[55];map&lt;char, int&gt; mapa;struct Tire&#123; int tot, nex[MAX][4], pre[MAX]; void init() &#123; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); tot = 1; &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][mapa[str[i]]]) nex[now][mapa[str[i]]] = ++tot; now = nex[now][mapa[str[i]]]; pre[now]++; &#125; &#125; void dfs(int now, int dep) &#123; for(int i = 0; i &lt; 4; ++i) &#123; if(nex[now][i]) dfs(nex[now][i], dep+1); &#125; if(pre[now] * dep &gt; res) res = pre[now] * dep; &#125; /*int Find(const char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][mapa[str[i]]]) return 0; now = nex[now][mapa[str[i]]]; &#125; return pre[now]; &#125;*/&#125;tire;void init()&#123; mapa['A'] = 0; mapa['C'] = 1; mapa['G'] = 2; mapa['T'] = 3;&#125;int main()&#123; init(); scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; res = 0; tire.init(); scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) scanf("%s", &amp;s), tire.add(s); //从根结点向下搜索，当前深度为0 tire.dfs(1,0); printf("Case %d: %d\n", cas, res); &#125; return 0;&#125; O - Consistency Checker LightOJ - 1129 【Easy】题目大意： 给出T个清单，每个清单上有n个互不相同的电话号码，每个电话号码长度在1 ~ 10之间，问这些清单是否具有一致性，即这张清单中的每个电话号码都不是其他某个号码的前缀。 解题思路： 建树，判断即可。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;int t, n;bool flag;char s[10010][11];struct Tire&#123; int nex[MAX][11], pre[MAX], cnt[MAX], tot; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre));// memset(cnt, 0, sizeof(cnt)); &#125; void add(char* str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; /*for(int j = 0; j &lt;= i; ++j) cout &lt;&lt; str[j]; cout &lt;&lt; " " &lt;&lt; pre[now] &lt;&lt; endl;*/ &#125;// cnt[now]++; &#125; int Find(char* str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125; tire;int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d",&amp;n); tire.init(); flag = true; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", s[i]); tire.add(s[i]); &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(tire.Find(s[i]) &gt; 1) &#123; flag = false; break; &#125; &#125; printf("Case %d: %s\n", cas, flag ? "YES" : "NO"); &#125; return 0;&#125; P - Consecutive Sum LightOJ - 1269题目大意： 解题思路： Mycode：12]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>HDU</tag>
        <tag>解题报告</tag>
        <tag>POJ</tag>
        <tag>LightOj</tag>
        <tag>专题训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玲珑学院 1138 震惊，99%+的中国人都会算错的问题 【容斥】【技巧】]]></title>
    <url>%2Fifrog-1138%2F</url>
    <content type="text"><![CDATA[题目大意：一开始编号1-n中的所有数字都为0，告诉你m个数字，将所有标号为这m个数字的倍数的值都^1，问最后有多少个数字值为1。 解题思路：考虑到n的范围很大，而m最多只有15个值，我们用容斥来做。 因为每次都是编号满足条件的值与1异或，所以值一直在1、0之间变动，因此不能像之前的找倍数那样直接加减。 (比如n=10，m=2，k1 k2分别为2 3时，编号6的值最终结果为0) 换个思路想就是这个格子是否被统计了奇数次(奇数次为1偶数次为0)，按二进制考虑，所以满足$A \times B$的倍数时就应在总数中 $- 2 \times 数量$，当满足$A \times B \times C$的倍数时就$ + 2^ 2 \times 数量$，这样…… 即$± 2 ^{(位数-1)} \times 数量$。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t, m;LL a[20], ans, n;LL gcd(LL a, LL b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;LL lcm(LL a, LL b)&#123; return a / gcd(a, b) * b;&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; ans = 0; scanf("%lld%d",&amp;n,&amp;m); for(int i = 0; i &lt; m; ++i) scanf("%lld",&amp;a[i]); for(int i = 1; i &lt; (1 &lt;&lt; m); ++i) &#123; LL mul = 1; int bits = 0; for(int j = 0; j &lt; m; ++j) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; bits++; mul = lcm(mul, a[j]); if(mul &gt; n) break; &#125; &#125; if(bits &amp; 1) ans += n / mul * (1 &lt;&lt; (bits - 1)); else ans -= n / mul * (1 &lt;&lt; (bits - 1)); &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>玲珑学院</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6299 Balanced Sequence 【贪心】]]></title>
    <url>%2Fhdu-6299%2F</url>
    <content type="text"><![CDATA[题目大意：现有n个字符串，每个串均有若干个()左右括号构成，请你选择一个连接顺序将这些串连在一起，使得匹配的括号对数最多。括号匹配的定义为左括号在右括号左边，每个括号均有一次参与匹配的机会。 解题思路： 首先在输入时对串进行处理，将已经匹配的记录下来，这样剩下的串只有4种情况：1.空串 2.只有左括号 3.只有右括号 4.右括号和左括号的混合 &amp;&amp; 右括号一定在左括号前边。 首先第1种情况肯定不用管了，剩下的该如何安排他们的顺序使得配对的数目最大化呢？肯定是要左括号尽量往左靠，右括号尽量往右靠，这样第2、3种情况也解决了。 最后一种是情况最多的，可以分为 (1).右括号数 &gt; 左括号数 (2).左括号数 &gt; 右括号数 以及 (3).左括号数 == 右括号数。考虑我们最初的目的，左括号尽量往左是为了什么？是为了不“浪费”这些括号，但是当必须“牺牲”一部分括号时，应当将“浪费”降到最低。于是我们找出了排序的关键字key = 左括号数 - 右括号数。两个变量相比较共四种情况：1.key1 &gt; 0 &amp;&amp; key2 &gt; 0 2.key1 &gt; 0 &amp;&amp; key2 &lt; 0 3.key1 &lt; 0 &amp;&amp; key2 &gt; 0 4.key1 &lt; 0 &amp;&amp; key2 &lt; 0，再将相等的情况随便插到几组中所有情况就都有了。这时排序的规则是一正一负正的在前，都为正时右括号少的在前，都为负时左括号多的在前，根据这样排完序挨个取就可以了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;char s[MAX];int t, n, tem, res;struct node&#123; int l, r, sub;&#125;a[MAX];bool cmp(node u, node v)&#123; if(u.sub &gt;= 0 &amp;&amp; v.sub &lt; 0) return true; if(u.sub &lt; 0 &amp;&amp; v.sub &gt;= 0) return false; if(u.sub &gt;= 0 &amp;&amp; v.sub &gt;= 0) return u.r &lt; v.r; return u.l &gt; v.l;&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; res = 0; memset(a, 0, sizeof(a)); scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", s); tem = 0; for(int j = 0; s[j]; ++j) &#123; if(s[j] == '(') ++tem; else &#123; if(tem == 0) ++a[i].r; else &#123; --tem; ++res; &#125; &#125; &#125; a[i].l = tem; a[i].sub = a[i].l - a[i].r; &#125; sort(a, a + n, cmp); tem = a[0].l; for(int i = 1; i &lt; n; ++i) &#123; res += min(tem, a[i].r); tem -= a[i].r; if(tem &lt; 0) tem = 0; tem += a[i].l; &#125; printf("%d\n", res&lt;&lt;1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>HDU</tag>
        <tag>多校联合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6301 Distinct Values 【贪心】【模拟】]]></title>
    <url>%2Fhdu-6301%2F</url>
    <content type="text"><![CDATA[题目大意：找出n个数，满足给出的m个区间内的数都不相同。问满足条件的字典序最小的序列是多少。 解题思路：字典序最小，说明肯定要越小的越往前填，如果没有限制区间的话答案就是$n$个$1$啦，加上后最先出现的区间要最先考虑，即$l_1$ ~ $r_1$内的数为$1$ ~ $r_1 - l_1$，后面的根据出现的顺序(指填到x时最先覆盖x的区间)依次从小往大填就好了。题目的难点就是填数时保证不重复。为了改变区间的顺序，肯定要先排序，排序是根据$l_i$为关键字。排序后模拟填数的过程：碰到区间就改变填的数的值，填数时要记录用过的数字，区间结束记得将区间覆盖不到的点再“收回”。而这个所需要的容器可以用优先队列或者set，想到合适的容器就简单多了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int MAX = 1e5+5;int t, n, m, L, R, res[MAX];struct node&#123; int l, r;&#125;a[MAX];bool cmp(node u, node v)&#123; if(u.l == v.l) return u.r &lt; v.r; return u.l &lt; v.l;&#125;set&lt;int&gt; S;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;n,&amp;m); for(int i = 0; i &lt; m; ++i) scanf("%d%d", &amp;a[i].l, &amp;a[i].r); sort(a, a + m, cmp); S.clear(); for(int i = 1; i &lt;= n; ++i) &#123; res[i] = 1; S.insert(i); &#125; L = a[0].l, R = a[0].r; for(int i = L; i &lt;= R; ++i) &#123; res[i] = *S.begin(); S.erase(S.begin()); &#125; for(int i = 1; i &lt; m; ++i) &#123; while(L &lt; a[i].l) &#123; S.insert(res[L++]); &#125; while(R &lt; a[i].r) &#123; ++R; if(R &lt; L) continue; res[R] = *S.begin(); S.erase(S.begin()); &#125; &#125; for(int i = 1; i &lt;= n; ++i) printf("%d%c", res[i], i == n ? '\n' : ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>HDU</tag>
        <tag>多校联合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 979B Treasure Hunt 【模拟】]]></title>
    <url>%2Fcf-979b%2F</url>
    <content type="text"><![CDATA[题目大意：3个人做游戏，每人初始时拥有一个长度相同的字符串，现每人都要对自己的字符串进行变换操作，问经过n次变换操作后谁的字符串的value最大，value的计算方法是字符串中出现次数最的的字母的次数。变换操作是将自己字符串中的任意一个字母变成除这个字母外的任意一个字母。 解题思路：设初始时出现次数最多的字母为m，之后我们将所有字母变成这个字母就是最佳答案了。变换时要对n进行判断，当n大于非m的字母数量时，最终答案为字符串的长度(即可以将所有字母变为m)，反之，为m的数量+n。【注意：】这里要考虑一种情况，就是n = 1 &amp;&amp; 所有字母都相同的时候，这时答案为字符串长度 - 1。 关于代码：自己写的略微“丑陋”，std看起来是真的舒服，想写这样的代码。现在对“Think twice code once”又有了新的理解，不仅要写正确的代码，还要写在表述清楚的前提下的简洁的代码。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;char a[111111], b[111111], c[111111];map&lt;char, int&gt; ca, cb, cc;int t, la, lb, lc, ra, rb, rc;int main()&#123; scanf("%d%s%s%s",&amp;t,a, b, c); la = strlen(a), lb = strlen(b), lc = strlen(c); for(int i = 0; i &lt; la; ++i) ca[a[i]]++; for(int i = 0; i &lt; lb; ++i) cb[b[i]]++; for(int i = 0; i &lt; lc; ++i) cc[c[i]]++; for(char i = 'a'; i &lt;= 'z'; ++i) &#123; ra = max(ra, ca[i]); rb = max(rb, cb[i]); rc = max(rc, cc[i]); &#125; for(char i = 'A'; i &lt;= 'Z'; ++i) &#123; ra = max(ra, ca[i]); rb = max(rb, cb[i]); rc = max(rc, cc[i]); &#125; if(ra == la &amp;&amp; t == 1) ra--; else ra += t; if(rb == lb &amp;&amp; t == 1) rb--; else rb += t; if(rc == lc &amp;&amp; t == 1) rc--; else rc += t; ra = min(ra, la); rb = min(rb, lb); rc = min(rc, lc); if(ra &gt; rb &amp;&amp; ra &gt; rc) puts("Kuro"); else if(rb &gt; ra &amp;&amp; rb &gt; rc) puts("Shiro"); else if(rc &gt; ra &amp;&amp; rc &gt; rb) puts("Katie"); else puts("Draw"); return 0;&#125; Stdcode:123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int a[256], b[256], c[256], n, ma, mb, mc;string p, q, r;int main() &#123; cin &gt;&gt; n &gt;&gt; p &gt;&gt; q &gt;&gt; r; for (char x: p) ma = max(ma, ++a[x]); for (char x: q) mb = max(mb, ++b[x]); for (char x: r) mc = max(mc, ++c[x]); if (n == 1 &amp;&amp; ma == (int)p.length()) p.pop_back(); if (n == 1 &amp;&amp; mb == (int)q.length()) q.pop_back(); if (n == 1 &amp;&amp; mc == (int)r.length()) r.pop_back(); ma = min(ma + n, (int)p.length()); mb = min(mb + n, (int)q.length()); mc = min(mc + n, (int)r.length()); if (ma &gt; mb &amp;&amp; ma &gt; mc) &#123; puts("Kuro"); return 0; &#125; if (mb &gt; ma &amp;&amp; mb &gt; mc) &#123; puts("Shiro"); return 0; &#125; if (mc &gt; ma &amp;&amp; mc &gt; mb) &#123; puts("Katie"); return 0; &#125; puts("Draw"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 967C Stairs and Elevators 【二分】]]></title>
    <url>%2Fcf-967c%2F</url>
    <content type="text"><![CDATA[题目大意：在一个n层高的楼层里，有m块呈直线连在一起的区域，有cl个楼梯和ce个电梯分别在 $a_1$ ~ $a_{cl}$ 和 $b_1$ ~ $b_{ce}$的位置上，从这个位置可以上到上一层楼或者下一层楼。楼梯1s可以上|下一层楼，电梯1s可以上|下$\leq$ v个楼层，从一块到相邻的一块也需要1s的时间。有q个询问，问最少经过多少时间可以从$x1, y1$到达$x2, y2$。 解题思路： 首先想到的是看走楼梯和走电梯哪个时间最少。如果走楼梯，可以走靠近当前位置的左边最近的或者右边最近的，其他同方向位置的楼梯花费的时间一定大于等于这两个位置。电梯同理。 接下来就是找位置了。找这4个位置的时候，因为给出的电梯/楼梯位置是升序的，所以可以用二分查找。一开始写的是分别二分查这4个位置，后来发现只要查两个位置就好了，比如查电梯的第一个$\geq$y1的位置后，另一个要找的位置就是这个位置左边的那个(如果存在的话)。【注意：】这里有个细节问题不要忽略，就是两位置在一层楼的时候，这时既不需要走楼梯也不需要走电梯。 Mycode(手写二分)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;int n, m, c1, c2, v;int a1[MAX], a2[MAX];int stx, sty, enx, eny, tem;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; v; for(int i = 0; i &lt; c1; ++i) cin &gt;&gt; a1[i]; for(int i = 0; i &lt; c2; ++i) cin &gt;&gt; a2[i]; a2[c2] = a1[c1] = 1e9; int t; cin &gt;&gt; t; while(t--) &#123; int res = 1e9; cin &gt;&gt; stx &gt;&gt; sty &gt;&gt; enx &gt;&gt; eny; if(stx == enx) &#123; res = abs(sty - eny); cout &lt;&lt; res &lt;&lt; endl; continue; &#125; int l, r, m, pos; if(c1) &#123; pos = -1, l = 0, r = c1; while(l &lt;= r) &#123; m = (l + r) &gt;&gt; 1; if(a1[m] &gt;= sty) &#123; r = m - 1; pos = m; &#125; else l = m + 1; &#125; if(pos != -1) &#123; tem = abs(sty - a1[pos]); tem += abs(eny - a1[pos]); tem += abs(stx - enx); res = min(res, tem); &#125;// cout &lt;&lt; pos &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt;tem &lt;&lt; " " &lt;&lt; res &lt;&lt; endl; pos = -1, l = 0, r = c1; while(l &lt;= r) &#123; m = (l + r) &gt;&gt; 1; if(a1[m] &lt;= sty) &#123; l = m + 1; pos = m; &#125; else r = m - 1; &#125; if(pos != -1) &#123; tem = abs(sty - a1[pos]); tem += abs(eny - a1[pos]); tem += abs(stx - enx); res = min(res, tem); &#125; &#125;// cout &lt;&lt; pos &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt;tem &lt;&lt; " " &lt;&lt; res &lt;&lt; endl; if(c2) &#123; pos = -1, l = 0, r = c2; while(l &lt;= r) &#123; m = (l + r) &gt;&gt; 1; if(a2[m] &gt;= sty) &#123; r = m - 1; pos = m; &#125; else l = m + 1; &#125; if(pos != -1) &#123; tem = abs(sty - a2[pos]); tem += abs(eny - a2[pos]); int tt = abs(stx - enx); tem += tt / v; if(tt % v) tem++; res = min(res, tem); &#125;// cout &lt;&lt; pos &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt;tem &lt;&lt; " " &lt;&lt; res &lt;&lt; endl; pos = -1, l = 0, r = c2; while(l &lt;= r) &#123; m = (l + r) &gt;&gt; 1; if(a2[m] &lt;= sty) &#123; l = m + 1; pos = m; &#125; else r = m - 1; &#125; if(pos != -1) &#123; tem = abs(sty - a2[pos]); tem += abs(eny - a2[pos]); int tt = abs(stx - enx); tem += tt / v; if(tt % v) tem++; res = min(res, tem); &#125; &#125;// cout &lt;&lt; pos &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt;tem &lt;&lt; " " &lt;&lt; res &lt;&lt; endl; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; Mycode(stl二分):12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;int n, m, cl, ce, v;int a1[MAX], a2[MAX];int stx, sty, enx, eny, tem, res;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;cl,&amp;ce,&amp;v); for(int i = 0; i &lt; cl; ++i) scanf("%d",&amp;a1[i]); for(int i = 0; i &lt; ce; ++i) scanf("%d",&amp;a2[i]); a1[cl] = a2[ce] = 1e9; int t; scanf("%d",&amp;t); while(t--) &#123; res = 1111111111; scanf("%d%d%d%d",&amp;stx,&amp;sty,&amp;enx,&amp;eny); if(stx == enx) res = abs(sty - eny); else &#123; if(cl &gt; 0) &#123; int pos = lower_bound(a1, a1+cl, sty) - a1; if(a1[pos] != 1e9) &#123; tem = 0; tem += abs(sty-a1[pos]); tem += abs(eny-a1[pos]); tem += abs(stx-enx); res = min(res, tem); &#125; if(pos &gt; 0) &#123; --pos; tem = 0; tem += abs(sty-a1[pos]); tem += abs(eny-a1[pos]); tem += abs(stx-enx); res = min(res, tem); &#125; &#125; if(ce &gt; 0) &#123; int pos = lower_bound(a2, a2+ce, sty) - a2; if(a2[pos] != 1e9) &#123; tem = 0; tem += abs(sty-a2[pos]); tem += abs(eny-a2[pos]); tem += ceil((double)abs(stx-enx)/v); res = min(res, tem); &#125; if(pos &gt; 0) &#123; --pos; tem = 0; tem += abs(sty-a2[pos]); tem += abs(eny-a2[pos]); tem += ceil((double)abs(stx-enx)/v); res = min(res, tem); &#125; &#125; &#125; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第六章习题】【2/14】]]></title>
    <url>%2Flrj-ch6-1%2F</url>
    <content type="text"><![CDATA[UVa 673 Parentheses Balance 【stack】题目大意：括号匹配 解题思路：借助栈来实现的括号匹配，最基础的应用。注意可能出现的不匹配情况：1.数量不匹配 2.类型不匹配 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;stack&gt;using namespace std;int t;string s;int main()&#123; cin &gt;&gt; t; getchar(); while(t--) &#123; getline(cin, s); bool flag = true; stack&lt;char&gt; S; for(int i = 0; i &lt; s.size() &amp;&amp; flag; ++i) &#123; if(s[i] == '(' || s[i] == '[') S.push(s[i]); else if(s[i] == ')') &#123; if(!S.empty() &amp;&amp; S.top() == '(') S.pop(); else flag = false; &#125; else if(s[i] == ']') &#123; if(!S.empty() &amp;&amp; S.top() == '[') S.pop(); else flag = false; &#125; &#125; if(!S.empty()) flag = false; puts(flag ? "Yes" : "No"); &#125; return 0;&#125; UVa 439 Knight Moves【BFS】题目大意：在一个8 * 8的棋盘上给你一个象棋“马”的位置，问这个马能最少用多少步到达目标位置。马行走的方式为“日”字型。 解题思路：因为范围很小，直接BFS即可，这里搜的时候同时记录走过的位置。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;bool vis[11][11];char s1[5], s2[5];int stx, sty, enx, eny;int dir[][2] = &#123;1,2,-1,2,2,1,-2,1,-1,-2,-2,-1,1,-2,2,-1&#125;;struct node&#123; int x, y, cnt;&#125;;bool check(int x, int y)&#123; if(vis[x][y]) return false; if(x &lt; 1 || x &gt; 8 || y &lt; 1 || y &gt; 8) return false; return true;&#125;int main()&#123; while(~scanf("%s%s", s1, s2)) &#123; memset(vis, 0, sizeof(vis)); stx = s1[0] - 'a' + 1; sty = s1[1] - '1' + 1; enx = s2[0] - 'a' + 1; eny = s2[1] - '1' + 1; vis[stx][sty] = 1; node now, nex; queue&lt;node&gt; Q; Q.push(node&#123;stx, sty, 0&#125;); while(!Q.empty()) &#123; now = Q.front(); if(now.x == enx &amp;&amp; now.y == eny) &#123; printf("To get from %s to %s takes %d knight moves.\n", s1, s2, now.cnt); break; &#125; Q.pop(); for(int i = 0; i &lt; 8; ++i) &#123; nex.x = now.x + dir[i][0]; nex.y = now.y + dir[i][1]; if(!check(nex.x, nex.y)) continue; nex.cnt = now.cnt + 1; Q.push(nex); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>并查集</tag>
        <tag>BFS</tag>
        <tag>queue</tag>
        <tag>解题报告</tag>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>数据结构</tag>
        <tag>stack</tag>
        <tag>list</tag>
        <tag>二叉树</tag>
        <tag>拓扑排序</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第六章例题】【17/22】]]></title>
    <url>%2Flrj-ch6-0%2F</url>
    <content type="text"><![CDATA[UVa 210 Concurrency Simulator 【Deque】题目大意：本题需要你模拟一些简单程序，每一个程序有以下5种指令： var = val，给变量赋值，简单起见保证变量名为一个字母，变量为所有进程共用，并且初始为0，保证val是不大于100的正整数； print var,输出变量var； lock对所有变量申请独占访问(不影响赋值和打印) unlock解除独占访问 end结束程序以上指令分别消耗t1,t2,t3,t4,t5的时间,一开始进程按照输入顺序依次插入到等待队列中，每次从等待队列队首选择一个进程执行。每个进程有一个配额(限定时间)Q，当配额用完时,该进程会在执行完当前语句后被立即插入到一个等待队列尾部中。但是lock语句和unlock语句会改变进程的执行顺序。当一个程序执行了lock语句,其他进程再执行到lock语句时会被立即插入到一个阻止队列队尾,当程序执行到unlock语句时，阻止队列的队首的第一个进程会被立即插入到等待队列队首。 解题思路：总体看来需要两个队列分别存取lock的进程和ready(等待)的进程。存取lock进程的队列只需要插入到队尾和从队首取这两种操作即可，普通队列就可完成；存取ready进程的队列除从队首取元素外，既需要插入到队尾又需要插入到队首，故需要双端队列来实现。然后模拟整个过程即可。具体实现时先把所有操作都存下来，并记录每个起始进程的坐标，然后模拟进程的运行，执行相应语句就行了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;deque&gt;using namespace std;bool flag;char s[1111][11];int t, n, c[5], q, val[26], ip[1111];queue&lt;int&gt; B;deque&lt;int&gt; R;void run(int idx)&#123; int T = q; while(T &gt; 0) &#123; char *p = s[ip[idx]]; switch(p[2]) &#123; case '=': //? = ? val[p[0] - 'a'] = isdigit(p[5]) ? (p[4] - '0') * 10 + p[5] - '0' : p[4]- '0'; T -= c[0]; break; case 'i': //print printf("%d: %d\n", idx, val[p[6] - 'a']); T -= c[1]; break; case 'c': //lock if(flag) &#123; B.push(idx); return ; &#125; flag = true; T-= c[2]; break; case 'l': //unlock flag = false; if(!B.empty()) &#123; int idx2 = B.front(); B.pop(); R.push_front(idx2); &#125; T-= c[3]; break; case 'd': return ; &#125; ip[idx]++; &#125; R.push_back(idx);&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; flag = false; memset(val, 0, sizeof(val)); scanf("%d%d%d%d%d%d%d",&amp;n,&amp;c[0],&amp;c[1],&amp;c[2],&amp;c[3],&amp;c[4],&amp;q); int line = 1; for(int i = 1; i &lt;= n; ++i) &#123; fgets(s[line++], 1111, stdin); ip[i] = line - 1; while(s[line - 1][2] != 'd') &#123; fgets(s[line++], 1111, stdin); &#125; R.push_back(i); &#125; while(!R.empty()) &#123; int idx1 = R.front(); R.pop_front(); run(idx1); &#125; if(t) puts(""); &#125; return 0;&#125; UVa 514 Rails【stack】题目大意：编号为1 ~ n 的n个元素依次入栈，问给出的出栈顺序是否是合法的。 解题思路：直接模拟比对即可。 Mycode：12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;stack&gt;using namespace std;int n, a[1111];int main()&#123; while(cin &gt;&gt; n &amp;&amp; n) &#123; while(cin &gt;&gt; a[1] &amp;&amp; a[1]) &#123; for(int i = 2; i &lt;= n; ++i) cin &gt;&gt; a[i]; int cnt = 1; stack&lt;int&gt; s; for(int i = 1; i &lt;= n; ++i) &#123; s.push(i); while(!s.empty() &amp;&amp; s.top() == a[cnt]) &#123; s.pop(); ++cnt; &#125; &#125; puts(s.empty() ? "Yes" : "No"); &#125; puts(""); &#125; return 0;&#125; UVa 442 Matrix Chain Multiplication【stack】题目大意：给出$t$个$n \times m$的矩阵，问给出的矩阵乘法表达式是否合法，合法的话进行了多少次普通乘法。 解题思路：$p \times q$ 的矩阵 只能与$q \times r$的矩阵相乘，此时进行的乘法次数为$p \times q \times r$次，再与其他相乘的时候就是次数之和了。表达式用栈来模拟就好了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;char ch;string op;int n, a, b;int main()&#123; while(cin &gt;&gt; n) &#123; map&lt;char, pair&lt;int, int&gt; &gt; mapa; for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; ch &gt;&gt; a &gt;&gt; b; mapa[ch] = make_pair(a, b); &#125; while(cin &gt;&gt; op) &#123; stack&lt;pair&lt;int, int&gt; &gt; num; int res = 0; bool flag = true; for(int i = 0; i &lt; op.size(); ++i) &#123; if(op[i] == '(') &#123; continue; &#125; else if(op[i] == ')') &#123; pair&lt;int, int&gt; p, q; p = num.top(); num.pop(); q = num.top(); num.pop(); if(q.second != p.first) &#123; flag = false; break; &#125; res += q.first * p.second * p.first; num.push(make_pair(q.first, p.second)); &#125; else &#123; num.push(mapa[op[i]]); &#125; &#125; if(flag) printf("%d\n", res); else puts("error"); &#125; &#125; return 0;&#125; UVa 11988 Broken Keyboard (a.k.a. Beiju Text) 【链表】题目大意：Albert的键盘出现了奇妙的故障，所有键都会正常的工作，但是键盘上的Home以及End键有时候会莫名其妙的自己按下。但是盲打很熟练的他一般习惯关闭显示器打字，因为这样很酷。 现在他正在打一段文本，假设你已经知道这段文本以及Home和End键会什么时候出现故障自行按下。请你编写一个程序，求出他最后打出的文本。 解题思路： 用数组保存这段文本，然后设置一个变量pos保存光标位置，这样输入一个字符相当于在数组中插入一个字符，这时把后面的字符向后移动就可以了。 但是这样会超时。 采用链表，每输入一个字符就把它存起来，设输入的字符串是s[1~n]，则可以用next[i]表示在当前显示屏中s[i]右边的字符编号(在s中的下标)。 具体做法：用变量记录当前位置和最后一个字母的位置，模拟移动、插入过程。方便起见，开头设置一个虚拟结点。 链表：用数组模拟链表的方法：一个数组记录原本的值，另一个数组记录该位置的下一个位置的下标。 Mycode：1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char s[111111];int cur, las, nex[111111];int main()&#123; while(~scanf("%s", s + 1)) &#123; int len = strlen(s + 1); cur = las = nex[0] = 0; for(int i = 1; i &lt;= len; ++i) &#123; if(s[i] == '[') cur = 0; else if(s[i] == ']') cur = las; else &#123; nex[i] = nex[cur]; nex[cur] = i; if(cur == las) las = i; cur = i; &#125; &#125; for(int i = nex[0]; i != 0; i = nex[i]) printf("%c", s[i]); puts(""); &#125; return 0;&#125; UVa 12657 Boxes in a Line【链表】题目大意：现有从左到右编号为1 ~ n的n个盒子摆成一行，分别执行如下4种指令的某些指令，问执行后所有奇数位置的盒子的编号之和。指令有： 1 x y 将盒子x移动到盒子y的左边 (如果x已经在y的左边，忽略此指令) 2 x y 将盒子x移动到盒子y的右边 (如果x已经在y的右边，忽略此指令) 3 x y 交换盒子x和y的位置 4 反转整条链 解题思路：采用双向链表模拟整个过程。 解后有感：小技巧： 对于过程4我们可以不用模拟反转的过程，用个标志进行记录是否进行了反转就可以。如果反转了，那1、2操作将变为相应的2、1操作，3操作无影响，最后结果记录偶数的位置就行。 关于代码：感觉自己写的十分“朴素”，写完后虽然能AC，但日后再看起肯定不好理解，而且调试时也不那么得心应手。看完LRJ大爷的代码，真真感觉到了自己菜爆。 首先链表的连接操作用一个函数表示，减少代码量的同时增加了美观性，方便调试。 链表建立时建的循环链表，而且一个循环left和right都构建完了，还是比我的好看多了。 特判交换位置时的那部分，将两种情况合为一种(其实就是xy的位置不同，完全能想到的)，也就减少了代码量。 最后的计算只计算正着看的奇数位的和，反转时直接用总和减去此时的值。 日后注意的地方： 多次用到一种计算时写成函数 先思考后写代码，逻辑弄清后再写 能用1行代码写清楚的地方就不用2行。 最后附上我和LRJ大爷的代码 对比感受一下。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, m;int op, x, y;int tem1, tem2;long long res;int rig[111111], lef[111111];void init()&#123; memset(rig, 0, sizeof(rig)); memset(lef, 0, sizeof(lef)); for(int i = 0; i &lt;= n; ++i) rig[i] = i + 1; for(int i = n + 1; i &gt; 0; --i) lef[i] = i - 1;&#125;void debug()&#123; cout &lt;&lt; "\n**************\n"; for(int i = 0; i &lt;= n+1; ++i) cout &lt;&lt; rig[i] &lt;&lt; " "; cout &lt;&lt; endl; for(int i = 0; i &lt;= n+1; ++i) cout &lt;&lt; lef[i] &lt;&lt; " "; cout &lt;&lt; endl; for(int i = rig[0], j = 1; j &lt;= n; i = rig[i], ++j) cout &lt;&lt; i &lt;&lt; " "; cout &lt;&lt; endl; cout &lt;&lt; "**************\n\n";&#125;int main()&#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); for(int cas = 1; ~scanf("%d%d",&amp;n,&amp;m); ++cas) &#123; init(); bool flag = true; while(m--) &#123;// debug(); scanf("%d",&amp;op); if(op == 4) &#123; flag = !flag; continue; &#125; if(op &lt; 3 &amp;&amp; !flag) op = 3 - op; scanf("%d%d",&amp;x,&amp;y); switch(op) &#123; case 1: if(x == lef[y]) break; rig[lef[x]] = rig[x]; lef[rig[x]] = lef[x]; rig[x] = y; lef[x] = lef[y]; rig[lef[y]] = x; lef[y] = x; break; case 2: if(x == rig[y]) break; rig[lef[x]] = rig[x]; lef[rig[x]] = lef[x]; lef[x] = y; rig[x] = rig[y]; lef[rig[y]] = x; rig[y] = x; break; case 3: if(x == lef[y]) &#123; tem1 = rig[y]; tem2 = lef[x]; lef[y] = tem2; rig[tem2] = y; rig[x] = tem1; lef[tem1] = x; lef[x] = y; rig[y] = x; &#125; else if(x == rig[y]) &#123; tem1 = rig[x]; tem2 = lef[y]; rig[y] = tem1; lef[tem1] = y; lef[x] = tem2; rig[tem2] = x; lef[y] = x; rig[x] = y; &#125; else &#123; tem1 = lef[y]; tem2 = rig[y]; lef[y] = lef[x]; rig[y] = rig[x]; rig[lef[x]] = y; lef[rig[x]] = y; lef[x] = tem1; rig[x] = tem2; rig[tem1] = x; lef[tem2] = x; &#125; break; &#125; &#125;// debug(); res = 0; if(flag) &#123;// cout &lt;&lt; "orign !\n"; for(int i = rig[0], j = 1; j &lt;= n; i = rig[i], ++j) if(j &amp; 1) res += i; &#125; else &#123;// cout &lt;&lt; "reverse !\n"; for(int i = lef[n + 1], j = 1; j &lt;= n; i = lef[i], ++j) if(j &amp; 1) res += i; &#125; printf("Case %d: %lld\n", cas, res); &#125; return 0;&#125; LRJ’s code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// UVa12657 Boxes in a Line// Rujia Liu#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;int n, left[maxn], right[maxn];inline void link(int L, int R) &#123; right[L] = R; left[R] = L;&#125;int main() &#123; int m, kase = 0; while(scanf("%d%d", &amp;n, &amp;m) == 2) &#123; for(int i = 1; i &lt;= n; i++) &#123; left[i] = i-1; right[i] = (i+1) % (n+1); &#125; right[0] = 1; left[0] = n; int op, X, Y, inv = 0; while(m--) &#123; scanf("%d", &amp;op); if(op == 4) inv = !inv; else &#123; scanf("%d%d", &amp;X, &amp;Y); if(op == 3 &amp;&amp; right[Y] == X) swap(X, Y); if(op != 3 &amp;&amp; inv) op = 3 - op; if(op == 1 &amp;&amp; X == left[Y]) continue; if(op == 2 &amp;&amp; X == right[Y]) continue; int LX = left[X], RX = right[X], LY = left[Y], RY = right[Y]; if(op == 1) &#123; link(LX, RX); link(LY, X); link(X, Y); &#125; else if(op == 2) &#123; link(LX, RX); link(Y, X); link(X, RY); &#125; else if(op == 3) &#123; if(right[X] == Y) &#123; link(LX, Y); link(Y, X); link(X, RY); &#125; else &#123; link(LX, Y); link(Y, RX); link(LY, X); link(X, RY); &#125; &#125; &#125; &#125; int b = 0; long long ans = 0; for(int i = 1; i &lt;= n; i++) &#123; b = right[b]; if(i % 2 == 1) ans += b; &#125; if(inv &amp;&amp; n % 2 == 0) ans = (long long)n*(n+1)/2 - ans; printf("Case %d: %lld\n", ++kase, ans); &#125; return 0;&#125; UVa 679 Dropping Balls 【二叉树编号】题目大意：一棵二叉树最大深度为D，所有叶子的深度都相同，所有结点从上到下从左到右编号为1，2，3，……，$2^D - 1$。在结点1处放个小球，它会往下落。每个结点处都有一个开关，初始时全部关闭，当有小球落到一个开关时其状态就会改变。当小球到达结点时若此开关开着则往左走，否则往右走，直到走到叶子结点。一些球从1处依次往下落，问第i个会落在哪。 解题思路：很明显对于一个结点k而言，其左子结点为$2 \times k$，右子结点为$2 \times k + 1$。因为每个球最终都会落在叶子结点上，所以前两个一定是第一个落在左子树上，第二个落在右子树上。推广到一般来看，只需知道小球是第几个落在根的子树里的就能知道它下一步是往左还是往右了。具体的，拿第一步为例，如果一开始i &amp; 1，那它就往左，此时位置变为1 &lt;&lt; 1，在新的“根结点”处它就成了第i + 1 &lt;&lt; 1个来到此结点的小球了；同理，如果一开始!(i &amp; 1)，那它就往右，位置变为1 &lt;&lt; 1 | 1，新的“根结点”处变成第i &lt;&lt; 1个到此位置的小球。然后我们就可以反复执行此过程直到小球落到叶子结点了。 Mycode：12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, d;int main()&#123; while(cin &gt;&gt; t &amp;&amp; t != -1) &#123; while(t--) &#123; cin &gt;&gt; d &gt;&gt; n; int k = 1; for(int i = 1; i &lt; d; ++i) &#123; if(n &amp; 1) &#123; k = k &lt;&lt; 1; n = n + 1 &gt;&gt; 1; &#125; else &#123; k = k &lt;&lt; 1 | 1; n = n &gt;&gt; 1; &#125; &#125; cout &lt;&lt; k &lt;&lt; endl; &#125; &#125; return 0;&#125; UVa 122 Trees on the level 【二叉树的层次遍历】题目大意：输入一颗二叉树，请你从上到下、从左到右的顺序输出各个结点的值。输入的格式详情参照题目说明。 解题思路： 我们可以将树上结点编号，然后把二叉树存到数组里。结点最多256个，如果他们形成一条链的话，最后一个结点的编号高达$2^{256} - 1​$，数组根本开不下。 采用动态结构，将需要的建立新的结点，然后将其组织成一棵树。 PS：下面的代码是参照LRJ大爷给出的代码写的，随着学习的深入越加觉得LRJ大爷真是tql！ Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int MAX = 1111;bool flag;char s[MAX];struct node&#123; int val; bool have_val; node *left, *right; node() : have_val(false), left(NULL), right(NULL) &#123;&#125;&#125; *root;void addnode(int val, char* s)&#123; node* u = root; for(int i = 0; s[i]; ++i) &#123; if(s[i] == 'L') &#123; if(u -&gt; left == NULL) u -&gt; left = new node(); u = u -&gt; left; &#125; else if(s[i] == 'R') &#123; if(u -&gt; right == NULL) u -&gt; right = new node(); u = u -&gt; right; &#125; &#125; if(u -&gt; have_val) flag = false; u -&gt; val = val; u -&gt; have_val = true;&#125;void delete_tree(node* u)&#123; if(u == NULL) return ; delete_tree(u -&gt; left); delete_tree(u -&gt; right); delete u;&#125;bool read()&#123; flag = true; delete_tree(root); root = new node(); for(;;) &#123; if(scanf("%s", s) != 1) return false; if(strcmp(s, "()") == 0) break; int v; sscanf(&amp;s[1], "%d", &amp;v); addnode(v, strchr(s, ',')+1); &#125; return true;&#125;bool bfs(vector&lt;int&gt;&amp; res)&#123; res.clear(); queue&lt;node*&gt; Q; Q.push(root); while(!Q.empty()) &#123; node* u = Q.front(); Q.pop(); if(!u -&gt; have_val) return false; res.push_back(u -&gt; val); if(u -&gt; left != NULL) Q.push(u -&gt; left); if(u -&gt; right != NULL) Q.push(u -&gt; right); &#125; return true;&#125;int main()&#123; vector&lt;int&gt; res; while(read()) &#123; if(!bfs(res)) flag = false; if(flag) &#123; for(int i = 0; i &lt; res.size(); ++i) &#123; printf("%d%c", res[i], i == res.size() - 1 ? '\n' : ' '); &#125; &#125; else puts("not complete"); &#125; return 0;&#125; UVa 548 Tree 【二叉树的递归遍历】题目大意：给出一颗点带权的二叉树的中序和后序遍历，找一个叶子使得它到根的路径上的权和最小。如果有多解，该叶子本身权应尽量小。 解题思路：后序遍历的最后一个字符是根，我们在中序遍历中找到它，然后就可以找到左右子树的中序和后序遍历了。根据这个把树通过递归构建出来，然后再执行一次递归遍历来找最优解就OK了。 Mycode：(参考紫书)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int MAX = 10010;int n, in_order[MAX], post_order[MAX], lch[MAX], rch[MAX];bool read_list(int* a)&#123; string line; if(!getline(cin, line)) return false; stringstream ss(line); n = 0; int x; while(ss &gt;&gt; x) a[n++] = x; return n &gt; 0;&#125;int build(int L1, int R1, int L2, int R2)&#123; if(L1 &gt; R1) return 0; int root = post_order[R2]; int p = L1; while(in_order[p] != root) ++p; int cnt = p - L1; lch[root] = build(L1, p-1, L2, L2+cnt-1); rch[root] = build(p+1, R1, L2+cnt, R2-1); return root;&#125;int best, bestsum;void dfs(int u, int sum)&#123; sum += u; if(!lch[u] &amp;&amp; !rch[u]) &#123; if(sum &lt; bestsum || (sum == bestsum &amp;&amp; u &lt; best)) &#123; best = u; bestsum = sum; &#125; &#125; if(lch[u]) dfs(lch[u], sum); if(rch[u]) dfs(rch[u], sum);&#125;int main()&#123; while(read_list(in_order)) &#123; read_list(post_order); build(0, n-1, 0, n-1); bestsum = 1111111111; dfs(post_order[n-1], 0); printf("%d\n", best); &#125; return 0;&#125; UVa 839 Not so Mobile【二叉树的递归遍历】题目大意：输入一个树状天平，根据力矩相等原则判断是否平衡。采用递归方式输入，0表示中间结点。 解题思路：其实可以直接做，就是看怎么写写的既简洁又高效，直接保留书上给的代码了，就不献丑了。。 LRJ’s code:123456789101112131415161718192021222324252627282930313233// 算法：在“建树”时直接读入并判断，并且无须把树保存下来#include&lt;iostream&gt;using namespace std;// 输入一个子天平，返回子天平是否平衡，参数W修改为子天平的总重量bool solve(int&amp; W)&#123; int W1, D1, W2, D2; bool b1 = true, b2 = true; cin &gt;&gt; W1 &gt;&gt; D1 &gt;&gt; W2 &gt;&gt; D2; if(!W1) b1 = solve(W1); if(!W2) b2 = solve(W2); W = W1 + W2; return b1 &amp;&amp; b2 &amp;&amp; (W1 * D1 == W2 * D2);&#125;int main()&#123; int T, W; cin &gt;&gt; T; while(T--) &#123; if(solve(W)) cout &lt;&lt; "YES\n"; else cout &lt;&lt; "NO\n"; if(T) cout &lt;&lt; "\n"; &#125; return 0;&#125; UVa 699 The Falling Leaves【二叉树的递归遍历】题目大意：给一颗二叉树，每个节点都有一个水平位置，左子结点在它左边一个单位，右子结点在它右边一个单位。按照先序遍历的方式输入，请你从左到右输出每个水平位置的所有结点的权值之和。 解题思路：按照递归建树的思想，输入的同时直接进行记录，真正的树不必记录下来。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 222;int sum[MAX];void build(int pos)&#123; int v; scanf("%d", &amp;v); if(v == -1) return ; sum[pos] += v; build(pos - 1); build(pos + 1);&#125;bool init()&#123; int v; scanf("%d", &amp;v); if(v == -1) return false; memset(sum, 0, sizeof(sum)); int pos = MAX &gt;&gt; 1; sum[pos] = v; build(pos - 1); build(pos + 1); return true;&#125;int main()&#123; for(int cas = 1; init(); ++cas) &#123; printf("Case %d:\n", cas); int p = 0; while(sum[p] == 0) ++p; printf("%d", sum[p++]); while(sum[p] != 0) printf(" %d", sum[p++]); puts("\n"); &#125; return 0;&#125; UVa 297 Quadtrees【四叉树】题目大意：给两棵四分树的先序遍历，求二者合并之后（黑色部分合并）黑色像素的个数。p表示中间结点，f表示黑色(full)，e表示白色(empty)。 解题思路：根据前面二叉树递归建树的思想建四叉树，然后统计就可以了。 然后，这个题有毒吧？我写的为啥过不了啊？？uDebug上的数据AC的代码过不了，我的能过，这都什么啊，找了一上午的问题，愣是没找出来。难受啊。把输入的字符串定义为全局变量直接访问而非通过参数传递访问就AC了。UPD：经过一下午的对比，发现因为我字符数组定义的位置不同，返回的结果不一样？定义在最上面AC，中间RE，最下面WA，真是神了。。 Mycode(Wrong Answer)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1024 + 10;//char s[MAX] 放这里 ACint n, res, pos;//char s[MAX] 放这里 REbool vis[35][35];char s[MAX]; //放这里 WAvoid solve(char* s, int x, int y, int w)&#123; char op = s[pos++]; if(op == 'p') &#123; solve(s, x, y + w / 2, w / 2); solve(s, x, y, w / 2); solve(s, x + w / 2, y, w / 2); solve(s, x + w / 2, y + w / 2, w / 2); &#125; else if(op == 'f') &#123; for(int i = x; i &lt; x + w; ++i) &#123; for(int j = y; j &lt; y + w; ++j) &#123; if(vis[i][j] == false) &#123; vis[i][j] = true; ++res; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); while(n--) &#123; res = 0; memset(vis, false, sizeof(vis)); for(int i = 0; i &lt; 2; ++i) &#123; pos = 0; scanf("%s", s); solve(s, 0, 0, 32); &#125; printf("There are %d black pixels.\n", res); &#125; return 0;&#125; Mycode(Accepted):1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1024 + 10;char s[MAX];int n, res, pos;bool vis[35][35];void solve(int x, int y, int w)&#123; char op = s[pos++]; if(op == 'p') &#123; solve(x, y + w / 2, w / 2); solve(x, y, w / 2); solve(x + w / 2, y, w / 2); solve(x + w / 2, y + w / 2, w / 2); &#125; else if(op == 'f') &#123; for(int i = x; i &lt; x + w; ++i) &#123; for(int j = y; j &lt; y + w; ++j) &#123; if(vis[i][j] == false) &#123; vis[i][j] = true; ++res; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); while(n--) &#123; res = 0; memset(vis, false, sizeof(vis)); for(int i = 0; i &lt; 2; ++i) &#123; pos = 0; scanf("%s", s); solve(0, 0, 32); &#125; printf("There are %d black pixels.\n", res); &#125; return 0;&#125; LRJ’s code:1234567891011121314151617181920212223242526272829303132333435363738394041424344// UVa297 Quadtrees// Rujia Liu// 题意：给两棵四分树的先序遍历，求二者合并之后（黑色部分合并）黑色像素的个数。p表示中间结点，f表示黑色（full），e表示白色（empty）// 算法：先建树，然后统计#include&lt;cstdio&gt;#include&lt;cstring&gt;const int len = 32;const int maxn = 1024 + 10;char s[maxn];int buf[len][len], cnt;// 把字符串s[p..]导出到以(r,c)为左上角，边长为w的缓冲区中// 2 1// 3 4void draw(const char* s, int&amp; p, int r, int c, int w) &#123; char ch = s[p++]; if(ch == 'p') &#123; draw(s, p, r, c+w/2, w/2); // 1 draw(s, p, r, c , w/2); // 2 draw(s, p, r+w/2, c , w/2); // 3 draw(s, p, r+w/2, c+w/2, w/2); // 4 &#125; else if(ch == 'f') &#123; // 画黑像素（白像素不画） for(int i = r; i &lt; r+w; i++) for(int j = c; j &lt; c+w; j++) if(buf[i][j] == 0) &#123; buf[i][j] = 1; cnt++; &#125; &#125;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; memset(buf, 0, sizeof(buf)); cnt = 0; for(int i = 0; i &lt; 2; i++) &#123; scanf("%s", s); int p = 0; draw(s, p, 0, 0, len); &#125; printf("There are %d black pixels.\n", cnt); &#125; return 0;&#125; UVa 572 Oil Deposits 【DFS】题目大意：求给定的图中有多少个@的连通块，每个@与它周围相邻的八个小块是联通的。 解题思路：DFS入门题。可以用vis标记访问过的内容，也可以直接将访问过的改为无关的符号(用过一次不再用时可以这样做)。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 105;int dir[][2] = &#123;0,1,1,0,0,-1,-1,0,1,1,-1,-1,1,-1,-1,1&#125;;int n, m, res;char mapa[MAX][MAX];void DFS(int x, int y)&#123; int xx, yy; for(int i = 0; i &lt; 8; ++i) &#123; xx = x + dir[i][0]; yy = y + dir[i][1]; if(xx &lt; 1 || yy &lt; 1 || xx &gt; n || yy &gt; m) continue; if(mapa[xx][yy] == '*') continue; mapa[xx][yy] = '*'; DFS(xx, yy); &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m)) &#123; res = 0; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) cin &gt;&gt; mapa[i][j]; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) if(mapa[i][j] == '@') DFS(i, j), ++res; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; UVa 1103 Ancient Messages 【DFS】题目大意：编程识别6种古代象形文字，每组数据包含一个H行W列的字符矩阵，每个字符矩阵为4个相邻像素点的十六进制(eg: $10011100$ 对应字符就是$9C$)。转化为2进制后，1代表黑点，0代表白点。输入满足：1.不会出现上述6种符号外的其他符号。2.输入至少包含一个符号，且每个黑像素都属于一个符号。3.图像中的每个黑色像素都是有效象形文字的一部分。4.象形文字不接触也不包含。5.如果两个黑像素有公共顶点那么他们一定有公共边。6.所有符号形状和给出的图形拓扑等价(可以随意拉伸但不能拉断)。 解题思路：1.16进制转换为2进制，建图。2.观察发现每个图都有一个与其他图像完全不同的特征——洞的个数，可以把此作为为突破点。3.第一遍把所有象形文字“抠”出来，具体操作是将所有为0的部分标记一下。4.第二遍开始给每个象形文字的洞标号。具体操作是找没被标记的部分开始DFS，将第i个图的洞全部标记为i号。5.第三遍数洞的个数。因为上一步已经将第i号的洞标记为了i，这时就遍历整个图看有几个连通块编号为i即可。(自己的代码不够精简，很明显的DFS0和DFS1是可以合并的，加个if判断就好了)【小技巧】因为步骤一中第一个非象形文字的洞的0不好确定，所以我们建图时可以从(1,1)开始存储给出的图，这样(0,0)必定是非象形文字的洞的0了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 205;string res;int vis[MAX][MAX];int mapa[MAX][MAX];map&lt;char, string&gt; q;int h, w, cas, tot, t;string ans = "WAKJSD";int dir[][2] = &#123;0,1,1,0,-1,0,0,-1&#125;;void debug()&#123; for(int i = 0; i &lt;= h + 1; ++i) &#123; for(int j = 0; j &lt;= w * 4 + 1; ++j) &#123; cout &lt;&lt; mapa[i][j]; &#125; cout &lt;&lt; endl; &#125;&#125;void debug2()&#123; for(int i = 0; i &lt;= h + 1; ++i) &#123; for(int j = 0; j &lt;= w * 4 + 1; ++j) &#123; cout &lt;&lt; vis[i][j]; &#125; cout &lt;&lt; endl; &#125;&#125;void initq()&#123; q['0'] = "0000"; q['1'] = "0001"; q['2'] = "0010"; q['3'] = "0011"; q['4'] = "0100"; q['5'] = "0101"; q['6'] = "0110"; q['7'] = "0111"; q['8'] = "1000"; q['9'] = "1001"; q['a'] = "1010"; q['b'] = "1011"; q['c'] = "1100"; q['d'] = "1101"; q['e'] = "1110"; q['f'] = "1111";&#125;void init()&#123; tot = 1; res = ""; memset(vis, 0, sizeof(vis)); memset(mapa, 0, sizeof(mapa));&#125;void Readmap()&#123; char tem; string t; int tot = 0; for(int i = 0; i &lt; h * w; ++i) &#123; cin &gt;&gt; tem; t = q[tem]; for(int j = 0; j &lt; 4; ++j) &#123; mapa[tot / (w * 4) + 1][tot % (w * 4) + 1] = t[j] - '0'; ++tot; &#125; &#125;&#125;void DFS0(int x, int y, int now)&#123; int xx, yy; for(int i = 0; i &lt; 4; ++i) &#123; xx = x + dir[i][0]; yy = y + dir[i][1]; if(xx &lt; 0 || yy &lt; 0 || xx &gt; h + 1 || yy &gt; w * 4 + 1) continue; if(vis[xx][yy]) continue; if(mapa[xx][yy]) continue; vis[xx][yy] = now; DFS0(xx, yy, now); &#125;&#125;void DFS1(int x, int y, int now)&#123; int xx, yy; for(int i = 0; i &lt; 4; ++i) &#123; xx = x + dir[i][0]; yy = y + dir[i][1]; if(xx &lt; 1 || yy &lt; 1 || xx &gt; h || yy &gt; w * 4) continue; if(vis[xx][yy]) continue; if(mapa[xx][yy] == 0) vis[xx][yy] = now; else vis[xx][yy] = 1; DFS1(xx, yy, now); &#125;&#125;void DFS2(int x, int y, int k)&#123; int xx, yy; for(int i = 0; i &lt; 4; ++i) &#123; xx = x + dir[i][0]; yy = y + dir[i][1]; if(xx &lt; 1 || yy &lt; 1 || xx &gt; h || yy &gt; w * 4) continue; if(vis[xx][yy] != k) continue; vis[xx][yy] = 1; DFS2(xx, yy, k); &#125;&#125;void solve()&#123; DFS0(0, 0, tot); //debug2(); //---above--- for(int i = 1; i &lt;= h; ++i) for(int j = 1; j &lt;= w * 4; ++j) if(mapa[i][j] &amp;&amp; vis[i][j] == 0) DFS1(i, j, ++tot); //debug2(); for(int k = 2; k &lt;= tot; ++k) &#123; t = 0; for(int i = 1; i &lt;= h; ++i) for(int j = 1; j &lt;= w * 4; ++j) if(vis[i][j] == k) &#123; DFS2(i, j, k); ++t; &#125; //cout &lt;&lt; "t = " &lt;&lt; t &lt;&lt; endl; //debug2(); res += ans[t]; &#125; sort(res.begin(), res.end());&#125;int main()&#123; initq(); while(cin &gt;&gt; h &gt;&gt; w &amp;&amp; (h || w)) &#123; init(); Readmap(); //debug(); solve(); cout &lt;&lt; "Case " &lt;&lt; ++cas &lt;&lt; ": " &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; UVa 816 Abbott’s Revenge 【BFS】题目大意：在一个最多包含9 * 9个交叉点的迷宫中，输入起点、离开起点时的朝向和终点，求一条最短路(多解时输出任意一条)。 解题思路：这个相对于一般的最短路问题而言多了方向，因此无法用最短路的算法求解，这时考虑到使用BFS来解决。对于路径的打印，可以采用递归的方式打印。如果最短路很长的话递归可能会引起栈的溢出，此时改用循环，用vector记录路径。PS：一开始接触这个题目时毫无头绪，也是参照了书上的内容一点一点扣了很久才弄明白的。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;//确定好方向后确定走的路线const int MAX = 11;const char* dirs = "NESW";const char* turns = "FLR";const int dr[] = &#123;-1,0,1,0&#125;;const int dc[] = &#123;0,1,0,-1&#125;;int dis[MAX][MAX][4]; //此位置到起点的距离bool iscon[MAX][MAX][4][3]; //是否能到达int r0, c0, r1, c1, r2, c2, dir;struct node&#123; int r, c, dir; node(int r = 0, int c = 0, int dir = 0) : r(r), c(c), dir(dir) &#123;&#125;&#125;p[MAX][MAX][4]; //父结点int dir_id(char c)&#123; return strchr(dirs, c) - dirs;&#125;int turn_id(int c)&#123; return strchr(turns, c) - turns;&#125;bool read()&#123; char s[99]; scanf("%s", s); if(strcmp(s, "END") == 0) return false; printf("%s\n", s); scanf("%d%d%s%d%d",&amp;r0,&amp;c0,s,&amp;r2,&amp;c2); dir = dir_id(s[0]); r1 = r0 + dr[dir]; c1 = c0 + dc[dir]; memset(iscon, false, sizeof(iscon)); int r, c; while(scanf("%d",&amp;r) &amp;&amp; r) &#123; scanf("%d", &amp;c); while(scanf("%s", s) &amp;&amp; s[0] != '*') &#123; for(int i = 1; s[i]; ++i) iscon[r][c][dir_id(s[0])][turn_id(s[i])] = true; &#125; &#125; return true;&#125;void print_ans(node u)&#123; vector&lt;node&gt; G; while(true) &#123; G.push_back(u); if(dis[u.r][u.c][u.dir] == 0) break; u = p[u.r][u.c][u.dir]; &#125; G.push_back(node(r0, c0, dir)); int cnt = 0; for(int i = G.size() - 1; i &gt;= 0; --i) &#123; if(cnt % 10 == 0) printf(" "); printf(" (%d,%d)",G[i].r,G[i].c); if(++cnt % 10 == 0) puts(""); &#125; if(cnt % 10) puts("");&#125;node walk(const node&amp; u, int turn)&#123; int dir = u.dir; if(turn == 1) dir = (dir + 3) % 4; if(turn == 2) dir = (dir + 1) % 4; return node(u.r + dr[dir], u.c + dc[dir], dir);&#125;bool islegal(int r, int c)&#123; return r &gt;= 1 &amp;&amp; c &gt;= 1 &amp;&amp; r &lt;= 9 &amp;&amp; c &lt;= 9;&#125;void solve()&#123; queue&lt;node&gt; Q; memset(dis, -1, sizeof(dis)); dis[r1][c1][dir] = 0; node u(r1, c1, dir); Q.push(u); while(!Q.empty()) &#123; node u = Q.front(); Q.pop(); if(u.r == r2 &amp;&amp; u.c == c2) &#123; print_ans(u); return ; &#125; //模拟从此位置出发往三个方向走(FLR) for(int i = 0; i &lt; 3; ++i) &#123; node v = walk(u, i); if(iscon[u.r][u.c][u.dir][i] &amp;&amp; islegal(v.r, v.c) &amp;&amp; dis[v.r][v.c][v.dir] &lt; 0) &#123; dis[v.r][v.c][v.dir] = dis[u.r][u.c][u.dir] + 1; p[v.r][v.c][v.dir] = u; Q.push(v); &#125; &#125; &#125; puts(" No Solution Possible");&#125;int main()&#123; while(read()) solve(); return 0;&#125; UVa 10305 Ordering Tasks 【拓扑排序】题目大意：给出n个任务和m个限制条件，要求任务i必须在任务j之前完成。请给出一个合适的任务完成顺序。 解题思路：拓扑排序裸题。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int MAX = 105;int n, m;int in[MAX];bool vis[MAX];vector&lt;int&gt; res;vector&lt;int&gt; G[MAX];int main()&#123; while(scanf("%d%d",&amp;n,&amp;m) &amp;&amp; (n + m)) &#123; for(int i = 0; i &lt;= n; ++i) G[i].clear(); memset(in, 0, sizeof(in)); memset(vis, false, sizeof(vis)); for(int i = 0; i &lt; m; ++i) &#123; int u, v; scanf("%d%d",&amp;u,&amp;v); in[v]++; G[u].push_back(v); &#125; bool flag = true; res.clear(); while(flag) &#123; flag = false; for(int i = 1; i &lt;= n; ++i) &#123; if(vis[i]) continue; if(in[i] == 0) &#123; res.push_back(i); vis[i] = true; flag = true; for(int j = 0; j &lt; G[i].size(); ++j) in[G[i][j]]--; &#125; &#125; if(!flag) break; &#125; if(res.size() != n) puts("Impossible"); else for(int i = 0; i &lt; res.size(); ++i) printf("%d%c", res[i], i == res.size() - 1 ? '\n' : ' '); &#125; return 0;&#125; UVa 10129 Play on Words 【欧拉回路】【并查集】题目大意：给出n个单词，能否可以把他们排成一列，使得每个单词的第一个字母和上一个单词的最后一个字母相同。 解题思路：将字母看做结点，单词看成有向边，那么当且仅当图中有欧拉回路的时候问题有解。有向图存在欧拉回路的条件有两个：1. 底图(即忽略方向后得到的无向图)联通 2.度数满足欧拉道路的条件。这里判断条件1时用的并查集，判断条件二时直接记录的度数。 欧拉回路 无向图中从一个结点出发走出一条道路，每条边恰好经过一次，这样的道路称为欧拉道路。 度：无向图里，度为一个顶点关联边的个数。 如果一个无向图是联通的，且最多有两个度数为奇数的点，那么一定存在欧拉道路。如果有两个奇点，则必须从一个奇点出发到另一个奇点终止，其余情况，则可以从任意点出发，最终一定会回到该点(称为欧拉回路)。 –&gt; 类推出有向图： 最多只能有两个点的入度不等于出度，而且必须是其中一个点的出度恰好比入度大1(起点)，另一个的入度比出度大1(终点)。 前提条件：忽略方向后，图是联通的。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;char s[1111];bool vis[256];int t, n, tot, f[256], deg[256];int Find(int x)&#123; return f[x] == x ? x : f[x] = Find(f[x]);&#125;void init()&#123; for(int i = 'a'; i &lt;= 'z'; ++i) f[i] = i; memset(vis, 0, sizeof(vis)); memset(deg, 0, sizeof(deg));&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; init(); tot = 26; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", s); char x = s[0]; char y = s[strlen(s) - 1]; ++deg[x], --deg[y]; vis[x] = vis[y] = true; int t1 = Find(x), t2 = Find(y); if(t1 != t2) &#123; f[t2] = t1; --tot; &#125; &#125; vector&lt;int&gt; d; for(int i = 'a'; i &lt;= 'z'; ++i) &#123; if(vis[i] == false) --tot; else if(deg[i]) d.push_back(deg[i]); &#125; bool ok = ((tot == 1) &amp;&amp; (d.empty() || (d.size() == 2 &amp;&amp; d[0] + d[1] == 0 &amp;&amp; abs(d[0]) == 1))); puts(ok ? "Ordering is possible." : "The door cannot be opened."); &#125; return 0;&#125; UVa 10562 Undraw the Trees 【树的结构】题目大意：给出一个多叉树，将其转化为括号表示法。 解题思路：直接在二维字符数组中递归，无需建树。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 222;int t, n;char buf[N][N];void DFS(int r, int c)&#123; printf("%c(", buf[r][c]); if(r + 1 &lt; n &amp;&amp; buf[r + 1][c] == '|') &#123; int i = c; while(i - 1 &gt;= 0 &amp;&amp; buf[r + 2][i - 1] == '-') --i; while(buf[r + 2][i] == '-' &amp;&amp; buf[r + 3][i] != '\0') &#123; if(!isspace(buf[r + 3][i])) DFS(r + 3, i); ++i; &#125; &#125; printf(")");&#125;void solve()&#123; n = 0; while(1) &#123; fgets(buf[n], N, stdin); if(buf[n][0] == '#') break; else ++n; &#125; printf("("); if(n) &#123; int len = strlen(buf[0]); for(int i = 0; i &lt; len; ++i) if(buf[0][i] != ' ') &#123; DFS(0, i); break; &#125; &#125; puts(")");&#125;int main()&#123; scanf("%d", &amp;t); getchar(); while(t--) solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>并查集</tag>
        <tag>BFS</tag>
        <tag>queue</tag>
        <tag>解题报告</tag>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>数据结构</tag>
        <tag>stack</tag>
        <tag>list</tag>
        <tag>二叉树</tag>
        <tag>拓扑排序</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018_SDNU_ACM-ICPC_Provincial_Team_Selection_Round_2【假装完结】]]></title>
    <url>%2Fsdnu-2018-2%2F</url>
    <content type="text"><![CDATA[山东省第九届acm大学程序设计竞赛山师选拔赛第二场(声明：标题是自己取的，如果有语法错误的话与他人无关) —————————————————————–分割线—————————————————————– Problem A. Alice and Bob(NimK博弈)题意：有N堆石子，每次可以取1~M堆中的任意多个石子，最后无石子可取的那个失败。Alice先手，问谁会赢。 思路：NimK博弈裸题，结论是当且仅当每一位二进制位上的数%(m+1)都是0的时候，先手必败，否则先手必胜。见识++。原理留坑待补。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int tem, tot;int u[MAX][55];int t, res, a, b, n, m;int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; memset(u, 0, sizeof(u)); scanf("%d%d",&amp;n,&amp;m); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;tem); tot = 0; while(tem) &#123; u[i][tot++] = tem &amp; 1; tem &gt;&gt;= 1; &#125; &#125; bool flag = true; for(int j = 0; j &lt; 32; ++j) &#123; int yy = 0; for(int i = 0; i &lt; n; ++i) &#123; yy += u[i][j]; &#125; if(yy % (m+1)) &#123; flag = false; break; &#125; &#125; printf("Case #%d: ", cas); puts(flag ? "Bob" : "Alice"); &#125; return 0;&#125; Problem B. SOS(基础)题意：已知gcd(a, c) = b， 给出a和b求满足条件的最小的不等于b的c。 思路：对式子变形得，gcd(a/b, c/b) = 1， 即求最小的与a/b互质的数。(之前做过一道一模一样的题SDNU-1132: 最大公约数改，枚举答案也能水过啦) Mycode：12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e6+7;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t, res, a, b;int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d%d",&amp;a,&amp;b); a /= b; for(int i = 2; ; ++i) &#123; if(gcd(a, i) == 1) &#123; res = i; break; &#125; &#125; printf("Case #%d: %d\n", cas, res * b); &#125; return 0;&#125; Problem C. Boooooooo(规律)题意：给出一个数N，找出最小的大于等于N的整数pp，其中pp满足存在整数hh使得2hh(hh + 1) = pp(pp + 1)。 思路：打表找规律。(找不出来怎么办？GG呗) Mycode：1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int t;long long n, res;long long a[30] = &#123;3,20&#125;;int main()&#123; for(int i = 2; i &lt; 25; ++i) &#123; a[i] = 6 * a[i-1] - a[i-2] + 2; //cout &lt;&lt; a[i] &lt;&lt; endl; &#125; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%lld", &amp;n); for(int i = 0; ; ++i) &#123; if(a[i] &gt;= n) &#123; printf("Case #%d: %lld\n", cas, a[i]); break; &#125; &#125; &#125; return 0;&#125; Problem D. XC’s pot(期望)题目原型：LightOJ-1027: A Dangerous Maze Problem E. SDNU ACM/ICPC TEAM(拓扑排序)题意不清，不如做这个吧：HDU-4857: 逃生 Problem F. The Avengers(最小生成树)队友补了，目前不想补。 Problem G. play the guitar(大数)题意：Calculate $n^k$ and change all 7,8,9 to 1,2,3(7 to 1, 8 to 2, 9 to 3). 思路：开上Java直接做。 Mycode：12345678910111213141516171819202122232425262728import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner scanner = new Scanner(System.in); int n, m; BigInteger res; String s; while(scanner.hasNext()) &#123; n = scanner.nextInt(); m = scanner.nextInt(); res = BigInteger.valueOf(1); for(int i = 1; i &lt;= m; ++i) &#123; res = res.multiply(BigInteger.valueOf(n)); &#125; s = res.toString(); s = s.replace('7','1'); s = s.replace('8','2'); s = s.replace('9','3'); System.out.println(s); &#125; &#125;&#125; Problem H. The chord(最长公共子串)题意：所有和弦中，伟大的歌手LHM只会其中的部分和弦，给出一个包含很多和弦的吉他谱，问LMH能弹奏的连续的最长的一段乐曲包含多少和弦。 思路：先将不同字符串转换，然后计算转换后的两个串的最长公共子串(套后缀数组的模板)。(转换时当然想到map，然而套各种模板都会超时，因此只好写个100+行的函数来转换。这个题目的idea还是不错的。) Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200000 + 10, INF = 0x3f3f3f3f;const char trans[] = &#123;'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r'&#125;;int sa[N], height[N], rnk[N], wa[N], wb[N], c[N];char str[N], S[N];int s[N], Q;bool cmp(int *r, int a, int b, int l)&#123; return r[a] == r[b] &amp;&amp; r[a+l] == r[b+l];&#125;void Rsort(int *x, int *y, int n, int m)&#123; for(int i = 0; i &lt; m; i++) c[i] = 0; for(int i = 0; i &lt; n; i++) c[x[y[i]]]++; for(int i = 1; i &lt; m; i++) c[i] += c[i-1]; for(int i = n-1; i &gt;= 0; i--) sa[--c[x[y[i]]]] = y[i];&#125;void da(int *s, int n, int m)&#123; int *x = wa, *y = wb; for(int i = 0; i &lt; n; i++) x[i] = s[i], y[i] = i; Rsort(x, y, n, m); for(int j = 1, p = 1; p &lt; n; j *= 2, m = p) &#123; p = 0; for(int i = n-j; i &lt; n; i++) y[p++] = i; for(int i = 0; i &lt; n; i++) if(sa[i] &gt;= j) y[p++] = sa[i] - j; Rsort(x, y, n, m); swap(x, y); p = 1; x[sa[0]] = 0; for(int i = 1; i &lt; n; i++) x[sa[i]] = cmp(y, sa[i-1], sa[i], j) ? p-1 : p++; &#125;&#125;void get_height(int *s, int n)&#123; int i, j, k = 0; for(i = 0; i &lt;= n; i++) rnk[sa[i]] = i; for(i = 0; i &lt; n; height[rnk[i++]] = k) for(k ? --k : 0, j = sa[rnk[i]-1]; s[i+k] == s[j+k]; k++);&#125;int change(int L)&#123; int res = 0; for(int i = 0; i &lt; L; ++i) &#123; if(str[i] == 'A') &#123; if(str[i+1] == '7') &#123; s[res++] = trans[1]; ++i; &#125; else if(str[i+1] == 'm') &#123; s[res++] = trans[2]; ++i; &#125; else if(str[i+1] == 's') &#123; s[res++] = trans[3]; i += 4; &#125; else s[res++] = trans[0]; &#125; else if(str[i] == 'B') &#123; if(str[i+1] == '7') s[res++] = trans[4]; else s[res++] = trans[5]; ++i; &#125; else if(str[i] == 'C') &#123; if(str[i+1] == '7') &#123; s[res++] = trans[7]; ++i; &#125; else s[res++] = trans[6]; &#125; else if(str[i] == 'D') &#123; if(str[i+1] == '7') &#123; s[res++] = trans[9]; ++i; &#125; else if(str[i+1] == 'm') &#123; if(str[i+2] == '7') &#123; s[res++] = trans[10]; i += 2; &#125; else &#123; s[res++] = trans[11]; i++; &#125; &#125; else s[res++] = trans[8]; &#125; else if(str[i] == 'E') &#123; if(str[i+1] == 'm') &#123; s[res++] = trans[13]; ++i; &#125; else s[res++] = trans[12]; &#125; else if(str[i] == 'F') &#123; if(str[i+1] == 'm') &#123; s[res++] = trans[14]; i += 4; &#125; else s[res++] = trans[15]; &#125; else if(str[i] == 'G') &#123; if(str[i+1] == '7') &#123; s[res++] = trans[16]; i++; &#125; else s[res++] = trans[17]; &#125; else &#123; Q = res; s[res++] = '$'; &#125; &#125; return res;&#125;int main()&#123; while(~scanf("%s", str)) &#123; int len = strlen(str); str[len] = '$'; scanf("%s", str + 1 + len); len = strlen(str); len = change(len); s[len] = 0; int len_1 = Q; da(s, len + 1, 130);//第二个参数，即长度比原数组大一，因为在末尾补了一个极小值，故+1 get_height(s, len);//此处传入原长度 int ans = 0; for(int i = 1; i &lt;= len; i++)//height[1]~height[len]，因为sa[0]是以极小值为起点的后缀，然后sa[1]~sa[len]，故height[1]~height[len] if(height[i] &gt; ans &amp;&amp; ((sa[i-1]&lt;len_1 &amp;&amp; sa[i]&gt;len_1) || (sa[i-1]&gt;len_1 &amp;&amp; sa[i]&lt;len_1))) ans = height[i]; printf("%d\n", ans); &#125; return 0;&#125; Problem I. Alice and Bob II(记忆化搜索)题意：N堆石子，Alice先手，每次两人都可以从石子的两端取任意一堆，问Alice最多能取多少石子。 思路：我觉得题目中这句they both smart不应该有，不然给出的正解讲不通。去掉这句话的话就是看Alice能取的石子最大值了。使Alice取最多即每次Alice往多了取，Bob往小了取。最多100堆，枚举每个状态的话肯定不能完成。采取记忆化搜索可以保留左右位置为l、r时的最优解，大大减少时间复杂度，任务完成。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 105;int a[MAX];int n, res, t;int dp[MAX][MAX];int DFS(int l, int r, bool flag)&#123; if(dp[l][r]) return dp[l][r]; int res = 0; if(flag) &#123; if(l == r) return a[l]; res = max(DFS(l+1, r, !flag) + a[l], DFS(l, r-1, !flag) + a[r]); &#125; else &#123; if(l == r) return 0; res = min(DFS(l+1, r, !flag), DFS(l, r-1, !flag)); &#125; dp[l][r] = res; return res;&#125;int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d",&amp;n); memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; ++i) scanf("%d",&amp;a[i]); int ans = DFS(1, n, true); printf("Case #%d: %d\n", cas, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018_SDNU_ACM-ICPC_Provincial_Team_Selection_Round_1【假装完结】]]></title>
    <url>%2Fsdnu-2018-1%2F</url>
    <content type="text"><![CDATA[山东省第九届acm大学程序设计竞赛山师选拔赛第一场(声明：标题是自己取的，如果有语法错误的话与他人无关) —————————————————————–分割线—————————————————————– A.网瘾少年周老灰(贪心)题意：周老灰玩炉石，场上目前有2 * n张牌，敌我各n张。发动进攻的方式是每张牌只能攻击一张牌，进攻完成后，敌方士兵生命值减少我方进攻士兵的攻击力，我方士兵生命值也要减少敌方进攻士兵的攻击力，当生命之小于等于0时，这张卡牌将消失。现在轮到我方发动进攻，问能否使得我方这一轮进行完后地方卡牌都被摧毁，而我方卡牌还都存活。 思路：考虑到数据范围，直接做就行了(数据范围再大点的话就是二分图匹配了)。每次贪心选取我方能打败的敌方选手中攻击力最高的，一直这样选直到全部选完||打败不了的情况。 碎碎念：数据出的太不负责了，出现了范围以外的数就不说了，TM除了一个本不该存在的n=0时输出Sorry about that!外，其他情况都输出Tell you a joke~？这种题目全随机数出现前一个答案的概率太小了，就不能手动出几组吗(没错我是因为他这个本不该出现的n=0浪费了近3小时的时间debug才如此气愤的)。UPD(04.18)：等了一周后还没改，自己出了几组随机数和手动出的数据传上去后rejudge，果然hack掉了几个。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 105;int t, n;struct node&#123; bool flag; int hp, mp;&#125;a[MAX], b[MAX];bool cmp(node u, node v)&#123; if(u.hp == v.hp) return u.mp &lt; v.mp; return u.hp &lt; v.hp;&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); bool flag; memset(b, 0, sizeof(b)); for(int i = 0; i &lt; n; ++i) scanf("%d%d",&amp;a[i].hp,&amp;a[i].mp); for(int i = 0; i &lt; n; ++i) scanf("%d%d",&amp;b[i].hp,&amp;b[i].mp); sort(a, a+n, cmp); sort(b, b+n, cmp); for(int i = 0; i &lt; n; ++i) &#123; flag = false; for(int j = n-1; j &gt;= 0; --j) &#123; if(b[j].flag == false &amp;&amp; a[i].hp &gt; b[j].mp &amp;&amp; a[i].mp &gt;= b[j].hp) &#123; flag = true; b[j].flag = true; break; &#125; &#125; if(!flag) break; &#125; if(flag) puts("Sorry about that!"); else puts("Tell you a joke~"); &#125; return 0;&#125; B.陆历川玩数位(数位DP)题目原型：HDU-4734: F(x) 队友补过了，目前不想补。 C.prime(素数筛)题意：给一个数n问n是否是素数，0 &lt; n &lt; 100000000。 思路：据说出题人本打算考察位图筛的，但没想到数组可以开到1e8这么大，于是让大家用素数筛水过去了。队友说素数筛会超时，于是我上的Miller-Rabin。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int S = 8;//随机算法判定次数，一般8~10次就够了//计算ret = (a*b)%c a, b, c &lt; 2^63long long mult_mod(long long a, long long b, long long c)&#123; a %= c; b %= c; long long ret = 0; long long tem = a; while(b) &#123; if(b &amp; 1) &#123; ret += tem; if(ret &gt; c) ret -= c;//直接取模慢很多 &#125; tem &lt;&lt;= 1; if(tem &gt; c) tem -= c; b &gt;&gt;= 1; &#125; return ret;&#125;//计算 ret = (a^n) % modlong long pow_mod(long long a, long long n, long long mod)&#123; long long ret = 1; long long tem = a % mod; while(n) &#123; if(n &amp; 1) ret = mult_mod(ret, tem, mod); tem = mult_mod(tem, tem, mod); n &gt;&gt;= 1; &#125; return ret;&#125;// 通过 a^(n-1)=1(mod n)来判断n是不是素数// n-1 = x * 2^t 中间使用二次判断// 是合数返回true，不一定是合数返回falsebool check(long long a, long long n, long long x, long long t)&#123; long long ret = pow_mod(a, x, n);//a^x % n long long last = ret; for(int i = 1; i &lt;= t; ++i)//进行t次(a^x % n)^2 % n &#123; ret = mult_mod(ret, ret, n); if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true;//合数 last = ret; &#125; if(ret != 1) return true; return false;//不一定是合数&#125;//**************************************************// Miller_Rabin算法// 是素数返回true,(可能是伪素数)// 不是素数返回false//**************************************************bool Miller_Rabin(long long n)&#123; if(n &lt; 2) return false; if(n == 2) return true; if( (n&amp;1) == 0) return false;//偶数 long long x = n - 1; long long t = 0; while( (x&amp;1) == 0) //将n分解为x*2^t; &#123; x &gt;&gt;= 1; t++; &#125; srand( time(NULL)); for(int i = 0; i &lt; S; ++i) &#123; long long a = rand()%(n-1) + 1;//产生随机数a(并控制其范围在1 ~ n-1之间) if(check(a, n, x, t))//是合数 return false; &#125; return true;&#125;int main()&#123; int T; long long n; scanf("%d", &amp;T); while(T--) &#123; scanf("%lld", &amp;n); if(Miller_Rabin(n)) cout &lt;&lt; "N" &lt;&lt; endl; else cout &lt;&lt; "Y" &lt;&lt; endl; &#125; return 0;&#125; D.陆历川爱合并(K叉哈夫曼树)题意：从n个元素中每次取不超过k个元素进行合并，合并时的花费为k个元素价值的总和，并且合并出的新元素价值为这k个元素的总和。问当最终花费不超过T时，最小的k是多少。 思路：0.当k=2时，这就是哈夫曼树，为使总花费最小，每次合并的两元素的价值最小。相关题目：SDNU-1412: Huffuman树。1.显然k越大总花费越小，满足单调性，因此我们可以采用二分的方法枚举k。2.因为每次取k个合并后变成一个总量其实减少了k-1个，每次减少这么多，再加上最后合并为1堆，因此当(n-1) % (k-1) == 0时，说明刚好能合并完成，否则会出现剩余的情况，如果最后合并这些多出来的部分的话会影响到上面1中的单调性，所以这种情况下要先合并多出来的这部分。3.合并时可以维护小的值一直在队列前面，省下了排序/查找的时间。 K叉哈夫曼树模板：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int Hafuman(int k) //返回总代价&#123; int ai, bi, blen; blen = 0; ai = bi = 0; int cost = 0; bool first = true; while (n - ai + blen - bi &gt; 1) &#123; int num = 0; if (first) &#123; if ((n - k) % (k - 1) == 0) num = k; else num = (n - k) % (k - 1) + 1; first = false; &#125; else num = k; int sum = 0; while (num--) &#123; if (ai == n) &#123; sum += b[bi]; bi++; &#125; else if (bi == blen) &#123; sum += a[ai]; ai++; &#125; else if (a[ai] &lt; b[bi]) &#123; sum += a[ai]; ai++; &#125; else &#123; sum += b[bi]; bi++; &#125; &#125; cost += sum; b[blen++] = sum; &#125; return cost;&#125; 题目原型：HDU-5884: Sort Mycode：(在HDU上过了，在这里T了，慢了200MS。自己将上面的模板套上后就能过了。)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 100005;int a[MAX];queue&lt;LL&gt; Q;int t, n, m, res;bool judge(int k)&#123; while(!Q.empty()) Q.pop(); LL tot = 0; LL tem = 0; int idx = 0; int lef = (n - 1) % (k - 1) + 1; if(lef) //多出的lef个先合并 &#123; while(idx &lt; lef) tem += a[idx++]; tot += tem; Q.push(tem); &#125; while(1) &#123; tem = 0; for(int i = 0; i &lt; k; ++i) &#123; if(idx &lt; n &amp;&amp; (Q.empty() || a[idx] &lt; Q.front())) tem += a[idx++]; else tem += Q.front(), Q.pop(); &#125; tot += tem; if(tot &gt; m) return false; if(idx &gt;= n &amp;&amp; Q.empty()) break; Q.push(tem); &#125; return tot &lt;= m;&#125;int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d%d",&amp;n, &amp;m); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); sort(a, a + n); int l = 2, r = n; int mid; while(l &lt;= r) &#123; mid = (l + r) / 2; if(judge(mid)) &#123; res = mid; r = mid - 1; &#125; else l = mid + 1; &#125; printf("Case #%d: %d\n", cas, res); &#125; return 0;&#125; E.Reasoning test(模拟)题意：给出10个问题，他们之间有相互限制的条件，问满足这些限制条件的每个问题的答案是多少。 思路：因为只要提交答案，本地枚举每种情况，然后把限制条件堆到一个函数里judge一下就好了。(比赛时都是手推的，这是江苏省公安厅网络安全小组的官方微博“江苏网警”发布的“2018年刑侦专题推理试题”，看来大家都有当刑警的潜力啊。) Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e6+7;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int a[15];char ch[] = &#123;'A','B','C','D'&#125;;void out()&#123; for(int i = 1; i &lt;= 10; ++i) cout &lt;&lt; ch[a[i]-1]; cout &lt;&lt; endl;&#125;bool judge()&#123; if(a[2] != (a[5]+1)%4+1) return false; if(a[3] == 1) &#123; if(a[3] == a[6]) return false; if(a[3] == a[2]) return false; if(a[3] == a[4]) return false; &#125; else if(a[3] == 2) &#123; if(a[6] == a[2]) return false; if(a[6] == a[3]) return false; if(a[6] == a[4]) return false; &#125; else if(a[3] == 3) &#123; if(a[2] == a[3]) return false; if(a[2] == a[4]) return false; if(a[2] == a[6]) return false; &#125; else if(a[3] == 4) &#123; if(a[4] == a[2]) return false; if(a[4] == a[3]) return false; if(a[4] == a[6]) return false; &#125; if(a[4] == 1 &amp;&amp; a[1] != a[5]) return false; if(a[4] == 2 &amp;&amp; a[2] != a[7]) return false; if(a[4] == 3 &amp;&amp; a[1] != a[9]) return false; if(a[4] == 4 &amp;&amp; a[6] != a[10]) return false; if(a[5] == 1 &amp;&amp; a[5] != a[8]) return false; if(a[5] == 2 &amp;&amp; a[5] != a[4]) return false; if(a[5] == 3 &amp;&amp; a[5] != a[9]) return false; if(a[5] == 4 &amp;&amp; a[5] != a[7]) return false; if(a[6] == 1) &#123; if(a[2] != a[4]) return false; if(a[2] != a[8]) return false; &#125; else if(a[6] == 2) &#123; if(a[1] != a[6]) return false; if(a[1] != a[8]) return false; &#125; else if(a[6] == 3) &#123; if(a[3] != a[10]) return false; if(a[3] != a[8]) return false; &#125; else if(a[6] == 4) &#123; if(a[5] != a[9]) return false; if(a[5] != a[8]) return false; &#125; int A, B, C, D; A = B = C = D = 0; for(int i = 1; i &lt;= 10; ++i) &#123; if(a[i] == 1) ++A; if(a[i] == 2) ++B; if(a[i] == 3) ++C; if(a[i] == 4) ++D; &#125; int minn = -1; if(A &lt; B &amp;&amp; A &lt; C &amp;&amp; A &lt; D) minn = 1; if(B &lt; A &amp;&amp; B &lt; C &amp;&amp; B &lt; D) minn = 2; if(C &lt; A &amp;&amp; C &lt; B &amp;&amp; C &lt; D) minn = 3; if(D &lt; A &amp;&amp; D &lt; B &amp;&amp; D &lt; C) minn = 4; if(a[7] == 1 &amp;&amp; minn != 3) return false; if(a[7] == 2 &amp;&amp; minn != 2) return false; if(a[7] == 3 &amp;&amp; minn != 1) return false; if(a[7] == 4 &amp;&amp; minn != 4) return false; if(a[8] == 1 &amp;&amp; abs(a[1]-a[7]) == 1) return false; if(a[8] == 2 &amp;&amp; abs(a[1]-a[5]) == 1) return false; if(a[8] == 3 &amp;&amp; abs(a[1]-a[2]) == 1) return false; if(a[8] == 4 &amp;&amp; abs(a[1]-a[10])== 1) return false; bool flag = (a[1] == a[6]); if(flag) &#123; if(a[9] == 1) &#123; if(a[6] == a[5]) return false; &#125; if(a[9] == 2) &#123; if(a[10] == a[5]) return false; &#125; if(a[9] == 3) &#123; if(a[2] == a[5]) return false; &#125; if(a[9] == 4) &#123; if(a[9] == a[5]) return false; &#125; &#125; else &#123; if(a[9] == 1) &#123; if(a[6] != a[5]) return false; &#125; if(a[9] == 2) &#123; if(a[10] != a[5]) return false; &#125; if(a[9] == 3) &#123; if(a[2] != a[5]) return false; &#125; if(a[9] == 4) &#123; if(a[9] != a[5]) return false; &#125; &#125; int maxx = -1; if(A &gt; B &amp;&amp; A &gt; C &amp;&amp; A &gt; D) maxx = 1; if(B &gt; A &amp;&amp; B &gt; C &amp;&amp; B &gt; D) maxx = 2; if(C &gt; A &amp;&amp; C &gt; B &amp;&amp; C &gt; D) maxx = 3; if(D &gt; A &amp;&amp; D &gt; B &amp;&amp; D &gt; C) maxx = 4; int dif = abs(maxx - minn); if(a[10] == 1 &amp;&amp; dif != 3) return false; if(a[10] == 2 &amp;&amp; dif != 2) return false; if(a[10] == 3 &amp;&amp; dif != 4) return false; if(a[10] == 4 &amp;&amp; dif != 1) return false; return true;&#125;void DFS(int idx, int val)&#123; a[idx] = val; if(idx == 10) &#123; if(judge()) out(); return ; &#125; for(int i = 1; i &lt;= 4; ++i) DFS(idx+1, i);&#125;int main()&#123; //DFS(0,0); cout &lt;&lt; "BCACACDABA" &lt;&lt; endl; return 0;&#125; F.陆历川让你A个题题意：问n的阶乘末尾有多少个0。 思路：将n的阶乘进行质因数分解后可以发现，实际影响末尾0的个数的只有因子2和5。而n的阶乘分解质因数后2的个数必定小于等于5的个数，因此只查询有多少个5就可以了。 Mycode：123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e6+7;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t, res, n;int main()&#123; cin &gt;&gt; t; while(t--) &#123; res = 0; cin &gt;&gt; n; while(n) &#123; n /= 5; res += n; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; G.请回答Alice和Bob请移步2017 省赛 山东 A Return of the Nim 【博弈】【Nim+Wythoff】。 H.强哥要置你于死地题意：强哥有n把枪，每个枪有3个属性，当一把枪的这三个属性都大于某一把枪的这三个属性时就称这把枪能完胜那把枪。问有这些枪分别能完胜多少把其他的枪。 思路：三位偏序裸题。 题目原型：BZOJ-3262: 陌上花开 队友补过了，目前不想补。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玲珑学院 1137 Sin your life 【数学】]]></title>
    <url>%2Fifrog-1137%2F</url>
    <content type="text"><![CDATA[题目大意：对于给定的n，求当x、y、z均为整数时$sin(x)+sin(y)+sin(z)$的最大值。结果保留到小数点后9位。 解题思路：如果枚举x、y的话是太暴力了。我们不妨把要求的式子化简一下，利用和差化积公式进行化简： $sin x + sin y = 2 \times sin(\frac{x+y}{2}) \times cos(\frac{x-y}{2})$ $sin x + sin y + sin z = 2 \times sin(\frac{x+y}{2}) \times cos(\frac{x-y}{2}) + sin(n - x - y)$ 化简后从2-n-1枚举x+y的值。 因为x+y的值固定，所以当它的值为偶数时，cos那部分的值最大为1(当x==y时)； 而当它的值为奇数时，x-y可以等于1,3,5…n-2，这时加个再判断来取cos那部分的最大值。 Mycode:123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n;double ans = -INF, tem, mac = -2;int main()&#123; scanf("%d",&amp;n); for(int i = 2; i &lt; n; ++i) &#123; if(i % 2 == 0) tem = 2.0*sin(i/2.0) + sin(n-i); else &#123; mac = max(mac, cos((i-2.0)/2.0)); tem = 2.0*sin(i/2.0)*mac + sin(n-i); &#125; if(ans &lt; tem) ans = tem; &#125; printf("%.9f\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>玲珑学院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU 1147 Pythagoras's Revenge 【技巧暴力】]]></title>
    <url>%2Fsdnu-1147%2F</url>
    <content type="text"><![CDATA[题目链接：SDNU 1147 Pythagoras’s Revenge 题目大意：给定直角三角形的一直角边，求出各边均为整数的以它为最小边的直角三角形的个数 解题思路：一、【真丶暴力】根据勾股定理可知$a^2+b^2=c^2$我们试着让b从等于a+1开始枚举可能的解，如果枚举出来的c是整数的话，让ans++，最后输出ans。 然而这样枚举的终止条件是什么呢？$10 \times a$ ？ $100 \times a $？ $1000 \times a$ ？ 我一直试到了$10000 \times a​$还是求不全。 显然这样是不行的。 二、【技巧丶暴力】对于$a^2+b^2=c^2$，我们移项可得$a^2=c^2-b^2$，再化，可得$a^2 = (c-b) \times (c+b)$。根据三角形任意两边之和大于第三边、任意两边之差小于第三边可知，令$i=c-b$, $j=c+b$，即$i$ &lt; $a$、$j$ &gt; $a$，且$j - i = 2b$。接下来枚举i就可以了。 Mycode:123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int main()&#123; LL a, b, ans; while(scanf("%lld",&amp;a) &amp;&amp; a) &#123; ans = 0; for(LL i = 1; i &lt; a; ++i) &#123; if(a * a % i == 0) &#123; LL j = a * a / i; if((j-i) % 2 == 0) &#123; b = (j-i) / 2; if(b &gt; a) ++ans; &#125; &#125; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玲珑学院 1143 计算几何你瞎暴力【计算几何】【技巧暴力】]]></title>
    <url>%2Fifrog-1143%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个教室的坐标(三维)以及求任意两点间距离的方式，q次询问，对每次询问输出距离小于R的坐标对数。 解题思路： 一、【真丶暴力】先离线存取每个点坐标，然后两层循环求出所有可能组合的情况，将结果存在答案数组里，因为数组里存的是距离等于R的组合种类数，而题目要求的是距离大于等于R的组合种类数，所以需要从前往后更新一下答案数组。最后对于每次询问，直接输出结果即可。 注：因为两坐标间距离最大为30，所以当R超过30时，将其看作30就可以了。 Mycode:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 50000+5;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t, n, q, tem, ans;struct node&#123; int x, y, z;&#125;;int dis(node a, node b)&#123; return (abs(a.x-b.x) + abs(a.y-b.y) + abs(a.z - b.z));&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; int aa[35]; node a[MAX]; scanf("%d%d",&amp;n,&amp;q); for(int i = 0; i &lt; n; ++i) scanf("%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].z); for(int i = 0; i &lt; n; ++i) &#123; for(int j = i+1; j &lt; n; ++j) &#123; ++aa[dis(a[i], a[j])]; &#125; &#125; for(int i = 1; i &lt;= 30; ++i) aa[i] += aa[i-1]; while(q--) &#123; scanf("%d",&amp;tem); if(tem &gt;= 30) printf("%d\n",aa[30]); else printf("%d\n",aa[tem]); &#125; &#125; return 0;&#125; 显然，这样做会TLE，毕竟n的范围达到了5 * 1e4。再读读题，这时才意识到坐标范围为[0，10]。根据这个条件可以得到思路二。 二、【技巧丶暴力】 用三维数组记录每个点出现的次数，然后遍历每个坐标，根据其出现次数得到组合时出现的情况。 注：(1).两坐标相同时，其可能的组合种类数为 n!/n 即 n $\times$ (n-1)/2 &lt;n为坐标的个数&gt;(2).两坐标不同时，其可能的组合种类数为 n $\times$ m / 2 &lt;n,m分别为两坐标的个数&gt; Mycode:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, q, t, tem;int a, b, c, x, y, z;LL aa[35];LL dex[15][15][15];int dis(int aa, int bb, int cc, int xx, int yy, int zz)&#123; return abs(aa-xx)+abs(bb-yy)+abs(cc-zz);&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; memset(aa, 0, sizeof(aa)); memset(dex, 0, sizeof(dex)); scanf("%d%d",&amp;n,&amp;q); while(n--) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ++dex[x][y][z]; &#125; for(a = 0; a &lt;= 10; ++a) for(b = 0; b &lt;= 10; ++b) for(c = 0; c &lt;= 10; ++c) if(dex[a][b][c]) for(x = 0; x &lt;= 10; ++x) for(y = 0; y &lt;= 10; ++y) for(z = 0; z &lt;= 10; ++z) if(dex[x][y][z]) &#123; tem = dis(a, b, c, x, y, z); if(tem == 0) aa[tem] += (dex[x][y][z])*(dex[x][y][z]-1)/2; else aa[tem] += dex[x][y][z]*dex[a][b][c]; &#125; for(int i = 1; i &lt;= 30; ++i) aa[i] /= 2; for(int i = 1; i &lt;= 30; ++i) aa[i] += aa[i-1]; while(q--) &#123; scanf("%d",&amp;tem); if(tem &gt; 30) tem = 30; printf("%lld\n",aa[tem]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>玲珑学院</tag>
        <tag>计算几何</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识点】 ---寻找第n个素数]]></title>
    <url>%2Ffind-prime%2F</url>
    <content type="text"><![CDATA[如何快速找到第n个素数呢？看到这个问题后我的第一思路就是用筛法筛出素数数组。 Mycode:1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 5000005;int pri[MAX];int main()&#123; memset(pri, 0, sizeof(pri)); for(int i = 2; i &lt;= MAX; ++i) &#123; if(!pri[i]) pri[++pri[0]] = i; for(int j = 1; j &lt;= pri[0] &amp;&amp; pri[j] &lt;= MAX / i; ++j) &#123; pri[pri[j]*i] = 1; if(i % pri[j] == 0) break; &#125; &#125; int n; int cas = 0; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; printf("Case %d: %d\n",++cas,pri[n]); &#125; return 0;&#125; 这种方法在n比较小的时候还是快的，但是当n变得很大，比如当n达到3000000时，1s是跑不完的。在此基础上稍微优化一下，多交几遍说不定就卡过去了。经过优化，速度确实快了点： Code：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;using namespace std;typedef long long LL;const int MAX = 50000000;bool vis[MAX];int prim[3100005];int main()&#123; int d = sqrt(1.0*MAX); int s = 0; for(int i = 3; i &lt;= d; i += 2) if(!vis[i]) for(int j = 3*i; j &lt;= MAX; j += 2*i) vis[j] = true; int len = 0; prim[++len] = 2; for(int i = 3; i &lt;= MAX; i += 2) if(!vis[i]) prim[++len] = i; int cas = 0; int n; while(scanf("%d",&amp;n) &amp;&amp; n) printf("Case %d: %d\n",++cas, prim[n]); return 0;&#125; 但是还是达不到更快的要求。怎么办？原来有专门的一种算法，可以很快的解决此问题。原文链接。源代码链接：http://paste.ubuntu.com/24702943/ Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdtr1c++.h&gt;#define MAXN 100#define MAXM 10001#define MAXP 40000#define MAX 400000#define clr(ar) memset(ar, 0, sizeof(ar))#define read() freopen("lol.txt", "r", stdin)#define dbg(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl#define chkbit(ar, i) (((ar[(i) &gt;&gt; 6]) &amp; (1 &lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))#define setbit(ar, i) (((ar[(i) &gt;&gt; 6]) |= (1 &lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))#define isprime(x) (( (x) &amp;&amp; ((x)&amp;1) &amp;&amp; (!chkbit(ar, (x)))) || ((x) == 2))using namespace std;namespace pcf&#123;long long dp[MAXN][MAXM];unsigned int ar[(MAX &gt;&gt; 6) + 5] = &#123;0&#125;;int len = 0, primes[MAXP], counter[MAX];void Sieve()&#123; setbit(ar, 0), setbit(ar, 1); for (int i = 3; (i * i) &lt; MAX; i++, i++) &#123; if (!chkbit(ar, i)) &#123; int k = i &lt;&lt; 1; for (int j = (i * i); j &lt; MAX; j += k) setbit(ar, j); &#125; &#125; for (int i = 1; i &lt; MAX; i++) &#123; counter[i] = counter[i - 1]; if (isprime(i)) primes[len++] = i, counter[i]++; &#125;&#125;void init()&#123; Sieve(); for (int n = 0; n &lt; MAXN; n++) &#123; for (int m = 0; m &lt; MAXM; m++) &#123; if (!n) dp[n][m] = m; else dp[n][m] = dp[n - 1][m] - dp[n - 1][m / primes[n - 1]]; &#125; &#125;&#125;long long phi(long long m, int n)&#123; if (n == 0) return m; if (primes[n - 1] &gt;= m) return 1; if (m &lt; MAXM &amp;&amp; n &lt; MAXN) return dp[n][m]; return phi(m, n - 1) - phi(m / primes[n - 1], n - 1);&#125;long long Lehmer(long long m)&#123; if (m &lt; MAX) return counter[m]; long long w, res = 0; int i, a, s, c, x, y; s = sqrt(0.9 + m), y = c = cbrt(0.9 + m); a = counter[y], res = phi(m, a) + a - 1; for (i = a; primes[i] &lt;= s; i++) res = res - Lehmer(m / primes[i]) + Lehmer(primes[i]) - 1; return res;&#125;&#125;long long solve(long long n)&#123; int i, j, k, l; long long x, y, res = 0; for (i = 0; i &lt; pcf::len; i++) &#123; x = pcf::primes[i], y = n / x; if ((x * x) &gt; n) break; res += (pcf::Lehmer(y) - pcf::Lehmer(x)); &#125; for (i = 0; i &lt; pcf::len; i++) &#123; x = pcf::primes[i]; if ((x * x * x) &gt; n) break; res++; &#125; return res;&#125;int main()&#123; pcf::init(); long long n, res,L,R,M,ca=1; while (scanf("%lld", &amp;n) != EOF) &#123; if(n==0) break; L=2; R=1e8; while(L&lt;R) &#123; M=(L+R)/2; res=pcf::Lehmer(M); if(res&gt;=n) R=M; else L=M+1; &#125; printf("Case %lld: %lld\n",ca++,L); &#125; return 0;&#125; 当然还有大神用了分块筛的方法。那个pos数组是以50000为间隔的前面几个块素数个数，是用之前的代码本地跑出来的，就是说1-5W有多少个素数，1-10w有多少个素数这样子。然后每次输入n找到他在哪个区间内，再单独筛出这个区间内的素数就好了。真的很厉害Orz。源代码链接：http://paste.ubuntu.com/24702950/ Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;string.h&gt;#define MIN(a,b) (((a)&lt;(b))?(a):(b))using namespace std;int pos[1005]= &#123;-1,5133,9592,13848,17984,22044,25997,29977,33860,37706,41538,45322,49098,52831,56543,60238,63951,67617,71274,74907,78498,82134,85714,89302,92938,96469,100021,103544,107126,110630,114155,117663,121127,124634,128141,131608,135072,138542,142029,145502,148933,152382,155805,159250,162662,166081,169511,172873,176302,179684,183072,186462,189880,193256,196645,199993,203362,206789,210109,213453,216816,220136,223492,226835,230209,233577,236900,240230,243539,246909,250150,253412,256726,260064,263397,266717,269987,273322,276611,279921,283146,286490,289774,293010,296314,299583,302824,306084,309335,312666,315948,319164,322441,325706,328964,332219,335439,338694,341992,345235,348513,351715,354971,358198,361407,364685,367900,371131,374362,377574,380800,383979,387202,390378,393606,396826,399993,403204,406429,409672,412849,416040,419246,422449,425648,428816,432073,435265,438410,441562,444757,447955,451159,454337,457497,460707,463872,467055,470283,473470,476648,479864,483015,486167,489319,492494,495666,498797,501962,505147,508261,511417,514565,517740,520910,524026,527154,530334,533506,536652,539777,542898,546024,549150,552319,555479,558597,561766,564877,567967,571119,574274,577439,580566,583714,586850,590006,593112,596222,599355,602489,605556,608672,611788,614917,618057,621177,624298,627400,630495,633578,636697,639851,642962,646054,649175,652265,655355,658445,661520,664579,667709,670820,673927,676970,680063,683178,686262,689382,692486,695609,698703,701795,704895,708007,711108,714154,717257,720341,723457,726517,729577,732707,735767,738873,741941,745001,748066,751131,754189,757288,760391,763455,766554,769639,772706,775773,778818,781906,784991,788060,791111,794149,797261,800285,803358,806435,809487,812601,815674,818703,821750,824801,827884,830940,834026,837099,840169,843192,846205,849252,852291,855281,858338,861401,864446,867482,870532,873606,876616,879640,882652,885698,888762,891833,894877,897938,900996,904057,907101,910077,913098,916147,919203,922193,925237,928293,931330,934441,937446,940455,943484,946551,949506,952566,955599,958651,961694,964695,967720,970704,973739,976761,979764,982776,985807,988851,991880,994839,997817,1000862,1003926,1006966,1009985,1013012,1016026,1019012,1022057,1025092,1028089,1031130,1034115,1037119,1040144,1043113,1046152,1049172,1052140,1055139,1058173,1061198,1064162,1067185,1070198,1073198,1076221,1079266,1082255,1085243,1088266,1091314,1094330,1097360,1100328,1103258,1106267,1109288,1112328,1115323,1118354,1121389,1124405,1127407,1130388,1133364,1136320,1139344,1142298,1145305,1148316,1151367,1154307,1157275,1160273,1163205,1166251,1169267,1172264,1175214,1178218,1181158,1184128,1187148,1190171,1193122,1196133,1199102,1202080,1205065,1208078,1211050,1214027,1216988,1219966,1222953,1225900,1228861,1231859,1234873,1237894,1240833,1243787,1246718,1249710,1252693,1255682,1258685,1261660,1264617,1267631,1270607,1273599,1276577,1279531,1282513,1285456,1288409,1291373,1294356,1297270,1300243,1303229,1306226,1309152,1312179,1315161,1318125,1321065,1324046,1326975,1329943,1332935,1335881,1338865,1341795,1344716,1347749,1350691,1353661,1356600,1359631,1362538,1365511,1368447,1371432,1374421,1377385,1380343,1383291,1386325,1389261,1392272,1395148,1398094,1401007,1403922,1406874,1409821,1412758,1415679,1418640,1421620,1424606,1427535,1430531,1433481,1436398,1439367,1442335,1445279,1448221,1451219,1454144,1457067,1460019,1462950,1465935,1468883,1471822,1474757,1477731,1480683,1483609,1486531,1489509,1492408,1495350,1498253,1501220,1504189,1507122,1510064,1512992,1515935,1518898,1521859,1524831,1527768,1530729,1533657,1536569,1539541,1542459,1545372,1548366,1551302,1554245,1557132,1560093,1562976,1565927,1568845,1571812,1574749,1577649,1580509,1583439,1586387,1589324,1592219,1595177,1598118,1601049,1603985,1606876,1609825,1612775,1615749,1618668,1621590,1624527,1627444,1630379,1633312,1636202,1639094,1642052,1644964,1647911,1650840,1653807,1656761,1659690,1662600,1665517,1668413,1671330,1674240,1677200,1680120,1683065,1685964,1688960,1691876,1694762,1697663,1700558,1703469,1706405,1709342,1712204,1715158,1718134,1721034,1723913,1726899,1729764,1732641,1735590,1738531,1741430,1744400,1747297,1750204,1753058,1756025,1758964,1761886,1764767,1767691,1770613,1773526,1776430,1779363,1782260,1785173,1788065,1790930,1793863,1796762,1799676,1802593,1805472,1808374,1811272,1814112,1817102,1820026,1822944,1825792,1828703,1831616,1834530,1837416,1840359,1843275,1846115,1849029,1852006,1854941,1857859,1860788,1863719,1866645,1869536,1872441,1875367,1878295,1881199,1884021,1886923,1889855,1892785,1895702,1898632,1901520,1904396,1907306,1910248,1913136,1915979,1918857,1921714,1924643,1927488,1930397,1933290,1936209,1939089,1941982,1944833,1947684,1950638,1953525,1956440,1959308,1962184,1965111,1968015,1970912,1973815,1976668,1979564,1982509,1985372,1988254,1991162,1994051,1996958,1999823,2002749,2005638,2008561,2011422,2014337,2017231,2020103,2022944,2025864,2028764,2031667,2034522,2037385,2040293,2043192,2046087,2048989,2051891,2054802,2057701,2060577,2063430,2066324,2069193,2072084,2074966,2077862,2080771,2083678,2086529,2089379,2092244,2095092,2097961,2100791,2103648,2106544,2109362,2112215,2115089,2118001,2120897,2123788,2126637,2129473,2132329,2135232,2138061,2141013,2143883,2146775,2149635,2152470,2155359,2158233,2161146,2163998,2166906,2169775,2172667,2175518,2178423,2181266,2184161,2187043,2189920,2192806,2195671,2198505,2201356,2204262,2207150,2210026,2212915,2215731,2218609,2221543,2224435,2227279,2230137,2233036,2235899,2238778,2241626,2244473,2247300,2250226,2253061,2255897,2258731,2261623,2264514,2267395,2270349,2273189,2276042,2278857,2281732,2284633,2287447,2290350,2293262,2296101,2298985,2301840,2304721,2307562,2310419,2313254,2316107,2318966,2321832,2324728,2327619,2330509,2333367,2336299,2339147,2342005,2344890,2347727,2350582,2353448,2356279,2359142,2362051,2364953,2367814,2370696,2373590,2376402,2379261,2382120,2384990,2387828,2390737,2393630,2396534,2399359,2402242,2405101,2407984,2410827,2413749,2416624,2419434,2422305,2425151,2427981,2430806,2433654,2436487,2439371,2442235,2445078,2447902,2450819,2453695,2456577,2459382,2462273,2465109,2467902,2470746,2473603,2476509,2479409,2482267,2485075,2487886,2490756,2493597,2496476,2499337,2502205,2505030,2507850,2510721,2513534,2516394,2519246,2522092,2524898,2527696,2530575,2533422,2536286,2539186,2542018,2544808,2547620,2550462,2553305,2556175,2559020,2561921,2564807,2567637,2570490,2573319,2576200,2579019,2581841,2584684,2587550,2590386,2593245,2596089,2598870,2601721,2604535,2607331,2610226,2613067,2615907,2618758,2621566,2624440,2627281,2630152,2632997,2635866,2638710,2641508,2644301,2647127,2649982,2652825,2655643,2658487,2661384,2664228,2667036,2669841,2672702,2675523,2678429,2681216,2684053,2686906,2689717,2692570,2695450,2698298,2701159,2703995,2706858,2709644,2712494,2715332,2718160,2721011,2723886,2726718,2729508,2732389,2735255,2738140,2740985,2743838,2746679,2749526,2752380,2755215,2758056,2760896,2763691,2766522,2769407,2772249,2775053,2777902,2780731,2783526,2786355,2789189,2791974,2794837,2797652,2800483,2803324,2806163,2808976,2811853,2814698,2817518,2820355,2823178,2826040,2828852,2831693,2834491,2837271,2840147,2842995,2845792,2848642,2851461,2854302,2857087,2859963,2862777,2865596,2868399,2871207,2874012,2876824,2879677,2882545,2885338,2888144,2890939,2893763,2896598,2899408,2902191,2905025,2907902,2910714,2913488,2916338,2919190,2921977,2924773,2927626,2930404,2933208,2936067,2938896,2941732,2944531,2947349,2950188,2952990,2955834,2958685,2961491,2964316,2967186,2970001,2972862,2975681,2978556,2981364,2984185,2987006,2989825,2992648,2995509,2998299&#125;;bool prime[60000],seive[60000];void seg_seive(int L,int R) //区间筛法&#123; int len=R-L+1; for(int i=0; i&lt;len; i++) prime[i]=1; if(1-L&gt;=0) prime[1-L]=0; //易错因为1不是素数也不是合数，这也是区间筛的一个易错bug for(int i=2; i*i&lt;=R ; i++) &#123; if(seive[i]) &#123; for(int j=max(2,(L-1+i)/i)*i; j&lt;=R; j+=i) //第二个易错点，j必须从大于1，因为L可能小于i，但是seive[i]是素数。 prime[j-L]=false; &#125; &#125;&#125;int main()&#123; for(int i=2; i&lt;50001; i++) seive[i]=1; for(int i=2; i*i&lt;50001; i++) //预处理 if(seive[i]) for(int j=2*i; j&lt;50001; j+=i) seive[j]=false; int n,rl=1; while(~scanf("%d",&amp;n)) &#123; if(n==0)break; int l=0,r=1000; while(l+1&lt;r) &#123; int mid=(l+r)/2; if(pos[mid]&lt;n) l=mid; else r=mid; &#125; int left=l*50000,right=r*50000; int x=n-pos[l]; seg_seive(left,right); //printf("%d %d %d\n",left,right,x); for(int i=left; i&lt;=right; i++) &#123; if(prime[i-left]==1) &#123; x--; if(x==0) &#123; printf("Case %d: %d\n",rl++,i); break; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51Nod 1130 N的阶乘的长度 V2(斯特林近似) 【数学】【斯特林公式】]]></title>
    <url>%2F51nod-1130%2F</url>
    <content type="text"><![CDATA[在进入正试讲解之前我们先来看一道简单点的题目压压惊。 题目链接：51nod 1058 Description：输入N求N的阶乘的10进制表示的长度。例如$6! = 720$，长度为3。 Input输入N($1$ &lt;= $N$ &lt;= $10^6$) Output输出N的阶乘的长度 Input示例6 Output示例3 题目大意：很明确，就是求n！的长度 解题思路：我们知道，对于任意的数n，$len = log10(X) + 1$就是X这个数的长度。当N的值不超过10^6时，直接求的话N的阶乘长度$len = log10(1 \times 2 \times 3 \times 4 \times \ldots \times N) + 1$ $= log10(1) + log10(2) + log10(3) + log10(4) + …… + log10(N) + 1 $。这样实现看起来有点笨拙，不过是可以AC的。 Mycode: 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1005;int main()&#123; int n; cin &gt;&gt; n; double ans = 1; for(int i = 1; i &lt;= n; ++i) &#123; ans += (log10(i)); &#125; cout &lt;&lt; (int)ans &lt;&lt; endl; return 0;&#125; 而对于下面这道题目来说，因为数据范围变大了很多，所以需要考虑用更优的解法了。 题目链接：51nod 1130 Description：输入N求N的阶乘的10进制表示的长度。例如$6! = 720​$，长度为3。 Input第1行：一个数T，表示后面用作输入测试的数的数量。（$1 &lt;= T &lt;= 1000$)第2 - T + 1行：每行1个数N。（$1 &lt;= N &lt;= 10^9$) Output共T行，输出对应的阶乘的长度。 Input示例3456 Output示例233 题目大意：和上道题一样，就是求$n!$的长度，不过数据范围大了很多。 解题思路：有个叫作斯特林公式的神奇公式(可参考百度百科：斯特林公式)，可以利用它进行求解。注意，当$n=1$的时候，上面的公式不适用，所以要单独处理n=1的情况。 这种方法速度很快就可以得到结果。用它来求n!的位数就很easy了。 Mycode: 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1005;const double PI = acos(-1.0);const double EXP = 2.718281828459;int main()&#123; int T; long long n, ans; scanf("%d",&amp;T); while(T--) &#123; scanf("%lld",&amp;n); if(n == 1) &#123; puts("1"); continue; &#125; ans = 0.5*log10(2*PI*n) + n*log10(n*1.0/EXP) + 1; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>51Nod</tag>
        <tag>数学</tag>
        <tag>斯特林公式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EOJ 3256 拼音魔法 【模拟】]]></title>
    <url>%2Feoj-3256%2F</url>
    <content type="text"><![CDATA[Description：魔法学校小学一年级有一种题。就是给一个字的拼音，给一个声调，让你正确地注音。但魔法老师给了巨量的题，你不用魔法根本不可能做完。所以现在要让你发明一种魔法完成这个任务。问题已经讲完了，下面开始教授汉语。（会汉语或者自认为会汉语的可以自动跳过）汉语中一个字的拼音由声母和韵母两部分组成，在极少数情况下也会没有声母，但一定有韵母。一般认为，声母有 b, p, m, f, d, t, l, n, g, k, h, j, q, x, z, c, s, zh, ch, sh, r, y, w；韵母有：a, e, o, i, u, ü, ai, ei, ui, ao, ou, iu, ie, üe, er, an, en, in, un, ün, ang, eng, ing, ong。不是所有的字母都能组合的，组合的时候有时会发生一些神奇的事情，例如 üe 变成了 ue。但是标调规则有如下口诀：有 a 先找 a，没 a 找 o e，i u 并排标在后，这样标调不会错。只有下面列出的元素可能会被标调。请按照下表输出（尤其注意 a 不要输出成 ɑ 了）：第一声：ā ē ī ō ū ǖ。第二声：á é í ó ú ǘ。第三声：ǎ ě ǐ ǒ ǔ ǚ。第四声：à è ì ò ù ǜ。轻声：a e i o u ü。辅助材料：由教育部公布的拼音方案。如果有描述不一致的地方，请以本题描述为准。 Input第一行一个整数T(1≤T≤10^5)。下面T行，每行一个拼音：拼音声调在各个拼音之后，用数字 [1-4] 进行表示。例如 zhong1 guo2。没有数字的说明是轻声，不用标调。按照国际惯例，输入文件全部由 ASCII 编码组成。ü 用 v 来代替。但在输出中，应仍然用 ü 来表示。 Output对于每一组数据，输出 Case x: y。其中 x 是从 1 开始的测试数据编号，y 是一个拼音标调后的答案。注意：对于非 ASCII 字符的输出，请使用 UTF-8 编码。 ExamplesInput5zhong1guo2meque1nv3 OutputCase 1: zhōngCase 2: guóCase 3: meCase 4: quēCase 5: nǚ Note会 C/C++ 的魔法师最可爱了。 Source2017 华东师范大学网赛 题目大意：给你T个拼音以及此拼音的声调，让你对其进行音标的标注。 解题思路：就是按照其要求对将要标记声调的字符进行替换就好了。但是替换的字符有的非ASCII 编码，所以用一个char字符是存不下的，这里我用的string来实现相应的存储。还有几个小细节要注意一下，比如v换为ü，标声调时i u 并排标在后等。 Mycode:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1005;int main()&#123; string ty[5][6] = &#123; &#123;"a","o","e","i","u","ü"&#125;, &#123;"ā","ō","ē","ī","ū","ǖ"&#125;, &#123;"á","ó","é","í","ú","ǘ"&#125;, &#123;"ǎ","ǒ","ě","ǐ","ǔ","ǚ"&#125;, &#123;"à","ò","è","ì","ù","ǜ"&#125; &#125;; int T; int pos, neww, sd; string s; scanf("%d",&amp;T); for(int cas = 1; cas &lt;= T; ++cas) &#123; cin &gt;&gt; s; int len = s.length(); //判断声调 if(s[len-1] == '1') sd = 1; else if(s[len-1] == '2') sd = 2; else if(s[len-1] == '3') sd = 3; else if(s[len-1] == '4') sd = 4; else &#123;sd = 0;len++;&#125; len--; //找应该被标记声调的字母 neww = pos = -1; for(int i = 0; i &lt; len; ++i) &#123; if(s[i] == 'a') &#123; pos = i; neww = 0; break; &#125; else if(s[i] == 'o') &#123; pos = i; neww = 1; &#125; else if(s[i] == 'e' &amp;&amp; ((neww == -1) || (neww &gt;= 2))) &#123; pos = i; neww = 2; &#125; else if(s[i] == 'i' &amp;&amp; ((neww == -1) || (neww &gt;= 3))) &#123; pos = i; neww = 3; &#125; else if(s[i] == 'u' &amp;&amp; ((neww == -1) || (neww &gt;= 3))) &#123; pos = i; neww = 4; &#125; else if(s[i] == 'v' &amp;&amp; ((neww == -1) || (neww &gt;= 5))) &#123; pos = i; neww = 5; &#125; &#125; //开始输出 printf("Case %d: ",cas); for(int i = 0; i &lt; len; ++i) &#123; if(pos == i) &#123; cout &lt;&lt; ty[sd][neww]; &#125; else if(s[i] == 'v') &#123; cout &lt;&lt; "ü"; &#125; else &#123; cout &lt;&lt; s[i]; &#125; &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>EOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5937 Game of Taking Stones 【威佐夫博弈+大数+高精度】]]></title>
    <url>%2Fhdu-5937%2F</url>
    <content type="text"><![CDATA[Problem DescriptionTwo people face two piles of stones and make a game. They take turns to take stones. As game rules, there are two different methods of taking stones: One scheme is that you can take any number of stones in any one pile while the alternative is to take the same amount of stones at the same time in two piles. In the end, the first person taking all the stones is winner.Now,giving the initial number of two stones, can you win this game if you are the first to take stones and both sides have taken the best strategy? InputInput contains multiple sets of test data.Each test data occupies one line,containing two non-negative integers a andb,representing the number of two stones.a and b are not more than $10^{100}$. OutputFor each test data,output answer on one line.1 means you are the winner,otherwise output 0. Sample Input2 1 8 4 4 7 Sample Output0 1 0 Source2016ACM/ICPC亚洲区大连站-重现赛（感谢大连海事大学） 题意：全裸的威佐夫博弈，但是输入的两个数长度长达100位 思路：对于该题，数据范围是10的100次方，还有小数乘法 —-&gt; 黄金分割率需要精确到小数点后100位 —-&gt; 通过二分求解。 威佐夫博弈：a为a、b中较小的数，先手是否会赢 —–&gt; $ \frac{\sqrt5+1}{2} \times (b - a) $ == a ？ lose : win AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.math.BigInteger;import java.math.BigDecimal;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); BigDecimal TWO = BigDecimal.valueOf(2); BigDecimal FIVE = BigDecimal.valueOf(5); BigDecimal EPS = new BigDecimal("-0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"); BigDecimal L = new BigDecimal("2.2360679774997"); BigDecimal R = new BigDecimal("2.2360679774998"); BigDecimal mid = null; while(L.subtract(R).compareTo(EPS) &lt; 0) &#123; mid = L.add(R).divide(TWO); if(mid.multiply(mid).subtract(FIVE).abs().compareTo(EPS.abs()) &lt; 0) break; if(mid.multiply(mid).subtract(FIVE).compareTo(EPS) &lt; 0) L = mid; else R = mid; &#125; BigDecimal GOLD = mid.add(BigDecimal.ONE).divide(TWO); //System.out.println(GOLD); while(scanner.hasNext()) &#123; BigDecimal a = scanner.nextBigDecimal(); BigDecimal b = scanner.nextBigDecimal(); if(a.compareTo(b) &gt; 0) //保证a是小的 &#123; BigDecimal t = a; a = b; b = t; &#125; BigDecimal c = b.subtract(a).multiply(GOLD); BigInteger aa = a.toBigInteger(); BigInteger cc = c.toBigInteger(); if(aa.equals(cc)) System.out.println("0"); else System.out.println("1"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>HDU</tag>
        <tag>ICPC</tag>
        <tag>大数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017_SDNU_ACM-ICPC_Provincial_Team_Selection_Round_2【--完结--】]]></title>
    <url>%2Fsdnu-2017-4%2F</url>
    <content type="text"><![CDATA[山东省第八届acm大学程序设计竞赛山师选拔赛第二场(声明：标题是自己取的，如果有语法错误的话与他人无关) —————————————————————–分割线—————————————————————– Problem_A(最近公共祖先)题意：SDNU的ACM集训队陷入了混乱中，如果你加入，你要成为一个人的小跟班，我们把你跟着的那个人称为“dalao”(/doge)。例如有两个菜鸟C和D加入了，他们的dalao是A，我们就称A是C和D的最近公共dalao。再比如C是E和F的dalao，那么E和C的最近公共dalao就是A。一共n个人，给你n-1组关系，问输入的两个人的最近公共dalao是谁，有的话输出他的名字，没有输出“I am so bad.”(注意一下Hint里的提示：A也是A的daolao 思路：一开始考虑用map来记录这个点的根节点，关系记录完后，不断向上查询，直至找到它的祖先，然后必然的TLE。其实这个题就是个经过封装的求LCA的题目，套上模板就能A了(主要目的应该是让我们学一下LCA吧。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 10010;const int DEG = 20;struct Edge&#123; int to,next;&#125; edge[MAXN*2];int head[MAXN],tot;void addedge(int u,int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;int fa[MAXN][DEG];//fa[i][j]表示结点i的第2^j个祖先int deg[MAXN];//深度数组void BFS(int root)&#123; queue&lt;int&gt;que; deg[root] = 0; fa[root][0] = root; que.push(root); while(!que.empty()) &#123; int tmp = que.front(); que.pop(); for(int i = 1; i &lt; DEG; i++) fa[tmp][i] = fa[fa[tmp][i-1]][i-1]; for(int i = head[tmp]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(v == fa[tmp][0])continue; deg[v] = deg[tmp] + 1; fa[v][0] = tmp; que.push(v); &#125; &#125;&#125;int LCA(int u,int v)&#123; if(deg[u] &gt; deg[v])swap(u,v); int hu = deg[u], hv = deg[v]; int tu = u, tv = v; for(int det = hv-hu, i = 0; det ; det&gt;&gt;=1, i++) if(det&amp;1) tv = fa[tv][i]; if(tu == tv)return tu; for(int i = DEG-1; i &gt;= 0; i--) &#123; if(fa[tu][i] == fa[tv][i]) continue; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;bool flag[MAXN];int main()&#123; int T; int n; int u,v; while(~scanf("%d",&amp;n)) &#123; init(); memset(fa,0,sizeof(fa)); memset(deg,0,sizeof(deg)); memset(flag,false,sizeof(flag)); for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d",&amp;u,&amp;v); addedge(u,v); addedge(v,u); flag[v] = true; &#125; int root; for(int i = 1; i &lt;= n; i++) if(!flag[i]) &#123; root = i; break; &#125; BFS(root); scanf("%d%d",&amp;u,&amp;v); if(LCA(u,v)) printf("%d\n",LCA(u,v)); else puts("I am so bad."); &#125; return 0;&#125; Problem_B(矩阵快速幂)题意：对任意的$(1+\sqrt2) ^ n$我们是否能找到对应的m使得上式化简为$\sqrt{m} + \sqrt{m-1}$，如果有，请输出$m \mod (1e9+7)$的值，没有输出”I want to talk a joke.” 思路：先写几个数字看看什么情况。化简后会看出(整数部分)系数为1、3、7、17……带有$\sqrt{2}$的部分的系数为1、2、5、12……后者数值等于它上一个数的这两部分的系数之和(2=1+1,5=3+2,12=7+5……)，前者的数值等于和他一个数的$\sqrt{2}$的部分的系数+它上一个数的$\sqrt{2}$的部分的系数(3=2+1,7=5+2,17=12+5……)。根据这个规律构造一个四阶矩阵，然后套上模板就可以了。注意每次乘完都要%MOD一下，防止溢出。 关于输出：如果n是奇数的话，就输出(整数部分)系数的^2，否则输出它的^2+1(自己推一推便知道了。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 10010;const int MOD = 1e9 + 7;const int ch = 4;struct matrix&#123; long long mat[ch][ch];&#125;;matrix multiply(matrix a, matrix b) //构造矩阵乘法&#123; int i, j, k; matrix t; memset(t.mat, 0, sizeof(t. mat)); for(i = 0; i &lt; ch; ++i) for(j = 0; j &lt; ch; ++j) for(k = 0; k &lt; ch; ++k) t.mat[i][j] = (t.mat[i][j] + a.mat[i][k]*b.mat[k][j]%MOD) % MOD; return t;&#125;long long fibonacci(long long n)&#123; long long tem = n; n--; matrix base, ans; memset(base.mat, 0, sizeof(base.mat)); memset(ans.mat, 0, sizeof(ans.mat)); base.mat[2][0] = base.mat[2][2] = base.mat[3][1] = base.mat[3][2] = base.mat[3][3] = 1; base.mat[2][3] = 2; ans.mat[0][1] = ans.mat[0][0] = 1; ans.mat[0][2] = 2; ans.mat[0][3] = 3; while(n) &#123; if(n &amp; 1) ans = multiply(ans, base); base = multiply(base, base); n &gt;&gt;= 1; &#125; //cout &lt;&lt; tem &lt;&lt; endl; if(!(tem&amp;1)) return ans.mat[0][1]*ans.mat[0][1]%MOD; return (ans.mat[0][1]*ans.mat[0][1]+1)%MOD;&#125;int main()&#123; long long n; while(cin &gt;&gt; n) cout &lt;&lt; fibonacci(n) &lt;&lt; endl; return 0;&#125; Problem_C(签到题)题意：给定1-n个城市，你处在x位置，求出满足|x-i|&lt;=r的正整数i的可能取到的数。 思路：因为给定了n的范围，所以一共会有4种情况，即左越界，左不越界，右越界，右不越界。4个if，轻松搞定。(我这个人比较懒，用一个for遍历了一遍，符合条件就让ans++，否则不作操作。比较而言当然是前者时间复杂度更低了，比赛时当然是要选择最优解法。 AC代码：1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; double n, r, x; //用int就行 scanf("%d",&amp;t); while(t--) &#123; int ans = 0; scanf("%lf%lf%lf",&amp;n,&amp;r,&amp;x); for(int i = 1; i &lt;= n; ++i) &#123; if(fabs(x-i) &lt;= r) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem_D(线段树单点更新求和+期望公式)题意：在一个长度为n的数组里，分别执行两种操作，1是把位置为x的元素改为y;2是求出区间l到r的方差。 思路：线段树的单点更新及求和，直接套模板就可以。 期望公式：D(x) = E(x^2) - E(x)^2。而求区间的方差此公式经过化简可得，D(x) = num $\times$ sum2 - sum $\times$ sum，其中num是区间的元素总个数，sum2是区间内每个元素的平方求和，sum是区间内的每个元素的和。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1&lt;&lt;16;struct node&#123; int l, r; long long sum, sum2;&#125; tree[MAX&lt;&lt;2];long long a[MAX];long long sum, sum2;void pushup(int rt)&#123; tree[rt].sum = tree[rt&lt;&lt;1].sum + tree[rt&lt;&lt;1|1].sum; tree[rt].sum2 = tree[rt&lt;&lt;1].sum2 + tree[rt&lt;&lt;1|1].sum2;&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; tree[rt].sum = 0; if(l == r) &#123; tree[rt].sum = a[l]; tree[rt].sum2 = a[l]*a[l]; return ; &#125; int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; //递归建树 build(l, mid, rt&lt;&lt;1); build(mid+1, r, rt&lt;&lt;1|1); pushup(rt);&#125;void update(int x, int y, int rt)&#123; //更新这个区间的值 if(tree[rt].l == tree[rt].r) &#123; tree[rt].sum = y; tree[rt].sum2 = y*y; return ; &#125; int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(x &lt;= mid) update(x, y, rt&lt;&lt;1); else update(x, y, rt&lt;&lt;1|1); pushup(rt);&#125;void query(int x, int y, int rt)&#123; if(tree[rt].l == x &amp;&amp; tree[rt].r == y) &#123; sum += tree[rt].sum; sum2 += tree[rt].sum2; return ; &#125; int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(y &lt;= mid) query(x, y, rt&lt;&lt;1); else if(x &gt; mid) query(x, y, rt&lt;&lt;1|1); else &#123; query(x, mid, rt&lt;&lt;1); query(mid+1, y, rt&lt;&lt;1|1); &#125;&#125;int main()&#123; int n, m; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= n; ++i) scanf("%lld",&amp;a[i]); build(1, n, 1); while(m--) &#123; int q; scanf("%d",&amp;q); if(q == 1) &#123; int pos, num; scanf("%d%d",&amp;pos,&amp;num); update(pos, num, 1); &#125; else &#123; int l, r; sum = sum2 = 0; scanf("%d%d",&amp;l,&amp;r); query(l, r, 1); long long ans = (r-l+1)*sum2 - sum*sum; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; Problem_E(最短路)题意：告诉你一系列的公交线路，问能否从1号站到m号站，如果能，输出最少的换乘次数，不能输出-1。 思路：建图。把任一公交线路中任意两点能到达的位置距离设置为1，这样条件都结束后不能到达的位置距离就是INF。然后转化为最短路问题解决就行了。 对输入的处理：每行结束的标志是’\n’，可以用gets读入一行后把数字当作字符挨个处理；其他人也有用scanf(“%d%c”,&amp;d,&amp;ch)这样读入的，当ch==’\n’时break;也可以像我一样用stringstream。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 510;int n;int adj[MAX][MAX];int a[MAX], dis[MAX];bool vis[MAX];void init()&#123; for(int i = 1; i &lt;= 500; ++i) &#123; for(int j = 1; j &lt;= 500; ++j) &#123; if(i == j) adj[i][j] = 0; else adj[i][j] = INF; &#125; &#125;&#125;void Dij()&#123; int tem, minx; memset(vis, false, sizeof(vis)); for(int i = 0; i &lt;= n; ++i) dis[i] = adj[1][i]; dis[1] = 0; vis[1] = true; for(int i = 1; i &lt; n; ++i) &#123; minx = INF; for(int j = 1; j &lt;= n; ++j) &#123; if(!vis[j] &amp;&amp; dis[j] &lt; minx) &#123; minx = dis[j]; tem = j; &#125; &#125; if(minx == INF) break; vis[tem] = 1; for(int j = 1; j &lt;= n; ++j) &#123; if(!vis[j] &amp;&amp; adj[tem][j] != INF &amp;&amp; dis[tem] + adj[tem][j] &lt;dis[j]) &#123; dis[j] = adj[tem][j] + dis[tem]; &#125; &#125; &#125;&#125;int main()&#123; int t; int item; string stem, s; while(~scanf("%d",&amp;t)) &#123; init(); scanf("%d",&amp;n); getchar(); while(t--) &#123; int cou = 0; getline(cin, stem); stringstream ss (stem); while(ss &gt;&gt; item) &#123; a[cou++] = item; &#125; for(int i = 0; i &lt; cou-1; ++i) for(int j = i+1; j &lt; cou; ++j) &#123; adj[a[i]][a[j]] = 1; &#125; &#125; Dij(); if(dis[n] == INF) cout &lt;&lt; "-1" &lt;&lt; endl; else cout &lt;&lt; dis[n]-1 &lt;&lt; endl; &#125; return 0;&#125; Problem_F(思维)题意：一群美女排成一排，各有各的颜值。现在GOD超要从中选取一些连续排列的美女，要求他们的颜值满足先增大后减小。如果有，依次输出起点美女和重点美女的坐标；多组的话输出长度最长的那组的两个下标；没有符合题意的输出-1 -1。 思路：之前做过一个合唱队列的题目(要求求出最长先严格上升后严格下降的子序列的长度，我从头到尾求了每个点作为终点的最长上升子序列的长度，从尾往前求出了每个点作为终点的最长上升子序列的长度，然后遍历一遍求出最大的两者之和-1的值)，开始以为是类似的，觉得有点麻烦，就略过了(而队友一直在调E，以至于到了最后也没做)。赛后看了看发现一个for循环就能解决。具体做法是从前往后遍历，让起点定位在第一个位置，开始下降后把终点定位。碰到再上升，就把之前的符合条件的与当前已有的答案比较，保留最优解。重复此过程直至遍历结束。详见代码。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 5e6 + 5;int a[N];int main()&#123; int n; bool flag; int ans1, ans2, tem1, tem2; while(~scanf("%d",&amp;n)) &#123; flag = true; ans1 = ans2 = -1; tem1 = 0; tem2 = -1; for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); for(int i = 1; i &lt; n; ++i) &#123; if(a[i-1] == a[i]) &#123; if(tem2 - tem1 &gt; ans2 - ans1)//更新答案 &#123; ans2 = tem2; ans1 = tem1; &#125; tem1 = tem2 = -1; continue; &#125; if(a[i-1] &lt; a[i]) //上升 &#123; if(!flag) &#123; if(tem2 - tem1 &gt; ans2 - ans1)//更新答案 &#123; ans2 = tem2; ans1 = tem1; &#125; flag = 1; tem1 = tem2 = -1; &#125; if(tem1 == -1) tem1 = i-1; //cout &lt;&lt; i &lt;&lt; "--" &lt;&lt; tem1 &lt;&lt; endl; &#125; else &#123; flag = 0; if(tem1 != -1) tem2 = i; &#125; if(tem2 - tem1 &gt; ans2 - ans1)//更新答案 &#123; ans2 = tem2; ans1 = tem1; &#125; &#125; if(ans1 != -1 &amp;&amp; ans2 != -1) cout &lt;&lt; ans1 &lt;&lt; " " &lt;&lt; ans2 &lt;&lt; endl; else cout &lt;&lt; "-1 -1" &lt;&lt; endl; &#125; return 0;&#125; Problem_G(并查集)题意：在一块1000$\times$1000的土地上施工，每周选择一块土地使这块土地由海洋变为陆地。问经过n周后，一共有多少块岛屿(上下左右相连接的属于一块)，岛屿面积是多少以及岛屿的周长。 思路：施工n次，假设每次开辟的新岛屿周围都没有与之相连接的岛屿，所以岛屿个数+1，面积+1，周长+4。然后再判断它周围是否有可以与之相连的岛屿，上下左右四个方向逐个判断，再将相连接的个数相减就好了。具体减的方法很简单，此处不再赘述，如有疑问，欢迎私戳。 并查集：用来快速判断两者是否属于同一个集合的工具，因为所给的数据范围不是很大，所以可以用f[x$\times$MAX+y]来表示点(x,y)所属的集合，这里转化完后就与普通的并查集没啥区别了。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int MAX = 1000;int tot, area, peri, cou;int f[MAX*MAX+5]; //记录是否联通char mapa[MAX+5][MAX+5]; //存图int dir[][2] = &#123;0,1,0,-1,1,0,-1,0&#125;;void init()&#123; for(int i = 0; i &lt;= MAX*MAX; ++i) &#123; f[i] = i; &#125;&#125;int getf(int v)&#123; if(f[v] != v) f[v] = getf(f[v]); return f[v];&#125;int merg(int u, int v)&#123; int t1 = getf(u); int t2 = getf(v); /*cout &lt;&lt; u &lt;&lt; "--" &lt;&lt; v &lt;&lt; endl; cout &lt;&lt; t1 &lt;&lt; "----" &lt;&lt; t2 &lt;&lt; endl &lt;&lt; endl;*/ if(t1 != t2) &#123; f[t2] = t1; return 1; //与周围的岛屿之前不连通 &#125; return 0;&#125;void solve(int x, int y)&#123; int xx, yy; for(int i = 0; i &lt; 4; ++i) &#123; xx = x + dir[i][0]; yy = y + dir[i][1]; if(xx &lt; 0 || xx &gt;= MAX || yy &lt; 0 || yy &gt; MAX) continue; if(mapa[xx][yy] != '#') continue; //cout &lt;&lt; xx &lt;&lt; "---" &lt;&lt; yy &lt;&lt; endl; if(merg(x*MAX+y, xx*MAX+yy)) //联通成功，总岛屿数-1 &#123; tot--; &#125; peri -= 2; //周围有一个岛屿的话，周长-2 &#125;&#125;int main()&#123; int t; int x, y; while(~scanf("%d",&amp;t)) &#123; init(); tot = area = peri = 0; memset(mapa, 0, sizeof(mapa)); while(t--) &#123; scanf("%d%d",&amp;x,&amp;y); if(mapa[x][y] == '#') &#123; cout &lt;&lt; tot &lt;&lt; " " &lt;&lt; area &lt;&lt; " " &lt;&lt; peri &lt;&lt; endl; continue; &#125; //先假设新加入的岛屿与其他都不连通 tot++; area++; peri += 4; mapa[x][y] = '#'; //开始做减法 solve(x, y); cout &lt;&lt; tot &lt;&lt; " " &lt;&lt; area &lt;&lt; " " &lt;&lt; peri &lt;&lt; endl; &#125; &#125; return 0;&#125; Problem_H(博弈+大数)题意：理解后可以改为两个人取石子，规则是每次可以取1-4个，谁先取到最后一块谁就能赢，A先取。 思路：很显然，当n∈[1,4]时，A必赢；n=5时，A必输。因为两人都采取最优策略，所以当n∈[6,9]时，A可以取到使石子数目剩余为5，这样他就必赢，而当n=10时，B就必赢了……总结一下得出结论，所给的石子总数为5的倍数时，B必赢，否则A必赢。另外，数据有点大，考虑到了用JAVA。不过鉴于这个数据的特殊性，是5的倍数，用C++的话只要判断最后一位数是否是5或0就好了，想到了会更加轻松。(这里C++的就不贴了 AC代码(JAVA)：12345678910111213141516171819202122import java.math.BigInteger;import java.math.BigDecimal;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T; BigInteger n; BigInteger MOD = new BigInteger("5"); T = scanner.nextInt(); while((T--) &gt; 0) &#123; n = scanner.nextBigInteger(); if(n.mod(MOD).compareTo(BigInteger.ZERO) == 0) System.out.println("chaochao"); else System.out.println("huahua"); &#125; &#125;&#125; Problem_I(素数打表)题意：给你一个偶数x，让你判断这个偶数能否用两个素数(a、b)之差表示出来(a-b=x)，能的话根据b的大小输出最小的一组，不能的话输出FAIL 思路：任一大于2的偶数都可写成两个质数之和(哥德巴赫猜想)，这道题自己想一下就会知道不会出现FAIL的情况。因为数据比较大，所以打两个表：第一个vis判断是否是素数，第二个a记录可能用到的素数。然后对于给定的x，依次将a[i]从第一个往后遍历，如果x+a[i]是素数那就输出他们，结束遍历。(这里不得不单独吐槽一下出题人→_→，题面的数据范围给小了，比赛时改了数据。赛后改了题面，做了这两天，让我WA到怀疑人生。看别人过了，更忍不了了，下载测试数据对拍后才发现，出题人标程没改，那个A了的是错的。难受。。后来那个lazy的出题人把数据范围缩小了╮(╯_╰)╭rejudge后轻松AC) AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1500005;int a[MAX], tot;bool vis[MAX];void init()//筛法求a数组&#123; memset(vis, false, sizeof(vis)); //vis[0] = vis[1] = true; tot = 0; int M = sqrt(MAX+0.5); for(int i = 2; i &lt;= M; ++i) &#123; if(!vis[i]) &#123; a[tot++] = i; for(int j = i*i; j &lt;= MAX; j += i) &#123; vis[j] = true; &#125; &#125; &#125;&#125;int main()&#123; init(); int t, n; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); for(int i = 0; i &lt; tot; ++i) &#123; if(!vis[n+a[i]]) &#123; cout &lt;&lt; n+a[i] &lt;&lt; " " &lt;&lt; a[i] &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; Problem_J(贪心)题意：有一块肉重为n，每切一次消耗n的体力，要求切成所给的t块重为a[i]的肉，问消耗的最小体力是多少。 思路：倒着想，根据所给的每块小肉，将它们合并为一块大肉，每次合并消耗所要合并的两块肉的重量之和。因为求最小的消耗体力，而最小的两块合并后不一定是最小的了，所以每次取完后都得重新排一次序。因之前后面的序列都已有序，直接用sort会造成大量的时间浪费，所以我可以用依次往后交换直到后面的数大于等于要交换的这个数为止。当然能用上优先队列的话就不用每次都重新排序了。 相似(?：石子合并简化版，每次取最大的合并，这样合并完后不用再排序，直接继续取就OK。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 20005;long long a[MAX];int main()&#123; int n; long long ans; while(~scanf("%d",&amp;n)) &#123; ans = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a, a+n); int tot = 1; while(tot &lt; n) &#123; a[tot] = a[tot] + a[tot-1]; ans += a[tot]; for(int i = tot; i &lt; n-1; ++i) &#123; if(a[i] &lt;= a[i+1]) break; swap(a[i], a[i+1]); &#125; tot++; /*cout &lt;&lt; " tot=" &lt;&lt; tot &lt;&lt; endl; for(int i = 0; i &lt; n; ++i) cout &lt;&lt; a[i] &lt;&lt; " "; cout &lt;&lt; endl;*/ &#125; //cout &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; AC代码(priority_queue)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;struct cmp //自定义优先级&#123; bool operator () (long long &amp;a, long long &amp;b) const &#123; //最小值优先 return a &gt; b; &#125;&#125;;int main()&#123; int n; long long ans, tem; priority_queue&lt;long long, vector&lt;long long&gt;, cmp &gt;pq; //因为priority_queue中有已经定义好的越小的整数优先级越大，所以可以直接调用 //priority_queue&lt;long long, vector&lt;long long&gt;, greater&lt;long long&gt; &gt;pq; while(~scanf("%d",&amp;n)) &#123; ans = 0; while(!pq.empty()) pq.pop(); while(n--) &#123; scanf("%lld",&amp;tem); pq.push(tem); &#125; while(!pq.empty()) &#123; tem = pq.top(); pq.pop(); if(pq.empty()) break; //cout &lt;&lt; "tem=" &lt;&lt; tem &lt;&lt; endl; tem += pq.top(); pq.pop(); //cout &lt;&lt; "tem2=" &lt;&lt; tem &lt;&lt; endl; ans += tem; pq.push(tem); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; —————————————————————–分割线—————————————————————– 选拔赛结束了，虽然以排名比较靠前的成绩进了正式队，但是心里很是不甘，特别是这一次，很多能做的题都没做出来，还有一开始I的数据范围看错+打表打错，浪费了太多时间也影响了整体士气(我的锅。还剩25天了，多学知识的同时也要修炼自己沉稳的性格，不管结果如何，不留遗憾就好。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017_SDNU_ACM-ICPC_Provincial_Team_Selection_Round_1【--完结--】]]></title>
    <url>%2Fsdnu-2017-3%2F</url>
    <content type="text"><![CDATA[山东省第八届acm大学程序设计竞赛山师选拔赛第一场(声明：标题是自己取的，如果有语法错误的话与他人无关) —————————————————————–分割线—————————————————————– Problem_A(大数判定2幂数)题意：给定一个数，判断它是否是2的n次方(0 &lt; n &lt; $2 ^ {1000}$) 按二进制考虑的话，如果n&amp;(n-1)==0，则这个数就是2的n次方,等于1就不是。 AC代码(JAVA版)： 1234567891011121314151617181920212223import java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T; BigInteger N; BigInteger ZERO = new BigInteger("0"); BigInteger ONE = new BigInteger("1"); T = scanner.nextInt(); for(int i = 0; i &lt; T; ++i) &#123; N = scanner.nextBigInteger(); BigInteger M = N.subtract(ONE); if(N.and(M).compareTo(ZERO) == 0) System.out.println("Yes"); else System.out.println("No"); &#125; &#125;&#125; Problem_B(离散化裸题)有些数据本身很大，自身无法作为数组的下标保存对应的属性。如果这时只是需要这堆数据的相对属性时，那么就可以对其进行离散化。所谓离散化就是指当数据只与它们之间的相对大小有关，而与具体是多少无关时可以用到的一种方法(？ 举个例子来说，假设有4个数：1234567、123456789、12345678、123456排序后是123456＜1234567＜12345678＜123456789（只考虑他们相对大小可以想为1＜2＜3＜4），那么这四个数可以表示成：2、4、3、1。 对数据进行离散化如果用上STL会很棒棒哦（思路：先排序，再去重，然后索引元素离散化后对应的值，详见代码）。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 2002;bool flag[N][N];long long x[N], y[N];long long xx[N], yy[N];int main()&#123; int n; scanf("%d",&amp;n); memset(flag, false, sizeof(flag)); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%lld%lld%lld%lld",&amp;xx[i],&amp;yy[i],&amp;xx[i+n],&amp;yy[i+n]); //输入的同时对数据进行离散化 x[2*i] = xx[i+n]; y[2*i] = yy[i+n]; x[2*i-1] = xx[i]; y[2*i-1] = yy[i]; &#125; //排序去重 sort(x+1, x+1+2*n); sort(y+1, y+1+2*n); unique(x+1, x+1+2*n); unique(y+1, y+1+2*n); //索引元素离散化后对应的值 for(int i = 1; i &lt;= 2*n; ++i) &#123; xx[i] = upper_bound(x+1, x+1+2*n, xx[i]) - (x+1); yy[i] = upper_bound(y+1, y+1+2*n, yy[i]) - (y+1); &#125; for(int k = 1; k &lt;= n; ++k) for(int i = xx[k]+1; i &lt;= xx[k+n]; ++i) //从xx[k]+1开始 for(int j = yy[k]+1; j &lt;= yy[k+n]; ++j)//从yy[k]+1开始 flag[i][j] = true; long long ans = 0; for(int i = 2; i &lt;= 2*n; ++i) for(int j = 2; j &lt;= 2*n; ++j) if(flag[i][j]) ans += (x[i]-x[i-1])*(y[j]-y[j-1]);//是y[j]-y[j-1] cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Problem_C(最长回文子串)题意：给定一序列，输出其最长回文子序列的长度。 思路：没有思路，Manacher模板一套带走。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e6+5;char MA[MAX*2];int MP[MAX*2];void Manacher(char s[], int len)&#123; int l = 0; MA[l++] = '$'; MA[l++] = '#'; for(int i = 0; i &lt; len; ++i) &#123; MA[l++] = s[i]; MA[l++] = '#'; &#125; MA[l] = 0; int mx = 0, id = 0; for(int i = 0; i &lt; l; ++i) &#123; MP[i] = mx &gt; i ? min(MP[2*id-i], mx-i) : 1; while(MA[i+MP[i]] == MA[i-MP[i]]) MP[i]++; if(i+MP[i]&gt;mx) &#123; mx = i + MP[i]; id = i; &#125; &#125;&#125;char s[MAX];int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; scanf("%s",s); int len = strlen(s); Manacher(s, len); int ans = 0; for(int i = 0; i &lt; 2*len+2; ++i) ans = max(ans, MP[i]-1); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem_D(多重背包)题意：有n个面值为A1,A2,..An,数量为C1,C2,..Cn的n个硬币，问他们之间互相组合能凑出多少种总面额小于m的面值 (可参照POJ的男人八题之Coins AC代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100000 + 5;int A[105], C[105];int DP[MAX]; //面额为A[i]的硬币在DP[i]位置用过的个数bool vis[MAX];//能凑成的面额int main()&#123; int N, M; while(scanf("%d%d",&amp;N,&amp;M) &amp;&amp; (N||M)) &#123; memset(vis, false, sizeof(vis)); for(int i = 1; i &lt;= N; ++i) scanf("%d",&amp;A[i]); for(int i = 1; i &lt;= N; ++i) scanf("%d",&amp;C[i]); vis[0] = true; for(int i = 1; i &lt;= N; ++i) &#123; memset(DP, 0, sizeof(DP)); for(int j = 1; j &lt;= M; ++j) &#123; //没有凑成过并且现在硬币的面额比要凑的面额大 if(vis[j] || j &lt; A[i]) continue; if(vis[j-A[i]] &amp;&amp; DP[j-A[i]]&lt;C[i]) &#123; vis[j] = true; //cout &lt;&lt; j &lt;&lt; " "; DP[j] = DP[j-A[i]] + 1; &#125; &#125; &#125; //cout &lt;&lt; endl; int ans = 0; for(int i = 1; i &lt;= M; ++i) if(vis[i]) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem_E（思维 签到）题意：给定n个数，从中抽取3个，将它们分成4组，问能否使每组的和相同。能的话输出抽取的三个数的位置，不能就输出I am done. 思路：设置i,j,k三个指针，一开始放在2,4,6这三个位置，然后不断判断分成的四组数据和是否相同，不同就找出其中最小的那一组，让他后面的指针往后移动。还有些小细节，比如k指针到头了，四组的值都相同了等等，自己处理一下就好了。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1005;int a[MAX];int MIN(int a, int b, int c, int d)&#123; if(a &lt;= b &amp;&amp; a &lt;= c &amp;&amp; a &lt;= d) return 1; if(b &lt;= a &amp;&amp; b &lt;= c &amp;&amp; b &lt;= d) return 2; if(c &lt;= a &amp;&amp; c &lt;= b &amp;&amp; c &lt;= d) return 3; if(d &lt;= a &amp;&amp; d &lt;= b &amp;&amp; d &lt;= c) return 4; return 0;&#125;int main()&#123; int n; int x, y, z; int ans1, ans2, ans3, ans4; while(~scanf("%d",&amp;n)) &#123; for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); bool flag = 1; if(n &lt; 7) flag = 0; if(flag) &#123; ans1 = ans2 = ans3 = ans4 = 0; x = 1; y = 3; z = 5; ans1 = a[0]; ans2 = a[2]; ans3 = a[4]; for(int i = 6; i &lt; n; ++i) ans4 += a[i]; while(flag) &#123; if(ans1 == ans2 &amp;&amp; ans1 == ans3 &amp;&amp; ans1 == ans4) break; int ans = MIN(ans1, ans2, ans3, ans4); switch(ans) &#123; case 0: case 4: flag = 0; break; case 1: x++; case 2: y++; case 3: z++; break; &#125; ans1 = ans2 = ans3 = ans4 = 0; for(int i = 0; i &lt; x; ++i) ans1 += a[i]; for(int i = x+1; i &lt; y; ++i) ans2 += a[i]; for(int i = y+1; i &lt; z; ++i) ans3 += a[i]; for(int i = z+1; i &lt; n; ++i) ans4 += a[i]; &#125; &#125; if(flag) cout &lt;&lt; x+1 &lt;&lt; " " &lt;&lt; y+1 &lt;&lt; " " &lt;&lt; z+1 &lt;&lt; endl; else cout &lt;&lt; "I am done." &lt;&lt; endl; &#125; return 0;&#125; Problem_F(八进制减法)题意：八进制减法 AC代码(C++–模拟)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/*************Author:E6ther*************/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; while(~scanf("%d",&amp;t)) &#123; getchar(); for(int j=0;j&lt;t;++j) &#123; char a[105],b[105]; int len1=0,len2=0; bool flag=1; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); char c; while((c=getchar())!=' '&amp;&amp;c!='\n') &#123; a[len1]=c-'0'; len1++; &#125; a[len1]=0; while((c=getchar())!=' '&amp;&amp;c!='\n') &#123; b[len2]=c-'0'; len2++; &#125; b[len2]=0; /*for(int i=0;i&lt;len1;++i) &#123; printf("%d",a[i]); &#125;cout&lt;&lt;endl; for(int i=0;i&lt;len2;++i) &#123; printf("%d",b[i]); &#125;cout&lt;&lt;endl;*/ //printf("%s %s\n",a,b); if(len1&gt;len2) &#123; flag=1; &#125; else if(len1&lt;len2) &#123; flag=0; &#125; else &#123; for(int i=0;i&lt;len1;++i) &#123; if(a[i]&gt;b[i]) &#123; flag=1; break; &#125; else if(a[i]&lt;b[i]) &#123; flag=0; break; &#125; &#125; &#125; if(flag) &#123; for(int i=len2-1,j=len1-1;i&gt;=0;--i,--j) &#123; if(a[j]&gt;=b[i]) &#123; a[j]=a[j]-b[i]; &#125; else &#123; a[j]=a[j]+8-b[i]; if(a[j-1]) a[j-1]--; else &#123; int flag2=0; for(int x=j-2;x&gt;=0;--x) &#123; if(a[x]) &#123; a[x]--; flag2=1; &#125; a[x+1]=7; if(flag2) break; &#125; &#125; &#125; &#125; &#125; else &#123; for(int i=len1-1,j=len2-1;i&gt;=0;--i,--j) &#123; if(a[i]&lt;=b[j]) &#123; b[j]=b[j]-a[i]; &#125; else &#123; b[j]=b[j]+8-a[i]; if(b[j-1]) b[j-1]--; else &#123; int flag2=0; for(int x=j-2;x&gt;=0;--x) &#123; if(b[x]) &#123; b[x]--; flag2=1; &#125; b[x+1]=7; if(flag2) break; &#125; &#125; &#125; &#125; &#125; bool flag1=0; if(flag) &#123; for(int i=0;i&lt;len1;++i) &#123; if(a[i]) flag1=1; if(flag1) printf("%d",a[i]); &#125; if(!flag1) cout&lt;&lt;"0"; &#125; else &#123; cout&lt;&lt;"-"; for(int i=0;i&lt;len2;++i) &#123; if(b[i]) flag1=1; if(flag1) printf("%d",b[i]); &#125; &#125; cout&lt;&lt;endl; &#125; &#125; return 0;&#125; AC代码(JAVA):12345678910111213141516171819202122import java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int T; Scanner scanner = new Scanner(System.in); T = scanner.nextInt(); BigInteger N, M, X, Y; for(int i = 0; i &lt; T; ++i) &#123; N = scanner.nextBigInteger(); M = scanner.nextBigInteger(); X = new BigInteger(N.toString(),8); Y = new BigInteger(M.toString(),8); X = X.subtract(Y); System.out.println(X.toString(8)); &#125; &#125;&#125; Problem_G(模拟)题意：给你n个数，输出对他们进行第一次快速排序后的结果。不知道快速排序的话，自己去搜(其实不知道也没关系，题目里已经给出了排序的方式了，按照它的来就是了)。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 10005;int a[MAX];void solve(int n)&#123; int tem = a[0]; int l = 0, r = n; while(l &lt;= r) &#123; for(--r; l &lt;= r; --r) &#123; if(a[r] &lt; tem) &#123; a[l] = a[r]; break; &#125; &#125; for(++l; l &lt;= r; ++l) &#123; if(a[l] &gt; tem) &#123; a[r] = a[l]; break; &#125; &#125; &#125; a[--l] = tem;&#125;int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; memset(a, 0, sizeof(a)); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); solve(n); for(int i = 0; i &lt; n; ++i) &#123; if(i) cout &lt;&lt; " "; cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Problem_H(大素数判定)题意：给你n个数，输出他们中素数的个数。要用到Miller-rabin算法，套个模板就好了。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;using namespace std;const int S = 8;//随机算法判定次数，一般8~10次就够了//计算ret = (a*b)%c a, b, c &lt; 2^63long long mult_mod(long long a, long long b, long long c)&#123; a %= c; b %= c; long long ret = 0; long long tem = a; while(b) &#123; if(b &amp; 1) &#123; ret += tem; if(ret &gt; c) ret -= c;//直接取模慢很多 &#125; tem &lt;&lt;= 1; if(tem &gt; c) tem -= c; b &gt;&gt;= 1; &#125; return ret;&#125;//计算 ret = (a^n) % modlong long pow_mod(long long a, long long n, long long mod)&#123; long long ret = 1; long long tem = a % mod; while(n) &#123; if(n &amp; 1) ret = mult_mod(ret, tem, mod); tem = mult_mod(tem, tem, mod); n &gt;&gt;= 1; &#125; return ret;&#125;// 通过 a^(n-1)=1(mod n)来判断n是不是素数// n-1 = x * 2^t 中间使用二次判断// 是合数返回true，不一定是合数返回falsebool check(long long a, long long n, long long x, long long t)&#123; long long ret = pow_mod(a, x, n);//a^x % n long long last = ret; for(int i = 1; i &lt;= t; ++i)//进行t次(a^x % n)^2 % n &#123; ret = mult_mod(ret, ret, n); if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true;//合数 last = ret; &#125; if(ret != 1) return true; return false;//不一定是合数&#125;//**************************************************// Miller_Rabin算法// 是素数返回true,(可能是伪素数)// 不是素数返回false//**************************************************bool Miller_Rabin(long long n)&#123; if(n &lt; 2) return false; if(n == 2) return true; if( (n&amp;1) == 0) return false;//偶数 long long x = n - 1; long long t = 0; while( (x&amp;1) == 0) //将n分解为x*2^t; &#123; x &gt;&gt;= 1; t++; &#125; srand( time(NULL)); for(int i = 0; i &lt; S; ++i) &#123; long long a = rand()%(n-1) + 1;//产生随机数a(并控制其范围在1 ~ n-1之间) if(check(a, n, x, t))//是合数 return false; &#125; return true;&#125;int main()&#123; int t, ans; long long tem; scanf("%d",&amp;t); ans = 0; while(t--) &#123; scanf("%lld",&amp;tem); if(Miller_Rabin(tem)) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU ACM-ICPC 2016-2017 Training Weekly Contest 2 【--完结--】]]></title>
    <url>%2Fsdnu-2017-2%2F</url>
    <content type="text"><![CDATA[题目链接：https://vjudge.net/contest/153814 A - An ant’s story(思维)HDU - 3343 感觉特别坑的一道题目，只要蚂蚁爬的速度&gt;0，它就能到终点，用到了极限思想？不明觉厉..GG.. AC代码：1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; int a, b, c; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(b &gt; 0) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125; B - War Chess(BFS&lt;用到优先队列&gt;)HDU - 3345 BFS好题，当时做的时候不是TLE就是MLE。赛后我重新写还是MLE（喵喵喵？ 后来问了一下陆历川大哥，他说得用优先队列，能用优先队列的就别用队列，然后给我发了个优先队列的讲解博客地址。又学到了新东西啊.. AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int MAX = 105;int n, m, v;int dir[][2] = &#123;0,1,1,0,-1,0,0,-1&#125;;char mapa[MAX][MAX], newa[MAX][MAX];bool vis[MAX][MAX], eme[MAX][MAX];struct node&#123; int x, y, v; bool operator &lt; (const node &amp;a) const &#123; return v &lt; a.v;//v大的优先 &#125;&#125; q, p;bool ok()&#123; if(p.x &lt; 0 || p.y &lt; 0 || p.x &gt;= n || p.y &gt;= m) return false; if(!p.v || vis[p.x][p.y] || mapa[p.x][p.y] == '#' || mapa[p.x][p.y] == 'E') return false; if(mapa[p.x][p.y] == '.' || mapa[p.x][p.y] == 'P') p.v -= 1; else if(mapa[p.x][p.y] == 'T') p.v -= 2; else if(mapa[p.x][p.y] == 'R') p.v -= 3; if(p.v &lt; 0) return false; if(eme[p.x][p.y]) p.v = 0; return true;&#125;void bfs()&#123; priority_queue&lt;node&gt; Q; Q.push(q); while(!Q.empty()) &#123; q = Q.top(); Q.pop(); for(int i = 0; i &lt; 4; ++i) &#123; p.x = q.x + dir[i][0]; p.y = q.y + dir[i][1]; p.v = q.v; if(ok()) &#123; vis[p.x][p.y] = 1; if(mapa[p.x][p.y] != 'P') newa[p.x][p.y] = '*'; Q.push(p); &#125; &#125; &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; memset(vis, 0, sizeof(vis)); memset(eme, 0, sizeof(eme)); scanf("%d%d%d",&amp;n, &amp;m, &amp;v); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s",mapa[i]); strcpy(newa[i], mapa[i]); &#125; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) &#123; if(mapa[i][j] == 'Y') &#123; vis[i][j] = 1; q.x = i; q.y = j; q.v = v; &#125; if(mapa[i][j] == 'E') &#123; if(i - 1 &gt;= 0) eme[i-1][j] = 1; if(j - 1 &gt;= 0) eme[i][j-1] = 1; if(i + 1 &lt; n) eme[i+1][j] = 1; if(j + 1 &lt; m) eme[i][j+1] = 1; &#125; &#125; bfs(); for(int i = 0; i &lt; n; ++i) cout &lt;&lt; newa[i] &lt;&lt; endl; cout &lt;&lt; endl; &#125; return 0;&#125; C - Lucky Number(基础)HDU - 3346 这个不多说了，又是抢的一血。额..当时有点激动漏了个条件（当然样例是不会让你看出来的，细心一点就好了。 AC代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t, n, ans, ans2; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; ans = ans2 = 0; scanf("%d",&amp;n); if(n % 8 == 0) cout &lt;&lt; "Lucky number!" &lt;&lt; endl; else &#123; int tem = n; while(tem) &#123; int qq = tem % 10; ans += qq; tem /= 10; ans2 = ans2 + qq*qq; &#125; if(ans % 8 == 0 || ans2 % 8 == 0) cout &lt;&lt; "Lucky number!" &lt;&lt; endl; else cout &lt;&lt; "What a pity!" &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; D - Calculate the expression(模拟)HDU - 3347 模拟呀..今下午自己写了会，用了不少STL的东西，后来将表示数字的字符转换为数字时我想到了atoi函数，然而这个函数对string不适用，想着改为char数组后再用这个函数吧，改着改着把自己改迷糊了..去听完报告回来后全换为char数组，结果TLE了（如果用stringstream不就直接弄死我..问了问我兄弟，他说在打游戏让我去他博客找找看（→_→ 你很棒棒哦 对比后感觉自己写的略微“高级”，然后我把“高级”部分改为朴素的if – else if然后就过了，噫，看来能A题的代码才是好代码。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;char s[105];char k[25];int main()&#123; int t, n, flag, tem, ans; scanf("%d",&amp;t); while(t--) &#123; flag = 1; ans = 0; map&lt;string, int&gt; ss; scanf("%d",&amp;n); //cout &lt;&lt; "n= " &lt;&lt; n &lt;&lt; endl; for(int i = 1; i &lt; n; ++i) &#123; scanf("%s = %d",s, &amp;tem); ss[s] = tem; //cout &lt;&lt; "s= " &lt;&lt; s &lt;&lt; " tem= " &lt;&lt; tem &lt;&lt; endl; //cout &lt;&lt; "???" &lt;&lt; endl; &#125; while(1) &#123; scanf("%s",s); tem = 0; if(s[0] &gt;= '0' &amp;&amp; s[0] &lt;= '9')//是正数 数字 &#123; for(int i = 0; i &lt; strlen(s); ++i) &#123; tem *= 10; tem += (s[i] - '0'); &#125; if(flag == 0) ans = ans - tem; else ans = ans + tem; &#125; else if(s[0] == '-') //这里注意一下 表达式中出现-号一定是常数 （我之前还以为会有 1 + -aa的情况.. &#123; for(int i = 1; i &lt; strlen(s); ++i) &#123; tem *= 10; tem += (s[i] - '0'); &#125; if(flag == 1) ans = ans - tem; else ans = ans + tem; &#125; else if(flag == 0) ans = ans - ss[s]; else ans = ans + ss[s]; scanf("%s",k); if(k[0] == '=') break; if(k[0] == '+') flag = 1; else flag = 0; &#125; scanf("%s",k);//处理最后剩下的"？" //cout &lt;&lt; "ans= " &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 写完这篇博客的第二天发现了个有趣的函数——c_str()，这个函数会生成一个const char*指针，指向以空字符终止的数组，有了它我们就可以对string使用atoi函数了。马上去写了一下，觉得爽的同时也觉得自己还是图样图森破。 （我发现的问题，那些前辈们肯定早就知道了，还有的早就在函数库里添加了相应的函数，只是我不知道而已(￣ε(#￣)☆╰╮(￣▽￣///) 最后再说一句——STL大法好 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;sstream&gt;using namespace std;int main()&#123; int t, n, tem, flag, ans; string s, stem; scanf("%d",&amp;t); while(t--) &#123; map&lt;string, int&gt; num; scanf("%d",&amp;n); for(int i = 1; i &lt; n; ++i) &#123; cin &gt;&gt; s; scanf(" = %d",&amp;tem); num[s] = tem; //cout &lt;&lt; s &lt;&lt; " " &lt;&lt; tem; &#125; getchar();//接收一个换行符 这里要注意一下 getline(cin, stem); stringstream ss(stem); ans = 0; flag = 1; while(ss &gt;&gt; s) &#123; if(s == "=") break; if(s == "-") flag = -1; else if(s == "+") flag = 1; else &#123; if(isalpha(s[0])) &#123; tem = num[s]; &#125; else &#123; tem = atoi(s.c_str());//666 &#125; ans += (tem*flag); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; E - coins(贪心)HDU - 3348 贪一贪。（代码写的通俗易懂，至于别人的空间复杂度低的我也不去管了，反正能A题的代码都是好代码(⊙v⊙) 明明很好解决的问题，却只有我和我兄弟做出来了。啧啧啧，队友瑕还说这个和上次做的多重背包的很像，受背包毒害不浅啊..还有通过这次训练，我决定我来作主代码手，毕竟我刷的（基础）题多，见识的（无用）知识点多，还有单身19年+的手速。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int a[5], b[5]; //面值为1 5 10 50 100的钞票个数int main()&#123; int t, p, ans1, ans2;; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;p); ans1 = ans2 = 0; for(int i = 0; i &lt; 5; ++i) scanf("%d",&amp;a[i]); for(int i = 0; i &lt; 5; ++i) b[i] = a[i]; int tem = p; while(tem &gt;= 100 &amp;&amp; a[4]) &#123; tem -= 100; a[4]--; ans2++; &#125; while(tem &gt;= 50 &amp;&amp; a[3]) &#123; tem -= 50; a[3]--; ans2++; &#125; while(tem &gt;= 10 &amp;&amp; a[2]) &#123; tem -= 10; a[2]--; ans2++; &#125; while(tem &gt;= 5 &amp;&amp; a[1]) &#123; tem -= 5; a[1]--; ans2++; &#125; while(tem &gt;= 1 &amp;&amp; a[0]) &#123; tem -= 1; a[0]--; ans2++; &#125; if(tem &gt; 0) &#123; ans2 = ans1 = -1; cout &lt;&lt; "-1 -1" &lt;&lt; endl; &#125; else &#123; while(b[0] + b[1] * 5 + b[2] * 10 + b[3] * 50 &lt; p) &#123; p -= 100; ans1++; &#125; while(b[0] + b[1] * 5 + b[2] * 10 &lt; p) &#123; p -= 50; ans1++; &#125; while(b[0] + b[1] * 5 &lt; p) &#123; p -= 10; ans1++; &#125; while(b[0] &lt; p) &#123; p -= 5; ans1++; &#125; ans1 += p; cout &lt;&lt; ans2 &lt;&lt; " " &lt;&lt; ans1 &lt;&lt; endl; &#125; &#125; return 0;&#125; F - lazy gege(数学)HDU - 3349 平面几何，找长方形的重心—&gt;看正方形的对角线长度和长方形中较短的边的关系，一共有三种情况，自己画个图就很好理解了。计算几何主要就是看思维了，代码实现并没有什么难度，注释的挺详细了，注意一下三个if的顺序。 AC代码：1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; double l, a, b, ans; scanf("%d",&amp;t); while(t--) &#123; scanf("%lf%lf%lf",&amp;l,&amp;a,&amp;b); if(a &gt; b) swap(a, b); //保证a为长方形的较小边 double tem = sqrt(2.0) * l; //正方形的对角线长度 if(a &lt; tem) ans = a*a/4.0; //放在正方形上的部分为等腰△ else if(a &gt; tem &amp;&amp; a &lt; 2.0*tem) ans = l*l - (tem - a/2)*(tem - a/2); //正方形面积减去等腰三角形面积 else ans = l*l; //覆盖正方形 printf("%.4lf\n",ans); &#125; return 0;&#125; G - #define is unsafe(模拟)HDU - 3350 用栈实现的模拟题，这里我用vector数组模拟了个栈。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int val;//值 int add;//+的次数&#125;;//用vector实现模拟栈的FILOvector&lt;node&gt; ans;//数值栈vector&lt;char&gt; sig;//符号栈int main()&#123; int T; string str; node tem, tem2; scanf("%d",&amp;T); while(T--) &#123; cin &gt;&gt; str; //不要忘记初始化 tem.val = tem.add = 0; ans.clear(); sig.clear(); for(int i = 0; i &lt; str.length(); ++i) &#123; //逐字扫描，只有'('、'+'、','、')'和数字是有用的 //"MAX"不做处理 //优先级：'(' &gt; '+' &gt; ',' &gt; ')' switch(str[i]) &#123; case '(': sig.push_back(str[i]); tem.val = tem.add = 0; break; case '+': ans.push_back(tem); sig.push_back(str[i]); tem.val = tem.add = 0; //每次push后都要初始化tem break; case ',': while(!sig.empty() &amp;&amp; sig.back() == '+') &#123; tem2 = ans.back(); tem.val += tem2.val; tem.add += tem2.add + 1; ans.pop_back(); sig.pop_back(); &#125; ans.push_back(tem); sig.push_back(str[i]); tem.val = tem.add = 0; //初始化tem break; case ')': while(!sig.empty() &amp;&amp; sig.back() == '+') &#123; tem2 = ans.back(); tem.val += tem2.val; tem.add += tem2.add + 1; ans.pop_back(); sig.pop_back(); &#125; tem2 = ans.back(); if(tem.val &lt; tem2.val) &#123; tem.val = tem2.val; tem.add = tem2.add*2 + tem.add; &#125; else &#123; tem.add = tem.add*2 + tem2.add; &#125; sig.pop_back(); sig.pop_back(); ans.pop_back(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': tem.val = tem.val*10 + str[i] - '0'; break; &#125; &#125; while(!sig.empty() &amp;&amp; sig.back() == '+') &#123; tem2 = ans.back(); tem.val += tem2.val; tem.add += tem2.add + 1; ans.pop_back(); sig.pop_back(); &#125; cout &lt;&lt; tem.val &lt;&lt; " " &lt;&lt; tem.add &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU ACM-ICPC 2016-2017 Training Weekly Contest 1 【--完结--】]]></title>
    <url>%2Fsdnu-2017-1%2F</url>
    <content type="text"><![CDATA[题目链接：https://vjudge.net/contest/152755#overview A - Skip the ClassHDU - 6015 思路：贪一贪 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;struct ss&#123; string les; int val;&#125;;int cmp(ss x, ss y)&#123; if(x.les == y.les) return x.val &gt; y.val; return x.les &gt; y.les;&#125;int main()&#123; int t, n, ans, flag; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; map&lt;string, int&gt; qq; ss f[105]; ans = flag = 0; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) cin &gt;&gt; f[i].les &gt;&gt; f[i].val; sort(f, f+n, cmp); for(int i = 0; i &lt; n; ++i) &#123; //cout &lt;&lt; f[i].les &lt;&lt; endl; //cout &lt;&lt; f[i].val &lt;&lt; endl; qq[f[i].les]++; if(qq[f[i].les] &lt;= 2) ans += f[i].val; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; B - Count the SheepHDU - 6016 思维练习。（数据比较大，用cin会超时） 题意：有n只公羊和m只母羊，以及k个关系，k个关系为编号为x的公羊和编号为y的母羊是好朋友。问从任意一只羊开始沿着朋友关系数够4只羊的方法有多少种。 思路：可以把给出的关系构造成一个图来看，从任意一点出发，沿着关系网找到目标。拿第一个样例来说，（为方便观察把母羊编号为3和4）从公羊出发的不同方式为1324，1423，2314，2413共四种，同理，从母羊出发也是四种（把母羊看作1，2，把公羊看作3，4），到这里，我们能看出：从公羊出发的情况乘以二就是答案。而从公羊出发到不同母羊的情况数就等于（这个公羊的度-1）*（母羊的度-1）（度是指与这个点相连的点的个数）. AC代码：1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;const int maxn = 100005;LL a[maxn], b[maxn], na[maxn], nb[maxn];int main()&#123; int t; int n, m, k; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); for(int i = 0; i &lt; k; ++i) &#123; scanf("%lld%lld",&amp;a[i],&amp;b[i]); na[a[i]]++; nb[b[i]]++; &#125; LL sum = 0; for(int i = 0; i &lt; k; ++i) sum += (na[a[i]] - 1) * (nb[b[i]] - 1); printf("%lld\n",sum &lt;&lt; 1); &#125; return 0;&#125; C - Lotus and CharactersHDU - 6011 开始以为是不要负数，自始至终一直在这样做。看两队1A了，继续提交，继续WA。 这道题看完样例后很多人会和我一样误认为把负数都不算上才能得出最优解，其实不然。给出两组测试数据就知道了： 123 -1 3 2 1 1 1 答案:82 -1 5 4 2 答案:27 正确的做法是把所有数据从大到小排序，然后从前往后加，直到新加的数小于0时停止相加。其实理解了就很简单。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct ss&#123; int val; int amo;&#125;;int cmp(ss x, ss y)&#123; return x. val &gt; y.val;&#125;int main()&#123; int t, n; long long cnt, ans; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; cnt = ans = 0; ss f[30]; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d%d",&amp;f[i].val, &amp;f[i].amo); sort(f, f+n, cmp); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; f[i].amo; ++j) &#123; cnt += f[i].val; if(cnt &lt; 0) break; ans += cnt; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; D - Lotus and HorticultureHDU - 6012 思维。 在温室里种花，给出n朵花的适宜生长温度，如果温室温度在这范围内的话，成熟后的每朵花价值为a，高于所给温度，价值为b，低于所给温度，价值为c。问需要让温室温度为多少才能获得最大价值。 一开始让室内温度为-inf,此时答案为∑c，然后模拟温度上升，不断更新最大价值，直到达到所给的最大温度。 这个过程可以用map来实现，first为温度，second为价值。 （这里的温度可以是实数，所以用到了点小技巧：让温度都扩大两倍避免了出现小数的情况） AC代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;typedef long long LL;const int maxn = 50005;int main()&#123; int t, n; int l, r, x, y, z; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); map&lt;int, LL&gt; s; while(n--) &#123; scanf("%d%d%d%d%d",&amp;l,&amp;r,&amp;x,&amp;y,&amp;z); s[0] += z; s[l * 2] += x - z; s[r * 2 + 1] += y - x; &#125; LL ans = 0; LL tem = 0; for(map&lt;int,LL&gt;::iterator it = s.begin(); it != s.end(); ++it) &#123; tem += it -&gt; second; ans = max(ans, tem); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; E - The Third Cup is FreeHDU - 5999 一眼看出是贪心，然后全部浏览完一遍题目后，把这道题敲完交上，9minA了全场第一题。 AC代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int a[100005];int main()&#123; int t, n, ans, flag, cou = 0; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; ans = flag = 0; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); sort(a, a+n); for(int i = n-1; i &gt;= 0; --i) &#123; if(flag == 2) &#123; flag = 0; continue; &#125; flag++; ans += a[i]; &#125; printf("Case #%d: ",++cou); cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; F - Pseudoprime numbersHDU - 1905 数论。 题目解法：先判断p是不是合数，是的话再判断a的p次方%p是否等于a，是输出yes，否输出no，简单地题套个快速幂模板一套带走.. AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;long long quickpow(long long a, long long b, long long c)&#123; long long ans = 1; a = a % c; while(b) &#123; if(b &amp; 1) ans = ans * a % c; b &gt;&gt;= 1; a = a*a % c; &#125; return ans;&#125;int main()&#123; int flag; long long a, p; while(~scanf("%lld%lld",&amp;p,&amp;a) &amp;&amp; (a || p)) &#123; flag = 0; for(int i = 2; i * i &lt; p; ++i) if(p % i == 0) &#123; flag = 1; break; &#125; if(flag == 0) cout &lt;&lt; "no" &lt;&lt; endl; else &#123; long long tem = quickpow(a, p, p); //cout &lt;&lt; tem &lt;&lt; endl; if(tem == a) cout &lt;&lt; "yes" &lt;&lt; endl; else cout &lt;&lt; "no" &lt;&lt; endl; &#125; &#125; return 0;&#125; G - 小明系列问题――小明序列HDU - 4521 最长上升子序列的O(nlogn)算法。 AC代码： 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1e5 + 10;int a[MAX], b[MAX], DP[MAX];int n, m;int main()&#123; int ans; while(~scanf("%d%d",&amp;n, &amp;m)) &#123; ans = 1; fill(DP, DP + MAX, INF); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;a[i]); b[i] = 1; &#125; for(int i = m; i &lt; n; ++i) &#123; b[i] = lower_bound(DP, DP + MAX, a[i]) - DP + 1; if(b[i] &gt; ans) ans = b[i]; if(DP[b[i-m]-1] &gt; a[i-m]) DP[b[i-m]-1] = a[i-m]; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; H - Doing Homework againHDU - 1789 上学期，江西师范新生赛见过这道题，当时排序是按的时间优先，后来看题解知道应该分数优先。这也是道贪心哦。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 1005;int a[10005];struct node&#123; int sco, ded;&#125;;int cmp(node x, node y)&#123; if(x.sco == y.sco) return x.ded &lt; y.ded; return x.sco &gt; y.sco;&#125;int main()&#123; int t, n; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; node f[maxn]; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;f[i].ded); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;f[i].sco); sort(f, f+n, cmp); int ans = 0; memset(a, 0, sizeof(a)); for(int i = 0; i &lt; n; ++i) &#123; int tem; for(tem = f[i].ded; tem &gt; 0; --tem) &#123; if(a[tem] == 0) &#123; a[tem] = 1; break; &#125; &#125; if(tem == 0) ans += f[i].sco; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; I - 敌兵布阵HDU - 1166 这个以为是模拟，结果TLE，赛后得知要用线段树或树状数组，会了的话这就是道裸题。 【补】AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 50010;long long ans;struct node&#123; int l, r; int sum;&#125; tree[MAX&lt;&lt;2];void pushup(int rt)&#123; tree[rt].sum = tree[rt&lt;&lt;1].sum + tree[rt&lt;&lt;1|1].sum;&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; tree[rt].sum = 0; if(l == r) //叶子结点 &#123; scanf("%d",&amp;tree[rt].sum); return ; &#125; int mid = (l+r)&gt;&gt;1; //递归建树 build(l, mid, rt&lt;&lt;1); build(mid+1, r, rt&lt;&lt;1|1); pushup(rt);&#125;void update(int pos, int val, int rt)&#123; //更新这个区间的值 if(tree[rt].l == tree[rt].r) &#123; tree[rt].sum += val; return ; &#125; int mid = (tree[rt].l+tree[rt].r)&gt;&gt;1; if(pos &lt;= mid) update(pos, val, rt&lt;&lt;1); else update(pos, val, rt&lt;&lt;1|1); pushup(rt);&#125;void query(int x, int y, int rt)&#123; if(x == tree[rt].l &amp;&amp; y == tree[rt].r) &#123; ans += tree[rt].sum; return ; &#125; int mid = (tree[rt].l+tree[rt].r)&gt;&gt;1; if(y &lt;= mid) query(x, y, rt&lt;&lt;1); else if(x &gt; mid) query(x, y, rt&lt;&lt;1|1); else &#123; query(x, mid, rt&lt;&lt;1); query(mid+1, y, rt&lt;&lt;1|1); &#125;&#125;int main()&#123; int T; int n, pos, val; string s; scanf("%d",&amp;T); for(int cas = 1; cas &lt;= T; ++cas) &#123; printf("Case %d:\n",cas); scanf("%d",&amp;n); build(1, n, 1); while(cin &gt;&gt; s) &#123; if(s == "End") break; scanf("%d%d",&amp;pos,&amp;val); if(s == "Add") &#123; update(pos, val, 1); &#125; else if(s == "Sub") &#123; update(pos, -val, 1); &#125; else if(s == "Query") &#123; ans = 0; int x = pos; int y = val; if(x &gt; y) swap(x, y); query(x, y, 1); cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识点】大数分解与素数判定 --- 【Miller-rabin算法】【pollard-rho算法】]]></title>
    <url>%2Fmr-pr%2F</url>
    <content type="text"><![CDATA[1.Miller-rabin算法：Miller-rabin算法是一个用来快速判断一个正整数是否为素数的算法。 根据费马小定理，如果p是素数，则a^(p-1)≡1(mod p)对所有的a∈[1,n-1]成立。所以如果在[1,n-1]中随机取出一个a，发现不满足费马小定理，则证明n必为合数。 【但是每次尝试过程中还做了一个优化操作，以提高用少量的a检测出p不是素数的概率。这个优化叫做二次探测。它是根据这个定理：如果p是一个素数，那么对于x(0&lt;x&lt;p)，若x^2%p=1，则x=1或p-1。】 为了计算a^(n-1)mod n，我们把n-1分解为x* 2^t的形式，其中t&gt;=1且x是奇数；因此，a^(n-1)≡(a^x)^(2^t)(mod n),所以可以通过先计算a^x mod n,然后对结果连续平方t次来计算a^(n-1) mod n。一旦发现某次平方后mod n等于1了，那么说明符合了二次探测定理的逆否命题使用条件，立即检查x是否等于1或n-1，如果不等于1也不等于n-1则可直接判定p为合数。 2.pollard-rho算法：这是一个用来快速对整数进行质因数分解的算法，需要与Miller-rabin共同使用。 算法原理： 1.通过某种方法得到两个整数a和b，而待分解的大整数为n。 2.计算p=gcd(a-b,n)，直到p不为1(就是a-b与n不是互质)，或者a，b出现循环为止。 3.然后再判断p=n？ 4.如果p=n，那么返回n是一个质数。 5.否则返回p是n的一个因子，那么我们又可以递归的计算Pollard(p)和Pollard(n/p)，这样，我们就可以求出n的所有质因子。 算法步骤：选取一个小的随机数x1，迭代生成x[i] = x[i-1]^2+c，一般取c=1，若序列出现循环则退出，计算p=gcd(x[i-1]-x[i],n)，若p=1则返回上一步继续迭代，否则跳出迭代过程。若p=n，则n为素数，否则p为n的一个约数，并递归分解p和n/p。 【小知识】：随机数生成C++中函数srand（），可以指定不同的数（无符号整数变元）为种子。但是如果种子相同，伪随机数列也相同。 比较理想的是用变化的数，比如时间来作为随机数生成器的种子。 time的值每时每刻都不同，即种子不同，所以，产生的随机数也不同。 用法什么的想深入了解自己去搜吧，这里只要明白下面的程序中随机数是这样产生的就行了。然后，在这里再举个小栗子以加深一下对它的理解： 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;//这个必须有using namespace std;int main()&#123; int a = 100; srand( time(NULL)); while(a--) cout &lt;&lt; rand() &lt;&lt; endl; return 0;&#125;//这个程序的作用是产生100个随机数//如果你和我一样有颗童心去多试几次的话你会发现——每次产生的随机数都不一样//噫 是不是狠有趣(。＾▽＾) 学了这么多是不是手痒了？别着急，点我有惊喜。AC代码（C++【因为涉及到ctime，所以G++会RE的】）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177/* ************************************************* * * Miller_Rabin 算法进行素数测试 * 速度快，可以判断一个 &lt; 2^63 的数是不是素数 * **************************************************/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;using namespace std;const int S = 8;//随机算法判定次数，一般8~10次就够了//计算ret = (a*b)%c a, b, c &lt; 2^63long long mult_mod(long long a, long long b, long long c)&#123; a %= c; b %= c; long long ret = 0; long long tem = a; while(b) &#123; if(b &amp; 1) &#123; ret += tem; if(ret &gt; c) ret -= c;//直接取模慢很多 &#125; tem &lt;&lt;= 1; if(tem &gt; c) tem -= c; b &gt;&gt;= 1; &#125; return ret;&#125;//计算 ret = (a^n) % modlong long pow_mod(long long a, long long n, long long mod)&#123; long long ret = 1; long long tem = a % mod; while(n) &#123; if(n &amp; 1) ret = mult_mod(ret, tem, mod); tem = mult_mod(tem, tem, mod); n &gt;&gt;= 1; &#125; return ret;&#125;// 通过 a^(n-1)=1(mod n)来判断n是不是素数// n-1 = x * 2^t 中间使用二次判断// 是合数返回true，不一定是合数返回falsebool check(long long a, long long n, long long x, long long t)&#123; long long ret = pow_mod(a, x, n);//a^x % n long long last = ret; for(int i = 1; i &lt;= t; ++i)//进行t次(a^x % n)^2 % n &#123; ret = mult_mod(ret, ret, n); if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true;//合数 last = ret; &#125; if(ret != 1) return true; return false;//不一定是合数&#125;//**************************************************// Miller_Rabin算法// 是素数返回true,(可能是伪素数)// 不是素数返回false//**************************************************bool Miller_Rabin(long long n)&#123; if(n &lt; 2) return false; if(n == 2) return true; if( (n&amp;1) == 0) return false;//偶数 long long x = n - 1; long long t = 0; while( (x&amp;1) == 0) //将n分解为x*2^t; &#123; x &gt;&gt;= 1; t++; &#125; srand( time(NULL)); for(int i = 0; i &lt; S; ++i) &#123; long long a = rand()%(n-1) + 1;//产生随机数a(并控制其范围在1 ~ n-1之间) if(check(a, n, x, t))//是合数 return false; &#125; return true;&#125;//********************************************** // // pollard_rho 算法进行质因素分解 // //********************************************* int tol;//质因数的个数，编号为0~tol-1long long factor[100];//质因素分解结果(刚返回时是无序的)long long gcd(long long a, long long b)&#123; long long t; while(b) &#123; t = a; a = b; b = t % b; &#125; if(a &gt;= 0) return a; return -a;&#125;//找出一个因子long long pollard_rho(long long x, long long c)&#123; long long i = 1, k = 2; srand( time(NULL)); long long x0 = rand()%(x-1) + 1;//产生随机数x0(并控制其范围在1 ~ x-1之间) long long y = x0; while(1) &#123; i++; x0 = (mult_mod(x0, x0, x) + c) % x; long long d = gcd(y - x0, x); if(d != 1 &amp;&amp; d != x) return d; if(y == x0) return x; if(i == k) &#123; y = x0; k += k; &#125; &#125;&#125;//对n进行素因子分解，存入factor。 k设置为107左右即可void findfac(long long n, int k)&#123; if(n == 1) return ; if(Miller_Rabin(n))//是素数就把这个素因子存起来 &#123; factor[tol++] = n; return ; &#125; int c = k; long long p = n; while(p &gt;= n) p = pollard_rho(p, c--);//值变化，防止陷入死循环k findfac(p, k); findfac(n/p, k);&#125;int main()&#123; int T; long long n; scanf("%d",&amp;T); while(T--) &#123; scanf("%lld",&amp;n); if(Miller_Rabin(n)) cout &lt;&lt; "Prime" &lt;&lt; endl; else &#123; tol = 0; findfac(n, 107); long long ans = factor[0]; for(int i = 1; i &lt; tol; ++i) ans = min(ans, factor[i]); cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; 经过了“几天”的学习，终于能明白M-r,p-r算法是怎么实现的了（吐槽一下那三位对我关爱有加的兄弟，给我留了个这么有用的知识点让我讲），然后对着板子敲了几遍熟悉了一下。可能是还没碰到这种题目吧，内心里总觉得。。？总之也算是没浪费这些时间，至少我可以对着板子来对这知识点进行自在应用了（比如用朴素算法一不小心就会超时的一道题目。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>Miller-rabin</tag>
        <tag>pollard-rho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[White_Society_March_9 【小组练习】【--完结--】]]></title>
    <url>%2Fsdnu-white-society%2F</url>
    <content type="text"><![CDATA[前言：今天下午14：00小组举行了第一次磨合赛，总体配合的感觉还可以，相信还有很多问题没暴露出来，还有不到两个月，把握好每次练习的机会，争取这方面不会有太大失分点。 感谢：在此特意感谢熬夜为我们准备题目的超哥，还有两位带我飞的队友。然后，先定个小目标——坐上山师4队的位置。 推荐题目：A、E A - AHDU - 1131 卡特兰数的应用。 在不考虑顺序的前提下，将节点编号为0~n-1，任取一个节点k作为根节点，从而衍生出两个子问题$f(k-1)$和$f(n-k)$，有$f(k-1) \times f(n-k)$棵树， 则$f(n) = f(0) \times f(n-1) + f(1) \times f(n-2) + \ldots + f(n-1) \times f(0)$,符合卡特兰数的递推公式。由该递推公式可以推出$f(n) = \frac{f(n-1) \times (4n-2)}{(n+1)}$。至此，卡特兰数的问题已经解决。 加入字母顺序以后，这可以看成已经准备好了n个位置，现在来安排座位，排序总数为$n!$种。所以数的数量就等于$f(n) \times n!$ 这里如果分别计算再相乘的话会很麻烦，所以直接令答案$h(n) = \frac{h(n-1) \times n \times (4n-2)}{(n+1)}$ 卡特兰数：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100;const int XX = 10000;int katelan[MAX+5][MAX+5];int main()&#123; katelan[0][1] = 1; for(int i = 1; i &lt;= MAX; ++i) &#123; for(int j = 1; j &lt;= MAX; ++j) &#123; katelan[i][j] += katelan[i-1][j]*(4*i-2); katelan[i][j+1] += katelan[i][j]/XX; katelan[i][j] %= XX; &#125; int tem; for(int j = MAX; j &gt; 0; --j) &#123; tem = katelan[i][j] % (i+1); katelan[i][j-1] += tem*XX; katelan[i][j] /= (i+1); &#125; &#125; int n; while(~scanf("%d",&amp;n)) &#123; int i = MAX; while(katelan[n][i] == 0) i--; cout &lt;&lt; katelan[n][i--]; while(i &gt; 0) &#123; printf("%04d",katelan[n][i--]); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100;const int XX = 10000;int katelan[MAX+5][MAX+5];int main()&#123; katelan[0][1] = 1; for(int i = 1; i &lt;= MAX; ++i) &#123; for(int j = 1; j &lt;= MAX; ++j) &#123; katelan[i][j] += katelan[i-1][j]*i*(4*i-2); katelan[i][j+1] += katelan[i][j]/XX; katelan[i][j] %= XX; &#125; int tem; for(int j = MAX; j &gt; 0; --j) &#123; tem = katelan[i][j] % (i+1); katelan[i][j-1] += tem*XX; katelan[i][j] /= (i+1); &#125; &#125; int n; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; int i = MAX; while(katelan[n][i] == 0) i--; cout &lt;&lt; katelan[n][i--]; while(i &gt; 0) &#123; printf("%04d",katelan[n][i--]); //%04d 表示在输出一个小于4位的数值时 //将在前面补0使其总宽度为4位 &#125; cout &lt;&lt; endl; &#125; return 0;&#125; B - BHDU - 1087 最长上升子序列。之前的博客也写过。 （队友及）AC代码：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1005;int a[MAX], dp[MAX];bool cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int n, ans; while(~scanf("%d",&amp;n) &amp;&amp; n) &#123; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;a[i]); dp[i]=a[i]; &#125; for(int i = 0; i &lt; n; ++i) &#123; for(int i1=i-1; i1&gt;=0; --i1) &#123; if(a[i]&gt;a[i1]&amp;&amp;dp[i]&lt;dp[i1]+a[i]) &#123; dp[i]=dp[i1]+a[i]; &#125; &#125; &#125; sort(dp,dp+n,cmp); cout&lt;&lt;dp[0]&lt;&lt;endl; &#125; return 0;&#125; C - CHDU - 1045 DFS。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char mapa[5][5];int vis[5][5];int n, ans;void init()&#123; ans = 0; memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) if(mapa[i][j] == 'X') vis[i][j] = 2;&#125;bool ok(int x, int y)&#123; if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n) return false; return true;&#125;bool okok(int x, int y)&#123; if(vis[x][y] == 2) return false; for(int i = x; ok(i, y); ++i)//右 &#123; if(vis[i][y] == 2) break;//如果碰到X直接退出 if(vis[i][y] == 1) return false; &#125; for(int i = x; ok(i, y); --i)//左 &#123; if(vis[i][y] == 2) break; if(vis[i][y] == 1) return false; &#125; for(int i = y; ok(x, i); ++i)//上 &#123; if(vis[x][i] == 2) break; if(vis[x][i] == 1) return false; &#125; for(int i = y; ok(x, i); --i)//下 &#123; if(vis[x][i] == 2) break; if(vis[x][i] == 1) return false; &#125; return true;&#125;void dfs(int num)&#123; if(num &gt; ans) ans = num; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) &#123; if(okok(i, j)) &#123; vis[i][j] = 1; dfs(num + 1); vis[i][j] = 0; &#125; &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n) &amp;&amp; n) &#123; for(int i = 0; i &lt; n; ++i) scanf("%s", mapa[i]); init(); dfs(0); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D - DHDU - 2052 额..打印图形..手速还是不够啊，交上时已经3分1秒了.. AC代码：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;int main()&#123; int n, m; while(~scanf("%d%d",&amp;n, &amp;m)) &#123; cout &lt;&lt; "+"; for(int i = 0; i &lt; n; ++i) cout &lt;&lt; "-"; cout &lt;&lt; "+" &lt;&lt; endl; for(int i = 0; i &lt; m; ++i) &#123; cout &lt;&lt; "|"; for(int j = 0; j &lt; n; ++j) cout &lt;&lt; " "; cout &lt;&lt; "|" &lt;&lt; endl; &#125; cout &lt;&lt; "+"; for(int i = 0; i &lt; n; ++i) cout &lt;&lt; "-"; cout &lt;&lt; "+" &lt;&lt; endl; cout &lt;&lt; endl; &#125; return 0;&#125; E - EHDU - 1060 给你一个数N（$0&lt;N&lt;1,000,000,000$）， 让你求$N^N$的最高位数字。 一开始找规律，找啊找，就是找不到。后来发现有公式。（这道题还是挺不错的） 假设最高位数字为a，则用科学计数法表示就可以表示为$N^N = a \times 10^x$，同时取对数，移项，化简，得$a = 10^{(N \times lgN - x)}$，而这里的x就是​$lg(N^N)$向下取整（别问我为什么）。 到这里答案就可以得出来了，注意一下强制类型转换。 (队友瑕)AC代码：12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; long long n; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; scanf("%lld",&amp;n); double b = pow(10, n*log10(n) - (long long)(n * (log10(n)))); cout &lt;&lt; (int)b &lt;&lt; endl; &#125; &#125; return 0;&#125; F - FHDU - 5578 两只小青蛙？呱呱呱？然而这些情景并没有什么用，主要是问给出的字符串中，找到两个相同的字符最小的距离，没有相同的字符就输出-1 （队友及）AC代码：12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1005;int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; for(int j=1;j&lt;=n;++j) &#123; char a[1005]; scanf("%s",a); int len=strlen(a),num=2000; for(int i=0;i&lt;len-1;++i) &#123; for(int i1=i+1;i1&lt;len;++i1) &#123; if(a[i]==a[i1]) &#123; if(num&gt;i1-i) &#123; num=i1-i; &#125; &#125; &#125; &#125; if(num!=2000) printf("Case #%d: %d\n",j,num); else printf("Case #%d: %d\n",j,-1); &#125; &#125; return 0;&#125; G - GHDU - 1097 这个是求$x^y$的个位数，可以用快速幂一套带走，也可以找规律，之前的博客也写过这个题.. （队友及）AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; long long a,b; while(~scanf("%lld%lld",&amp;a,&amp;b)) &#123; if(a%10==0) a=0; else if(a%10==1) a=1; else if(a%10==2) &#123; switch(b%4) &#123; case 1:a=2;break; case 2:a=4;break; case 3:a=8;break; case 0:a=6;break; &#125; &#125; else if(a%10==3) &#123; switch(b%4) &#123; case 1:a=3;break; case 2:a=9;break; case 3:a=7;break; case 0:a=1;break; &#125; &#125; else if(a%10==4) &#123; switch(b%2) &#123; case 1:a=4;break; case 0:a=6;break; &#125; &#125; else if(a%10==5) &#123; a=5; &#125; else if(a%10==6) &#123; a=6; &#125; else if(a%10==7) &#123; switch(b%4) &#123; case 1:a=7;break; case 2:a=9;break; case 3:a=3;break; case 0:a=1;break; &#125; &#125; else if(a%10==8) &#123; switch(b%4) &#123; case 1:a=8;break; case 2:a=4;break; case 3:a=2;break; case 0:a=6;break; &#125; &#125; else if(a%10==9) &#123; switch(b%2) &#123; case 1:a=9;break; case 0:a=1;break; &#125; &#125; cout&lt;&lt;a&lt;&lt;endl; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1005;long long quickpow(long long a, long long b, long long c)&#123; long long ans = 1; a = a % c; while(b) &#123; if(b &amp; 1) ans = ans * a % c; b &gt;&gt;= 1; a = a*a%c; &#125; return ans;&#125;int main()&#123; long long n, m; while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; long long ans = quickpow(n, m, 10); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【kuangbin带你飞】专题一 【简单搜索】【--完结--】]]></title>
    <url>%2Fkuangbin-1%2F</url>
    <content type="text"><![CDATA[比赛链接：点击打开链接 A - 棋盘问题AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, k, ans;int che[10][10];int vis[10];void dfs(int row, int num)&#123; if(num == k) //搜索到最后一个格子 &#123; ans++; return ; &#125; if(row &gt; n) return ;//越界 for(int j = 1; j &lt;= n; ++j) if(che[row][j] &amp;&amp; !vis[j]) &#123; vis[j] = 1; dfs(row+1, num+1); vis[j] = 0;//搜索完成后归零 &#125; dfs(row+1, num); return ;&#125;int main()&#123; char ch; while(~scanf("%d%d",&amp;n,&amp;k)) &#123; if(n == -1 &amp;&amp; k == -1) break; ans = 0; memset(che, 0, sizeof(che)); memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; ++i) &#123; getchar(); for(int j = 1; j &lt;= n; ++j) &#123; scanf("%c",&amp;ch); if(ch == '#') che[i][j] = 1; &#125; &#125; dfs(1, 0); //第一行，符合条件的棋子数为0 cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; B - Dungeon MasterAC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;int n, m, k, flag;int startx, starty, startz;int endx, endy, endz;char e[35][35][35];int nexta[6][3] = &#123;&#123;0,1,0&#125;,&#123;0,-1,0&#125;,&#123;1,0,0&#125;,&#123;-1,0,0&#125;,&#123;0,0,1&#125;,&#123;0,0,-1&#125; &#125;;struct node&#123; int x, y, z; int sum;&#125;;int bfs(int a, int b, int c)&#123; node t1, t2, t3; queue&lt;node&gt; q; t1.x = a; t1.y = b; t1.z = c; t1.sum = 0; q.push(t1); while(!q.empty()) &#123; t2 = q.front(); q.pop(); for(int i = 0; i &lt; 6; ++i) &#123; t3.x = t2.x + nexta[i][0]; t3.y = t2.y + nexta[i][1]; t3.z = t2.z + nexta[i][2]; t3.sum = t2.sum + 1; if(t3.x &lt; 0 || t3.x &gt;= n || t3.y &lt; 0 || t3.y &gt;= m || t3.z &lt; 0 || t3.z &gt;= k)//越界 continue; if(e[t3.x][t3.y][t3.z] != '#') &#123; if(t3.x == endx &amp;&amp; t3.y == endy &amp;&amp; t3.z == endz) &#123; flag = 1; return t3.sum; &#125; q.push(t3); e[t3.x][t3.y][t3.z] = '#'; &#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d%d%d",&amp;n,&amp;m,&amp;k)) &#123; if(n == 0 &amp;&amp; m == 0 &amp;&amp; k == 0) break; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) for(int r = 0; r &lt; k; ++r) &#123; cin &gt;&gt; e[i][j][r]; if(e[i][j][r] == 'S') &#123; startx = i; starty = j; startz = r; &#125; if(e[i][j][r] == 'E') &#123; endx = i; endy = j; endz = r; &#125; &#125; flag = 0; int sum = bfs(startx, starty, startz); if(flag == 1) cout &lt;&lt; "Escaped in " &lt;&lt; sum &lt;&lt; " minute(s)." &lt;&lt; endl; else cout &lt;&lt; "Trapped!" &lt;&lt; endl; &#125; return 0;&#125; C - Catch That CowAC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;int n, k, ans;int vis[200005];struct pos&#123; int x, t;&#125;;queue&lt;pos&gt; s;void bfs(int x)&#123; pos b; b.x = x; b.t = 0; vis[x] = 1; s.push(b); while(!s.empty()) &#123; pos tem = s.front(); s.pop(); if(tem.x == k) &#123; ans = tem.t; return ; &#125; pos nex; //开始向目标方向搜索 nex.x = tem.x + 1; if(nex.x &gt;= 0 &amp;&amp; nex.x &lt;= 100000 &amp;&amp; vis[nex.x] == 0) &#123; nex.t = tem.t + 1; vis[nex.x] = 1; s.push(nex); &#125; nex.x = tem.x - 1; if(nex.x &gt;= 0 &amp;&amp; nex.x &lt;= 100000 &amp;&amp; vis[nex.x] == 0) &#123; nex.t = tem.t + 1; vis[nex.x] = 1; s.push(nex); &#125; nex.x = tem.x * 2; if(nex.x &gt;= 0 &amp;&amp; nex.x &lt;= 100000 &amp;&amp; vis[nex.x] == 0) &#123; nex.t = tem.t + 1; vis[nex.x] = 1; s.push(nex); &#125; &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;n, &amp;k)) &#123; memset(vis, 0, sizeof(vis)); while(!s.empty()) s.pop(); bfs(n); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D - FliptileAC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 16;const int inf = 0x3f3f3f3f;int m, n;int cow[maxn][maxn];int flip[maxn][maxn];int opt[maxn][maxn];int dir[][2] = &#123;0, 0, 0, 1, 0, -1, -1, 0&#125;;void getmap()&#123; for(int i = 0; i &lt; m; ++i) for(int j = 0; j &lt; n; ++j) scanf("%d",&amp;cow[i][j]);&#125;int getcolo(int x, int y)&#123; int tem = cow[x][y], xx, yy; for(int i = 0; i &lt; 4; ++i) &#123; xx = x + dir[i][0]; yy = y + dir[i][1]; if(xx &gt;= 0 &amp;&amp; xx &lt; m &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; n) tem += flip[xx][yy]; &#125; return tem &amp; 1;&#125;int dfs(int k)&#123; int sum, i, j; if(k == m -1) &#123; for(i = 0; i &lt; n; ++i) if(getcolo(k, i)) break; if(i != n) return -1; for(i = sum = 0; i &lt; m; ++i) for(j = 0; j &lt; n; ++j) if(flip[i][j]) sum++; return sum; &#125; for(int j = 0; j &lt; n; ++j) if(getcolo(k, j)) flip[k + 1][j] = 1; return dfs(k + 1);&#125;void solve()&#123; int i, j, maxcase = 1 &lt;&lt; n, ret = inf, num, tem; for(i = 0; i &lt; maxcase; ++i) &#123; memset(flip, 0, sizeof(flip)); for(j = n - 1, tem = i; j &gt;= 0; --j, tem &gt;&gt;= 1) flip[0][j] = tem &amp; 1; num = dfs(0); if(num != -1 &amp;&amp; num &lt; ret) &#123; ret = num; memcpy(opt, flip, sizeof(flip)); &#125; &#125; if(ret == inf) cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl; else &#123; for(i = 0; i &lt; m; ++i) for(j = 0; j &lt; n; ++j) if(j == n -1) cout &lt;&lt; opt[i][j] &lt;&lt; endl; else cout &lt;&lt; opt[i][j] &lt;&lt; " "; &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;m,&amp;n)) &#123; getmap(); solve(); &#125; return 0;&#125; E - Find The MultipleAC代码： 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int flag;void dfs(unsigned long long t, int n, int k)&#123; if(flag) return ; //已发现答案 退出 if(t % n == 0) &#123; //输出答案并标记 cout &lt;&lt; t &lt;&lt; endl; flag = 1; return ; &#125; if(k == 19) return ; //到第19层，回溯 dfs(t*10, n, k+1); //搜索t*10 dfs(t*10+1, n, k+1); //搜索t*10+1&#125;int main()&#123; int n; while(~scanf("%d",&amp;n) &amp;&amp; n) &#123; flag = 0; dfs(1, n, 0); &#125; return 0;&#125; F - Prime PathAC代码： //要选G++，C++会CE（我也不知道为什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int Max = 10010;int m, n;struct node&#123; int x; int sum;&#125;;int pri[Max];int vis[Max];int bfs()&#123; memset(vis, 0, sizeof(vis)); node now, nex; now.x = n; now.sum = 0; queue&lt;node&gt; q; vis[n] = 1; q.push(now); while(!q.empty()) &#123; now = q.front(); q.pop(); if(now.x == m) return now.sum; for(int i = 0; i &lt; 10; ++i) //换个位 &#123; nex.x = now.x/10*10+i; nex.sum = now.sum + 1; if(!vis[nex.x] &amp;&amp; !pri[nex.x])//未访问过此数并且这是个素数 &#123; vis[nex.x] = 1; q.push(nex); &#125; &#125; for(int i = 0; i &lt; 10; ++i) //换十位 &#123; int tem = now.x % 10; nex.x = now.x/100*100+(10*i)+tem; nex.sum = now.sum + 1; if(!vis[nex.x] &amp;&amp; !pri[nex.x]) &#123; vis[nex.x] = 1; q.push(nex); &#125; &#125; for(int i = 0; i &lt; 10; ++i) //换百位 &#123; int tem = now.x % 100; nex.x = now.x/1000*1000+(100*i)+tem; nex.sum = now.sum + 1; if(!vis[nex.x] &amp;&amp; !pri[nex.x]) &#123; vis[nex.x] = 1; q.push(nex); &#125; &#125; for(int i = 1; i &lt; 10; ++i) //换千位,要从1开始哦 &#123; nex.x = now.x%1000 + i*1000; nex.sum = now.sum + 1; if(!vis[nex.x] &amp;&amp; !pri[nex.x]) &#123; vis[nex.x] = 1; q.push(nex); &#125; &#125; &#125; return 0;&#125;int main()&#123; int t; memset(pri, 0, sizeof(pri)); pri[1] = 1; pri[0] = 1; m=sqrt(Max)+1; for(int i = 2; i &lt; m; i++) &#123; if(!pri[i]) &#123; for(int j=i*i;j&lt;=Max;j+=i) &#123; pri[j]=1; &#125; &#125; &#125; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; scanf("%d%d",&amp;m,&amp;n); printf("%d\n",bfs()); &#125; &#125; return 0;&#125; G - Shuffle’m UpAC代码： //这是一道模拟题吧，放错位置了或者也可以用搜索做 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;string s1, s2, s, ans;int main()&#123; int t, flag, num, n; while(~scanf("%d",&amp;t)) &#123; for(int cou = 1; cou &lt;= t; ++cou) &#123; num = 0; map&lt;string, int&gt; tem; scanf("%d",&amp;n); int j = 0; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; ans; while(1) &#123; num++; s.clear(); for(int i = 0; i &lt; n; ++i) &#123; s += s2[i]; s += s1[i]; &#125; if(s == ans) &#123; flag = 1; break; &#125; else &#123; if(tem[s]) &#123; flag = 0; break; &#125; tem[s] = 1; &#125; s1 = s2 = ""; for(int i = 0; i &lt; n; ++i) s1 += s[i]; for(int i = n; i &lt; 2*n; ++i) s2 += s[i]; &#125; if(flag) cout &lt;&lt; cou &lt;&lt; " " &lt;&lt; num &lt;&lt; endl; else cout &lt;&lt; cou &lt;&lt; " -1" &lt;&lt; endl; &#125; &#125; return 0;&#125; H - PotsAC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int inf = 0x3f3f3f3f;int a, b, c;int flag, res;int vis[105][105];char pa[10010], pp[10010];void dfs(int x, int y, int dep)&#123; if(dep &gt; res) return ; if(x == c || y == c) //找到目标 &#123; if(dep &lt; res) &#123; flag = 1; res = dep; for(int i = 0; i &lt; res; ++i) pa[i] = pp[i]; &#125; return ; &#125; if(x &lt; a &amp;&amp; !vis[a][y])//FILL 1 &#123; vis[a][y] = 1; pp[dep] = 'f'; dfs(a, y, dep+1); vis[a][y] = 0; &#125; if(y &lt; b &amp;&amp; !vis[x][b])//FILL 2 &#123; vis[x][b] = 1; pp[dep] = 'F'; dfs(x, b, dep+1); vis[x][b] = 0; &#125; if(x &gt; 0 &amp;&amp; !vis[0][y])//DROP 1 &#123; vis[0][y] = 1; pp[dep] = 'd'; dfs(0, y, dep+1); vis[0][y] = 0; &#125; if(y &gt; 0 &amp;&amp; !vis[x][0])//DROP 2 &#123; vis[x][0] = 1; pp[dep] = 'D'; dfs(x, 0, dep+1); vis[x][0] = 0; &#125; if(x &gt; 0 &amp;&amp; y &lt; b)//POUR(1,2) &#123; int t = min(x, b-y); if(!vis[x-t][y+t]) &#123; vis[x-t][y+t] = 1; pp[dep] = 'p'; dfs(x-t, y+t, dep+1); vis[x-t][y+t] = 0; &#125; &#125; if(y &gt; 0 &amp;&amp; x &lt; a)//POUR(2,1) &#123; int t = min(y, a-x); if(!vis[x+t][y-t]) &#123; vis[x+t][y-t] = 1; pp[dep] = 'P'; dfs(x+t, y-t, dep+1); vis[x+t][y-t] = 0; &#125; &#125; return ;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;a,&amp;b,&amp;c) &amp;&amp; (a||b||c)) &#123; memset(vis, 0, sizeof(vis)); vis[0][0] = 1; flag = 0; res = inf; dfs(0, 0, 0); if(flag) &#123; cout &lt;&lt; res &lt;&lt; endl; for(int i = 0; i &lt; res; ++i) &#123; if(pa[i] == 'f') cout &lt;&lt; "FILL(1)" &lt;&lt; endl; else if(pa[i] == 'F') cout &lt;&lt; "FILL(2)" &lt;&lt; endl; else if(pa[i] == 'd') cout &lt;&lt; "DROP(1)" &lt;&lt; endl; else if(pa[i] == 'D') cout &lt;&lt; "DROP(2)" &lt;&lt; endl; else if(pa[i] == 'p') cout &lt;&lt; "POUR(1,2)" &lt;&lt; endl; else if(pa[i] == 'P') cout &lt;&lt; "POUR(2,1)" &lt;&lt; endl; &#125; &#125; else cout &lt;&lt; "impossible" &lt;&lt; endl; &#125; return 0;&#125; I - Fire GameAC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int inf = 0x3f3f3f3f;int n, m, tmin, tmax;int mapa[15][15], vis[15][15];int dir[4][2] = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125; &#125;;int visit[15][15][15][15];struct state&#123; int x, y; int t;&#125;;void bfs(int x1, int y1, int x2,int y2)&#123; queue&lt;state&gt; s; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) vis[i][j] = mapa[i][j]; state p; p.x = x1; p.y = y1; p.t = 0; s.push(p); p.x = x2; p.y = y2; p.t = 0; s.push(p); vis[x1][y1] = vis[x2][y2] = 0; while(!s.empty()) &#123; state q; q = s.front(); s.pop(); tmax = q.t; for(int i = 0; i &lt; 4; ++i) &#123; state tem; tem.x = q.x + dir[i][0]; tem.y = q.y + dir[i][1]; tem.t = q.t + 1; if(tem.x &lt; 1 || tem.x &gt; n || tem.y &lt; 1 || tem.y &gt; m) continue; if(!vis[tem.x][tem.y]) continue; vis[tem.x][tem.y] = 0; s.push(tem); &#125; &#125; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) if(vis[i][j]) tmax = inf;&#125;int main()&#123; int t, cou; char c; while(~scanf("%d",&amp;t)) &#123; for(cou = 1; cou &lt;= t; ++cou) &#123; scanf("%d%d",&amp;n, &amp;m); getchar(); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; c; if(c == '#') mapa[i][j] = 1; else mapa[i][j] = 0; &#125; &#125; tmin = inf; memset(visit, 0, sizeof(visit)); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) for(int p = 1; p &lt;= n; ++p) for(int q = 1; q &lt;= m; ++q) &#123; if(mapa[i][j] &amp;&amp; mapa[p][q] &amp;&amp; !visit[i][j][p][q]) &#123; visit[i][j][p][q] = 1; bfs(i, j, p, q); tmin = min(tmin, tmax); &#125; &#125; if(tmin == inf) printf("Case %d: -1\n",cou); else printf("Case %d: %d\n",cou, tmin); &#125; &#125; return 0;&#125; J - Fire!AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;int n, m;char mapa[1005][1005];int fir[1005][1005];int vis[1005][1005];int dir[4][2] = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125; &#125;;struct node&#123; int x, y;&#125;;queue&lt;node&gt; q1;queue&lt;node&gt; q2;void Fbfs()&#123; node now; while(!q1.empty()) &#123; now = q1.front(); q1.pop(); for(int i = 0; i &lt; 4; ++i) &#123; int xx = now.x + dir[i][0]; int yy = now.y + dir[i][1]; if(xx &gt; n || xx &lt; 1 || yy &lt; 1 || yy &gt; m) continue; if(mapa[xx][yy] == '#' || mapa[xx][yy] == 'F') continue; if(fir[xx][yy] != -1) continue; node tem; fir[xx][yy] = fir[now.x][now.y] + 1; tem.x = xx; tem.y = yy; q1.push(tem); &#125; &#125;&#125;void Jbfs()&#123; node now; while(!q2.empty()) &#123; now = q2.front(); q2.pop(); if(now.x == 1 || now.x == n || now.y == 1 || now.y == m) &#123; cout &lt;&lt; vis[now.x][now.y]+1 &lt;&lt; endl; return ; &#125; for(int i = 0; i &lt; 4; ++i) &#123; int xx = now.x + dir[i][0]; int yy = now.y + dir[i][1]; if(xx &gt; n || xx &lt; 1 || yy &lt; 1 || yy &gt; m) continue; if(mapa[xx][yy] == '#' || mapa[xx][yy] == 'F' || mapa[xx][yy] == 'J') continue; if(vis[xx][yy] != -1) continue; if(fir[xx][yy] == -1 || (vis[now.x][now.y] &lt; fir[xx][yy] - 1)) &#123; node tem; vis[xx][yy] = vis[now.x][now.y] + 1; tem.x = xx; tem.y = yy; q2.push(tem); &#125; &#125; &#125; cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl;&#125;int main()&#123; int t; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; scanf("%d%d",&amp;n,&amp;m); node peop, fire; memset(vis, -1, sizeof(vis)); memset(fir, -1, sizeof(fir)); while(!q1.empty()) q1.pop(); while(!q2.empty()) q2.pop(); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; mapa[i][j]; if(mapa[i][j] == 'F') &#123; fire.x = i; fire.y = j; q1.push(fire); fir[i][j] = 0; &#125; if(mapa[i][j] == 'J') &#123; peop.x = i; peop.y = j; q2.push(peop); vis[i][j] = 0; &#125; &#125; Fbfs(); Jbfs(); &#125; &#125; return 0;&#125; K - 迷宫问题AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int a[5][5];int dir[4][2] = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125; &#125;;struct node&#123; int x, y, pre;&#125;q[100];int fir = 0,las = 1;void print(int n)&#123; if(q[n].pre != -1) &#123; print(q[n].pre); printf("(%d, %d)\n",q[n].x, q[n].y); &#125;&#125;void bfs(int x, int y)&#123; q[fir].pre = -1; q[fir].x = x; q[fir].y = y; int xx, yy; while(fir &lt; las) &#123; for(int i = 0; i &lt; 4; ++i) &#123; xx = q[fir].x + dir[i][0]; yy = q[fir].y + dir[i][1]; if(xx &lt; 0 || yy &lt; 0 || xx &gt;= 5 || yy &gt;= 5 || a[xx][yy]) continue; a[xx][yy] = 1; q[las].pre = fir; q[las].x = xx; q[las].y = yy; las++; if(xx == 4 &amp;&amp; yy == 4) print(fir); &#125; fir++; &#125;&#125;int main()&#123; for(int i = 0; i &lt; 5; ++i) for(int j = 0; j &lt; 5; ++j) cin &gt;&gt; a[i][j]; printf("(0, 0)\n"); bfs(0, 0); printf("(4, 4)\n"); return 0;&#125; L - Oil DepositsAC代码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 105;char pic[maxn][maxn];int m, n, idx[maxn][maxn];void dfs(int r, int c, int id)&#123; if(r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n) return ;//越界 if(idx[r][c] &gt; 0 || pic[r][c] != '@') return ;//非'@'格子或已访问过格子 idx[r][c] = id; for(int dr = -1; dr &lt;= 1; ++dr) for(int dc = -1; dc &lt;= 1; ++dc) if(dr != 0 || dc != 0) dfs(r+dr, c+dc, id);&#125;int main()&#123; while(~scanf("%d%d",&amp;m,&amp;n)) &#123; if(n == 0 &amp;&amp; m == 0) break; for(int i = 0; i &lt; m; ++i) scanf("%s",pic[i]); memset(idx, 0, sizeof(idx)); int cnt = 0; for(int i = 0; i &lt; m; ++i) for(int j = 0; j &lt; n; ++j) if(idx[i][j] == 0 &amp;&amp; pic[i][j] == '@') dfs(i, j, ++cnt); cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125; M - 非常可乐AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;int rq[3]; //容器的容量int vis[105][105][105];struct qingkuang&#123; int num[3]; int out;&#125; now, nex;void bfs(int ss, int n, int m)&#123; memset(vis, 0, sizeof(vis)); queue&lt;qingkuang&gt; s; now.num[0] = ss; now.num[1] = n; now.num[2] = m; vis[ss][n][m] = 1; now.out = 0; s.push(now); while(!s.empty()) &#123; now = s.front(); s.pop(); for(int i = 0; i &lt; 2; ++i) //是否满足情况(共三种，这里有种判断了2次，还可以优化一下) for(int j = 0; j &lt; 3; ++j) &#123; if(i == j) continue; if(now.num[i] == now.num[j] &amp;&amp; now.num[3-i-j] == 0) &#123; cout &lt;&lt; now.out &lt;&lt; endl; return ; &#125; &#125;//所有倒的方法一共就6种，分别为1-&gt;2,1-&gt;3,2-&gt;1,2-&gt;3,3-&gt;1,3-&gt;2//开始模拟倒可乐的过程 for(int i = 0; i &lt; 3; ++i) &#123; for(int j = 0; j &lt; 3; ++j) &#123; if(i == j) continue; if(now.num[i] + now.num[j] &lt;= rq[j]) //i全部倒入j中 &#123; nex.num[j] = now.num[j] + now.num[i]; nex.num[i] = 0; &#125; else //j被倒满 &#123; nex.num[i] = now.num[i] - (rq[j] - now.num[j]); nex.num[j] = rq[j]; &#125; for(int k = 0; k &lt; 3; ++k) //维护一下当前步骤 &#123; if(k == i || k == j) continue; nex.num[k] = now.num[k]; &#125; nex.out = now.out + 1; if(vis[nex.num[0]][nex.num[1]][nex.num[2]] == 0) &#123; vis[nex.num[0]][nex.num[1]][nex.num[2]] = 1; s.push(nex); &#125; &#125; &#125; &#125; cout &lt;&lt; "NO" &lt;&lt; endl; return ;&#125;int main()&#123; int s, n, m; while(~scanf("%d%d%d",&amp;s, &amp;n, &amp;m) &amp;&amp; (s || n || m)) &#123; rq[0] = s; rq[1] = n; rq[2] = m; bfs(s, 0, 0); &#125; return 0;&#125; N - Find a wayAC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int inf = 0x3f3f3f3f;char mapa[205][205];int vis[205][205];int dis[2][205][205];int dir[4][2] = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125; &#125;;int n, m;int startx, starty;int endx, endy;struct node&#123; int x, y; int sum;&#125;;void bfs(int idx, int x, int y)&#123; memset(vis, 0, sizeof(vis)); vis[x][y] = 1; queue&lt;node&gt; q; node now, nex; now.x = x; now.y = y; now.sum = 0; q.push(now); while(!q.empty()) &#123; now = q.front(); q.pop(); if(mapa[now.x][now.y] == '@') dis[idx][now.x][now.y] = now.sum; for(int i = 0; i &lt; 4; ++i) &#123; nex.x = now.x + dir[i][0]; nex.y = now.y + dir[i][1]; if(nex.x &lt; 0 || nex.x &gt;= n || nex.y &lt; 0 || nex.y &gt;= m) continue; //越界 if(vis[nex.x][nex.y]) continue; if(mapa[nex.x][nex.y] == '#') continue; vis[nex.x][nex.y] = 1; nex.sum = now.sum + 1; q.push(nex); &#125; &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; memset(mapa, 0, sizeof(mapa)); memset(dis, inf, sizeof(dis)); //初始化为无穷远 for(int i = 0; i &lt; n; ++i) scanf("%s",mapa[i]); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) &#123; if(mapa[i][j] == 'Y') &#123; startx = i; starty = j; &#125; if(mapa[i][j] == 'M') &#123; endx = i; endy = j; &#125; &#125; bfs(0, startx, starty); bfs(1, endx, endy); int ans = inf; /*cout &lt;&lt; 233 &lt;&lt; endl; cout &lt;&lt; startx &lt;&lt; " " &lt;&lt; starty &lt;&lt; endl; cout &lt;&lt; endx &lt;&lt; " " &lt;&lt; endy &lt;&lt; endl;*/ for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) if(mapa[i][j] == '@') ans = min(ans, dis[0][i][j] + dis[1][i][j]); cout &lt;&lt; ans*11 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第五章习题】【6/16】]]></title>
    <url>%2Flrj-ch5-1%2F</url>
    <content type="text"><![CDATA[UVa 1593 Alignment of Code【模拟】【vector】题目大意：给出若干行代码，要求对齐。对齐规则为按照每列中长度最长的那个字符串为最大长度左对齐，相邻字符串间用一个空格分割。 解题思路：直接做。 MyCode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int cnt, cou;int mlen[MAX];string t, s;vector&lt;string&gt; yy[MAX];int main()&#123; cnt = 0; memset(mlen, 0, sizeof(mlen)); while(getline(cin, t)) &#123; cou = 0; stringstream ss (t); while(ss &gt;&gt; s) &#123; yy[cnt].push_back(s); mlen[cou] = max(mlen[cou], (int)s.size()); ++cou; &#125; ++cnt; &#125; for(int i = 0; i &lt; cnt; ++i) &#123; int j; for(j = 0; j &lt; yy[i].size()-1; ++j) &#123; int k; for(k = 0; k &lt; yy[i][j].size(); ++k) cout &lt;&lt; yy[i][j][k]; for(; k &lt;= mlen[j]; ++k) cout &lt;&lt; " "; &#125; cout &lt;&lt; yy[i][j]; puts(""); &#125; return 0;&#125; UVa 1594 Ducci Sequence【模拟】题目大意：按照规则进行操作，看1000步内能否使这个组的所有元素全变成0。 解题思路：直接做。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int a[MAX];int main()&#123; int t, n; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); int tem, k; bool flag = false; for(int i = 0; i &lt; 1000; ++i) &#123; tem = a[0]; for(int j = 0; j &lt; n-1; ++j) &#123; a[j] = abs(a[j]-a[j+1]); &#125; a[n-1] = abs(a[n-1]-tem); /*cout &lt;&lt; "tem=" &lt;&lt;tem &lt;&lt; endl; for(int tt = 0; tt &lt; n; ++tt) &#123; cout &lt;&lt; a[tt] &lt;&lt; " "; &#125; puts("");*/ for(k = 0; k &lt; n; ++k) &#123; if(a[k] != 0) break; &#125; if(k == n) &#123; flag = true; break; &#125; &#125; if(flag) puts("ZERO"); else puts("LOOP"); &#125; return 0;&#125; UVa 10935 Throwing cards away I【模拟】【vector】题目大意：按照规则模拟这个过程。 解题思路：直接做。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;struct node&#123; int num; bool flag;&#125;;int main()&#123; int n, xx, tot, now, pos; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; if(n==1) &#123; printf("Discarded cards:\n"); printf("Remaining card: 1\n"); continue; &#125; node a[55]; vector&lt;int&gt; ans; for(int i = 0; i &lt; n; ++i) &#123; a[i].num = i; a[i].flag = true; &#125; a[0].num = n; ans.push_back(1); a[1].flag = false; tot = 1; pos = 2; while(tot &lt; n-1) &#123; xx = 0; now = pos; for(int i = 0; i &lt; n; ++i) &#123; if(a[(now+i)%n].flag) &#123; xx++; pos = (now+i)%n; if(xx == 2) &#123; a[(now+i)%n].flag = false; tot++; ans.push_back(a[(now+i)%n].num); break; &#125; &#125; &#125; &#125; printf("Discarded cards: "); for(int i = 0; i &lt; ans.size(); ++i) &#123; if(i) cout &lt;&lt; ", "; cout &lt;&lt; ans[i]; &#125; puts(""); printf("Remaining card: "); for(int i = 0; i &lt; n; ++i) &#123; if(a[i].flag) cout &lt;&lt; a[i].num; &#125; puts(""); &#125; return 0;&#125; UVa 10763 Foreign Exchange【模拟】【map】题目大意：给出$n$组数，每组包含两个数A、B，判断是否所有的A、B都有对应的B、A组相对应。 解题思路：map标记一下，然后判断就好了。 MyCode：12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int main()&#123; int n; int a, b; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; map&lt;pair&lt;int,int&gt;, int&gt; ss; bool flag = true; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d",&amp;a,&amp;b); ++ss[make_pair(a, b)]; &#125; for(auto it = ss.begin(); it != ss.end(); ++it) &#123; if(ss[make_pair(it-&gt;first.second, it-&gt;first.first)] != it-&gt;second) &#123; flag = false; break; &#125; &#125; if(flag) puts("YES"); else puts("NO"); &#125; return 0;&#125; UVa 10391 Compound Words【模拟】【map】题目大意：给出许多单词，找出其中的“复合词”，即恰好由这些单词中的两个拼接而成。 解题思路：直接拼不好拼，因为单词数很多，正着不行反着来——枚举每个单词的组成，看组成的两个单词是否之前出现过。 MyCode：12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 120005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int main()&#123; string s; string ss[MAX]; map&lt;string, bool&gt; mp; int tot = 0; while(cin &gt;&gt; s) &#123; ss[tot++] = s; mp[s] = true; &#125; string a, b; for(int i = 0; i &lt; tot; ++i) &#123; for(int j = 0; j &lt; ss[i].size()-1; ++j) &#123; a = ss[i].substr(0, j+1); if(!mp[a]) continue; b = ss[i].substr(j+1); if(!mp[b]) continue; cout &lt;&lt; ss[i] &lt;&lt; endl; break; &#125; &#125; return 0;&#125; UVa 1595 Symmetry【模拟】【map】题目大意：给出$n$个点，问是否可以找到一条竖线，使得所有的点左右对称。 解题思路：因为是竖线，所以如果对称轴存在，那么它一定为$x = \frac{max + min}{2}$，因此我们只要找出$x$坐标的最大值和最小值就可以求出“疑似对称轴”的竖线了，然后对于每个点挨个进行验证就好了——看它对称轴另一边是否存在对应的点。 小技巧：因为/2可能会出现小数的情况，造成运算的不便，因此我们可以通过将所有横坐标 × 2的操作避免小数的出现。为什么都×2对最终结果无影响呢？因为我们看的只是他们的相对大小。 MyCode：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, t;int x[MAX], y[MAX];int main()&#123; scanf("%d",&amp;t); while(t--) &#123; map&lt;pair&lt;int,int&gt;, bool&gt; mapa; scanf("%d",&amp;n); int mi = INF; int ma = -INF; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d",&amp;x[i],&amp;y[i]); x[i] &lt;&lt;= 1; mi = min(mi, x[i]); ma = max(ma, x[i]); mapa[make_pair(x[i], y[i])] = 1; &#125; int xx = (mi + ma) / 2;// cout &lt;&lt; xx &lt;&lt; endl; bool f = true; for(int i = 0; i &lt; n; ++i) &#123; if(!mapa[make_pair(2*xx - x[i], y[i])]) &#123; f = false; break; &#125; &#125; if(f) puts("YES"); else puts("NO"); &#125; return 0;&#125; UVa 12100 Printer Queue题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12 UVa题目大意：解题思路：MyCode：12]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>vector</tag>
        <tag>STL</tag>
        <tag>map</tag>
        <tag>解题报告</tag>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第五章例题】【9/12】]]></title>
    <url>%2Flrj-ch5-0%2F</url>
    <content type="text"><![CDATA[UVa 10474 Where is the Marble?【排序】【lower_bound】1234567891011121314151617181920212223// UVa10474 Where is the Marble?// Rujia Liu#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10000;int main() &#123; int n, q, x, a[maxn], kase = 0; while(scanf("%d%d", &amp;n, &amp;q) == 2 &amp;&amp; n) &#123; printf("CASE# %d:\n", ++kase); for(int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); sort(a, a+n); // 排序 while(q--) &#123; scanf("%d", &amp;x); int p = lower_bound(a, a+n, x) - a; // 在已排序数组a中寻找x if(a[p] == x) printf("%d found at %d\n", x, p+1); else printf("%d not found\n", x); &#125; &#125; return 0;&#125; UVa 101 The Blocks Problem【模拟】【vector】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;int n;vector&lt;int&gt; pile[30];void init()&#123; for(int i = 0; i &lt; n; ++i) &#123; pile[i].push_back(i); &#125;&#125;void find_block(int a, int&amp; p, int&amp; h)&#123; for(p = 0; p &lt; n; ++p) for(h = 0; h &lt; pile[p].size(); ++h) if(pile[p][h] == a) return ;&#125;void clear_above(int p, int h)&#123; for(int i = h+1; i &lt; pile[p].size(); ++i) &#123; int tt = pile[p][i]; pile[tt].push_back(tt); &#125; pile[p].resize(h+1);&#125;void pile_onto(int p, int h, int p2)&#123; for(int i = h; i &lt; pile[p].size(); ++i) &#123; pile[p2].push_back(pile[p][i]); &#125; pile[p].resize(h);&#125;void print()&#123; for(int i = 0; i &lt; n; ++i) &#123; printf("%d:",i); for(int j = 0; j &lt; pile[i].size(); ++j) printf(" %d",pile[i][j]); puts(""); &#125;&#125;int main()&#123; int a, b; string s1, s2; scanf("%d",&amp;n); init(); while(cin &gt;&gt; s1 &gt;&gt; a &gt;&gt; s2 &gt;&gt; b) &#123; int pa, pb, ha, hb; find_block(a, pa, ha); find_block(b, pb, hb); if(pa == pb) continue; if(s2 == "onto") clear_above(pb, hb); if(s1 == "move") clear_above(pa, ha); pile_onto(pa, ha, pb); &#125; print(); return 0;&#125; UVa 10815 Andy’s First Dictionary【set】123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;cctype&gt;using namespace std;set&lt;string&gt; dict; //string集合int main()&#123; string s, buf; while(cin &gt;&gt; s) &#123; for(int i = 0; i &lt; s.length(); ++i) &#123; if(isalpha(s[i])) s[i] = tolower(s[i]); else s[i] = ' '; &#125; stringstream ss(s); while(ss &gt;&gt; buf) dict.insert(buf); &#125; for(set&lt;string&gt;::iterator it = dict.begin(); it != dict.end(); ++it) cout &lt;&lt; *it &lt;&lt; endl; return 0;&#125; UVa 156 Ananagrams【map】【vector】123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;map&lt;string, int&gt; cnt;vector&lt;string&gt; words;string repr(const string&amp; s)&#123; string ans = s; for(int i = 0; i &lt; ans.length(); ++i) ans[i] = tolower(ans[i]); sort(ans.begin(), ans.end()); return ans;&#125;int main()&#123; string s; while(cin &gt;&gt; s) &#123; if(s == "#") break; words.push_back(s); string r = repr(s); if(!cnt[r]) cnt[r] = 0; cnt[r]++; &#125; vector&lt;string&gt; ans; for(int i = 0; i &lt; words.size(); ++i) if(cnt[repr(words[i])] == 1) ans.push_back(words[i]); sort(ans.begin(), ans.end()); for(int i = 0; i &lt; ans.size(); ++i) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;&#125; UVa 12096 The SetStack Computer【set】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;#define ALL(x) x.begin(), x.end()#define INS(x) inserter(x, x.begin())int t, n;char op[10];vector&lt;set&lt;int&gt; &gt; ccc;map&lt;set&lt;int&gt;, int&gt; aaa;int ID(set&lt;int&gt; x)&#123; if(aaa.count(x)) return aaa[x]; ccc.push_back(x); return aaa[x] = ccc.size() - 1;&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; stack&lt;int&gt; s; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", op); if(op[0] == 'P') s.push(ID(set&lt;int&gt;())); else if(op[0] == 'D') s.push(s.top()); else &#123; set&lt;int&gt; x1 = ccc[s.top()]; s.pop(); set&lt;int&gt; x2 = ccc[s.top()]; s.pop(); set&lt;int&gt; x; if(op[0] == 'U') set_union(ALL(x1), ALL(x2), INS(x)); if(op[0] == 'I') set_intersection(ALL(x1), ALL(x2), INS(x)); if(op[0] == 'A') &#123; x = x2; x.insert(ID(x1)); &#125; s.push(ID(x)); &#125; cout &lt;&lt; ccc[s.top()].size() &lt;&lt; endl; &#125; puts("***"); &#125; return 0;&#125; UVa 540 Team Queue【queue】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;char com[10];int t, n, x, tt;int main()&#123; int cas = 0; while(cin &gt;&gt; t &amp;&amp; t) &#123; printf("Scenario #%d\n", ++cas); map&lt;int, int&gt; team; for(int i = 1; i &lt;= t; ++i) &#123; cin &gt;&gt; n; while(n--) &#123; cin &gt;&gt; x; team[x] = i; &#125; &#125; queue&lt;int&gt; zong, fen[MAX]; while(cin &gt;&gt; com) &#123; char op = com[0]; if(op == 'S') break; if(op == 'E') //入队 &#123; int yy; cin &gt;&gt; yy; tt = team[yy]; if(fen[tt].empty()) zong.push(tt); fen[tt].push(yy); &#125; else //出队 &#123; tt = zong.front(); //整队 cout &lt;&lt; fen[tt].front() &lt;&lt; endl; fen[tt].pop(); if(fen[tt].empty()) zong.pop(); &#125; &#125; puts(""); &#125; return 0;&#125; UVa 136 Ugly Numbers【priority_queue】123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int coeff[3] = &#123;2, 3, 5&#125;;int main()&#123; priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; pq; //greater使大数往后排 set&lt;LL&gt; s; pq.push(1); s.insert(1); for(int i = 1; ; ++i) &#123; LL x = pq.top(); pq.pop();//不断更新队列最小元素 if(i == 1500)//找到目标 &#123; cout &lt;&lt; "The 1500'th ugly number is " &lt;&lt; x &lt;&lt; ".\n"; break; &#125; for(int j = 0; j &lt; 3; ++j) &#123; LL x2 = x * coeff[j]; //生成新的“丑数” if(!s.count(x2)) &#123; s.insert(x2); pq.push(x2);&#125; &#125; &#125; return 0;&#125; UVa 400 Unix ls【模拟】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 105;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, mlen;int maxc = 60;string s[MAX];void print(string ss, int len, char extra)&#123; cout &lt;&lt; ss; for(int i = 0; i &lt; len - ss.length(); ++i) cout &lt;&lt; extra;&#125;int main()&#123; while(~scanf("%d",&amp;n)) &#123; mlen = 0; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; s[i]; mlen = max(mlen, (int)s[i].length()); &#125; //计算C和R int col = (maxc - mlen) / (mlen + 2) + 1; int row = (n - 1) / col + 1;// cout &lt;&lt; mlen &lt;&lt; "--" &lt;&lt; col &lt;&lt; "--" &lt;&lt; row &lt;&lt; endl; print("", 60, '-'); puts(""); //排序 sort(s, s + n);// for(int i = 0; i &lt; n; ++i)// cout &lt;&lt; s[i] &lt;&lt;endl; int idx; for(int r = 0; r &lt; row; ++r) &#123; for(int c = 0; c &lt; col; ++c) &#123; idx = c * row + r; if(idx &lt; n) print(s[idx], c == col - 1 ? mlen: mlen + 2, ' '); &#125; puts(""); &#125; &#125; return 0;&#125; UVa 1592 Datebase【map】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, m, cnt;int a[MAX][15];string t, tem, s;map&lt;string, int&gt; mapa;int main()&#123;END: while(~scanf("%d%d",&amp;n,&amp;m)) &#123; getchar(); mapa.clear(); cnt = 1; for(int i = 1; i &lt;= n; ++i) &#123; int cou = 1; getline(cin, t); tem = ""; for(int j = 0; j &lt; t.size(); ++j) &#123; if(t[j] == ',') &#123; if(!mapa.count(tem)) mapa[tem] = cnt++; a[i][cou++] = mapa[tem];// cout &lt;&lt; tem &lt;&lt; "**" &lt;&lt; endl; tem = ""; &#125; else tem += t[j]; &#125; if(!mapa.count(tem)) mapa[tem] = cnt++; a[i][cou++] = mapa[tem];// cout &lt;&lt;tem &lt;&lt; "**" &lt;&lt;endl; &#125;// for(int i = 1; i &lt;= n; ++i)// &#123;// for(int j = 1; j &lt;= m; ++j)// cout &lt;&lt; a[i][j] &lt;&lt; " ";// puts("");// &#125; for(int i = 1; i &lt; m; ++i) &#123; for(int j = i+1; j &lt;= m; ++j) &#123; map&lt;pair&lt;int, int&gt;, int&gt; app; for(int k = 1; k &lt;= n; ++k) &#123; if(app[make_pair(a[k][i], a[k][j])]) &#123; int r1 = app[make_pair(a[k][i], a[k][j])]; int r2 = k; int c1 = i; int c2 = j; puts("NO"); printf("%d %d\n", r1, r2); printf("%d %d\n", c1, c2); goto END; &#125; app[make_pair(a[k][i], a[k][j])] = k; &#125; &#125; &#125; puts("YES"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>解题报告</tag>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第四章习题】【10/10】]]></title>
    <url>%2Flrj-ch4-1%2F</url>
    <content type="text"><![CDATA[UVa 1589 Xiangqi【模拟】题目大意：给出一个象棋残局，按照象棋规则，此时红方已被“将军”，判断红方是否已被“将死”。 解题思路：模拟黑方所有棋子下一步可能走的位置，将这些位置进行标记。之后枚举红方的帥能走的每一个位置，看是否有一个没被标记的位置。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1005;int dir[][2] = &#123;0,1,1,0,-1,0,0,-1&#125;;struct node&#123; char ch; int x, y;&#125;;bool check(char ch) //没棋子是真&#123; if(ch == 'G') return false; if(ch == 'H') return false; if(ch == 'R') return false; if(ch == 'C') return false; return true;&#125;char mapa[25][25];bool mmpa[25][25];int main()&#123; //int cas = 0; int t, n, m; bool flag; while(cin &gt;&gt; t &gt;&gt; n &gt;&gt; m &amp;&amp; (t||n||m)) &#123; //cout &lt;&lt; "case:" &lt;&lt; cas++ &lt;&lt; endl; node ss[10]; bool flag = false; memset(mapa, 0, sizeof(mapa)); memset(mmpa, 0, sizeof(mmpa)); for(int i = 0; i &lt; t; ++i) &#123; cin &gt;&gt; ss[i].ch &gt;&gt; ss[i].x &gt;&gt; ss[i].y; mapa[ss[i].x][ss[i].y] = ss[i].ch; &#125; for(int ii = 0; ii &lt; t; ++ii) //标记棋盘将不能到达的位置 &#123; //cout &lt;&lt; ss[ii].ch &lt;&lt; endl; if(ss[ii].ch == 'R')//车 &#123; for(int i = ss[ii].x-1; i &gt; 0; --i) //Up &#123; mmpa[i][ss[ii].y] = true; if(!check(mapa[i][ss[ii].y])) break; &#125; for(int i = ss[ii].x+1; i &lt; 11; ++i) //Down &#123; mmpa[i][ss[ii].y] = true; if(!check(mapa[i][ss[ii].y])) break; &#125; for(int i = ss[ii].y-1; i &gt; 0; --i) //Left &#123; mmpa[ss[ii].x][i] = true; if(!check(mapa[ss[ii].x][i])) break; &#125; for(int i = ss[ii].y+1; i &lt; 11; ++i) //Right &#123; mmpa[ss[ii].x][i] = true; if(!check(mapa[ss[ii].x][i])) break; &#125; &#125; if(ss[ii].ch == 'C') //炮 &#123; flag = false; for(int i = ss[ii].x-1; i &gt; 0; --i) //Up &#123; if(!check(mapa[i][ss[ii].y])) &#123; if(flag) break;//&#123;mmpa[i][ss[ii].y] = true;break;&#125; flag = true; &#125; if(flag) mmpa[i-1][ss[ii].y] = true; //mmpa[i][ss[ii].y] = true; &#125; flag = false; for(int i = ss[ii].x+1; i &lt; 11; ++i) //Down &#123; if(!check(mapa[i][ss[ii].y])) &#123; if(flag) break;//&#123;mmpa[i][ss[ii].y] = true;break;&#125; flag = true; &#125; if(flag) mmpa[i+1][ss[ii].y] = true; //mmpa[i][ss[ii].y] = true; &#125; flag = false; for(int i = ss[ii].y-1; i &gt; 0; --i) //Left &#123; if(!check(mapa[ss[ii].x][i])) &#123; if(flag) break;//&#123; mmpa[ss[ii].x][i] = true;break;&#125; flag = true; &#125; if(flag) mmpa[ss[ii].x][i-1] = true; //mmpa[ss[ii].x][i] = true; &#125; flag = false; for(int i = ss[ii].y+1; i &lt; 10; ++i) //Right &#123; if(!check(mapa[ss[ii].x][i])) &#123; if(flag) break;//&#123;mmpa[ss[ii].x][i] = true;break;&#125; flag = true; &#125; if(flag) mmpa[ss[ii].x][i+1] = true; //mmpa[ss[ii].x][i] = true; &#125; &#125; if(ss[ii].ch == 'H') //马 &#123; if(check(mapa[ss[ii].x-1][ss[ii].y])) &#123;// mmpa[ss[ii].x-1][ss[ii].y+2] = true;// mmpa[ss[ii].x-1][ss[ii].y-2] = true; if(ss[ii].x-2 &gt; 0) &#123; if(ss[ii].y-1 &gt; 0) mmpa[ss[ii].x-2][ss[ii].y-1] = true; mmpa[ss[ii].x-2][ss[ii].y+1] = true; &#125; &#125; if(check(mapa[ss[ii].x+1][ss[ii].y])) &#123;// mmpa[ss[ii].x+1][ss[ii].y+2] = true;// mmpa[ss[ii].x+1][ss[ii].y-2] = true; if(ss[ii].y-1 &gt; 0) mmpa[ss[ii].x+2][ss[ii].y-1] = true; mmpa[ss[ii].x+2][ss[ii].y+1] = true; &#125; if(check(mapa[ss[ii].x][ss[ii].y+1])) &#123;// mmpa[ss[ii].x-2][ss[ii].y+1] = true;// mmpa[ss[ii].x+2][ss[ii].y+1] = true; if(ss[ii].x-1 &gt; 0) mmpa[ss[ii].x-1][ss[ii].y+2] = true; mmpa[ss[ii].x+1][ss[ii].y+2] = true; &#125; if(check(mapa[ss[ii].x][ss[ii].y-1])) &#123;// mmpa[ss[ii].x-2][ss[ii].y-1] = true;// mmpa[ss[ii].x+2][ss[ii].y-1] = true; if(ss[ii].y-2 &gt; 0) &#123; if(ss[ii].x-1 &gt; 0) mmpa[ss[ii].x-1][ss[ii].y-2] = true; mmpa[ss[ii].x+1][ss[ii].y-2] = true; &#125; &#125; &#125; if(ss[ii].ch == 'G') //帅 &#123; //cout &lt;&lt; ss[ii].x &lt;&lt; "---" &lt;&lt; ss[ii].y &lt;&lt; endl; for(int i = ss[ii].x-1; i &gt; 0; --i) //上 &#123; mmpa[i][ss[ii].y] = true; if(!check(mapa[i][ss[ii].y])) break; //cout &lt;&lt; i &lt;&lt; "--" &lt;&lt; ss[ii].y &lt;&lt; endl; &#125; &#125; //cout &lt;&lt; ss[ii].ch &lt;&lt; endl; &#125; bool ans = false; //将可以到达的位置 for(int i = 0; i &lt; 4; ++i) &#123; int xx = n + dir[i][0]; int yy = m + dir[i][1]; if(xx &lt; 1 || xx &gt; 3 || yy &lt; 4 || yy &gt; 6) continue; //越界continue// if(!check(mapa[xx][yy])) continue; //有棋子continue if(!mmpa[xx][yy]) ans = true; &#125; if(!mmpa[n][m]) ans = true; /*puts(""); puts("棋盘"); for(int q = 1; q &lt; 10; ++q) &#123; for(int w = 1; w &lt; 12; ++w) &#123; cout &lt;&lt; mmpa[q][w] &lt;&lt; " "; &#125; puts(""); &#125;*/ if(!ans) puts("YES"); else puts("NO"); //puts(""); &#125; return 0;&#125; 对拍Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; srand(time(NULL)); int maxn = 6, cou = 0; int dir[11][10]; const char s0[] = "RRCCHH"; //for(int s = 3; s &gt;= 1; --s) for(int s = (1&lt;&lt;maxn) - 1; s &gt;= 1; --s) &#123; for(int num = 1; num; num--) &#123; memset(dir, 0, sizeof(dir)); int n = 0, is = 0; int r0 = 1 + rand()%3, c0 = 4+rand()%3; dir[r0][r0] = 1; int r1 = 8 + rand()%3, c1 = 4 + rand()%3; while(c0 == c1) c1 = 4 + rand()%3; dir[r1][c1] = 1; for(int i = 0; i &lt; maxn; ++i) if(s &amp; (1&lt;&lt;i)) n++; printf("\n%d %d %d\nG %d %d\n",n+1,r0,c0,r1,c1); cou++; for(int i = 0; i &lt; maxn; ++i) if(s &amp; (1&lt;&lt;i)) &#123; int r = 1+rand()%10, c = 1+rand()%9; if(is == 0 &amp;&amp; s0[i] != 'C') &#123; if(s0[i] != 'H') &#123; r = r0 +1; c = c0; &#125; else &#123; r = r0+2; c = c0+1; &#125; is = 1; &#125; else &#123; while(dir[r][c]) &#123; r = 1+rand()%10; c = 1+rand()%9; &#125; &#125; dir[r][c] = 1; printf("%c %d %d\n",s0[i], r, c); &#125; &#125; &#125; printf("0 0 0\n"); return 0;&#125; UVa 201 Squares【模拟】题目大意：在n行n列的小黑点中，用m条线段将这些黑点进行连接，按照边长统计这些线段构成了多少个正方形。 解题思路：因为数据范围很小，我直接用四维数组存下了任意两点之间是否有线段将其连接。最后遍历每个顶点，记录以当前顶点为正方形的左上角边长为k的正方形是否存在。 PS：其实完全可以用二维数组做出来的。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;map&lt;int,int&gt; a;bool xx[10][10][10][10];bool yy[10][10][10][10];int main()&#123; int n, _; char op; int x, y, cas = 0; while(cin &gt;&gt; n &gt;&gt; _) &#123; if(cas) puts("\n**********************************\n"); a.clear(); memset(xx, false, sizeof(xx)); memset(yy, false, sizeof(yy)); while(_--) &#123; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if(op == 'H') xx[x][y][x][y+1] = true; else yy[y][x][y+1][x] = true; &#125; /*for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) cout &lt;&lt; xx[i][j] &lt;&lt; " "; puts(""); &#125; puts(""); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) cout &lt;&lt; yy[i][j] &lt;&lt; " "; puts(""); &#125; puts("");*/ for(int i = 1; i &lt; n; ++i) &#123; for(int j = 1; j &lt; n; ++j) &#123; for(int k = 1; k &lt;= n; ++k) &#123; if(k + j &gt; n) break; if(k + i &gt; n) break; int q; for(q = i; q &lt; i+k; ++q) &#123; if(yy[q][j][q+1][j] == 0 || yy[q][j+k][q+1][j+k] == 0) break;// if(xx[q][j] == 0 || yy[q][j] == 0) break;// if(xx[q][j+k] == 0 || yy[q][j+k] == 0) break; &#125; if(q &lt; i+k) continue;; for(q = j; q &lt; j+k; ++q) &#123; if(xx[i][q][i][q+1] == 0 || xx[i+k][q][i+k][q+1] == 0) break;// if(xx[i][q] == 0 || yy[i][q] == 0) break;// if(xx[i+k][q] == 0 || yy[i+k][q] == 0) break; &#125; if(q &lt; j+k) continue;; //printf("i=%d j=%d k=%d\n",i,j,k); //cout &lt;&lt; k &lt;&lt; endl; if(!a.count(k)) a[k] = 0; ++a[k]; &#125; &#125; &#125; //cout &lt;&lt; "a.size=" &lt;&lt; a.size() &lt;&lt; endl; printf("Problem #%d\n\n",++cas); if(a.size()) &#123; for(auto it = a.begin(); it != a.end(); ++it) printf("%d square (s) of size %d\n", it-&gt;second,it-&gt;first); &#125; else puts("No completed squares can be found."); &#125; return 0;&#125; UVa 220 Othello【模拟】题目大意：模拟黑白棋的游戏进程。 PS：这里紫书上有点错误，就是给出的例子白旗有8个合法操作，书上少了(3,6)和(7,5)这两个位置(网站上的题面是正确的)。 解题思路：模块化一下程序，直接模拟就好了。 这里比较重要的模块是判断某个点放置某个棋子时是否合法，用变量为0和1来控制棋子的颜色，写完这个模块，其他的都很轻松了。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;string tem;int t, p, x, y; //p为1是W-白，0是B-黑char mapa[10][10];int dir[][2] = &#123;1,0,-1,0,1,1,1,-1,-1,1,-1,-1,0,1,0,-1&#125;;bool judge(int x, int y, int p)&#123; bool f1, f2; int xx, yy, dx, dy; char now = p ? 'W' : 'B'; char nex = p ? 'B' : 'W'; for(int i = 0; i &lt; 8; ++i) &#123; f1 = f2 = false; xx = x, yy = y; dx = dir[i][0], dy = dir[i][1]; while(1) &#123; xx += dx, yy += dy; if(mapa[xx][yy] == nex) f1 = true; else if(mapa[xx][yy] == now) &#123; f2 = true; break; &#125; else break; &#125; if(f1 &amp;&amp; f2) return true; &#125; return false;&#125;void legal(int p)&#123; int cnt = 0; for(int i = 1; i &lt;= 8; ++i) &#123; for(int j = 1; j &lt;= 8; ++j) &#123; if(mapa[i][j] != '-') continue; if(judge(i, j, p)) &#123; if(cnt) printf(" "); printf("(%d,%d)", i, j); ++cnt; &#125; &#125; &#125; if(cnt) puts(""); else puts("No legal move.");&#125;void update(int x, int y, int p)&#123; bool f1, f2; int xx, yy, dx, dy; char now = p ? 'W' : 'B'; char nex = p ? 'B' : 'W'; mapa[x][y] = now; for(int i = 0; i &lt; 8; ++i) &#123; f1 = f2 = false; xx = x, yy = y; dx = dir[i][0], dy = dir[i][1]; while(1) &#123; xx += dx, yy += dy; if(mapa[xx][yy] == nex) f1 = true; else if(mapa[xx][yy] == now) &#123; f2 = true; break; &#125; else break; &#125; if(f1 &amp;&amp; f2) &#123; for(int q = x + dx, w = y + dy; (q != xx || w != yy); q += dx, w += dy) mapa[q][w] = now; &#125; &#125;&#125;void out()&#123; int cnt1 = 0, cnt2 = 0; for(int i = 1; i &lt;= 8; ++i) &#123; for(int j = 1; j &lt;= 8; ++j) &#123; if(mapa[i][j] == 'B') cnt1++; if(mapa[i][j] == 'W') cnt2++; &#125; &#125; printf("Black - %2d White - %2d\n", cnt1, cnt2);&#125;int main()&#123; cin &gt;&gt; t; for(int cas = 1; cas &lt;= t; ++cas) &#123; if(cas &gt; 1) puts(""); for(int i = 1; i &lt;= 8; ++i) scanf("%s",mapa[i]+1); cin &gt;&gt; tem; p = (tem == "W"); while(cin &gt;&gt; tem &amp;&amp; tem != "Q") &#123; if(tem == "L") //L legal(p); else //Mxy &#123; x = tem[1] - '0'; y = tem[2] - '0'; if(!judge(x, y, p)) p ^= 1; update(x, y, p); out(); p ^= 1; &#125; &#125; for(int i = 1; i &lt;= 8; ++i) puts(mapa[i]+1); &#125; return 0;&#125; Uva 253 Cube painting【模拟】题目大意：给两个骰子，问他们是否等价。 解题思路：我直接找了个魔方标记了一下然后把所有情况都找出来了。太暴力了，我好菜啊。 PS：这样做的话要注意所有的if都是并列的，就是只要满足任意一种情况，答案就是TRUE。 MyCode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s, a, b; while(cin &gt;&gt; s) &#123; a = b = " "; for(int i = 0; i &lt; 6; ++i) a += s[i]; for(int i = 6; i &lt; 12; ++i) b += s[i]; bool flag = false; char ch = b[3]; char ca = b[4]; //cout &lt;&lt; ch &lt;&lt; "--" &lt;&lt; b[3] &lt;&lt; "--" &lt;&lt; a[6] &lt;&lt; endl; //cout &lt;&lt; ca &lt;&lt; "--" &lt;&lt; b[4] &lt;&lt; "--" &lt;&lt; a[1] &lt;&lt; endl; if(ch==a[1] &amp;&amp; ca==a[6]) &#123; if(b[1]==a[4] &amp;&amp; b[2]==a[2] &amp;&amp; b[5]==a[5] &amp;&amp; b[6]==a[3]) flag = true; if(b[1]==a[2] &amp;&amp; b[2]==a[3] &amp;&amp; b[5]==a[4] &amp;&amp; b[6]==a[5]) flag = true; if(b[1]==a[3] &amp;&amp; b[2]==a[5] &amp;&amp; b[5]==a[2] &amp;&amp; b[6]==a[4]) flag = true; if(b[1]==a[5] &amp;&amp; b[2]==a[4] &amp;&amp; b[5]==a[3] &amp;&amp; b[6]==a[2]) flag = true; &#125; if(ch==a[2] &amp;&amp; ca==a[5]) &#123; if(b[1]==a[1] &amp;&amp; b[2]==a[4] &amp;&amp; b[5]==a[3] &amp;&amp; b[6]==a[6]) flag = true; if(b[1]==a[3] &amp;&amp; b[2]==a[1] &amp;&amp; b[5]==a[6] &amp;&amp; b[6]==a[4]) flag = true; if(b[1]==a[4] &amp;&amp; b[2]==a[6] &amp;&amp; b[5]==a[1] &amp;&amp; b[6]==a[3]) flag = true; if(b[1]==a[6] &amp;&amp; b[2]==a[3] &amp;&amp; b[5]==a[4] &amp;&amp; b[6]==a[1]) flag = true; &#125; if(ch==a[3] &amp;&amp; ca==a[4]) &#123; if(b[1]==a[1] &amp;&amp; b[2]==a[2] &amp;&amp; b[5]==a[5] &amp;&amp; b[6]==a[6]) flag = true; if(b[1]==a[2] &amp;&amp; b[2]==a[6] &amp;&amp; b[5]==a[1] &amp;&amp; b[6]==a[5]) flag = true; if(b[1]==a[6] &amp;&amp; b[2]==a[5] &amp;&amp; b[5]==a[2] &amp;&amp; b[6]==a[1]) flag = true; if(b[1]==a[5] &amp;&amp; b[2]==a[1] &amp;&amp; b[5]==a[6] &amp;&amp; b[6]==a[2]) flag = true; &#125; if(ch==a[4] &amp;&amp; ca==a[3]) &#123; if(b[1]==a[1] &amp;&amp; b[2]==a[5] &amp;&amp; b[5]==a[2] &amp;&amp; b[6]==a[6]) flag = true; if(b[1]==a[5] &amp;&amp; b[2]==a[6] &amp;&amp; b[5]==a[1] &amp;&amp; b[6]==a[2]) flag = true; if(b[1]==a[6] &amp;&amp; b[2]==a[2] &amp;&amp; b[5]==a[5] &amp;&amp; b[6]==a[1]) flag = true; if(b[1]==a[2] &amp;&amp; b[2]==a[1] &amp;&amp; b[5]==a[6] &amp;&amp; b[6]==a[5]) flag = true; &#125; if(ch==a[5] &amp;&amp; ca==a[2]) &#123; if(b[1]==a[1] &amp;&amp; b[2]==a[3] &amp;&amp; b[5]==a[4] &amp;&amp; b[6]==a[6]) flag = true; if(b[1]==a[3] &amp;&amp; b[2]==a[6] &amp;&amp; b[5]==a[1] &amp;&amp; b[6]==a[4]) flag = true; if(b[1]==a[6] &amp;&amp; b[2]==a[4] &amp;&amp; b[5]==a[3] &amp;&amp; b[6]==a[1]) flag = true; if(b[1]==a[4] &amp;&amp; b[2]==a[1] &amp;&amp; b[5]==a[6] &amp;&amp; b[6]==a[3]) flag = true; &#125; if(ch==a[6] &amp;&amp; ca==a[1]) &#123; if(b[1]==a[2] &amp;&amp; b[2]==a[4] &amp;&amp; b[5]==a[3] &amp;&amp; b[6]==a[5]) flag = true; if(b[1]==a[4] &amp;&amp; b[2]==a[5] &amp;&amp; b[5]==a[2] &amp;&amp; b[6]==a[3]) flag = true; if(b[1]==a[5] &amp;&amp; b[2]==a[3] &amp;&amp; b[5]==a[4] &amp;&amp; b[6]==a[2]) flag = true; if(b[1]==a[3] &amp;&amp; b[2]==a[2] &amp;&amp; b[5]==a[5] &amp;&amp; b[6]==a[4]) flag = true; &#125; //cout &lt;&lt; a &lt;&lt; "---" &lt;&lt; b &lt;&lt; endl; if(flag) puts("TRUE"); else puts("FALSE"); &#125; return 0;&#125; UVa 1590 IP Networks【模拟】【位运算】题目大意：给出n个IP地址，求最小的网络包含所有的输入地址。 解题思路：因题目背景需要计算机网络的知识，所以理解起来可能比较难。但读懂题意后就是二进制和十进制的转换。 翻译一下就是将给出的点分十进制形式的IP地址转化为32位的二进制形式，找出他们前n项的二进制表示是一样的“公共前缀”，最小IP地址就是这前缀之后的二进制全改为0然后写成点分十进制的结果，子网掩码就是将这些前缀二进制表示全改成1后转化为点分十进制的结果。(表述能力有限，可自己查阅《计算机网络》这本书或者当♂面问我) MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t;string ans, ipp;struct node&#123; int yi[5]; string yy[5];&#125;;string trans(int a)&#123; string aft = ""; while(a) &#123; if(a &amp; 1) aft = '1' + aft; else aft = '0' + aft; a &gt;&gt;= 1; &#125; while(aft.size() &lt; 8) aft = '0' + aft; return aft;&#125;void solve()&#123; int tem; for(int i = 0; i &lt; 4; ++i) &#123; tem = 0; for(int j = 0; j &lt; 8; ++j) &#123; tem += (1 &lt;&lt; (8-j-1)) * (ipp[i*8+j] - '0'); &#125; printf("%d", tem); printf("%c", i &lt; 3 ? '.' : '\n'); &#125; for(int i = 0; i &lt; 4; ++i) &#123; tem = 0; for(int j = 0; j &lt; 8; ++j) &#123; tem += (1 &lt;&lt; (8-j-1)) * (ans[i*8+j] - '0'); &#125; printf("%d", tem); printf("%c", i &lt; 3 ? '.' : '\n'); &#125;&#125;int main()&#123; while(cin &gt;&gt; t) &#123; node s[MAX]; for(int i = 0; i &lt; t; ++i) &#123; scanf("%d.%d.%d.%d",&amp;s[i].yi[0], &amp;s[i].yi[1], &amp;s[i].yi[2], &amp;s[i].yi[3]); for(int j = 0; j &lt; 4; ++j) s[i].yy[j] = trans(s[i].yi[j]); //cout &lt;&lt; s[i].yy &lt;&lt; " " &lt;&lt; s[i].ee &lt;&lt; " " &lt;&lt; s[i].aa &lt;&lt; " " &lt;&lt; s[i].ii &lt;&lt; endl; &#125; int pos = 32; for(int i = 0; i &lt; t; ++i) &#123; for(int j = i+1; j &lt; t; ++j) &#123; bool flag = true; for(int k = 0; k &lt; 4 &amp;&amp; flag; ++k) &#123; for(int q = 0; q &lt; 8; ++q) &#123; if(s[i].yy[k][q] != s[j].yy[k][q]) &#123; pos = min(pos, k*8 + q); flag = false; break; &#125; &#125; &#125; &#125; &#125; ans = ipp = "";// string ipp = ""; bool flag = true; for(int i = 0; i &lt; 4 &amp;&amp; flag; ++i) &#123; for(int j = 0; j &lt; 8; ++j) &#123; if(i*8 + j &gt;= pos) &#123; flag = false; break; &#125; ipp += s[0].yy[i][j]; &#125; &#125;// cout &lt;&lt; ipp &lt;&lt; endl;// string ans = ""; for(int i = 0; i &lt; pos; ++i) ans += '1'; for(int i = pos+1; i &lt;= 32; ++i) &#123; ans += '0'; ipp += '0'; &#125;// cout &lt;&lt; ans.size() &lt;&lt; endl;// cout &lt;&lt; ipp &lt;&lt; "-----" &lt;&lt; ans &lt;&lt; endl; solve(); &#125; return 0;&#125; UVa 508 Morse Mismatches【模拟】【map】题目大意：给出加密方式、待加密文本和加密文本，要你根据前两项内容输出加密文本代表的什么。如果精准匹配则直接输出；如果多个匹配则输出字典序最小的那个后加上!；如果无法匹配则选一个字典序最小的可能匹配的单词输出并在最后加个?，其中可能匹配指的是可以在编码尾部加上或删去若干字符。 (紫书上表述有误，多个单词精准匹配时输出字典序最小的，非精准匹配时也要输出字典序最小的可能匹配的单词) 解题思路：因为不同文本加密后可能是相同的密文，所以根据密文直接模拟找明文是无法实现的。因为我们已经知道了待加密文本，所以我们可以直接将待加密文本和它加密后的密文存起来，直接拿着这些密文和要求的密文作对比并记录。 因为map自动按照字典序排列了，所以前两种情况很容易实现。对于第三种情况直接拿map中的文本和要匹配的文本进行子序列判断也可以很容易实现。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;char a;string s;map&lt;char, string&gt; morse;map&lt;string, string&gt; context;void read_morse()&#123; while(1) &#123; cin &gt;&gt; a; if(a == '*') return ; cin &gt;&gt; s; morse[a] = s; &#125;&#125;string trans(string before)&#123; string after = ""; for(int i = 0; i &lt; before.size(); ++i) after += morse[before[i]]; return after;&#125;void read_context()&#123; while(1) &#123; cin &gt;&gt; s; if(s == "*") return ; context[s] = trans(s); &#125;&#125;void solve()&#123; string yy, tt; while(1) &#123; cin &gt;&gt; s; if(s == "*") return ; yy = ""; int flag = 0; for(auto it = context.begin(); it != context.end(); ++it) &#123; tt = it -&gt; second; if(tt == s) &#123; if(flag == 0) yy = it -&gt; first; ++flag; &#125; &#125; if(flag == 1) //精确匹配 cout &lt;&lt; yy &lt;&lt; endl; else if(flag &gt; 1) //! cout &lt;&lt; yy &lt;&lt; "!" &lt;&lt; endl; else //? &#123; int hh = INF; bool ok = false; bool is_first = true; for(auto it = context.begin(); it != context.end(); ++it) &#123; if(is_first) yy = it -&gt; first; is_first = false; tt = it -&gt; second; if(tt.size() &gt; s.size()) &#123; if(tt.find(s) == 0) &#123; if(tt.size() - s.size() &lt; hh) &#123; hh = tt.size() - s.size(); yy = it -&gt; first; ok = true; &#125; &#125; &#125; else if(tt.size() &lt; s.size()) &#123; if(s.find(tt) == 0) &#123; if(s.size() - tt.size() &lt; hh) &#123; hh = s.size() - tt.size(); yy = it -&gt; first; ok = true; &#125; &#125; &#125; &#125; cout &lt;&lt; yy &lt;&lt; "?" &lt;&lt;endl; &#125; &#125;&#125;int main()&#123; read_morse(); read_context(); solve(); return 0;&#125; UVa 509 RAID!【模拟】【位运算】题目大意：给出了一种磁盘保护技术，要你根据规则检验一下磁盘存储数据是否正确及能否恢复，如果可以输出存储的数据。 解题思路：先检验是否合法，如果大于1个x，一定不合法；若恰好一个x，则可以根据规则将这个x恢复出来；若没有x则直接将这些位进行异或操作看最终结果。确定合法后再讲二进制转化为16进制输出就可以了。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;char op;int jiou;int d, s, b;char mapa[10][MAX];char hexa[] = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;;string trans(string zz)&#123; int tot = 0; tot += (zz[0] - '0') * 8; tot += (zz[1] - '0') * 4; tot += (zz[2] - '0') * 2; tot += (zz[3] - '0') * 1; string ans = ""; ans += hexa[tot]; return ans;&#125;int main()&#123; int cas = 0; while(cin &gt;&gt; d &amp;&amp; d) &#123; cin &gt;&gt; s &gt;&gt; b; cin &gt;&gt; op; //1是奇校验，0是偶校验。 jiou = (op == 'O' ? 1 : 0); for(int i = 1; i &lt;= d; ++i) &#123; scanf("%s",mapa[i]+1); &#125; bool flag = true; for(int i = 1; i &lt;= s*b; ++i) &#123; int t = 0; int x = 0; int idx = 0; for(int j = 1; j &lt;= d; ++j) &#123; if(mapa[j][i] == 'x') &#123; ++x; idx = j; continue; &#125; t ^= (mapa[j][i] - '0'); &#125; if(x &gt; 1) &#123; flag = false; break; &#125; if(x == 1) &#123; if(t == jiou) mapa[idx][i] = '0'; else mapa[idx][i] = '1'; &#125; else //x==0 &#123; if(t != jiou) &#123; flag = false; break; &#125; &#125; &#125; if(!flag) printf("Disk set %d is invalid.\n", ++cas); else &#123; int temp = 0; for(int i = 1; i &lt;= b; ++i) &#123; int ii = i % d; if(ii == 0) ii = d; for(int j = 1; j &lt;= s; ++j) &#123; mapa[ii][j+temp] = '2'; &#125; temp += s; &#125; //d、s、b string stem = "", ans = ""; for(int i = 1; i &lt;= b*s; i += s) &#123; for(int j = 1; j &lt;= d; ++j) &#123; for(int k = 0; k &lt; s; ++k) &#123; if(mapa[j][k+i] == '2') continue; stem += mapa[j][k+i]; if(stem.size() == 4) &#123; ans += trans(stem); stem = ""; &#125; &#125; &#125; &#125; //不足位补0 if(stem.size()) &#123; int goal = 4 - stem.size(); while(goal--) stem += '0'; ans += trans(stem); &#125; printf("Disk set %d is valid, contents are: ", ++cas); cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; UVa 12108 Extraordinarily Tired Students【模拟】题目大意：给出n个学生的清醒-睡眠周期以及初始时他们所处的周期的哪个时间，当课堂上睡觉人数大于清醒人数时他就会睡觉，否则再听课A_i分钟后再观察一下。问经过多次时间后全班同学都处于清醒状态，或者不存在这种情况。 解题思路：直接模拟睡觉的过程。 MyCode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 505;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, tot;bool slp[15];int a[15], b[15], c[15], pri[15];int main()&#123; int cas = 0; while(cin &gt;&gt; n &amp;&amp; n) &#123; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i]; pri[i] = a[i] + b[i]; slp[i] = (c[i] &gt; a[i]); &#125; int t = 1; bool f = false; while(t &lt; MAX) &#123; int awake = 0; int sleep = 0; for(int i = 0; i &lt; n; ++i) &#123; if(slp[i]) sleep++; else awake++; &#125; if(awake == n) &#123; f = true; break; &#125; for(int i = 0; i &lt; n; ++i) &#123; if(c[i] == a[i]) //判断是否要入睡 &#123; if(sleep &lt;= awake) //坚持听课a_i分钟再说 &#123; slp[i] = false; c[i] = 1; &#125; else //睡吧 &#123; slp[i] = true; c[i]++; &#125; &#125; else if(c[i] == pri[i]) //恰好一个周期结束 &#123; c[i] = 1; slp[i] = false; &#125; else //还在睡中 c[i]++; &#125; t++; &#125; if(f) printf("Case %d: %d\n", ++cas, t); else printf("Case %d: -1\n", ++cas); &#125; return 0;&#125; UVa 1591 Data Mining【模拟】题目大意：？？？ 解题思路：直接枚举AB的取值即可。 MyCode：1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;LL n, Sp, Sq, K, A, B, Pofs, tem;int main()&#123; while(cin &gt;&gt; n &gt;&gt; Sp &gt;&gt; Sq) &#123; K = Sq * n &lt;&lt; 10; Pofs = (n-1) * Sp; for(int a = 0; a &lt; 32; ++a) for(int b = 0; b &lt; 32; ++b) &#123; tem = ((Pofs + (Pofs &lt;&lt; a)) &gt;&gt; b) + Sq; if(tem &gt;= n * Sq &amp;&amp; tem &lt; K) &#123; K = tem; A = a; B = b; &#125; &#125; cout &lt;&lt; K &lt;&lt; " " &lt;&lt; A &lt;&lt; " " &lt;&lt; B &lt;&lt; endl; &#125; return 0;&#125; UVa 815 Flooded!【模拟】【二分】题目大意：输入一个n x m的网格及每个格子的高度，每个格子都是边长为10m的正方形，网格四周是无限大的墙壁。给你网格内雨水的总体积，输出水位的海拔及多少百分比的区域有水。 解题思路：雨水分布只与网格高度有关，和其位置分布无关，因此我们可以将网格按照高度从小到大排序后，看雨水能淹没到哪里。当无法全部淹没时找到恰好无法淹没的那个位置，根据它的高度来二分枚举最终水位的高度。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;const double eps = 1e-8;double a[MAX];int main()&#123; int n, m; int cas = 0, tot, num; double wat, res, tem, ans; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; m) &#123; tot = 0; n *= m; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; sort(a, a+n); cin &gt;&gt; wat; wat /= 100; num = -1; tem = 0; for(int i = 1; i &lt; n; ++i) &#123; tem += (a[i] - a[i-1])*i; //cout &lt;&lt;tem &lt;&lt; endl; if(tem &gt;= wat) &#123; //cout &lt;&lt; tem &lt;&lt; endl; num = i; break; &#125; &#125; if(num == -1) //全部淹没 &#123; ans = a[n-1] + (wat - tem)/n; tot = n; //cout &lt;&lt; ans &lt;&lt;endl; &#125; else &#123; tem -= (a[num]-a[num-1])*num; double l = a[num-1], r = a[num]; double hh = l; while(r-l &gt; eps) &#123; double mid = (r+l)/2; //cout &lt;&lt; mid &lt;&lt; "==" &lt;&lt; tem + (mid-hh)*num &lt;&lt; endl; if(tem + (mid-hh)*num &gt; wat) r = mid; else l = mid; //cout &lt;&lt; r &lt;&lt; "--" &lt;&lt; l &lt;&lt; endl; &#125; ans = l; for(int i = 0; i &lt; n; ++i) &#123; if(a[i] &lt; ans) tot++; &#125; &#125; res = 100.0 * tot / n; printf("Region %d\n",++cas); printf("Water level is %.2f meters.\n",ans); printf("%.2f percent of the region is under water.\n",res); puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>函数和递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第四章例题】【6/6】]]></title>
    <url>%2Flrj-ch4-0%2F</url>
    <content type="text"><![CDATA[UVa 1339 Ancient Cipher【排序】1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 111;const int M = 26;int a[M], b[M];char s1[N], s2[N];int main()&#123; while(~scanf("%s%s", s1, s2)) &#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for(int i = 0; s1[i]; ++i) ++a[s1[i] - 'A']; for(int i = 0; s2[i]; ++i) ++b[s2[i] - 'A']; sort(a, a + M); sort(b, b + M); bool flag = true; for(int i = 0; i &lt; M; ++i) if(a[i] != b[i]) flag = false; puts(flag ? "YES" : "NO"); &#125; return 0;&#125; UVa 489 Hangman Judge【模拟】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 111;bool win, lose;char s1[N], s2[N];int cas, chance, leftt, len1, len2;void guess(char ch)&#123; bool flag = true; for(int i = 0; i &lt; len1; ++i) &#123; if(s1[i] == ch) &#123; --leftt; s1[i] = ' '; flag = false; &#125; &#125; if(flag) --chance; if(!chance) lose = 1; if(!leftt) win = 1;&#125;int main()&#123; while(scanf("%d%s%s", &amp;cas, s1, s2) == 3 &amp;&amp; cas != -1) &#123; len1 = strlen(s1); len2 = strlen(s2); leftt = len1; chance = 7; win = lose = false; for(int i = 0; i &lt; len2; ++i) &#123; guess(s2[i]); if(win || lose) break; &#125; printf("Round %d\n", cas); if(win) puts("You win."); else if(lose) puts("You lose."); else puts("You chickened out."); &#125; return 0;&#125; UVa 133 The Dole Queue【模拟】(自己写的太丑了，不好意思贴出来) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// UVa133 The Dole Queue// Rujia Liu#include&lt;stdio.h&gt;#define maxn 25int n, k, m, a[maxn];// 逆时针走t步，步长是d（-1表示顺时针走），返回新位置int go(int p, int d, int t)&#123; while(t--) &#123; do &#123; p = (p+d+n-1) % n + 1; &#125; while(a[p] == 0); // 走到下一个非0数字 &#125; return p;&#125;int main()&#123; while(scanf("%d%d%d", &amp;n, &amp;k, &amp;m) == 3 &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; i++) a[i] = i; int left = n; // 还剩下的人数 int p1 = n, p2 = 1; while(left) &#123; p1 = go(p1, 1, k); p2 = go(p2, -1, m); printf("%3d", p1); left--; if(p2 != p1) &#123; printf("%3d", p2); left--; &#125; a[p1] = a[p2] = 0; if(left) printf(","); &#125; printf("\n"); &#125; return 0;&#125; UVa 213 Message Decoding【模拟】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int readchar()&#123; while(1) &#123; int ch = getchar(); if(ch != '\n' &amp;&amp; ch != '\r') return ch; &#125;&#125;int readint(int c)&#123; int v = 0; while(c--) v = v * 2 + readchar() - '0'; return v;&#125;int code[8][1&lt;&lt;8];int readcodes()&#123; memset(code, 0, sizeof(code)); code[1][0] = readchar(); for(int len = 2; len &lt;= 7; ++len) &#123; for(int i = 0; i &lt; (1 &lt;&lt; len) - 1; ++i) &#123; int ch = getchar(); if(ch == EOF) return 0; if(ch == '\n' || ch == '\r') return 1; code[len][i] = ch; &#125; &#125; return 1;&#125;void printcodes()&#123; for(int len = 1; len &lt;= 7; ++len) for(int i = 0; i &lt; (1 &lt;&lt; len)-1; ++i) &#123; if(code[len][i] == 0) return ; printf("code[%d][%d] = %c\n", len, i, code[len][i]); &#125;&#125;int main()&#123; while(readcodes()) &#123;// printcodes(); while(1) &#123; int len = readint(3); if(len == 0) break;// printf("len=%d\n", len); while(1) &#123; int v = readint(len);// printf("v=%d\n", v); if(v == (1 &lt;&lt; len) - 1) break; putchar(code[len][v]); &#125; &#125; puts(""); &#125; return 0;&#125; UVa 512 Spreadsheet Tracking【模拟】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;struct node&#123; char com[5]; int x1, y1, x2, y2; int a, x[25];&#125; cmd[MAX];int xx, yy;int r, c, n;int solve(int x, int y)&#123; xx = x, yy = y; for(int i = 0; i &lt; n; ++i) &#123; int dr = 0, dc = 0; if(cmd[i].com[0] == 'E') &#123; if(cmd[i].x1 == xx &amp;&amp; cmd[i].y1 == yy) &#123; xx = cmd[i].x2; yy = cmd[i].y2; &#125; else if(cmd[i].x2 == xx &amp;&amp; cmd[i].y2 == yy) &#123; xx = cmd[i].x1; yy = cmd[i].y1; &#125; &#125; else &#123; for(int j = 0; j &lt; cmd[i].a; ++j) &#123; int x = cmd[i].x[j]; if(cmd[i].com[0] == 'I') //插入 &#123; if(cmd[i].com[1] == 'R' &amp;&amp; x &lt;= xx) dr++; if(cmd[i].com[1] == 'C' &amp;&amp; x &lt;= yy) dc++; &#125; else //删除 &#123; if(cmd[i].com[1] == 'R' &amp;&amp; x == xx) return 0; if(cmd[i].com[1] == 'C' &amp;&amp; x == yy) return 0; if(cmd[i].com[1] == 'R' &amp;&amp; x &lt; xx) dr--; if(cmd[i].com[1] == 'C' &amp;&amp; x &lt; yy) dc--; &#125; &#125; &#125; xx += dr; yy += dc; &#125; return 1;&#125;int main()&#123; int cas = 0; while(cin &gt;&gt; r &gt;&gt; c &amp;&amp; r) &#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; cmd[i].com; if(cmd[i].com[0] == 'E') cin &gt;&gt; cmd[i].x1 &gt;&gt; cmd[i].y1 &gt;&gt; cmd[i].x2 &gt;&gt; cmd[i].y2; else &#123; cin &gt;&gt; cmd[i].a; for(int j = 0; j &lt; cmd[i].a; ++j) cin &gt;&gt; cmd[i].x[j]; &#125; &#125; if(cas) puts(""); printf("Spreadsheet #%d\n", ++cas); int q, x, y; cin &gt;&gt; q; while(q--) &#123; cin &gt;&gt; x &gt;&gt; y; printf("Cell data in (%d,%d) ", x, y); if(!solve(x, y)) printf("GONE"); else printf("moved to (%d,%d)", xx, yy); puts(""); &#125; &#125; return 0;&#125; UVa 12412 A Typical Homework (a.k.a Shi Xiong Bang Bang Mang)【模拟】题目大意：编写一个成绩管理系统，对应的每次输入都作出相应的回复。 解题思路：直接模拟即可，有很多细节要注意。 注意细节：1.计算平均分的时候要注意一下精度问题。为防止精度丢失，我在每个计算出的精度后面都加上了eps(1e-5)。2.计算rank时，不要忘记考虑并列的情况。（如果有两个学生成绩并列第一，那么除他们外最高分就是第三名）。3.当从主菜单输入4时，只返回一句话，那句话中的 ‘ 应该是英文的，直接从描述中复制过来是中文的。4.看到有些博客中写到要防止除0的情况发生。我的程序中除0就是在求单科ave时可能出现的，但是经过测试，数据中并没有这种情况，所以可以不必考虑。 【注】以上就是我出现的错误，其他的细节都是很好发现的了。如果没出现这些错误但是你还过不了的话，不要着急，再仔细想想哪些细节出了问题，或者是私信/留言给我，作为一个在这上面WA到怀疑XX之后还坚持不懈最终A了这道题的快乐的咸鱼，我会乐意帮助你的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;const double eps = 1e-5; int op, tot;struct node&#123; int chi, mat, eng, pro, sum, rk; //四课分数 string SID, CID, name; double ave; bool flag; int pas; &#125; a[MAX]; bool cmp(int A, int B)&#123; return A &gt; B;&#125; void hello()&#123; puts("Welcome to Student Performance Management System (SPMS)."); puts(""); puts("1 - Add"); puts("2 - Remove"); puts("3 - Query"); puts("4 - Show ranking"); puts("5 - Show Statistics"); puts("0 - Exit"); puts("");&#125; void work1()&#123; string si, ci, na; int c, m, e, p; while(1) &#123; puts("Please enter the SID, CID, name and four scores. Enter 0 to finish."); cin &gt;&gt; si; if(si == "0") return ; cin &gt;&gt; ci &gt;&gt; na &gt;&gt; c &gt;&gt; m &gt;&gt; e &gt;&gt; p; bool f = true; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; a[i].SID == si) &#123; puts("Duplicated SID."); f = false; break; &#125; &#125; if(f) &#123; a[tot].SID = si; a[tot].CID = ci; a[tot].name = na; a[tot].chi = c; a[tot].eng = e; a[tot].mat = m; a[tot].pro = p; a[tot].sum = c + e + m + p; a[tot].ave = (c + e + m + p) / 4.0 + eps; a[tot].flag = true; ++tot; &#125; &#125;&#125; void work2()&#123; string tt; while(1) &#123; puts("Please enter SID or name. Enter 0 to finish."); cin &gt;&gt; tt; if(tt == "0") return ; int cnt = 0; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag) &#123; if(a[i].name == tt || a[i].SID == tt) &#123; a[i].flag = false; cnt++; &#125; &#125; &#125; printf("%d student(s) removed.\n", cnt); &#125;&#125; void work3()&#123; //每次查询都计算一下rank int tem[MAX], rrk[MAX], srk = 1, now = 0; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag) tem[now++] = a[i].sum; &#125; sort(tem, tem + now, cmp); rrk[0] = 1; srk++; for(int i = 1; i &lt; now; ++i) &#123; if(tem[i] != tem[i-1]) rrk[i] = srk; else rrk[i] = rrk[i-1]; ++srk; &#125; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag) &#123; for(int t = 0; t &lt; now; ++t) &#123; if(a[i].sum == tem[t]) &#123; a[i].rk = rrk[t]; break; &#125; &#125; &#125; &#125; string tt; while(1) &#123; puts("Please enter SID or name. Enter 0 to finish."); cin &gt;&gt; tt; if(tt == "0") return ; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; (a[i].SID == tt || a[i].name == tt)) &#123; cout &lt;&lt; a[i].rk &lt;&lt; " " &lt;&lt; a[i].SID &lt;&lt; " " &lt;&lt; a[i].CID &lt;&lt; " " &lt;&lt; a[i].name; printf(" %d %d %d %d %d %.2f\n", a[i].chi, a[i].mat, a[i].eng, a[i].pro, a[i].sum, a[i].ave); &#125; &#125; &#125;&#125; void work4()&#123; puts("Showing the ranklist hurts students' self-esteem. Don't do that."); return ;&#125; void work5()&#123; puts("Please enter class ID, 0 for the whole statistics."); string tt; cin &gt;&gt; tt; int pas, fai, yy[5], qq; double suma, cnta, avea; puts("Chinese"); suma = cnta = pas = fai = 0; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; (a[i].CID == tt || tt == "0")) &#123; ++cnta; suma += a[i].chi; if(a[i].chi &gt;= 60) ++pas; else ++fai; &#125; &#125; if(cnta == 0) avea = 0; else avea = suma / cnta + eps; printf("Average Score: %.2f\n", avea); printf("Number of passed students: %d\n", pas); printf("Number of failed students: %d\n", fai); puts(""); puts("Mathematics"); suma = cnta = pas = fai = 0; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; (a[i].CID == tt || tt == "0")) &#123; ++cnta; suma += a[i].mat; if(a[i].mat &gt;= 60) ++pas; else ++fai; &#125; &#125; if(cnta == 0) avea = 0; else avea = suma / cnta + eps; printf("Average Score: %.2f\n", avea); printf("Number of passed students: %d\n", pas); printf("Number of failed students: %d\n", fai); puts(""); puts("English"); suma = cnta = pas = fai = 0; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; (a[i].CID == tt || tt == "0")) &#123; ++cnta; suma += a[i].eng; if(a[i].eng &gt;= 60) ++pas; else ++fai; &#125; &#125; if(cnta == 0) avea = 0; else avea = suma / cnta + eps; printf("Average Score: %.2f\n", avea); printf("Number of passed students: %d\n", pas); printf("Number of failed students: %d\n", fai); puts(""); puts("Programming"); suma = cnta = pas = fai = 0; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; (a[i].CID == tt || tt == "0")) &#123; ++cnta; suma += a[i].pro; if(a[i].pro &gt;= 60) ++pas; else ++fai; &#125; &#125; if(cnta == 0) avea = 0; else avea = suma / cnta + eps; printf("Average Score: %.2f\n", avea); printf("Number of passed students: %d\n", pas); printf("Number of failed students: %d\n", fai); puts(""); memset(yy, 0, sizeof(yy)); puts("Overall:"); for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; (a[i].CID == tt || tt == "0")) &#123; qq = (a[i].chi &gt;= 60) + (a[i].eng &gt;= 60) + (a[i].pro &gt;= 60) + (a[i].mat &gt;= 60); yy[qq]++; &#125; &#125; printf("Number of students who passed all subjects: %d\n", yy[4]); printf("Number of students who passed 3 or more subjects: %d\n", yy[4] + yy[3]); printf("Number of students who passed 2 or more subjects: %d\n", yy[4] + yy[3] + yy[2]); printf("Number of students who passed 1 or more subjects: %d\n", yy[4] + yy[3] + yy[2] + yy[1]); printf("Number of students who failed all subjects: %d\n", yy[0]); puts("");&#125; int main()&#123; hello(); while(cin &gt;&gt; op &amp;&amp; op) &#123; if(op == 1) work1(); else if(op == 2) work2(); else if(op == 3) work3(); else if(op == 4) work4(); else if(op == 5) work5(); hello(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>函数和递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第三章习题】【12/12】]]></title>
    <url>%2Flrj-ch3-1%2F</url>
    <content type="text"><![CDATA[UVa 1585 Score 【字符串】【模拟】【基础】题目大意：给定一个由O和X组成的字符串，每个O都有一定的分数，是目前连续出现的O的个数，问这个字符串的得分是多少。 解题思路：直接做。 Mycode：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, res, tem;string s;int main()&#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; s; res = 0; tem = 0; for(int i = 0; i &lt; s.size(); ++i) &#123; if(s[i] == 'O') ++tem; else tem = 0; res += tem; &#125; cout &lt;&lt; res &lt;&lt; "\n"; &#125; return 0;&#125; UVa 1586 Molar mass【字符串】【模拟】【基础】题目大意：给出一个物质的分子式，求分子量。 解题思路：直接做。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;string s;int t, tem;double res;double Q(char ch)&#123; if(ch == 'C') return 12.01; if(ch == 'H') return 1.008; if(ch == 'O') return 16.00; return 14.01;&#125;int main()&#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; s; res = 0; tem = 0; for(int i = 0; i &lt; s.size(); ++i) &#123; if(isalpha(s[i])) &#123; tem = 1; int j = 1; while(isdigit(s[i + j])) &#123; if(j == 1) tem = 0; tem = tem * 10 + (s[i + j] - '0'); ++j; &#125; res += Q(s[i]) * tem; &#125; &#125; printf("%.3f\n", res); &#125; return 0;&#125; UVa 1225 Digit Counting【模拟】【基础】题目大意：将前n个数字顺次写到一起，问1 ~ 9 各出现多少次。 解题思路：直接做。 Mycode：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, a[11];void solve(int x)&#123; while(x) &#123; ++a[x % 10]; x /= 10; &#125;&#125;int main()&#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; n; memset(a, 0, sizeof(a)); for(int i = 1; i &lt;= n; ++i) solve(i); for(int i = 0; i &lt; 10; ++i) printf("%d%c", a[i], i == 9 ? '\n' : ' '); &#125; return 0;&#125; UVa 455 Periodic Strings【字符串】【模拟】【基础】题目大意：如果一个字符串可以通过某个长度为k的字符串多次重复得到，那么称该串以k为周期。给一个字符串，问其最小周期是多少。 解题思路：直接做。枚举答案。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;string s;int t, res, len;bool judge(int x)&#123; for(int i = x; i &lt; len; ++i) &#123; if(s[i] != s[i % x]) return false; &#125; return true;&#125;int main()&#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; s; len = s.size(); res = len; for(int i = 1; i &lt; len; ++i) &#123; if((len % i == 0) &amp;&amp; judge(i)) &#123; res = i; break; &#125; &#125; cout &lt;&lt; res &lt;&lt; "\n"; if(t) cout &lt;&lt; "\n"; &#125; return 0;&#125; UVa 227 Puzzle【字符串】【模拟】【基础】题目大意：根据指令完成对应操作。注意字符的读入。 解题思路：直接做。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char op;string s[6];int nowx, nowy;void FindNowIdx()&#123; for(int i = 0; i &lt; 5; ++i) for(int j = 0; j &lt; 5; ++j) if(s[i][j] == ' ' || s[i][j] == '\0') &#123; nowx = i; nowy = j; return ; &#125;&#125;void Debug()&#123; cout &lt;&lt; "\n\n******Debug******\n"; for(int i = 0; i &lt; 5; ++i) cout &lt;&lt; s[i] &lt;&lt; "\n"; cout &lt;&lt; nowx &lt;&lt; " " &lt;&lt; nowy &lt;&lt; "\n"; cout &lt;&lt; "******Debug******\n\n";&#125;int main()&#123; int cas = 0; while(getline(cin, s[0]) &amp;&amp; s[0][0] != 'Z') &#123; for(int i = 1; i &lt; 5; ++i) getline(cin, s[i]); FindNowIdx();// Debug(); bool flag = true; while(cin &gt;&gt; op &amp;&amp; op != '0') &#123;// cout &lt;&lt; "op = " &lt;&lt; op &lt;&lt; "\n"; if(op == 'A') &#123; if(nowx == 0) flag = false; else &#123; swap(s[nowx][nowy], s[nowx-1][nowy]); --nowx; &#125; &#125; else if(op == 'B') &#123; if(nowx == 4) flag = false; else &#123; swap(s[nowx][nowy], s[nowx+1][nowy]); ++nowx; &#125; &#125; else if(op == 'L') &#123; if(nowy == 0) flag = false; else &#123; swap(s[nowx][nowy], s[nowx][nowy-1]); --nowy; &#125; &#125; else if(op == 'R') &#123; if(nowy == 4) flag = false; else &#123; swap(s[nowx][nowy], s[nowx][nowy+1]); ++nowy; &#125; &#125; &#125; if(cas) cout &lt;&lt; "\n"; printf("Puzzle #%d:\n", ++cas); if(flag) &#123; for(int i = 0; i &lt; 5; ++i) &#123; for(int j = 0; j &lt; 5; ++j) &#123; if(j) cout &lt;&lt; " "; cout &lt;&lt; s[i][j]; &#125; cout &lt;&lt; "\n"; &#125; &#125; else cout &lt;&lt; "This puzzle has no final configuration.\n"; getchar(); &#125; return 0;&#125; UVa 232 Crossword Answers【模拟】题目大意：将格子里的单词按照要求的顺序输出。 解题思路：算是“预处理”吧，把每个单词的起始位置标记出来，然后再确定是横向还是纵向。我用map先存下单词再输出，其实可以直接输出的。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;const int N = 15;int a[N][N];char s[N][N];bool cro[N][N], dow[N][N];bool check(int i, int j)&#123; if(i == 0 || j == 0) return true; if(s[i-1][j] == '*' || s[i][j-1] == '*') return true; return false;&#125;int main()&#123; int n, m; int cas = 0; while(cin &gt;&gt; n &amp;&amp; n) &#123; if(cas) puts(""); cin &gt;&gt; m; memset(s, 0, sizeof(s)); memset(a, 0, sizeof(a)); for(int i = 0; i &lt; n; ++i) scanf("%s",s[i]); int tot = 0; for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; if(s[i][j] != '*' &amp;&amp; check(i, j)) a[i][j] = ++tot; &#125; &#125; /*puts(""); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; cout &lt;&lt; a[i][j] &lt;&lt; " "; &#125; puts(""); &#125;*/ map&lt;int, string&gt; mapc; map&lt;int, string&gt; mapd; string tem; memset(cro, false, sizeof(cro)); memset(dow, false, sizeof(dow)); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; if(a[i][j] &amp;&amp; !cro[i][j]) &#123; tem = ""; int k; for(k = j; k &lt; m;++k) &#123; if(s[i][k] == '*') break; if(cro[i][k]) break; cro[i][k] = true; tem += s[i][k]; &#125;// cout &lt;&lt; a[i][j] &lt;&lt; " ";// cout &lt;&lt; " tem=" &lt;&lt; tem &lt;&lt; endl; mapc[a[i][j]] = tem; &#125; &#125; &#125; for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; if(a[i][j] &amp;&amp; !dow[i][j]) &#123; tem = ""; int k; for(k = i; k &lt; n;++k) &#123; if(s[k][j] == '*') break; if(dow[k][j]) break; dow[k][j] = true; tem += s[k][j]; &#125;// cout &lt;&lt; a[i][j] &lt;&lt; " ";// cout &lt;&lt; "tem=" &lt;&lt; tem &lt;&lt; endl; mapd[a[i][j]] = tem; &#125; &#125; &#125; printf("puzzle #%d:\n",++cas); puts("Across"); for(auto it = mapc.begin(); it != mapc.end(); ++it) &#123; printf("%3d",it-&gt;first); //cout &lt;&lt; " " &lt;&lt; it -&gt; first cout &lt;&lt; "." &lt;&lt; it -&gt; second &lt;&lt; endl; &#125; puts("Down"); for(auto iter = mapd.begin(); iter != mapd.end(); ++iter) &#123; printf("%3d",iter-&gt;first); //cout &lt;&lt; " " &lt;&lt; iter -&gt; first cout &lt;&lt; "." &lt;&lt; iter -&gt; second &lt;&lt; endl; &#125; &#125; return 0;&#125; UVa 1368 DNA Consensus String【模拟】【构造】题目大意：给出n个长度为m的DNA序列，要你构造出一个和他们之间Hamming距离最小的一个DNA序列，如果存在多解，输出字典序最小的那个。 解题思路：直接砍每个位置上哪个字母出现次数最多，出现次数相等时选字典序小的那个作为解。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1111;const int M = 55;int t, n, m, a[5];char DNA[M][N];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;n,&amp;m); for(int i = 0; i &lt; n; ++i) scanf("%s", DNA[i]); int cost = 0; for(int j = 0; j &lt; m; ++j) &#123; memset(a, 0, sizeof(a)); for(int i = 0; i &lt; n; ++i) &#123; if(DNA[i][j] == 'A') ++a[1]; if(DNA[i][j] == 'C') ++a[2]; if(DNA[i][j] == 'G') ++a[3]; if(DNA[i][j] == 'T') ++a[4]; &#125; if(a[1] &gt;= a[2] &amp;&amp; a[1] &gt;= a[3] &amp;&amp; a[1] &gt;= a[4]) putchar('A'), cost += a[2] + a[3] + a[4]; if(a[2] &gt; a[1] &amp;&amp; a[2] &gt;= a[3] &amp;&amp; a[2] &gt;= a[4]) putchar('C'), cost += a[1] + a[3] + a[4]; if(a[3] &gt; a[2] &amp;&amp; a[3] &gt; a[1] &amp;&amp; a[3] &gt;= a[4]) putchar('G'), cost += a[2] + a[1] + a[4]; if(a[4] &gt; a[2] &amp;&amp; a[4] &gt; a[3] &amp;&amp; a[4] &gt; a[1]) putchar('T'), cost += a[2] + a[3] + a[1]; &#125; putchar('\n'); printf("%d\n", cost); &#125; return 0;&#125; UVa 202 Repeating Decimals【模拟】【高精度】题目大意：将分数化为小数，并且输出循环的长度。 解题思路：类似高精度，用数组不断记录就可以。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 3005;int cx[MAX];int fs[MAX];int main()&#123; int n, m, t, i; int cou, cas = 0; while(cin &gt;&gt; n &gt;&gt; m) &#123; cou = 0; memset(cx, 0, sizeof(cx)); memset(fs, 0, sizeof(fs)); printf("%d/%d = %d.",n, m, n/m); t = n; while(1) &#123; t = t % m * 10; fs[cou] = t / m; for(i = 0; i &lt; cou; ++i) if(cx[i] == t) break; if(i != cou) break; cx[cou++] = t; &#125; for(int q = 0; q &lt; i; ++q) cout &lt;&lt; fs[q]; cout &lt;&lt; "("; if(cou &gt; 50) &#123; for(int q = i; q &lt; i+50; ++q) cout &lt;&lt; fs[q]; cout &lt;&lt; "...)\n"; &#125; else &#123; for(int q = i; q &lt; cou; ++q) cout &lt;&lt; fs[q]; cout &lt;&lt; ")\n"; &#125; printf(" %d = number of digits in repeating cycle\n\n", cou-i); &#125; return 0;&#125; UVa 10340 All in All【模拟】【基础】题目大意：两个字符串s1和s2，问能否从s2中删掉若干字符得到s1。 解题思路：直接做。 Mycode：123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 111111char s1[N],s2[N];int main()&#123; int len1, len2; while(~scanf("%s %s",s1,s2)) &#123; len1 = strlen(s1); len2 = strlen(s2); int j = 0; for(int i = 0; i &lt; len2; ++i) &#123; if(s1[i] == s2[j]) ++j; &#125; if(j == len1) puts("Yes"); else puts("No"); &#125; return 0;&#125; UVa 1587 Box【模拟】【基础】题目大意：给出6个矩形的长和宽，问能否构成一个矩形。 解题思路：排序后直接判断就行。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct node&#123; int w, h;&#125; ss[10];bool cmp(node a, node b)&#123; if(a.w == b.w) return a.h &lt; b.h; return a.w &lt; b.w;&#125;int main()&#123; int a, b; while(cin &gt;&gt; a &gt;&gt; b) &#123; ss[0].w = min(a, b); ss[0].h = max(a, b); for(int i = 1; i&lt;6; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; ss[i].w = min(a, b); ss[i].h = max(a, b); &#125; sort(ss, ss+6, cmp); /*for(int i = 0; i &lt; 6; ++i) cout &lt;&lt; ss[i].w &lt;&lt; " " &lt;&lt; ss[i].h &lt;&lt; endl;*/ bool flag = true;; int i; for(i = 0; i &lt; 6; i += 2) &#123; if(ss[i].h != ss[i+1].h) break; if(ss[i].w != ss[i+1].w) break; &#125; if(i &lt; 6) flag = false; //cout &lt;&lt; i &lt;&lt; " " &lt;&lt; flag &lt;&lt; endl;; if(flag) &#123; if(ss[0].w != ss[2].w) flag = false; if(ss[0].h != ss[4].w) flag = false; if(ss[2].h != ss[4].h) flag = false; &#125; if(flag) puts("POSSIBLE"); else puts("IMPOSSIBLE"); &#125; return 0;&#125; UVa 1588 Kickdown【模拟】题目大意：将两个长度分别为n1，n2且列高只为1或2的长条放入一个高度为3的容器中，问能容纳它们的最短容器长度。 解题思路：n1、n2长度不超过100，直接做。 这里要注意，不一定是短的连接在后面，也有可能是长的和短的去匹配，看代码最后的样例。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1111;char s1[N], s2[N];int a1[N], a2[N], res1, res2, len1, len2;bool judge(int st)&#123; for(int i = st, j = 0; j &lt; len1; ++i, ++j) &#123; if(a2[i] + a1[j] == 4) return false; &#125; return true;&#125;bool judge2(int st)&#123; for(int i = st, j = 0; j &lt; len2; ++i, ++j) &#123; if(a1[i] + a2[j] == 4) return false; &#125; return true;&#125;int main()&#123; while(~scanf("%s%s", s1, s2)) &#123; res1 = res2 = 0; len1 = strlen(s1); len2 = strlen(s2); memset(a1, 0, sizeof(a1)); memset(a2, 0, sizeof(a2)); for(int i = 0; i &lt; len1; ++i) a1[i] = s1[i] - '0'; for(int i = 0; i &lt; len2; ++i) a2[i] = s2[i] - '0';// cout &lt;&lt; len1 &lt;&lt; ' ' &lt;&lt; s1 &lt;&lt; '\n';// cout &lt;&lt; len2 &lt;&lt; ' ' &lt;&lt; s2 &lt;&lt; '\n'; for(int st = 0; st &lt; len2; ++st) &#123; if(judge(st)) &#123; res1 = max(st + len1, len2); break; &#125; &#125; if(!res1) res1 = len1 + len2; for(int st = 0; st &lt; len1; ++st) &#123; if(judge2(st)) &#123; res2 = max(st + len2, len1); break; &#125; &#125; if(!res2) res2 = len1 + len2; printf("%d\n", min(res1, res2)); &#125; return 0;&#125;/*212211112212212212211res = 17*/ UVa 11809 Floating-Point Numbers【数学】题目大意：给你一个浮点数$A \times 10^B$，问当用阶码-尾数的形式表示出来时需要阶码、尾数各多少位。 解题思路：题目意思就是说，当$A \times 10^B == tm \times 2^{te}$时，$M$和$E$的取值。 其中$tm$为小数部分取$M$个1时表示的最大值，即$1 - \frac{1}{2^{M+1}}$。 $te$为尾数取$E$个1时的最大值，即$2^E-1$。 直接求解，数值太大无法求。 常见的大数转为小数的方法就是取对数，对等式两边进行取对数，得： $log_{10}A + B == log_{10}tm + log_{10}2 \times te$。 为方便表示，令等式右边的值为$tem$。 因为$0&lt;A&lt;10$ &amp;&amp; $B$为整数，所以$B == \lfloor tem \rfloor$，$A == \lfloor tem \rfloor - tem$。还有我们观察到$0 \leq M \leq 9$，$1 \leq E \leq 30$，所以可以预处理出所有答案最后直接查询即可。 最后别忘了浮点数判断相等只要他们大小在某个误差范围内相等就可以。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int M = 11;const int E = 33;const double eps = 1e-4;string s;int b, B[M][E];double a, A[M][E];void init()&#123; for(int m = 0; m &lt;= 9; ++m) &#123; for(int e = 1; e &lt;= 30; ++e) &#123; double tm = 1 - 1.0 / (1 &lt;&lt; (m + 1)); double te = (1 &lt;&lt; e) - 1; double tem = log10(tm) + log10(2) * te; B[m][e] = tem; A[m][e] = pow(10, tem - B[m][e]); &#125; &#125;&#125;int main()&#123; init(); while(cin &gt;&gt; s &amp;&amp; s != "0e0") &#123; for(int i = 0; i &lt; s.size(); ++i) if(s[i] == 'e') s[i] = ' '; stringstream ss(s); ss &gt;&gt; a &gt;&gt; b; for(int m = 0; m &lt;= 9; ++m) &#123; for(int e = 1; e &lt;= 30; ++e) &#123; if(b == B[m][e] &amp;&amp; fabs(a - A[m][e]) &lt; eps) &#123; printf("%d %d\n", m, e); break; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第三章例题】【6/6】]]></title>
    <url>%2Flrj-ch3-0%2F</url>
    <content type="text"><![CDATA[例题 3-112345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int flag=1; int c; while((c = getchar()) != EOF) &#123; if(c == '"') &#123; if(flag) cout &lt;&lt; "``"; else cout &lt;&lt; "''"; flag = !flag; &#125; else printf("%c", c); &#125; return 0;&#125; 例题 3-2123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char s[] = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./";int main()&#123; int i, c; while((c = getchar()) != EOF) &#123; for(i = 1; s[i] &amp;&amp; s[i] != c; ++i); if(s[i]) putchar(s[i-1]); else putchar(c); &#125; return 0;&#125; 例题 3-3123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const char* rev = "A 3 HIL JM O 2TUVWXY51SE Z 8 ";const char* res[] = &#123;"not a palindrome", "a regular palindrome", "a mirrored string", "a mirrored palindrome"&#125;;char r(char ch)&#123; if(ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') return rev[ch - 'A']; else return rev[ch - '0' + 25];&#125;int main()&#123; char s[30]; while(~scanf("%s", s)) &#123; int len = strlen(s); int p = 1, m = 1; for(int i = 0; i &lt; (len + 1) / 2; ++i) &#123; if(s[i] != s[len - 1 - i]) p = 0; if(r(s[i]) != s[len-1-i]) m = 0; &#125; printf("%s -- is %s.\n\n", s, res[m * 2 + p]); &#125; return 0;&#125; 例题 3-4123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1010;int n, cnt1, cnt2;int a[MAX], b[MAX];int main()&#123; for(int cas = 1; scanf("%d",&amp;n) &amp;&amp; n; ++cas) &#123; printf("Game %d:\n", cas); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); while(true) &#123; cnt1 = cnt2 = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;b[i]); if(a[i] == b[i]) ++cnt1; &#125; if(b[0] == 0) break; for(int d = 1; d &lt;= 9; ++d) &#123; int c1 = 0, c2 = 0; for(int i = 0; i &lt; n; ++i) &#123; if(a[i] == d) ++c1; if(b[i] == d) ++c2; &#125; cnt2 += min(c1, c2); &#125; printf(" (%d,%d)\n", cnt1, cnt2 - cnt1); &#125; &#125; return 0;&#125; 例题 3-512345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100010;int t, n;int res[MAX];void init()&#123; for(int i = 1; i &lt; MAX; ++i) &#123; int x = i, y = i; while(x) &#123; y += x % 10; x /= 10; &#125; if(res[y] == 0 || i &lt; res[y]) res[y] = i; &#125;&#125;int main()&#123; init(); scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); printf("%d\n", res[n]); &#125; return 0;&#125; 例题 3-612345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int les(char* s, int p, int q)&#123; int n = strlen(s); for(int i = 0; i &lt; n; ++i) &#123; if(s[(p+i)%n] != s[(q+i)%n]) return s[(p+i)%n] &lt; s[(q+i)%n]; &#125; return 0;&#125;int main()&#123; char s[105]; int n, ans, len; while(~scanf("%d",&amp;n)) &#123; while(n--) &#123; ans = 0; scanf("%s",s); len = strlen(s); for(int i = 0; i &lt; len; ++i) if(les(s, i, ans)) ans = i; for(int i = 0; i &lt; len; ++i) cout &lt;&lt; s[(ans+i)%len]; cout &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
</search>
