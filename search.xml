<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU 5527 Too Rich【思维】【贪心】]]></title>
    <url>%2Fhdu5527%2F</url>
    <content type="text"><![CDATA[题目大意：给你面值为1，5，10，20，50，100，200，500，1000，2000的钞票$c_1、c_2 \ldots c_{10}$，问你给出的这些钱能否恰好凑出p元来，如果可以，最多的数量是多少。 解题思路：用给出的钱从大到小比较和p的关系凑很容易检查能否凑出p元来，这时是用的最少的数量凑的。 用最多的数量的话就是用tot - (最少的钱数凑的sum - p的数量)，tot是总数量，sum是总面值和。本来以为到这里就结束了，然而满足上面这是最少使用量的前提是小面额是大面额的因子，即任意数量的大面额总能用若干小面额凑出来，而在本题中20、50，200、500不满足。对于这种情况的解法，我们可以将两个50的合成一个100的，两个500的合成一个1000的来算，但是答案可能还有用到1个50/500的情况。好在他们的搭配只有4种，这时我们只要枚举这4种情况就好了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;int t, p, tot, sum;int a[11], b[11], val[11];void init()&#123; val[0] = 1, val[1] = 5, val[2] = 10; val[3] = 20, val[4] = 50, val[5] = 100; val[6] = 200, val[7] = 500, val[8] = 1000; val[9] = 2000;&#125;void init2()&#123; for(int i = 0; i &lt; 10; ++i) b[i] = a[i];&#125;int solve(int num)&#123; int ans = 0, tem; for(int i = 9; i &gt;= 0; --i) &#123; if(i == 4 || i == 7) &#123; tem = min(num / (val[i] * 2), b[i] / 2); num -= tem * val[i] * 2; ans += tem * 2; &#125; else &#123; tem = min(num / val[i], b[i]); num -= tem * val[i]; ans += tem; &#125;// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; tem &lt;&lt; endl; &#125; //cout &lt;&lt; "ans = " &lt;&lt; ans &lt;&lt; '\n'; if(num) return INF; return ans;&#125;int main()&#123; init(); scanf("%d", &amp;t); while(t--) &#123; tot = sum = 0; scanf("%d", &amp;p); for(int i = 0; i &lt; 10; ++i) &#123; scanf("%d", &amp;a[i]); tot += a[i]; sum += a[i] * val[i]; &#125; //cout &lt;&lt; "tot = " &lt;&lt; tot &lt;&lt; " sum = " &lt;&lt; sum &lt;&lt; '\n'; if(sum &lt; p) &#123; puts("-1"); continue; &#125; //凑组成p最多的，就是sum - p最少的，tot - res就是答案 p = sum - p; int res = INF; for(int i = 0; i &lt; 2; ++i) &#123; for(int j = 0; j &lt; 2; ++j) &#123; init2(); int tem = p; if(i &amp;&amp; b[4]) &#123; --b[4]; tem -= 50; &#125; if(j &amp;&amp; b[7]) &#123; --b[7]; tem -= 500; &#125; if(tem &lt; 0) continue;// cout &lt;&lt; "res = " &lt;&lt; res &lt;&lt; endl; res = min(res, solve(tem) + i + j); &#125; &#125; printf("%d\n", (res == INF ? -1 : tot - res)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>ICPC</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6435 Problem J.CSGO【思维】【二进制枚举】]]></title>
    <url>%2Fhdu6435%2F</url>
    <content type="text"><![CDATA[题目大意：现在有n把主武器和m把副武器，每个武器除了有1个固定属性外，还有k个能互相影响的属性，具体体现在当你选择两把武器时，固定属性带给你的加成是两者的固定属性值之和，而这k个属性带给你的加成是两武器的对应各属性差的绝对值之和。 现在要你选择一把主武器和一把副武器，使得两武器配合带来的加成最大。 解题思路：考虑到n和m的范围最大值都是100000，所以直接看搭配方案是不可行的，而属性k最大只有5，我们可以从这里入手。两武器搭配，对应的k个属性要么是加上带来的加成，要么是减去带来的加成，所以我们可以把每一把武器的每一种状态都枚举出来，就是$2^k$种加减组合，枚举的同时更新此状态下的最大值，对于最后的答案就是将主武器的这个集合和副武器的补集求和。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;int t, n, m, k, up;ll v, a[6], MW[44], SW[44];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); up = 1 &lt;&lt; k; memset(MW, -INF, sizeof(MW)); memset(SW, -INF, sizeof(SW)); for(int o = 0; o &lt; n; ++o) &#123; scanf("%lld", &amp;v); for(int i = 0; i &lt; k; ++i) scanf("%lld", &amp;a[i]); for(int i = 0; i &lt; up; ++i) &#123; ll tem = v; for(int j = 0; j &lt; k; ++j) &#123; if(i &amp; (1 &lt;&lt; j)) tem += a[j]; else tem -= a[j]; &#125; MW[i] = max(MW[i], tem); &#125; &#125; /*for(int o = 0; o &lt; up; ++o) cout &lt;&lt; MW[o] &lt;&lt; " "; cout &lt;&lt; '\n';*/ for(int o = 0; o &lt; m; ++o) &#123; scanf("%lld", &amp;v); for(int i = 0; i &lt; k; ++i) scanf("%lld", &amp;a[i]); for(int i = 0; i &lt; up; ++i) &#123; ll tem = v; for(int j = 0; j &lt; k; ++j) &#123; if(i &amp; (1 &lt;&lt; j)) tem += a[j]; else tem -= a[j]; &#125; SW[i] = max(SW[i], tem); &#125; &#125; /*for(int o = 0; o &lt; up; ++o) cout &lt;&lt; SW[o] &lt;&lt; " "; cout &lt;&lt; '\n';*/ ll res = -INF; for(int o = 0; o &lt; up; ++o) res = max(res, MW[o] + SW[up - o - 1]); printf("%lld\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>思维</tag>
        <tag>多校联合</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6266 Hakase and Nano【规律】]]></title>
    <url>%2Fhdu6266%2F</url>
    <content type="text"><![CDATA[题目大意：H和N玩取石子游戏，给出n堆石子，每堆$a_i$个，H每回合取两次，N每回合取一次，每次都只能从某一堆石子中取出至少一个石子，取走最后一个(堆)石子的获得胜利。 规定先后手，两者都采取最佳策略，问最后H能否获胜。 解题思路：H先手时，经过手算(?)我们发现当n % 3 == 0 &amp;&amp; n个石子全为1的时候先手必输。所以当H后手的时候，只要先手通过一步操作使当前局面变成上述局面H就输了。 这样只需要记录一下所给石子中不为0的石子堆的数目，根据这个输出答案就可以了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, k, a, o;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d",&amp;n,&amp;k); o = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;a); o += (a &gt; 1); &#125; if(k == 1) &#123; if(n % 3 == 0 &amp;&amp; o == 0) puts("No"); else puts("Yes"); &#125; else &#123; if((n - 1) % 3 == 0 &amp;&amp; o &lt;= 1) puts("No"); else if(n % 3 == 0 &amp;&amp; o == 1) puts("No"); else puts("Yes"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>规律</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6418 Rikka with Stone-Paper-Scissors【思维】【期望】]]></title>
    <url>%2Fhdu6418%2F</url>
    <content type="text"><![CDATA[题目大意：现在A和B进行剪刀石头布的游戏，两者中赢得一方会+1分，输得一方-1分，平局分不变。已知A的剪刀石头布各出的次数为a、b、c，B的为a’、b‘、c’(保证A和B出的总次数相同)，B知道A的牌组组成，求当B按照最优策略出牌时，B最大的得分期望。 解题思路：得分期望 = $\sum_{k=1}^n​$ 得分 * 得分概率。 B要获得最大分数，当A出剪刀时，B要出石头，此时B可以得到A出剪刀的分数，也可以失去A出布的分数，则A出剪刀时，B的得分期望为$ b’ \times \frac{a}{a + b + c} - b’ \times \frac{c}{a + b + c} $，依次类推，可以得出答案为$\frac{a’ \times (c - b) + b’ \times (a - c) + c’ \times (b - a)}{a + b + c}$。 最后注意化简一下就好了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll a, b, c, a1, b1, c1;ll gcd(ll a, ll b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; int t; scanf("%d", &amp;t); while(t--) &#123; scanf("%lld%lld%lld%lld%lld%lld", &amp;a, &amp;b, &amp;c, &amp;a1, &amp;b1, &amp;c1); ll mu = a + b + c; ll zi = a1 * (c - b) + b1 * (a - c) + c1 * (b - a); if(zi == 0) puts("0"); else &#123; bool f = 0; if(zi &lt; 0) &#123; zi = -zi; f = 1; &#125; ll g = gcd(zi, mu); zi /= g; mu /= g; if(f) putchar('-'); if(mu == 1) printf("%lld\n", zi); else printf("%lld/%lld\n", zi, mu); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>思维</tag>
        <tag>多校联合</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6406 Taotao Picks Apples【思维】【线段树】]]></title>
    <url>%2Fhdu6406%2F</url>
    <content type="text"><![CDATA[题目大意：现在有一个长度为n的序列，给出m个操作，每次操作都是将第p个位置处的数值替换为q，问每次操作后以第一个元素为起点的LIS的长度是多少。 解题思路：利用线段树维护区间最大值 &amp;&amp; 以区间左端点为起点的LIS的长度，这样答案就是以1为起点的LIS长度。对于每次查询只要替换对应位置上的值和更新树就好了，查询完后记得改回来。 有几点比较巧妙的地方稍微写一下： 区间的LIS长度 = 左子树的LIS长度 + 以左子树最大值为起点的右子树的LIS长度。 计算以某个值为起点的LIS长度时，继续比较这个值和此区间的左子树的最大值，大于等于就查询右子树，否则就返回继续查询左子树的LIS长度 + 用左子树的最大值查询右子树的LIS长度(写的很乱，直接看代码的calc函数和pushup函数好了)。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1e5+5;int t, n, m, pos, val, a[N];struct node&#123; int l, r; int maxx, val;&#125; tree[N&lt;&lt;2];int calc(int val, int rt)&#123; if(tree[rt].l == tree[rt].r) return val &lt; tree[rt].maxx; if(tree[rt&lt;&lt;1].maxx &lt;= val) return calc(val, rt&lt;&lt;1|1); else return calc(val, rt&lt;&lt;1) + (tree[rt].val - tree[rt&lt;&lt;1].val);&#125;void pushup(int rt)&#123; tree[rt].maxx = max(tree[rt&lt;&lt;1].maxx, tree[rt&lt;&lt;1|1].maxx); tree[rt].val = tree[rt&lt;&lt;1].val + calc(tree[rt&lt;&lt;1].maxx, rt&lt;&lt;1|1);&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; if(l == r) &#123; tree[rt].maxx = a[l]; tree[rt].val = 1; return ; &#125; int mid = l + r &gt;&gt; 1; build(l, mid, rt &lt;&lt; 1); build(mid + 1, r, rt &lt;&lt; 1 | 1); pushup(rt);&#125;void update(int pos, int val, int rt)&#123; if(tree[rt].l == tree[rt].r) &#123; tree[rt].maxx = val; return ; &#125; int mid = tree[rt].l + tree[rt].r &gt;&gt; 1; if(pos &lt;= mid) update(pos, val, rt&lt;&lt;1); else update(pos, val, rt&lt;&lt;1|1); pushup(rt);&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); build(1, n, 1); while(m--) &#123; scanf("%d%d", &amp;pos, &amp;val); update(pos, val, 1); printf("%d\n", tree[1].val); update(pos, a[pos], 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>思维</tag>
        <tag>线段树</tag>
        <tag>多校联合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5071 Chat【模拟】【vector】]]></title>
    <url>%2Fhdu5071%2F</url>
    <content type="text"><![CDATA[题目大意：现在有一个聊天界面(可以想象为一个队列)，请你模拟以下操作： Add u： 在队列中加入一个优先级为u的窗口。如果已经存在同优先级的窗口，输出”same priority.”，否则输出 “success.”。 Close u：将队列中优先级为u的窗口关闭。如果不存在优先级为u的窗口，输出”invalid priority.” 否则输出”close u with c.”，其中c是和优先级为u的窗口的聊天次数。 Chat w：向当前在最顶端的窗口输入w句话。如果当前队列中没有窗口，输出”empty.” 否则输出”success.”。 Rotate x：将当前排在第x位的窗口翻转到最前面。如果x非法，输出”out of range.” 否则输出”success.”。 Prior：将优先级最高的窗口翻转到最前面。如果当前队列中没有窗口，输出”empty.” 否则输出”success.”。 Choose u：将优先级为u的窗口翻转到最前面。如果当前队列中没有此窗口，输出”invalid priority.” 否则输出”success.”。 Top u：将优先级为u的窗口置顶。如果当前队列中没有此窗口，输出”invalid priority.” 否则输出”success.”。 Untop：取消当前置顶的窗口。如果当前没有置顶的窗口，输出”no such person.” 否则输出 “success.”。 解题思路：我们可以用vector来模拟这个“队列”，里面的元素为记录优先级&amp;聊天次数的pair对，然后直接做就好了(可以通过写一些函数来模块化一些操作来减少代码量)。 PS：对于置顶这个操作，可以直接用一个变量来记录优先级，通过优先级找到它在队列中的原始位置，因为这个值是不变的，对于后续操作十分方便。 PPS：active时不要忘记忽略掉聊天次数为0的那些窗口。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;char op[9];int t, n, x, mx, pos, val;pair&lt;int, long long&gt; p;vector&lt;pair&lt;int, long long&gt; &gt; V;int Find(int v)&#123; for(int i = 0; i &lt; V.size(); ++i) if(V[i].first == v) return i; return -1;&#125;void Erase(int v)&#123; //删除第v个 int idx = 0; for(auto it = V.begin(); it != V.end(); ++it, ++idx) &#123; if(idx == v) &#123; V.erase(it); return ; &#125; &#125;&#125;void Add()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos != -1) puts("same priority."); else &#123; V.push_back(&#123;x, 0&#125;); puts("success."); &#125;&#125;void Close()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else &#123; printf("close %d with %lld.\n", V[pos].first, V[pos].second); Erase(pos); &#125;&#125;void Chat()&#123; scanf("%d", &amp;x); if(V.empty()) puts("empty."); else &#123; if(val) pos = Find(val); else pos = 0; V[pos].second += x; puts("success."); &#125;&#125;void Rotate(int x)&#123; --x; if(x &lt; 0 || x &gt;= V.size()) puts("out of range."); else &#123; p = V[x]; Erase(x); V.insert(V.begin(), p); puts("success."); &#125;&#125;void Prior()&#123; if(V.empty()) puts("empty."); else &#123; mx = -1; for(int i = 0; i &lt; V.size(); ++i) &#123; if(V[i].first &gt; mx) &#123; mx = V[i].first; pos = i; &#125; &#125; Rotate(pos + 1); &#125;&#125;void Choose()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else Rotate(pos + 1);&#125;void Top()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else &#123; val = x; puts("success."); &#125;&#125;void Untop()&#123; if(val) &#123; val = 0; puts("success."); &#125; else puts("no such person.");&#125;void active()&#123; if(val) &#123; pos = Find(val); if(V[pos].second) &#123; printf("Bye %d: %lld\n", V[pos].first, V[pos].second); Erase(pos); &#125; &#125; for(int i = 0; i &lt; V.size(); ++i) if(V[i].second) printf("Bye %d: %lld\n", V[i].first, V[i].second);&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; val = 0; V.clear(); scanf("%d", &amp;n); for(int cas = 1; cas &lt;= n; ++cas) &#123; scanf("%s", op); printf("Operation #%d: ", cas); if(op[0] == 'A') Add(); else if(op[0] == 'R') scanf("%d", &amp;x), Rotate(x); else if(op[0] == 'P') Prior(); else if(op[0] == 'T') Top(); else if(op[0] == 'U') Untop(); else if(op[1] == 'l') Close(); else if(op[2] == 'a') Chat(); else Choose(); &#125; active(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>模拟</tag>
        <tag>vector</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5929 Basic Data Structure【模拟】【deque】]]></title>
    <url>%2Fhdu5929%2F</url>
    <content type="text"><![CDATA[题目大意： 现有一个栈，请你对它做出如下操作： PUSH x：将元素x入栈。 POP：将栈顶元素出栈。 REVERSE：将栈内元素翻转。 QUERY：查询从栈顶元素开始到栈底元素的NAND和。 其中NAND的定义为： 0 nand 0 = 1 0 nand 1 = 1 1 nand 0 = 1 1 nand 1 = 0 解题思路：对于操作1和操作2直接模拟就好了，费时的部分是剩余的两个操作。 考虑到n的范围最大取值为200000，我们可以开个400000的数组，取中间部分为初始起点，当进行操作3的时候直接将头对另一边进行1、2操作就好了。 观察这个nand运算我们发现，只要和0进行运算的，答案都变成了1，利用这一点我们可以记录0出现的位置，就是出现了0就将它存起来。我们可以也像上面那样进行记录，出于好写我这里直接用的deque。这样，每当查询时我们直接看存起来的0的位置，如果没有0那就数1的个数；如果有的话就看从头开始最后一个出现的0之后有多少个1。这里有个细节要注意，就是当只有1个0的时候，要特别判断一下。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;deque&gt;using namespace std;const int N = 200010;char op[11];int t, n, x, rig, lef, a[N&lt;&lt;1];int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; deque&lt;int&gt; Q; rig = 200001; lef = rig - 1; bool flag = true; printf("Case #%d:\n", cas); scanf("%d", &amp;n); while(n--) &#123; scanf("%s", op); if(op[0] == 'P') &#123; if(op[1] == 'U') &#123; scanf("%d", &amp;x); if(flag) &#123; if(!x) Q.push_back(rig); a[rig++] = x; &#125; else &#123; if(!x) Q.push_front(lef); a[lef--] = x; &#125; &#125; else &#123; if(flag) &#123; --rig; if(!a[rig]) Q.pop_back(); &#125; else &#123; ++lef; if(!a[lef]) Q.pop_front(); &#125; &#125; &#125; if(op[0] == 'Q') &#123; if(lef + 1 == rig) puts("Invalid."); else if(Q.empty()) printf("%d\n", (rig - lef - 1) &amp; 1); else &#123; if(flag) &#123; printf("%d\n", ((Q.front() - lef - 1) +(rig - 1 != Q.front())) &amp; 1); &#125; else &#123; printf("%d\n", ((rig - Q.back() - 1) +(lef + 1 != Q.back())) &amp; 1); &#125; &#125; &#125; if(op[0] == 'R') &#123; flag = !flag; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>模拟</tag>
        <tag>CCPC</tag>
        <tag>deque</tag>
      </tags>
  </entry>
</search>
