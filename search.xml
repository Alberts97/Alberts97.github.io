<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[QLU ACM-ICPC大学生程序设计迎新赛-正式赛【解题报告】]]></title>
    <url>%2Fqlu-2018-2%2F</url>
    <content type="text"><![CDATA[前言：再次作为吃瓜群众围观4小时，之前一直作为参赛选手参加比赛，从来没想到边缘ob也可以如此精彩。这次还和swt一起“解说”了这场比赛，感觉好有意思，解说真好玩.jpg 因为赛中L题数据出了问题，所以最后一直没人能AK，赛后rejudge时发现崔健聪其实早就在比赛过去$\frac{3}{4}$时AK了，而柳总是第一个过L的，宋健、刘陶然也都1A了。 此次比赛共13题，去掉最后一道直接输出答案的，还剩12道，正好请3位现场AK的队员分工写了下题解，这样我只需要整理一下，不用亲自去做每个题了hhhhh，在此表示一下感谢。 题解：崔健聪：A、B、C、DA、约数个数题目大意：输入$n$和$g$，$g$是一个质数，输入$n$行表示$n$个质数$p_1 \ldots p_n$，输入$n$行表示$n$个质数的幂次$ a_1 \ldots a_n$，构成一个$num = p_1^{a_1} \times p_2 ^ {a_2} \ldots p_n^{a_n}$，问你$num$的约数中有多少可以被$g$整除。 解题思路：因为$g$是质数，所以如果所给的$p$没有$g$那么就不会存在能被$g$整除的$num$的约数，有$g$的话，就是一个排列组合问题。除了$p_i == g$的那个质数外，其余被分解出来的质数都可以去$0 - a_1$个，所以最后的结果就是： $a_i（p_i == g）\times (a_1 + 1) \times (a_2+1) \times \ldots \times(a_i-1 + 1) \times (a_i+1 + 1) \times \ldots \times (a_n+1)$。 Code：12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 1e2;int p[maxn];int a[maxn];int cnt[maxn];int main()&#123; int n,g; scanf("%d%d",&amp;n,&amp;g); for(int i = 1;i &lt;= n;++i) scanf("%d",&amp;p[i]); memset(cnt,0,sizeof(cnt)); for(int i = 1;i &lt;= n;++i) &#123; scanf("%d",&amp;a[i]); cnt[p[i]] = a[i]; &#125; if(cnt[g] == 0) printf("0\n"); else &#123; ll ret = cnt[g]; for(int i = 1;i &lt;= n;++i) &#123; if(p[i] == g)continue; ret *= (ll)(a[i] + 1); &#125; printf("%lld\n",ret); &#125; return 0;&#125; B、Alice and Bob题目大意：输入n表示有n堆数，输入n个数，表示数的大小。 游戏规则，Alice先手，Bob后手，先手轮流来，一次只能拿光一堆数，最后所得到的数的和最大者获胜。 解题思路：为了获胜，Alice和Bob肯定都从当前所有数中那最大的。 所以排序，Alice那偶数位，Bob拿奇数位，计算sum1，sum2，比较输出即可。 局面只有平局和Alice胜利。 Code：1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 1e2;int cnt[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;++i) scanf("%d",&amp;cnt[i]); ll sum1 = 0,sum2 = 0; sort(cnt+1,cnt + n + 1); for(int i = n;i &gt;= 0;--i) &#123; if((n - i) % 2 == 0) &#123; sum1 += cnt[i]; &#125; else &#123; sum2 += cnt[i]; &#125; &#125; if(sum1 == sum2) printf("again\n"); else printf("A\n"); return 0;&#125; C、黑白黑题目大意：两种选择，少数为败，存在平局。 输出平局again或者失败的名字。 解题思路：if判断就好吧。 Code：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;#define read(n) scanf("%d",&amp;n);#define readll(n) sacnf("%lld",&amp;n);const int maxn = 1e4 + 1e3;int main()&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(a == b &amp;&amp; b == c)&#123; printf("aha\n"); &#125; else if(a == b) &#123; printf("C\n"); &#125; else if(a == c) &#123; printf("B\n"); &#125; else if(b == c) &#123; printf("A\n"); &#125; return 0;&#125; D、GPA题目大意：输入7门成绩和对应的学分，给你平均绩点的计算方法，根据该方法进行计算即可。 解题思路：浮点运算，输出两位小数。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;#define read(n) scanf("%d",&amp;n);#define readll(n) sacnf("%lld",&amp;n);const int maxn = 1e4 + 1e3;int cost[100];int fen[100];double getfen(int x)&#123; double ret; if(x &gt;= 91)ret = 4.0; else if(x &gt;= 86)ret = 3.5; else if(x &gt;= 81)ret = 3.0; else if(x &gt;= 76)ret = 2.5; else if(x &gt;= 71)ret = 2.0; else if(x &gt;= 66)ret = 1.5; else if(x &gt;= 60)ret = 1.0; else ret = 0; return ret;&#125;int main()&#123; for(int i = 1;i &lt;= 7;i++) &#123; scanf("%d",&amp;cost[i]); &#125; int sum = 0; for(int i = 1;i &lt;= 7;i++) &#123; scanf("%d",&amp;fen[i]); sum += fen[i]; &#125; double ret = 0; for(int i = 1;i &lt;= 7;i++) &#123; ret += getfen(cost[i]) * 1.0 * fen[i]; &#125; ret = ret / (sum * 1.0); printf("%.2lf\n",ret); return 0;&#125; 刘陶然：E、F、G、HE、are you ok?题目大意：给你一个数据的数目大小 n (2 &lt;= n &lt;= 100)，然后给你两行数据，每行有n个，第一行每个数据是字符串（长度不超过10），第二行是对应字符串的个数，拿样例来说，代表apple这个字符串有0个，milk这个字符串有2个。 当所有的字符串的个数为0时就输出are you ok?，否者就出数目不为0 的字符串与其对应的数目。 解题思路：可以用两个数组分别保存字符串还有相应字符串对应的数字，先特判一下是否都为0，是就输出are you ok?否者就按顺序输出字符串的数目不为0 的那些。 Code： F、折纸达人题目大意：先输入一个数代表有几组样例($1&lt;= t &lt;= 100$)，对于每组样例，第一行是有几个操作数($1&lt;=n&lt;=10^5$)（L,R,T,B L表示从左向右折……）一个字幕为一次操作，第二行就是给你说具体的操作了，第三行是询问，共四种询问LR,RL,TB,BT，LR表示从左向右剪,依次类推。（Left，Right ，Top ，Bottom）。 解题思路：​ 你可以先拿一张纸出来，你会发现往左与往右折是一回事，同样往上往下也是，就是左右对折一下或者上下对折一下。从左往右还有从右往左剪开也是一样的，同理上下减也一样。所以问题就是说：左右折几下，上下折几下，然后问你上下剪，或者左右剪开之后有几张纸。 ​ 可以再想一下，咱们先就针对上下剪的情况进行讨论一下： ​ 仅上下对折的情况：你会发现你上下对折无数次，剪开仅剩下两张纸。（其实想明白了上下对折对上下剪，没有任何影响,想不明白没关系，继续看）。 ​ 仅仅左右对折的情况：你会发现对折0次的时候剪开是1+1张，对折1次剪开是2+1张，对折3次剪开是4+1张，对折4次是8+1张，……（大家可以动手试一下）对折n次是$2^n + 1$张。 ​ 即上下对折也左右对折的情况：你会发现只要是你是上下剪开的和你上下对折多少次都没有关系（你可以试一下，你会发现你上下对折影响的其实就是，你还是折下看下把，试一下都明白了）。 ​ 所以总结规律当你上下剪的时候只需要看左右对折的次数，$剪开纸的数目==2^n + 1$ 张。 同理当你左右剪的时候，只需要看上下对折的次数，规律一样。 Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#define INF 0x3f3f3f3f //大家设置int类型最大值的时候可以设置为这个数，将近int类型最大数的一半，而且乘2还不会爆int（这里好像用不到，习惯了，一般都会打上）using namespace std;typedef long long ll;int T;ll lr, tb;//这里用快速幂写了一下，算帮大家复习一下了。其实for循环也可以过，因为n最大10^5，//所以不会超时。但是最好不要用c/c++自带的pow(a, b),他会损失精度，int类型的也会//损失导致结果错误。ll power(ll a, ll b) &#123; ll ans = 1, base = a; while(b != 0)&#123; if(b&amp;1 != 0)&#123; ans = base * ans % 1000000007; &#125; base = base * base % 1000000007; b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; lr = 0; tb = 0; ll n; scanf("%lld", &amp;n); string c; cin&gt;&gt;c; for(int i = 0; i &lt; n; i++)&#123; //统计一下左右折 与 上下折的次数 if(c[i] == 'B' || c[i] == 'T') tb++; else lr++; &#125; string s; cin&gt;&gt;s; if(s == "TB" || s == "BT" )&#123; printf("%lld\n", ( power(2, lr) + 1 )% 1000000007 ); //结果输出之前 // 记得再摸一下 有可能加1正好等于1000000007，那就尴尬了。 &#125; else&#123; printf("%lld\n", ( power(2, tb) + 1 )% 1000000007 ); &#125; &#125; return 0;&#125; G、数数题目大意： 题意题目描述说的比较清楚了，这里就不在赘述了，简单说就是给你一个串，按照规则翻译成一个别的串，规则题目说的很清楚。 解题思路： 把这个串存起来，然后从头往后找，看有几个连续的，如果就它自己连续，那么输出1x，x就是对应的字符，如果连续n个为它就输出nx。 Code： H、神奇老虎机题目大意：先给你一个样例的个数，然后对于每一个样例，第一行轮子的个数n（$1&lt;=n &lt;=1000$），第二行为n个整数（$1 &lt;= 每个数大小 &lt;= 100$），他让你每组输入对应一行输出，输出字典序最小时老虎机滚轮上显示的数字 解题思路：​ 贪心，你让每个轮子的字典序都最小，那么整个字典序不就最小么 ​ 当 1 &lt;= n &lt;= 9时 那么该轮子最小的字典序为1 ​ 当1 &lt;= n &lt;= 99 时 那么该轮子的最小字典序为10 ​ 当1 &lt;= n &lt;= 100 时 那么该轮子的最小字典序为100​ 但是要注意最后一个轮子，由于它规定了（220的字典序比22的大，因为22是220的一个前缀 ）所以最后一个轮子一定要是1，才可以保证字典序最小。 举个栗子：样例输入： 1 6 2 9 11 59 100 63 那么其最小字典序应该对应为： 1 1 10 10 100 1 你可以试一下，不会有比这个更小的了，如果不理解可以找找看有没有比它更小的，找一下，你就理解了。 Code： 宋健：I、J、K、LI、五环题目大意：输入一个串，输出一个串； 解题思路：可以用if else 暴力来做，或者采用Map； map&lt;string,string&gt;_map; Code： J、开挂的小洋题目大意：给你N个地鼠出现的时间，在一秒钟最多砸死两个地鼠。求在m时间内最多可以砸死多少只地鼠； 解题思路：可以定义一个vis数组记录第i秒内出现的地鼠的数量，ans记录最后的结果。 Code： K、数字匹配题目大意：给你一个长度为n的a数组和长度为n的b数组，求两者匹配之后求和的最大和最小； 解题思路：先对两者进行排序，a最大的乘以b最大的为最大；maxx=sum(a[i]*b[i]) a,b都是从小到大排序 a最小的乘以b最大的为最小； Minn=sum(a[i]*b[i])a从小到大排序，b从大到小排序 下证：强强联合，弱弱联合 负数的时候也符合此规律 可以参考白皮书P126页、 Code： L、寄蒜几盒题目大意：输入一个n;然后输入n段距离，表示第1个点与第2个点之间圆弧的长度、第2个点与第3个点之间圆弧的长度······第n个点与第1个点之间圆弧的长度。 解：转化问题求在n条线段，分成三段完全相等的线段。 解题思路一：参考白皮书P146。 开2倍的数组，能够实现以任意点为起点的一个环。 尺取：定义c为环的长度/3。 以1为起点开始尺取，取s为头，t为结尾后的第一个节点。 定义sum为第一段的长度，因为环的长度为3*c，若尺取的第一段长度等于c,这时特判从t（t为第一段之后的第一个节点）向后加一直到大于等于c，若有等于c的情况，说明第一段和第二段都满足c，此时可以输出yes； 若此时的第一段长度大于c，则sum减去s的长度，s++; 若s&gt;n，则表示以1到n的节点为头指针的每一段，都不满足情况，输出no; Code1：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;int a[(int)1e7+1000];int main()&#123; int n;scanf("%d",&amp;n); int sum=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); sum+=a[i]; a[n+i]=a[i]; &#125; if(sum%3!=0)puts("No"); else &#123; int c=sum/3; int s=1,t=1,sum=0; bool flg=0; while(1) &#123; while(sum&lt;c) sum+=a[t++]; if(sum==c) &#123; int temp=t; int ff=0; while(ff&lt;c)ff+=a[temp++]; if(ff==c) &#123; flg=1; break; &#125; &#125; sum-=a[s++]; if(s&gt;n) break; &#125; if(flg==1)puts("Yes"); else puts("No"); &#125;&#125; 解题思路二：n的数据范围为1e6 ，每个数据从(1，1000)相乘不会爆int，可以用set集合存数据，二分来取数据（三个点），看是否成立。 可以把环看出一条循环的线，从坐标0出发，第一个点的坐标为0+a[1],第二个坐标为0+a[1]+a[2]…… 因为是循环的一个环，所以要增加一倍的坐标放入set容器里，然后用set容器的find函数进行查找； 定义c为环长度的1/3； 从每一个点开始，例如d坐标 ,查找d+c ,d+2*c的坐标是否存在。 若存在，则输出yes,否则以下一个点为起点继续查找，一直找不到输出no; Code2： 某不愿透露姓名的帅哥：MM、签到题题目大意：略。 解题思路：略。 Mycode：略。 吐槽：三位队员都给我发的word文档！！而且仅有一位主动附了代码。。Markdown这么好用为啥不用呀，好多公式还要手动调整(没想到整理出来也用了1h+)，用word就用word吧，代码还以图片的形式放到里面…emmm…]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>QLU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QLU ACM-ICPC大学生程序设计迎新赛-热身赛【解题报告】]]></title>
    <url>%2Fqlu-2018-1%2F</url>
    <content type="text"><![CDATA[前言：作为吃瓜群众围观两小时，见证了昌38s1A猜数题(太欧了吧)，中途lzw登顶，柳总封榜前7秒AK等精彩刺激的环节，感觉2小时也并不漫长。 赛后和大家一起讨论了下题目，感觉都是可做的，预备队员最低要求为4题(D和F可能费点事)，现役队员应该AK。 可能之前有没接触过猜答案的题目的，权当娱乐吧。 题解说明仅附代码，因为题面都是中文且思路都很明显。 题目序号 问题 A: 寻找欧皇123456789101112#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; printf("7\n"); return 0;&#125; 问题 B: 人类的本质1234567891011121314151617#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n;string s;int main()&#123; while(cin &gt;&gt; s &gt;&gt; n) &#123; while(n--) cout &lt;&lt; s &lt;&lt; '\n'; &#125; return 0;&#125; 问题 C: 数的价值1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;string s;long long res;int main()&#123; while(cin &gt;&gt; s) &#123; res = 1; for(int i = 0; i &lt; s.size(); ++i) if(s[i] != '0') res = res * (s[i] - '0'); if(s == "0") res = 0; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125; 问题 D: 方格填充1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, x, y;int res[7][7] =&#123; &#123;1, 1, 1, 2, 2, 2, 3&#125;, &#123;1, 2, 2, 2, 3, 4, 4&#125;, &#123;1, 2, 3, 4, 4, 5, 6&#125;, &#123;2, 2, 4, 4, 6, 6, 8&#125;, &#123;2, 3, 4, 6, 7, 8, 9&#125;, &#123;2, 4, 5, 6, 8, 10, 11&#125;, &#123;3, 4, 6, 8, 9, 11, 13&#125;,&#125;;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", res[x-1][y-1]); &#125; return 0;&#125; 问题 E: 买铅笔12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, num, price, res[3];int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; 3; ++i) &#123; scanf("%d%d", &amp;num, &amp;price); int need = n / num + ((n % num) ? 1 : 0); res[i] = need * price; &#125; res[0] = min(res[0], res[1]); res[0] = min(res[0], res[2]); printf("%d\n", res[0]); return 0;&#125; 问题 F: 图书管理员12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1010;int n, t, x, q, a[N];int len[] = &#123;0,10,100,1000,10000,100000,1000000,10000000&#125;;int main()&#123; scanf("%d%d", &amp;n,&amp;q); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); sort(a, a + n); while(q--) &#123; bool flag = 0; scanf("%d%d", &amp;t, &amp;x); for(int i = 0; i &lt; n; ++i) &#123; if(a[i] % len[t] == x) &#123; flag = 1; printf("%d\n", a[i]); break; &#125; &#125; if(!flag) puts("-1"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>QLU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU ACM-ICPC 2018 Training Weekly Contest(Freshman/11-11)【解题报告】]]></title>
    <url>%2Fsdnu-2018-3%2F</url>
    <content type="text"><![CDATA[题目难度分析及考察内容：easy：1004(C语言)1001(快速幂模板，周五晚刚讲的)1005(简单字符串处理)1006(模拟 + 细节)medium：1002(规律||直接做&lt;数组开全局就能开的下了&gt;)1003(中等字符串处理)1008(结构体排序&lt;课上没讲吗?那就趁这个机会学一下&gt;)1007(题意理解)hard：1009(map + 题意)发现的问题： 乱加getchar()。(王某) 数组不开全局，导致RE。(孙某) 8102年了，不知道递推，求fibonacci数列还用递归(第二题没做出来的xxxxxxx) 不跟榜，在一个题上从开场WA到结束。 对罚时还没概念，这个慢慢培养吧，身处弱校 + 自身菜鸡很多时候都靠罚时蹭个牌。。 说明：这些题目一周内完全可以补完，下周一至周四尽量补完。 充分思考后再看思路，最后再看代码。AC过也最好看看，说不定就学到新知识了呢。 一定要保证最后能自己写出来并AC掉。 题解1349.快速幂入门快速幂模板题，签到 Code:无。 1356.Fibonacci题意：给出一个序列，序列的定义为 $\operatorname{F[i]}=\begin{cases}7 &amp; \text{i = 0 } \\text 11 &amp; \text{i = 1}\ F[n-1] + F[n-2] &amp; \text{i $\geq$ 2 } \\end{cases}$ 问F[n] % 3 是否等于 0 思路： 直接做(怎么还有人用递归？这种可以递推的别递归啊，看一下n的范围，递归这不明摆着过不了吗) 可以直接做的原因是 $(a + b) \% m = ((a \% m) + (b \% m)) \% m$。 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1000010;int f[N], n;void init()&#123; f[0] = 7, f[1] = 11; for(int i = 2; i &lt; N; ++i) f[i] = (f[i - 1] + f[i - 2]) % 3;&#125;int main()&#123; init(); while(~scanf("%d", &amp;n)) puts(f[n] ? "no" : "yes"); return 0;&#125; 找规律(写出几项来就发现了) 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;//int f[111];int main()&#123; /* f[0] = 7, f[1] = 11; for(int i = 2; i &lt;= 20; ++i) f[i] = f[i - 1] + f[i - 2]; for(int i = 0; i &lt;= 20; ++i) cout &lt;&lt; f[i] % 3 &lt;&lt; ' '; cout &lt;&lt; '\n'; */ int n; while(~scanf("%d", &amp;n)) puts((n - 2) % 4 ? "no" : "yes"); return 0;&#125; 1357.Text Reverse题意：将输入的每个字符进行翻转。 思路：直接做 代码：用string的reverse函数可以简单快速的实现 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int t;string a, s;int main()&#123; scanf("%d", &amp;t); getchar(); while(t--) &#123; getline(cin, s); //读取一行 stringstream ss(s); //创建一个“字符串流” bool flag = 0; //控制空格 while(ss &gt;&gt; a) &#123; if(flag) cout &lt;&lt; ' '; flag = 1; reverse(a.begin(), a.end()); cout &lt;&lt; a; &#125; cout &lt;&lt; '\n'; &#125; return 0;&#125; 1358.Buildings题意：记录只有0和1构成的$N \times M$的矩阵中有多少个1。 思路：直接做(疑问：用数组干啥啊？)。 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, m, tem, res;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; res = 0; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; n * m; ++i) &#123; scanf("%d", &amp;tem); res += tem; &#125; printf("%d\n", res); &#125; return 0;&#125; 1359.GPA题意：自己翻译。 思路：直接做。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;bool flag;int val[256];char s[1111];int cnt, len, sum;void init()&#123; memset(val, -1, sizeof(val)); val['A'] = 4; val['B'] = 3; val['C'] = 2; val['D'] = 1; val['F'] = 0;&#125;int main()&#123; init(); while(gets(s)) &#123; flag = 1; sum = cnt = 0; len = strlen(s); for(int i = 0; i &lt; len; ++i) &#123; if(s[i] == ' ') continue; if(val[s[i]] == -1) &#123; flag = 0; break; &#125; ++cnt; sum += val[s[i]]; &#125; if(!flag) puts("Unknown letter grade in input"); else printf("%.2f\n", (double)sum / cnt); &#125; return 0;&#125; 1361.Grasshopper And the String题意：找出一个字符串的两个相邻的元音字母(‘A’, ‘E’, ‘I’, ‘O’, ‘U’ and ‘Y’)的最大位置。 思路：直接做。记得初始位置和结束位置特判。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char s[111];bool judge(char ch)&#123; if(ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' || ch =='Y') return true; return false;&#125;int main()&#123; while(~scanf("%s", s)) &#123; int len = strlen(s); int res = 0, tmp = -1; for(int i = 0; i &lt; len; ++i) &#123; if(judge(s[i])) &#123; res = max(res, i - tmp); tmp = i; &#125; &#125; res = max(res, len - tmp); printf("%d\n", res); &#125; return 0;&#125; 1362.Parade题意：阅读理解题，这里不写了，自己细细品味。 思路：嗯。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 100010;int n, res, sum1, sum2, a[N], b[N];int t1, t2, best;int main()&#123; while(~scanf("%d", &amp;n)) &#123; sum1 = sum2 = 0; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d", &amp;a[i], &amp;b[i]); sum1 += a[i]; sum2 += b[i]; &#125; res = 0; best = abs(sum1 - sum2); for(int i = 1; i &lt;= n; ++i) &#123; t1 = sum1 - a[i] + b[i]; t2 = sum2 - b[i] + a[i]; if(abs(t1 - t2) &gt; best) &#123; best = abs(t1 - t2); res = i; &#125; &#125; printf("%d\n", res); &#125; return 0;&#125; 1363.Solving Order题意：嗯。 思路：结构体排序。 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, m;struct node&#123; int cnt; char color[11];&#125; a[11];bool cmp(node u, node v)&#123; return u.cnt &gt; v.cnt;&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%s%d", &amp;a[i].color, &amp;a[i].cnt); sort(a + 1, a + n + 1, cmp); for(int i = 1; i &lt;= n; ++i) printf("%s%c", a[i].color, i == n ? '\n' : ' '); &#125; return 0;&#125; 1533.寻找复读机题意：中文题面。 思路：map标记，直接找。 坑点： 1. 卡PE 2. `找出所有可能是复读机的群友`(我们只能确定出明确不是复读机的群友，剩下的不确定的都可能是)。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;const int N = 1111;string s[N];int n, m, a[N];map&lt;int, bool&gt; MP;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m) &#123; for(int i = 1; i &lt;= m; ++i) cin &gt;&gt; a[i] &gt;&gt; s[i]; for(int i = 1; i &lt;= n; ++i) MP[i] = 1; MP[a[1]] = 0; for(int i = 2; i &lt;= m; ++i) if(s[i] != s[i - 1]) MP[a[i]] = 0; bool flag = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(!MP[i]) continue; if(flag) cout &lt;&lt; ' '; flag = 1; cout &lt;&lt; i; &#125; cout &lt;&lt; '\n'; &#125; return 0;&#125; END： 每当在书中读及那些卑微的努力，都觉得感动且受震撼。也许每个人在发出属于自己的光芒之前，都经历了无数的煎熬，漫长的黑夜，无尽的孤独，甚至不断的嘲讽和否定，但好在那些踮脚的少年，最后都得到了自己想要的一切。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5527 Too Rich【思维】【贪心】]]></title>
    <url>%2Fhdu-5527%2F</url>
    <content type="text"><![CDATA[题目大意：给你面值为1，5，10，20，50，100，200，500，1000，2000的钞票$c_1、c_2 \ldots c_{10}$，问你给出的这些钱能否恰好凑出p元来，如果可以，最多的数量是多少。 解题思路：用给出的钱从大到小比较和p的关系凑很容易检查能否凑出p元来，这时是用的最少的数量凑的。 用最多的数量的话就是用tot - (最少的钱数凑的sum - p的数量)，tot是总数量，sum是总面值和。本来以为到这里就结束了，然而满足上面这是最少使用量的前提是小面额是大面额的因子，即任意数量的大面额总能用若干小面额凑出来，而在本题中20、50，200、500不满足。对于这种情况的解法，我们可以将两个50的合成一个100的，两个500的合成一个1000的来算，但是答案可能还有用到1个50/500的情况。好在他们的搭配只有4种，这时我们只要枚举这4种情况就好了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;int t, p, tot, sum;int a[11], b[11], val[11];void init()&#123; val[0] = 1, val[1] = 5, val[2] = 10; val[3] = 20, val[4] = 50, val[5] = 100; val[6] = 200, val[7] = 500, val[8] = 1000; val[9] = 2000;&#125;void init2()&#123; for(int i = 0; i &lt; 10; ++i) b[i] = a[i];&#125;int solve(int num)&#123; int ans = 0, tem; for(int i = 9; i &gt;= 0; --i) &#123; if(i == 4 || i == 7) &#123; tem = min(num / (val[i] * 2), b[i] / 2); num -= tem * val[i] * 2; ans += tem * 2; &#125; else &#123; tem = min(num / val[i], b[i]); num -= tem * val[i]; ans += tem; &#125;// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; tem &lt;&lt; endl; &#125; //cout &lt;&lt; "ans = " &lt;&lt; ans &lt;&lt; '\n'; if(num) return INF; return ans;&#125;int main()&#123; init(); scanf("%d", &amp;t); while(t--) &#123; tot = sum = 0; scanf("%d", &amp;p); for(int i = 0; i &lt; 10; ++i) &#123; scanf("%d", &amp;a[i]); tot += a[i]; sum += a[i] * val[i]; &#125; //cout &lt;&lt; "tot = " &lt;&lt; tot &lt;&lt; " sum = " &lt;&lt; sum &lt;&lt; '\n'; if(sum &lt; p) &#123; puts("-1"); continue; &#125; //凑组成p最多的，就是sum - p最少的，tot - res就是答案 p = sum - p; int res = INF; for(int i = 0; i &lt; 2; ++i) &#123; for(int j = 0; j &lt; 2; ++j) &#123; init2(); int tem = p; if(i &amp;&amp; b[4]) &#123; --b[4]; tem -= 50; &#125; if(j &amp;&amp; b[7]) &#123; --b[7]; tem -= 500; &#125; if(tem &lt; 0) continue;// cout &lt;&lt; "res = " &lt;&lt; res &lt;&lt; endl; res = min(res, solve(tem) + i + j); &#125; &#125; printf("%d\n", (res == INF ? -1 : tot - res)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>HDU</tag>
        <tag>ICPC</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6435 Problem J.CSGO【思维】【二进制枚举】]]></title>
    <url>%2Fhdu-6435%2F</url>
    <content type="text"><![CDATA[题目大意：现在有n把主武器和m把副武器，每个武器除了有1个固定属性外，还有k个能互相影响的属性，具体体现在当你选择两把武器时，固定属性带给你的加成是两者的固定属性值之和，而这k个属性带给你的加成是两武器的对应各属性差的绝对值之和。 现在要你选择一把主武器和一把副武器，使得两武器配合带来的加成最大。 解题思路：考虑到n和m的范围最大值都是100000，所以直接看搭配方案是不可行的，而属性k最大只有5，我们可以从这里入手。两武器搭配，对应的k个属性要么是加上带来的加成，要么是减去带来的加成，所以我们可以把每一把武器的每一种状态都枚举出来，就是$2^k$种加减组合，枚举的同时更新此状态下的最大值，对于最后的答案就是将主武器的这个集合和副武器的补集求和。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;int t, n, m, k, up;ll v, a[6], MW[44], SW[44];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); up = 1 &lt;&lt; k; memset(MW, -INF, sizeof(MW)); memset(SW, -INF, sizeof(SW)); for(int o = 0; o &lt; n; ++o) &#123; scanf("%lld", &amp;v); for(int i = 0; i &lt; k; ++i) scanf("%lld", &amp;a[i]); for(int i = 0; i &lt; up; ++i) &#123; ll tem = v; for(int j = 0; j &lt; k; ++j) &#123; if(i &amp; (1 &lt;&lt; j)) tem += a[j]; else tem -= a[j]; &#125; MW[i] = max(MW[i], tem); &#125; &#125; /*for(int o = 0; o &lt; up; ++o) cout &lt;&lt; MW[o] &lt;&lt; " "; cout &lt;&lt; '\n';*/ for(int o = 0; o &lt; m; ++o) &#123; scanf("%lld", &amp;v); for(int i = 0; i &lt; k; ++i) scanf("%lld", &amp;a[i]); for(int i = 0; i &lt; up; ++i) &#123; ll tem = v; for(int j = 0; j &lt; k; ++j) &#123; if(i &amp; (1 &lt;&lt; j)) tem += a[j]; else tem -= a[j]; &#125; SW[i] = max(SW[i], tem); &#125; &#125; /*for(int o = 0; o &lt; up; ++o) cout &lt;&lt; SW[o] &lt;&lt; " "; cout &lt;&lt; '\n';*/ ll res = -INF; for(int o = 0; o &lt; up; ++o) res = max(res, MW[o] + SW[up - o - 1]); printf("%lld\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>思维</tag>
        <tag>多校联合</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6266 Hakase and Nano【规律】]]></title>
    <url>%2Fhdu-6266%2F</url>
    <content type="text"><![CDATA[题目大意：H和N玩取石子游戏，给出n堆石子，每堆$a_i$个，H每回合取两次，N每回合取一次，每次都只能从某一堆石子中取出至少一个石子，取走最后一个(堆)石子的获得胜利。 规定先后手，两者都采取最佳策略，问最后H能否获胜。 解题思路：H先手时，经过手算(?)我们发现当n % 3 == 0 &amp;&amp; n个石子全为1的时候先手必输。所以当H后手的时候，只要先手通过一步操作使当前局面变成上述局面H就输了。 这样只需要记录一下所给石子中不为0的石子堆的数目，根据这个输出答案就可以了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, k, a, o;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d",&amp;n,&amp;k); o = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;a); o += (a &gt; 1); &#125; if(k == 1) &#123; if(n % 3 == 0 &amp;&amp; o == 0) puts("No"); else puts("Yes"); &#125; else &#123; if((n - 1) % 3 == 0 &amp;&amp; o &lt;= 1) puts("No"); else if(n % 3 == 0 &amp;&amp; o == 1) puts("No"); else puts("Yes"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>CCPC</tag>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6418 Rikka with Stone-Paper-Scissors【思维】【期望】]]></title>
    <url>%2Fhdu-6418%2F</url>
    <content type="text"><![CDATA[题目大意：现在A和B进行剪刀石头布的游戏，两者中赢得一方会+1分，输得一方-1分，平局分不变。已知A的剪刀石头布各出的次数为a、b、c，B的为a’、b‘、c’(保证A和B出的总次数相同)，B知道A的牌组组成，求当B按照最优策略出牌时，B最大的得分期望。 解题思路：得分期望 = $\sum_{k=1}^n​$ 得分 * 得分概率。 B要获得最大分数，当A出剪刀时，B要出石头，此时B可以得到A出剪刀的分数，也可以失去A出布的分数，则A出剪刀时，B的得分期望为$ b’ \times \frac{a}{a + b + c} - b’ \times \frac{c}{a + b + c} $，依次类推，可以得出答案为$\frac{a’ \times (c - b) + b’ \times (a - c) + c’ \times (b - a)}{a + b + c}$。 最后注意化简一下就好了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll a, b, c, a1, b1, c1;ll gcd(ll a, ll b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; int t; scanf("%d", &amp;t); while(t--) &#123; scanf("%lld%lld%lld%lld%lld%lld", &amp;a, &amp;b, &amp;c, &amp;a1, &amp;b1, &amp;c1); ll mu = a + b + c; ll zi = a1 * (c - b) + b1 * (a - c) + c1 * (b - a); if(zi == 0) puts("0"); else &#123; bool f = 0; if(zi &lt; 0) &#123; zi = -zi; f = 1; &#125; ll g = gcd(zi, mu); zi /= g; mu /= g; if(f) putchar('-'); if(mu == 1) printf("%lld\n", zi); else printf("%lld/%lld\n", zi, mu); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>思维</tag>
        <tag>多校联合</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6406 Taotao Picks Apples【思维】【线段树】]]></title>
    <url>%2Fhdu-6406%2F</url>
    <content type="text"><![CDATA[题目大意：现在有一个长度为n的序列，给出m个操作，每次操作都是将第p个位置处的数值替换为q，问每次操作后以第一个元素为起点的LIS的长度是多少。 解题思路：利用线段树维护区间最大值 &amp;&amp; 以区间左端点为起点的LIS的长度，这样答案就是以1为起点的LIS长度。对于每次查询只要替换对应位置上的值和更新树就好了，查询完后记得改回来。 有几点比较巧妙的地方稍微写一下： 区间的LIS长度 = 左子树的LIS长度 + 以左子树最大值为起点的右子树的LIS长度。 计算以某个值为起点的LIS长度时，继续比较这个值和此区间的左子树的最大值，大于等于就查询右子树，否则就返回继续查询左子树的LIS长度 + 用左子树的最大值查询右子树的LIS长度(写的很乱，直接看代码的calc函数和pushup函数好了)。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1e5+5;int t, n, m, pos, val, a[N];struct node&#123; int l, r; int maxx, val;&#125; tree[N&lt;&lt;2];int calc(int val, int rt)&#123; if(tree[rt].l == tree[rt].r) return val &lt; tree[rt].maxx; if(tree[rt&lt;&lt;1].maxx &lt;= val) return calc(val, rt&lt;&lt;1|1); else return calc(val, rt&lt;&lt;1) + (tree[rt].val - tree[rt&lt;&lt;1].val);&#125;void pushup(int rt)&#123; tree[rt].maxx = max(tree[rt&lt;&lt;1].maxx, tree[rt&lt;&lt;1|1].maxx); tree[rt].val = tree[rt&lt;&lt;1].val + calc(tree[rt&lt;&lt;1].maxx, rt&lt;&lt;1|1);&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; if(l == r) &#123; tree[rt].maxx = a[l]; tree[rt].val = 1; return ; &#125; int mid = l + r &gt;&gt; 1; build(l, mid, rt &lt;&lt; 1); build(mid + 1, r, rt &lt;&lt; 1 | 1); pushup(rt);&#125;void update(int pos, int val, int rt)&#123; if(tree[rt].l == tree[rt].r) &#123; tree[rt].maxx = val; return ; &#125; int mid = tree[rt].l + tree[rt].r &gt;&gt; 1; if(pos &lt;= mid) update(pos, val, rt&lt;&lt;1); else update(pos, val, rt&lt;&lt;1|1); pushup(rt);&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); build(1, n, 1); while(m--) &#123; scanf("%d%d", &amp;pos, &amp;val); update(pos, val, 1); printf("%d\n", tree[1].val); update(pos, a[pos], 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>HDU</tag>
        <tag>思维</tag>
        <tag>多校联合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5071 Chat【模拟】【vector】]]></title>
    <url>%2Fhdu-5071%2F</url>
    <content type="text"><![CDATA[题目大意：现在有一个聊天界面(可以想象为一个队列)，请你模拟以下操作： Add u： 在队列中加入一个优先级为u的窗口。如果已经存在同优先级的窗口，输出”same priority.”，否则输出 “success.”。 Close u：将队列中优先级为u的窗口关闭。如果不存在优先级为u的窗口，输出”invalid priority.” 否则输出”close u with c.”，其中c是和优先级为u的窗口的聊天次数。 Chat w：向当前在最顶端的窗口输入w句话。如果当前队列中没有窗口，输出”empty.” 否则输出”success.”。 Rotate x：将当前排在第x位的窗口翻转到最前面。如果x非法，输出”out of range.” 否则输出”success.”。 Prior：将优先级最高的窗口翻转到最前面。如果当前队列中没有窗口，输出”empty.” 否则输出”success.”。 Choose u：将优先级为u的窗口翻转到最前面。如果当前队列中没有此窗口，输出”invalid priority.” 否则输出”success.”。 Top u：将优先级为u的窗口置顶。如果当前队列中没有此窗口，输出”invalid priority.” 否则输出”success.”。 Untop：取消当前置顶的窗口。如果当前没有置顶的窗口，输出”no such person.” 否则输出 “success.”。 解题思路：我们可以用vector来模拟这个“队列”，里面的元素为记录优先级&amp;聊天次数的pair对，然后直接做就好了(可以通过写一些函数来模块化一些操作来减少代码量)。 PS：对于置顶这个操作，可以直接用一个变量来记录优先级，通过优先级找到它在队列中的原始位置，因为这个值是不变的，对于后续操作十分方便。 PPS：active时不要忘记忽略掉聊天次数为0的那些窗口。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;char op[9];int t, n, x, mx, pos, val;pair&lt;int, long long&gt; p;vector&lt;pair&lt;int, long long&gt; &gt; V;int Find(int v)&#123; for(int i = 0; i &lt; V.size(); ++i) if(V[i].first == v) return i; return -1;&#125;void Erase(int v)&#123; //删除第v个 int idx = 0; for(auto it = V.begin(); it != V.end(); ++it, ++idx) &#123; if(idx == v) &#123; V.erase(it); return ; &#125; &#125;&#125;void Add()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos != -1) puts("same priority."); else &#123; V.push_back(&#123;x, 0&#125;); puts("success."); &#125;&#125;void Close()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else &#123; printf("close %d with %lld.\n", V[pos].first, V[pos].second); Erase(pos); &#125;&#125;void Chat()&#123; scanf("%d", &amp;x); if(V.empty()) puts("empty."); else &#123; if(val) pos = Find(val); else pos = 0; V[pos].second += x; puts("success."); &#125;&#125;void Rotate(int x)&#123; --x; if(x &lt; 0 || x &gt;= V.size()) puts("out of range."); else &#123; p = V[x]; Erase(x); V.insert(V.begin(), p); puts("success."); &#125;&#125;void Prior()&#123; if(V.empty()) puts("empty."); else &#123; mx = -1; for(int i = 0; i &lt; V.size(); ++i) &#123; if(V[i].first &gt; mx) &#123; mx = V[i].first; pos = i; &#125; &#125; Rotate(pos + 1); &#125;&#125;void Choose()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else Rotate(pos + 1);&#125;void Top()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else &#123; val = x; puts("success."); &#125;&#125;void Untop()&#123; if(val) &#123; val = 0; puts("success."); &#125; else puts("no such person.");&#125;void active()&#123; if(val) &#123; pos = Find(val); if(V[pos].second) &#123; printf("Bye %d: %lld\n", V[pos].first, V[pos].second); Erase(pos); &#125; &#125; for(int i = 0; i &lt; V.size(); ++i) if(V[i].second) printf("Bye %d: %lld\n", V[i].first, V[i].second);&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; val = 0; V.clear(); scanf("%d", &amp;n); for(int cas = 1; cas &lt;= n; ++cas) &#123; scanf("%s", op); printf("Operation #%d: ", cas); if(op[0] == 'A') Add(); else if(op[0] == 'R') scanf("%d", &amp;x), Rotate(x); else if(op[0] == 'P') Prior(); else if(op[0] == 'T') Top(); else if(op[0] == 'U') Untop(); else if(op[1] == 'l') Close(); else if(op[2] == 'a') Chat(); else Choose(); &#125; active(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>HDU</tag>
        <tag>vector</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5929 Basic Data Structure【模拟】【deque】]]></title>
    <url>%2Fhdu-5929%2F</url>
    <content type="text"><![CDATA[题目大意： 现有一个栈，请你对它做出如下操作： PUSH x：将元素x入栈。 POP：将栈顶元素出栈。 REVERSE：将栈内元素翻转。 QUERY：查询从栈顶元素开始到栈底元素的NAND和。 其中NAND的定义为： 0 nand 0 = 1 0 nand 1 = 1 1 nand 0 = 1 1 nand 1 = 0 解题思路：对于操作1和操作2直接模拟就好了，费时的部分是剩余的两个操作。 考虑到n的范围最大取值为200000，我们可以开个400000的数组，取中间部分为初始起点，当进行操作3的时候直接将头对另一边进行1、2操作就好了。 观察这个nand运算我们发现，只要和0进行运算的，答案都变成了1，利用这一点我们可以记录0出现的位置，就是出现了0就将它存起来。我们可以也像上面那样进行记录，出于好写我这里直接用的deque。这样，每当查询时我们直接看存起来的0的位置，如果没有0那就数1的个数；如果有的话就看从头开始最后一个出现的0之后有多少个1。这里有个细节要注意，就是当只有1个0的时候，要特别判断一下。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;deque&gt;using namespace std;const int N = 200010;char op[11];int t, n, x, rig, lef, a[N&lt;&lt;1];int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; deque&lt;int&gt; Q; rig = 200001; lef = rig - 1; bool flag = true; printf("Case #%d:\n", cas); scanf("%d", &amp;n); while(n--) &#123; scanf("%s", op); if(op[0] == 'P') &#123; if(op[1] == 'U') &#123; scanf("%d", &amp;x); if(flag) &#123; if(!x) Q.push_back(rig); a[rig++] = x; &#125; else &#123; if(!x) Q.push_front(lef); a[lef--] = x; &#125; &#125; else &#123; if(flag) &#123; --rig; if(!a[rig]) Q.pop_back(); &#125; else &#123; ++lef; if(!a[lef]) Q.pop_front(); &#125; &#125; &#125; if(op[0] == 'Q') &#123; if(lef + 1 == rig) puts("Invalid."); else if(Q.empty()) printf("%d\n", (rig - lef - 1) &amp; 1); else &#123; if(flag) &#123; printf("%d\n", ((Q.front() - lef - 1) +(rig - 1 != Q.front())) &amp; 1); &#125; else &#123; printf("%d\n", ((rig - Q.back() - 1) +(lef + 1 != Q.back())) &amp; 1); &#125; &#125; &#125; if(op[0] == 'R') &#123; flag = !flag; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>HDU</tag>
        <tag>CCPC</tag>
        <tag>deque</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 864D Make a Permutation! 【贪心】【模拟】]]></title>
    <url>%2Fcf-864d%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个数，每次可以花费1单位体力来将其中的任意一个数改变为任意一个数。现在他想要将这n个数经过若干次变换，使之包含1-n的所有数字。问他改变完成后花费的最小体力，并输出改变后的序列。如果存在多组解，输出这全排列中字典序最小的哪种方案。 解题思路：既然花费体力最小，那当然要优先考虑将出现过多次的数字替换为未出现的数字了。然后就是稍微困难点的部分了——字典序最小。我们考虑一下替换过程中可能会出现的情况可以发现，当一个数要被替换时，如果替换为的数小于这个数，那就取最靠前的数字来进行替换，否则就取靠后的来替换。（如11123 -&gt; 14523, 23334 -&gt; 21354）接下来的实现，先找一个数组记录这个序列，再找一个来记录每个数字出现的次数。因为最终替换为的是没有出现过的数字，所以还要记录下哪些数字没有出现过，这里可以用set也可以用priority_queue。最后遍历一遍原序列，开始进行替换（即出现次数大于一次的要被没出现过的替换掉）。因为还要比较大小关系，如果被替换的数&gt;要替换的数，直接替换就好了；否则标记下这个数，这里没有替换，以后再遇到不管怎样都要替换掉（再加个vis数组标记一下就好了）。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 200005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, tot;bool vis[MAX];int a[MAX], b[MAX];priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q;int main()&#123; scanf("%d",&amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d",&amp;a[i]); ++b[a[i]]; &#125; for(int i = 1; i &lt;= n; ++i) if(!b[i]) Q.push(i); for(int i = 1; i &lt;= n; ++i) &#123; if(Q.empty()) break; if(b[a[i]] &gt; 1) &#123; if(Q.top() &lt; a[i] || vis[a[i]]) &#123; ++tot; --b[a[i]]; a[i] = Q.top(); Q.pop(); &#125; else vis[a[i]] = true; &#125; &#125; printf("%d\n", tot); for(int i = 1; i &lt;= n; ++i) printf("%d ", a[i]); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 771A Bear and Friendship Condition 【并查集/DFS】]]></title>
    <url>%2Fcf-771a%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个点，m条边构成的一个无向图。问是否图中所有的边都满足：当a和b相连、b和c相连时，a和c也相连。 解题思路：当满足上述条件时就说明这k个点构成了一个无向完全图，这种图的充要条件是：边数 = 点数 * (点数 - 1) / 2。根据这个突破点用DFS搜或者并查集判都可以了。 Mycode(并查集):1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 150010;int f[N];long long t[N], e;void init()&#123; for(int i = 1; i &lt; N; ++i) f[i] = i;&#125;int Find(int v)&#123; if(f[v] != v) f[v] = Find(f[v]); return f[v];&#125;void Union(int u, int v)&#123; int t1 = Find(u); int t2 = Find(v); if(t1 != t2) f[t2] = t1;&#125;int main()&#123; init(); int n, m; scanf("%d%d",&amp;n,&amp;m); for(int i = 0; i &lt; m; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); Union(u, v); &#125; for(int i = 1; i &lt;= n; ++i) &#123; ++t[Find(i)]; &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(t[i]) e += t[i] * (t[i] - 1) / 2; &#125; puts(e == m ? "YES" : "NO"); return 0;&#125; Mycode(DFS):12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int M = 150010;bool vis[M];vector&lt;int&gt; G[M];int n, m, x, y, v, e;void DFS(int t, int &amp; v, int &amp; e)&#123; vis[t] = true; ++v; e += G[t].size(); for(int i = 0; i &lt; G[t].size(); ++i) if(!vis[G[t][i]]) DFS(G[t][i], v, e);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; scanf("%d%d",&amp;x,&amp;y); G[x].push_back(y); G[y].push_back(x); &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(!vis[i]) &#123; v = e = 0; DFS(i, v, e); if(e != 1ll * v * (v - 1)) &#123; puts("NO"); return 0; &#125; &#125; &#125; puts("YES"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>DFS</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5461 Largest Point 【思维】]]></title>
    <url>%2Fhdu-5461%2F</url>
    <content type="text"><![CDATA[题目大意：现在有n个点，给出a和b，从这n个点中选出不同的两个点x、y，使得$ax ^ 2 + by$最大。问最大值是多少。 解题思路：首先想到的是找出最大值和最小值来，分4种情况讨论： a &gt; 0 &amp;&amp; b &gt; 0 a &gt; 0 &amp;&amp; b &lt; 0 a &lt; 0 &amp;&amp; b &gt; 0 a &lt; 0 &amp;&amp; b &lt; 0 分成这样后发现需要找的还有次大值、次小值以及最接近0的那个值。然后当最大值或最小值和最接近0的值是同一个时还要再进行判断。到这里有点晕了。。 后来发现一种很巧妙的思路，就是用两个数组存一下$ax^2$$和$$bx$的值，然后将两者排序，直接取两者的最大值就行了。当两者的最大值用的是同一个x后再加个比较就行了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 5000010;int t, n, x;long long a, b, res;struct node&#123; int idx; long long val;&#125; A[N], B[N];bool cmp(node u, node v)&#123; return u.val &lt; v.val;&#125;int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d%lld%lld", &amp;n, &amp;a, &amp;b); for(int i= 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;x); A[i].val = a * x * x; B[i].val = b * x; A[i].idx = B[i].idx = i; &#125; sort(A + 1, A + 1 + n, cmp); sort(B + 1, B + 1 + n, cmp); if(A[n].idx == B[n].idx) res = max(A[n].val + B[n - 1].val, A[n - 1].val + B[n].val); else res = A[n].val + B[n].val; printf("Case #%d: %lld\n", cas, res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>ICPC</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 242E XOR on Segment 【线段树】【异或】]]></title>
    <url>%2Fcf-242e%2F</url>
    <content type="text"><![CDATA[题目大意：给出一个包含n个数的数组，先要对数组中的数进行m次操作，当输入的指令为1时，输出区间l~r的数的和；当输入的指令为2时，将区间l~r的数全部^x。 解题思路：区间更新，区间求和，线段树的典型应用。求和好解决，但是更新呢？如果单点更新肯定超时不用想。考虑异或的性质，是否可以将存的数分解为二进制的形式进行存储呢，答案是可以的。因为$a_i$最大不超过$ 2^{20} $，所以将sum改为大小为20的数组来存取二进制形式的每一位是能实现的。更新时还是延迟标记的思想，查询时再将这些数“合起来”就行了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 100010;int a[MAX];struct node&#123; int l, r; int sum[22], lazy;&#125; tree[MAX&lt;&lt;2];void pushup(int rt)&#123; for(int i = 0; i &lt;= 20; ++i) tree[rt].sum[i] = tree[rt&lt;&lt;1].sum[i] + tree[rt&lt;&lt;1|1].sum[i];&#125;void pushdown(int rt)&#123; int mid = tree[rt].r + tree[rt].l &gt;&gt; 1; for(int i = 0; i &lt;= 20; ++i) &#123; if(tree[rt].lazy &amp; (1 &lt;&lt; i)) &#123; tree[rt&lt;&lt;1].sum[i] = mid - tree[rt].l + 1 - tree[rt&lt;&lt;1].sum[i]; tree[rt&lt;&lt;1|1].sum[i] = tree[rt].r - mid - tree[rt&lt;&lt;1|1].sum[i]; &#125; &#125; tree[rt&lt;&lt;1].lazy ^= tree[rt].lazy; tree[rt&lt;&lt;1|1].lazy ^= tree[rt].lazy; tree[rt].lazy = 0;&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; tree[rt].lazy = 0; if(l == r) &#123; for(int i = 0; i &lt;= 20; ++i) tree[rt].sum[i] = (a[l] &amp; (1 &lt;&lt; i)) &gt; 0; return ; &#125; int mid = l + r &gt;&gt; 1; build(l, mid, rt&lt;&lt;1); build(mid+1, r, rt&lt;&lt;1|1); pushup(rt);&#125;void update(int l, int r, int val, int rt)&#123; if(tree[rt].l == l &amp;&amp; tree[rt].r == r) &#123; tree[rt].lazy ^= val; for(int i = 0; i &lt;= 20; ++i) &#123; //注意这里的更新值 if(val &amp; (1 &lt;&lt; i)) tree[rt].sum[i] = r - l + 1 - tree[rt].sum[i]; &#125; return ; &#125; if(tree[rt].lazy) pushdown(rt); int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(r &lt;= mid) update(l, r, val, rt&lt;&lt;1); else if(l &gt; mid) update(l, r, val, rt&lt;&lt;1|1); else &#123; update(l, mid, val, rt&lt;&lt;1); update(mid+1, r, val, rt&lt;&lt;1|1); &#125; pushup(rt);&#125;long long query(int l, int r, int rt)&#123; long long res = 0; if(tree[rt].l == l &amp;&amp; tree[rt].r == r) &#123; for(int i = 0; i &lt;= 20; ++i) res += (1ll &lt;&lt; i) * tree[rt].sum[i]; return res; &#125; if(tree[rt].lazy) pushdown(rt); int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(r &lt;= mid) res += query(l, r, rt&lt;&lt;1); else if(l &gt; mid) res += query(l, r, rt&lt;&lt;1|1); else res += query(l, mid, rt&lt;&lt;1) + query(mid+1, r, rt&lt;&lt;1|1); return res;&#125;int main()&#123; int n, m, l, r, val, Q; scanf("%d",&amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d",&amp;a[i]); build(1, n, 1); scanf("%d",&amp;m); while(m--) &#123; scanf("%d%d%d",&amp;Q,&amp;l,&amp;r); if(Q == 1) printf("%lld\n", query(l, r, 1)); else &#123; scanf("%d", &amp;val); update(l, r, val, 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>线段树</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 822C Hacker, pack your bags! 【贪心】【模拟】]]></title>
    <url>%2Fcf-822c%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个区间，每个区间有个值$c_i​$。现要你从中选出两个区间，使得它们不相交 &amp;&amp; 区间长度之和恰好为 x。无解时输出-1， 存在多个可行解时输出$c_i + c_j​$ 最小的和。 解题思路：第一感觉是排序后选定一个区间，然后二分找到满足值为$x - c_i$的那个区间，然后写炸了。后来补题时发现可以用个vector将区间的左端点和值存下来，下标就是区间长度，这样查的时候就变得很好查了。然后每个区间按照左端点从小到大排好序，因为区间长度固定，这样遍历时就可以遍历区间长度为i的区间，对于长度为$x - i$的，只遍历在长度为i的区间的左边的区间并同时记录最小值就可以了。详细看代码吧。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int N = 200010;const int oo = 2e9+7;int n, x, l, r, c, res, tem;vector&lt; pair&lt;int, int&gt; &gt; G[N];int main()&#123; scanf("%d%d", &amp;n, &amp;x); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d%d", &amp;l, &amp;r, &amp;c); G[r - l + 1].push_back(&#123;l, c&#125;); &#125; for(int i = 1; i &lt; x; ++i) sort(G[i].begin(), G[i].end()); res = oo; for(int cost = 1; cost &lt; x; ++cost) &#123; tem = oo; auto &amp;u = G[cost], &amp;v = G[x - cost]; for(int i = 0, j = 0; i &lt; v.size(); ++i) &#123; while(j &lt; u.size() &amp;&amp; u[j].first + cost - 1 &lt; v[i].first) &#123; tem = min(tem, u[j].second); ++j; &#125; if(tem != oo) res = min(res, tem + v[i].second); &#125; &#125; printf("%d\n", res == oo ? -1 : res); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6438 Buy and Resell 【思维】【贪心】]]></title>
    <url>%2Fhdu-6348%2F</url>
    <content type="text"><![CDATA[题目大意：现在有n个城市，你依次经过城市$1$ ~ $n$。每个城市都有一个共同的物品，但它们的价格可能会不一样。你经过一个城市时可以选择将这个物品以 $a_i$ 的价格买下来，或者是以 $a_i$的价格卖出去(卖出去的前提是你已经有至少一个此物品)，每个城市最多进行一次买/卖操作。初始时你又无限多的钱，问在走完这n个城市后你的钱最多能变成多少，并输出此时交易的次数。当能通过多种买/卖的方法达到最多钱的时候，输出交易次数最少的那一次。 解题思路：我们可以用一个可以自动排好序的容器存储当前可以买到哪些货，排序是按照最便宜的在前面这样，每次到了可以卖的时候就先卖掉，然后到一个可以赚更多钱的城市的时候，再收回，重新卖一遍。每个输入的x存两次是一次代表着买入一次代表着卖出。当买入时说明一定在最后卖出了，这时买卖次数++。 Mycode：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;long long res;int t, n, cnt, x;pair&lt;int, int&gt; pp;multiset&lt; pair&lt;int, int&gt; &gt; Q;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; Q.clear(); res = cnt = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;x); Q.insert(make_pair(x, 1)); //sell Q.insert(make_pair(x, 2)); //buy pp = *Q.begin(); res += x - pp.first; if(!(pp.second &amp; 1)) ++cnt; Q.erase(Q.begin()); &#125; printf("%lld %d\n", res, cnt &lt;&lt; 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>HDU</tag>
        <tag>思维</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5832 A water problem 【大数取模】]]></title>
    <url>%2Fhdu-5832%2F</url>
    <content type="text"><![CDATA[题目大意：告诉你个长度为$10000000$的数字，问这个数字是否既是73的倍数又是137的倍数。 解题思路：大数取模。c++的大数取模是根据秦九韶公式来的， 举个例子来说$123 = ((1 \times 10 + 2) \times 10) + 3$， 而$(a \times b) \% M = a \% M \times b \% M$， 然后我们就能得到$123 \% M = ((1 \% M \times 10 + 2) \% M \times 10) \% M + 3 \% M$。 Mycode：1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 10000010;const int M1 = 73;const int M2 = 137;char s[N];int main()&#123; for(int cas = 1; ~scanf("%s", s); ++cas) &#123; int len = strlen(s); int sum1 = 0, sum2 = 0; for(int i = 0; i &lt; len; ++i) &#123; sum1 = (sum1 * 10 + s[i] - '0') % M1; sum2 = (sum2 * 10 + s[i] - '0') % M2; &#125; printf("Case #%d: %s\n", cas, (!sum1 &amp;&amp; !sum2) ? "YES" : "NO"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>大数</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6150 Vertex Cover 【构造】]]></title>
    <url>%2Fhdu-6150%2F</url>
    <content type="text"><![CDATA[题目大意：最小顶点覆盖问题是一个传统的NP完全问题，就是多项式复杂程度的非确定性问题。现在告诉你一个此问题的近似解法，算法的主要思想是遍历每个顶点，贪心的选取当前未被选取的点中的与另外的点相连数目最多的顶点，相连数目相同时选序号靠后的那个点。伪代码实现如下： 1234567891011121314151617181920212223for (int i = 1; i &lt;= n; ++i) &#123; use[i] = false; deg[i] = degree of the vertex i;&#125;int ans = 0;while (true) &#123; int mx = -1, u; for (int i = 1; i &lt;= n; ++i) &#123; if (use[i]) continue; if (deg[i] &gt;= mx) &#123; mx = deg[i]; u = i; &#125; &#125; if (mx &lt;= 0) break; ++ans; use[u] = true; for (each vertex v adjacent to u) --deg[v];&#125;return ans; 现在要你找出一组数据来，使得按照他的方法跑出来的结果是最优解的3倍以上。 解题思路：题目中给出的思路显然是不对的，hack掉这个程序的关键就是当数目相同时他去掉的是靠后的那个点。 我们可以构造两组点，使得左边的那一组为正确答案，右边的为按照他的算法得出的答案。正确答案为左边，假设有n个点，先在右边构造n个点，和左边的一一相连；然后再在右边构造$\lfloor \frac{n}{2} \rfloor$个点，使得这些点依次与{1、2}、{3、4}……这些点相连，最后不足以连接的就不连；然后再在右边构造$\lfloor \frac{n}{3} \rfloor$个点，进行连接；……；直至构造了1个与n个点相连的点。 上面的构造方法就是根据前面的漏洞制定的，最后确定一下n为多少就好了。因为要求$3 * n \leq \sum_{i=1}^n{\lfloor \frac{n}{i} \rfloor}$, 所以n = 15就够了。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int L, R, cnt;struct node&#123; int x, y;&#125;a[666];int main()&#123; L = R = 15; //num就是构造的下一个点与左边集合的点相连数目 for(int num = 1; num &lt;= L; ++num) &#123; //st为与左边相连的顶点的起点 for(int st = 1; st &lt;= L; st += num) &#123; //要连的数目超过了左边顶点的数目 if(st + num - 1 &gt; L) break; ++R; //开始将新构造的点与[st,st+num)间的点相连 for(int t = st; t &lt; st + num; ++t) &#123; a[cnt].x = t; a[cnt].y = R; ++cnt; &#125; &#125; &#125; printf("%d %d\n", R, cnt); for(int i = 0; i &lt; cnt; ++i) printf("%d %d\n", a[i].x, a[i].y); printf("%d\n", L); for(int i = 1; i &lt;= L; ++i) printf("%d\n", i); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>CCPC</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4825 Xor Sum 【01字典树】]]></title>
    <url>%2Fhdu-4825%2F</url>
    <content type="text"><![CDATA[题目大意：从一个N个数集合中找出一个数K，使得这个数与给出的S异或结果最大。 解题思路：涉及到异或问题，将给的数都用二进制形式表示出来。为了使异或结果最大，即从高位开始选，K的这一位为1时选S的这一位为0的，为0时刚好相反。然后用字典树进行存储分解后的二进制表示就OK了。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX =100010;int t, n, m;long long x;struct Trie&#123; int nex[MAX * 32][2], tot; long long pre[MAX * 32]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); &#125; void add() &#123; int now = 1; for(int i = 32; i &gt;= 0; --i) &#123; if(nex[now][(x &gt;&gt; i) &amp; 1] == 0) nex[now][(x &gt;&gt; i) &amp; 1] = ++tot; now = nex[now][(x &gt;&gt; i) &amp; 1]; &#125; pre[now] = x; &#125; long long query() &#123; int now = 1; for(int i = 32; i &gt;= 0; --i) &#123; if(nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]) now = nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]; else now = nex[now][(x &gt;&gt; i) &amp; 1]; &#125; return pre[now]; &#125;&#125; trie;int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; trie.init(); printf("Case #%d:\n", cas); scanf("%d%d",&amp;n,&amp;m); while(n--) &#123; scanf("%lld", &amp;x); trie.add(); &#125; while(m--) &#123; scanf("%lld", &amp;x); printf("%lld\n", trie.query()); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 979D Kuro and GCD and XOR and SUM 【01字典树】]]></title>
    <url>%2Fcf-979d%2F</url>
    <content type="text"><![CDATA[题目大意：现在要对一个数组执行q次指令，指令有两种类型，分别为”1 x”和”2 x k s”，前一种是向数组中加一个数x，后一种是查询数组中是否存在这样一个v，使得v满足$k \mid \gcd(x, v) , x + v &lt; s$, 若不存在，输出-1，否则输出满足条件的v中值最大的那个。 解题思路：首先观察条件，很明显的当$x \mod k \neq 0$时，答案是-1， 当$s - x \leq 0$时，答案是-1。对于其余情况，因为插入的数在1 ~ $10^5$间，而且用到这个数只要它出现过就可以，与它出现的次数无关。所以我们可以用桶排序的思想，用一个数组标记这个数字是否出现过。对于给出的查询，我们只需从k开始找，到$s - x$为止，每次加k，看枚举的数是否出现过，同时更新记录最大值就OK了。然而这样会T。因为当k = 1时，这样做就和暴力无差了。那么我们怎么办呢？k = 1，就是从1 ~ $s - x$中找出一个数使得这个数与x的异或结果最大。没错，就是区间异或最大值！字典树！前两篇讲的是没有最大值限制的查询，这里有了限制也很简单，我们把之前用的这一位是0|1的pre数组改为到此结点时最小值是多少，然后从根结点开始往下搜索，最后返回叶子结点存的值就好了。为什么这样是对的？因为我们往下找的时候是根据异或结果找的，找到叶子结点时当然就是最大的了。对了，往下找的时候要多加一句判断——是否下面的最小值不大于我们的限制。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;int t, x, k, s, maxx, op, a[MAX];struct Trie&#123; int nex[MAX * 17][2], o[MAX * 17], tot; void init() &#123; tot = 1; memset(o, 0x3f, sizeof(o)); memset(nex, 0, sizeof(nex)); &#125; void add() &#123; int now = 1; o[now] = min(o[now], x); for(int i = 17; i &gt;= 0; --i) &#123; if(nex[now][(x &gt;&gt; i) &amp; 1] == 0) nex[now][(x &gt;&gt; i) &amp; 1] = ++tot; now = nex[now][(x &gt;&gt; i) &amp; 1]; o[now] = min(o[now], x); &#125; &#125; int query() &#123; if(o[1] &gt; maxx) return -1; int now = 1; for(int i = 17; i &gt;= 0; --i) &#123; if(nex[now][((x &gt;&gt; i) &amp; 1) ^ 1] &amp;&amp; o[nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]] &lt;= maxx) now = nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]; else now = nex[now][(x &gt;&gt; i) &amp; 1]; &#125; return o[now]; &#125;&#125;trie;int main()&#123; trie.init(); scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;op); if(op == 1) &#123; scanf("%d", &amp;x); trie.add(); a[x] = true; &#125; else &#123; scanf("%d%d%d",&amp;x,&amp;k,&amp;s); maxx = s - x; if(x % k) puts("-1"); else if(k == 1) printf("%d\n", trie.query()); else &#123; int maxxor = -1, res = -1; for(int i = k; i &lt;= maxx; i += k) &#123; if(a[i] &amp;&amp; (i ^ x) &gt; maxxor) &#123; res = i; maxxor = i ^ x; &#125; &#125; printf("%d\n", res); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 706D Vasiliy's Multiset 【01字典树】]]></title>
    <url>%2Fcf-706d%2F</url>
    <content type="text"><![CDATA[题目大意：现在要对一个multiset执行q次指令，请你根据指令作出相应操作。共有3种指令类型，分别为”+ x”，”- x”和”? x”，他们的要求依次为：向集合中添加一个元素x、删除集合中的一个元素x和查询集合中现已存在的数与x的异或结果最大值。注意：multiset是一个允许相同元素存在于集合中的一个容器。初始时集合中有且仅有0这个元素。 解题思路：全题中最重要的指令就是”? x”这个指令了。异或结果最大，就是分解为二进制后，从高位往低位看，这一位为0时尽量取这一位为1的与他进行异或，为1时同理。到这里就能看出来是很明显的字典树啦。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX =200010;char op;int q, x;struct Trie&#123; int nex[MAX * 30][2], pre[MAX * 30], tot; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); &#125; void add() &#123; int now = 1; for(int i = 30; i &gt;= 0; --i) &#123; if(nex[now][(x &gt;&gt; i) &amp; 1] == 0) nex[now][(x &gt;&gt; i) &amp; 1] = ++tot; now = nex[now][(x &gt;&gt; i) &amp; 1]; ++pre[now]; &#125; &#125; void sub() &#123; int now = 1; for(int i = 30; i &gt;= 0; --i) &#123; now = nex[now][(x &gt;&gt; i) &amp; 1]; --pre[now]; &#125; &#125; int query() &#123; int now = 1, res = 0; for(int i = 30; i &gt;= 0; --i) &#123; //存在此结点 &amp;&amp; 此结点有值 if(nex[now][((x &gt;&gt; i) &amp; 1) ^ 1] &amp;&amp; pre[nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]]) res += (1 &lt;&lt; i), now = nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]; else now = nex[now][(x &gt;&gt; i) &amp; 1]; &#125; return res; &#125;&#125; trie;int main()&#123; trie.init(); trie.add(); scanf("%d", &amp;q); while(q--) &#123; getchar(); scanf("%c%d", &amp;op, &amp;x); if(op == '+') trie.add(); else if(op == '-') trie.sub(); else printf("%d\n", trie.query()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 1011F Mars rover 【模拟】【DFS】]]></title>
    <url>%2Fcf-1011f%2F</url>
    <content type="text"><![CDATA[题目大意：给出一颗根结点为1的树，每个结点最多有两个叶子结点，每个结点的值非0即1。现在给出部分结点的值(0或1)，剩余结点告诉你它们值和子结点值的关系(AND、OR、XOR、NOT)。现在要你求的内容是按照输入顺序依次改变初始时给出的结点的值(0变为1，1变为0)，问每次改变后的根结点的值是多少。 解题思路：首先根据给出的关系我们可以求出每个结点初始状态的值，后面怎么做呢？我们可以挨个枚举每个点变化后的情况如果枚举变化情况的话TLE无疑。观察最后的值发现，答案非0即1，每个结点的值都是这样。那么我们可以不用模拟整个过程，而是记录到某个结点时它的值是否改变了，举个例子的话就是当这个结点是由前面两个结点AND得来的，正好有个结点是0，此时1所在结点的那个分支不论怎么变到这个位置出结果都是0。根据这个思想，我们再对这棵树进行一次DFS做下标记就可以了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int MAX = 1e6+5;int n, m;char s[4];struct node&#123; char op; vector&lt;int&gt; in; bool val, flag;&#125;G[MAX];bool GetVal(int rt)&#123; char c = G[rt].op; if(c == 'A') G[rt].val = GetVal(G[rt].in[0]) &amp; GetVal(G[rt].in[1]); else if(c == 'X') G[rt].val = GetVal(G[rt].in[0]) ^ GetVal(G[rt].in[1]); else if(c == 'O') G[rt].val = GetVal(G[rt].in[0]) | GetVal(G[rt].in[1]); else if(c == 'N') G[rt].val = !GetVal(G[rt].in[0]); return G[rt].val;&#125;void GetFlag(int rt)&#123; if(G[rt].flag == false) for(int i = 0; i &lt; G[rt].in.size(); ++i) G[G[rt].in[i]].flag = false; else &#123; char c = G[rt].op; if(c == 'A') &#123; if(G[rt].val == (!G[G[rt].in[0]].val &amp; G[G[rt].in[1]].val)) G[G[rt].in[0]].flag = false; else G[G[rt].in[0]].flag = true; if(G[rt].val == (!G[G[rt].in[1]].val &amp; G[G[rt].in[0]].val)) G[G[rt].in[1]].flag = false; else G[G[rt].in[1]].flag = true; &#125; else if(c == 'O') &#123; if(G[rt].val == (!G[G[rt].in[0]].val | G[G[rt].in[1]].val)) G[G[rt].in[0]].flag = false; else G[G[rt].in[0]].flag = true; if(G[rt].val == (!G[G[rt].in[1]].val | G[G[rt].in[0]].val)) G[G[rt].in[1]].flag = false; else G[G[rt].in[1]].flag = true; &#125; else if(c == 'X') &#123; if(G[rt].val == (!G[G[rt].in[0]].val ^ G[G[rt].in[1]].val)) G[G[rt].in[0]].flag = false; else G[G[rt].in[0]].flag = true; if(G[rt].val == (!G[G[rt].in[1]].val ^ G[G[rt].in[0]].val)) G[G[rt].in[1]].flag = false; else G[G[rt].in[1]].flag = true; &#125; else if(c == 'N') &#123; if(G[rt].val == (!!G[G[rt].in[0]].val)) G[G[rt].in[0]].flag = false; else G[G[rt].in[0]].flag = true; &#125; &#125; for(int i = 0; i &lt; G[rt].in.size(); ++i) GetFlag(G[rt].in[i]);&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", s); G[i].op = s[0]; scanf("%d", &amp;m); if(s[0] == 'I') G[i].val = m; else &#123; G[i].in.push_back(m); if(s[0] != 'N') &#123; scanf("%d", &amp;m); G[i].in.push_back(m); &#125; &#125; &#125; GetVal(1); /*for(int i = 1; i &lt;= n; ++i) if(G[i].val) cout &lt;&lt; i &lt;&lt; " "; cout &lt;&lt; endl;*/ G[1].flag = true; GetFlag(1); /*for(int i = 1; i &lt;= n; ++i) if(G[i].flag) cout &lt;&lt; i &lt;&lt; " "; cout &lt;&lt; endl;*/ for(int i = 1; i &lt;= n; ++i) if(G[i].op == 'I') printf("%d", G[1].val ^ G[i].flag); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>模拟</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6341 Problem J. Let Sudoku Rotate 【暴力剪枝】]]></title>
    <url>%2Fhdu-6341%2F</url>
    <content type="text"><![CDATA[题目大意：现在有个已经完成的$16 \times 16$的数独(即满足数独的要求)，它的某些部分被逆时针旋转过了。已知每次旋转的角度为90°，问最少经过多少次旋转能将它转回原样。 解题思路：因为数独要求很严格，所以我们可以直接进行搜索 + 剪枝。 PS：给的标程是真的好看，特别是旋转的那一部分，既简洁又优美。Orz。 ACcode:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char s[16];int res, a[16][16], r[16][16], c[16][16], b[4][4];int trans(char ch)&#123; if(isdigit(ch)) return ch - '0'; return ch - 'A' + 10;&#125;void add(int ip, int jp, int val)&#123; for(int i = ip * 4; i &lt; (ip + 1) * 4; ++i) &#123; for(int j = jp * 4; j &lt; (jp + 1) * 4; ++j) &#123; r[i][a[i][j]] += val; c[j][a[i][j]] += val; &#125; &#125;&#125;//进行旋转操作bool rot(int ip, int jp)&#123; for(int i = ip * 4; i &lt; (ip + 1) * 4; ++i) &#123; for(int j = jp * 4; j &lt; (jp + 1) * 4; ++j) &#123; //先把要旋转的部分拿出来 --r[i][a[i][j]]; --c[j][a[i][j]]; b[j - jp * 4][(ip + 1) * 4 - i - 1] = a[i][j]; &#125; &#125; bool flag = true; for(int i = ip * 4; i &lt; (ip + 1) * 4; ++i) &#123; for(int j = jp * 4; j &lt; (jp + 1) * 4; ++j) &#123; //将拿出来的部分进行归位 a[i][j] = b[i - ip * 4][j - jp * 4]; //出现了不符合要求的情况 if((++r[i][a[i][j]] &gt; 1) || (++c[j][a[i][j]] &gt; 1)) flag = false; &#125; &#125; return flag;&#125;void dfs(int ip, int jp, int now)&#123; if(ip == 4 &amp;&amp; jp == 0) &#123; res = min(res, now); return ; &#125; //状态改变 add(ip, jp, 1); if(now &gt;= res) return ; for(int i = 1; i &lt;= 4; ++i) &#123; //旋转i次 if(rot(ip, jp)) dfs(jp == 3 ? ip + 1 : ip, jp == 3 ? 0 : jp + 1, now + (i &amp; 3)); &#125; //状态恢复 add(ip, jp, -1);&#125;int main()&#123; int t; scanf("%d", &amp;t); while(t--) &#123; for(int i = 0; i &lt; 16; ++i) &#123; scanf("%s", s); for(int j = 0; j &lt; 16; ++j) &#123; a[i][j] = trans(s[j]); &#125; &#125; memset(r, 0, sizeof(r)); memset(c, 0, sizeof(c)); res = 16 * 4; dfs(0, 0, 0); printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>多校联合</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6319 Problem A. Ascending Rating 【单调队列】]]></title>
    <url>%2Fhdu-6319%2F</url>
    <content type="text"><![CDATA[题目大意：给定一个序列 a[1..n]，对于每个长度为 m 的连续子区间，求出区间 a 的最大值以及从左往右扫描该区间时 a 的最大值的变化次数。$1 ≤ m ≤ n ≤ 10^7$。 解题思路：求区间最大值，我首先想到的是很经典的滑动窗口求区间最大值问题。对于这个问题，因为还要求最大值的变化次数，所以直接利用滑窗的话变化次数不好求。于是就有题解上说的考虑按照 r 从 n 到 m 的顺序倒着求出每个区间的答案了。此时所维护的值是从大到小的顺序(因为倒着求的嘛)，而对应的变化次数就是队列中元素的个数。考虑到直接上deque挺耗时的，所以直接通过数组模拟就OK了。 【注意】完善a数组时要注意精度问题。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e7+5;int T, n, m, k, P, Q, R, M, t, a[MAX], q[MAX], head, tail;long long A, B;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; A = B = 0; scanf("%d%d%d%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;P,&amp;Q,&amp;R,&amp;M); for(int i = 1; i &lt;= k; ++i) scanf("%d",&amp;a[i]); for(int i = k + 1; i &lt;= n; ++i) a[i] = (1ll * P * a[i-1] + 1ll * Q * i + R) % M; head = 1, tail = 0; for(int i = n; i &gt; 0; --i) &#123; while(tail &gt;= head &amp;&amp; a[q[tail]] &lt;= a[i]) --tail; q[++tail] = i; if(i + m - 1 &lt;= n) &#123; while(q[head] - i &gt;= m) ++head; A += a[q[head]] ^ i; B += tail - head + 1 ^ i; &#125; &#125; printf("%lld %lld\n", A, B); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>多校联合</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 965E Short Code 【Trie】【启发式合并】]]></title>
    <url>%2Fcf-965e%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个不同的仅由小写字母构成的变量名，要求你对其取前缀将其简化，使简化后的变量名各不相同并且最终的总长度最小。 解题思路：对单词建立字典树，记录每个单词的长度。然后从树的叶子结点开始向上进行启发式合并，这个过程用multiset进行维护。启发式合并在这道题中的应用，个人的理解为到达这个结点时，发现这个结点还是空的时候，即可以将一个变量名简化为当前结点代表的变量名的时候，我们要选择它下面的所有变量名中名字最长的那个进行简化，为了便于维护，那就从下往上不断记录到此位置时可以简化的单词长度为多少。在代码中的体现就是DFS中的部分。35-37行为向上传递值，29、39-43行为简化操作。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int MAX = 1e5 + 5;char str[MAX];multiset&lt;int&gt; st[MAX];int n, tot, now, nex[MAX][26], dep[MAX], res;void add()&#123; now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) &#123; nex[now][str[i]-'a'] = ++tot; dep[tot] = dep[now] + 1; &#125; now = nex[now][str[i]-'a']; &#125; st[now].insert(dep[now]);&#125;void DFS(int u = 1)&#123; bool emp = (u &gt; 1 &amp;&amp; st[u].empty()); for(int i = 0; i &lt; 26; ++i) &#123; int v = nex[u][i]; if(!v) continue; DFS(v); for(auto t : st[v]) st[u].insert(t); st[v].clear(); &#125; if(emp) &#123; st[u].erase(--st[u].end()); st[u].insert(dep[u]); &#125;&#125;int main()&#123; tot = 1; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", str); add(); &#125; DFS(); for(auto t : st[1]) res += t; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>Trie</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 967E Big Secret 【异或】【贪心】]]></title>
    <url>%2Fcf-967e%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个数，将它们重新排序，使得排序后的序列满足前n个数的异或值依次递增。 解题思路：考虑这样一个问题，要使$p \bigoplus q &gt; p$并且此时花费的p最小，用x代表p的二进制表示中从最低位往最高位处第一个不为0的位置，那么最小的q即为二进制表示中的x位是1且其余位都是0。对于这个问题，我们以二进制表示中的最高位为区分点，先把所有数用一个容器存起来。取数时先看当前的数第一个为0的低位是否有对应的q满足要求，有的话就取，没有就继续往下找，这样依次取直到取完所有数或者满足不了要求为止。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int MAX = 1e5+5;int n;bool flag;long long t, res[MAX];vector&lt;long long&gt; G[64];int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%I64d", &amp;t); for(int i = 60; i &gt;= 0; --i) &#123; if((t &gt;&gt; i) &amp; 1) &#123; G[i].push_back(t); break; &#125; &#125; &#125; t = 0; for(int idx = 0; idx &lt; n; ++idx) &#123; flag = false; for(int i = 0; i &lt;= 60; ++i) &#123; if((t &amp; (1ll &lt;&lt; i)) == 0 &amp;&amp; G[i].size()) &#123; res[idx] = G[i].back(); t = t ^ G[i].back(); G[i].pop_back(); flag = true; break; &#125; &#125; if(flag == false) break; &#125; if(flag) &#123; puts("Yes"); for(int i = 0; i &lt; n; ++i) printf("%I64d ", res[i]); &#125; else puts("No"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>异或</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 964D Destruction of a Tree 【贪心】]]></title>
    <url>%2Fcf-964d%2F</url>
    <content type="text"><![CDATA[题目大意：给出一个由n个点和n - 1条边构成的树，每次可以摧毁掉一个度数为偶数的点，问是否存在一个摧毁的顺序使得所有点都能被摧毁掉。 解题思路：先说结论：当n为偶数时，总会存在度数为奇数的点无法被摧毁掉(很明显的)。当n为奇数时，答案总是存在的(证明略)。对于答案存在的情况，我们每次都摧毁靠近叶子结点的度数为偶数的结点，因为如果这个点不摧毁，而先摧毁了其父结点，那它的度数就变为奇数，并且叶子结点度数均为1，它们就无法消除了。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int MAX = 200010;bool vis[MAX];stack&lt;int&gt; sta;vector&lt;int&gt; G[MAX], res;int n, t, tem, deg[MAX], f[MAX];void DFS(int x, int p)&#123; sta.push(x); f[x] = p; for(int i = 0; i &lt; G[x].size(); ++i) &#123; if(G[x][i] == p) continue; DFS(G[x][i], x); &#125;&#125;void DFS2(int x)&#123; res.push_back(x); vis[x] = true; for(int i = 0; i &lt; G[x].size(); ++i) &#123; int nex = G[x][i]; --deg[nex]; if(nex == f[x]) continue; if(vis[nex]) continue; if(deg[nex] % 2 == 0) DFS2(nex); &#125;&#125;int main()&#123; scanf("%d", &amp;n); if(n &amp; 1) &#123; puts("YES"); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;t); if(!t) continue; ++deg[t], ++deg[i]; G[t].push_back(i); G[i].push_back(t); &#125; DFS(1, 0); while(!sta.empty()) &#123; tem = sta.top(); sta.pop(); if(deg[tem] % 2 == 0) DFS2(tem); &#125; for(int i = 0; i &lt; res.size(); ++i) printf("%d\n", res[i]); &#125; else puts("NO"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【专题训练】 —字典树【11/16】]]></title>
    <url>%2Ftrie-contest%2F</url>
    <content type="text"><![CDATA[专题链接：https://vjudge.net/contest/50484 A - Shortest Prefixes POJ - 2001 【Easy】题目大意： 将给出的所有单词通过取其前缀来代替此单词进行“简化”，使“简化”后的单词能唯一标识这个单词，在这前提下找到最简的化简结果。例如，给出car、cart、carton“简化”后的单词分别为car、cart、carto。 解题思路： 建立字典树，对于每个要“化简”的单词，我们找到那个到此位置处前缀只有这一种情况的结点，然后输出这条路径上的字符就是要找的最简结果。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 1010;const int MAXL = 1010 * 20;string tem;char s[MAXN][22];struct Tire&#123; int nex[MAXL][26], tot, pre[MAXL]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a']; pre[now]++; &#125; &#125; /*int Find(const char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) return 0; now = nex[now][str[i]-'a']; &#125; return now; &#125;*/ void print(char *str) &#123; printf("%s ", str); int now = 1; for(int i = 0; str[i]; ++i) &#123; now = nex[now][str[i]-'a']; printf("%c", str[i]); if(pre[now] == 1) break; &#125; puts(""); &#125;&#125;tire;int main()&#123; tire.init(); int n; for(n = 1; ~scanf("%s", s[n]); ++n) &#123; tire.add(s[n]); &#125; for(int i = 1; i &lt; n; ++i) &#123; tire.print(s[i]); &#125; return 0;&#125; B - T9 POJ - 1451题目大意： 解题思路： Mycode：12 C - Wild Words POJ - 1816题目大意： 解题思路： Mycode：12 D - Phone List POJ - 3630 【Easy】题目大意： 判断是否有前缀。 解题思路： 建树直接判。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5 + 5;struct Tire&#123; int tot, nex[MAX][11], pre[MAX], cnt[MAX]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre));// memset(cnt, 0, sizeof(cnt)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; &#125;// cnt[now]++; &#125; int Find(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; int t, n; char s[MAX][11]; scanf("%d",&amp;t); while(t--) &#123; tire.init(); scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", s[i]); tire.add(s[i]); &#125; bool flag = true; for(int i = 0; i &lt; n &amp;&amp; flag; ++i) &#123; if(tire.Find(s[i]) &gt; 1) flag = false; &#125; puts(flag ? "YES" : "NO"); &#125; return 0;&#125; E - Colored Sticks POJ - 2513 【Medium】题目大意： 给出一些列颜色，问是否可以将它们前后相连连成一条线。相连的条件是颜色相同。 解题思路： 这就是典型的欧拉回路问题，简单版的可以看 UVa 10129，这里n达到了250000，直接用map是不行了，于是用trie树代替map记录出现的颜色。剩下的就是求欧拉回路啦，这里还是用的并查集判的底图是否联通。 PS：这题里还要考虑一种特殊情况，就是什么输入也没有，此时也是Possible。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXL = 5000010;const int MAXN = 500010;int f[MAXN], deg[MAXN];int nex[MAXL][26], tot;void init()&#123; for(int i = 1; i &lt; MAXN; ++i) f[i] = i;&#125;int Find(int x)&#123; if(x != f[x]) f[x] = Find(f[x]); return f[x];&#125;void Union(int u, int v)&#123; int t1 = Find(u); int t2 = Find(v); if(t1 != t2) f[t1] = t2;&#125;int add(char *str)&#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a']; &#125; return now;&#125;int main()&#123; init(); char s1[11], s2[11]; while(~scanf("%s%s", s1, s2)) &#123; int t1 = add(s1); int t2 = add(s2); ++deg[t1], ++deg[t2]; Union(t1, t2); &#125; int odd = 0, root = 0; for(int i = 1; i &lt;= tot; ++i) &#123; if(deg[i] &amp; 1) ++odd; if(deg[i] &amp;&amp; f[i] == i) ++root; if(odd &gt; 2 || root &gt; 1) break; &#125; if(((odd == 0 || odd == 2) &amp;&amp; root == 1) || (root == 0 &amp;&amp; odd == 0)) puts("Possible"); else puts("Impossible"); return 0;&#125; F - Anagram Groups POJ - 2408题目大意： 解题思路： Mycode：12 G - 统计难题 HDU - 1251 【Easy】题目大意： 给出一系列单词，空行分割后查询接下来给出的单词是前面的多少单词的前缀。 解题思路： 建树直接做。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 4e5+5;struct Tire&#123; int nex[MAX][26], pre[MAX], cnt[MAX], tot; void init() &#123; memset(nex, 0, sizeof(nex)); pre[tot = 1] = 0; //tot = 1, pre[1] = 0; &#125; void add(char* str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a']; pre[now]++; /*for(int j = 0; j &lt;= i; ++j) cout &lt;&lt; str[j]; cout &lt;&lt; " " &lt;&lt; pre[now] &lt;&lt; endl;*/ &#125; cnt[now]++; &#125; int Find(char* str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) return 0; now = nex[now][str[i]-'a']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; char s[11]; tire.init(); while(gets(s)) &#123; if(strlen(s) == 0) break; tire.add(s); &#125; while(gets(s)) &#123; printf("%d\n",tire.Find(s)); &#125; return 0;&#125; H - What Are You Talking About HDU - 1075 【Easy】题目大意： 给出单词代表另一个单词，然后给出一段话输出它代表的话。 解题思路： 记录然后替换就好了，然后就是比较麻烦的模拟了。这里的trie树完全可以用map代替。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int MAX = 1000005;struct Tire&#123; int tot, nex[MAX][26], pre[MAX], cnt[MAX]; char res[MAX][11]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex));// memset(pre, 0, sizeof(pre)); memset(cnt, 0, sizeof(cnt)); memset(res, 0, sizeof(res)); &#125; void add(char *str, char *q) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a'];// pre[now]++; &#125; cnt[now]++; strcpy(res[now], q); &#125; int Find(const char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) return 0; now = nex[now][str[i]-'a']; &#125;// return pre[now]; return now; &#125;&#125; tire;int main()&#123; string trs; char op[3333]; char s[11], t[11]; tire.init(); scanf("%s", s); while(scanf("%s", s) &amp;&amp; s[0] != 'E') &#123; scanf("%s", t); tire.add(t, s); &#125; getchar();gets(s); while(gets(op) &amp;&amp; op[0] != 'E') &#123; int len = strlen(op); for(int i = 0; i &lt; len;) &#123; if(islower(op[i])) &#123; trs = ""; int j; for(j = 0; isalpha(op[i]); ++j, ++i) &#123; trs+=op[i]; &#125; int tt = tire.Find(trs.c_str()); if(tire.cnt[tt]) printf("%s", tire.res[tt]); else cout &lt;&lt; trs; &#125; else &#123; printf("%c", op[i++]); &#125; &#125; puts(""); &#125; return 0;&#125; I - Hat’s Words HDU - 1247 【Easy】题目大意： 给出若干单词，找出可以由其中的两个单词连接后凑成新的单词的单词(就是一个单词可以由已经存在的俩个单词凑成)。这里不用想复杂了，假设有a和aa两个单词，aa也是满足条件的。 解题思路： 建树后，暴力枚举每个单词是否可以被凑成就行了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 50010;int idx;string t1, t2;char s[MAX][1010];struct Tire&#123; int nex[MAX][26], pre[MAX], cnt[MAX], tot; void init() &#123; memset(nex, 0, sizeof(nex));// memset(pre, 0, sizeof(pre)); memset(cnt, 0, sizeof(cnt)); tot = 1; &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a']; &#125; cnt[now]++; &#125; int Find(const char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) return 0; now = nex[now][str[i]-'a']; &#125; return cnt[now]; &#125;&#125;tire;bool judge(const string &amp;p)&#123; if(p.size() == 1) return false; int k1, k2; for(int i = 1; i &lt; p.size(); ++i) &#123; t1 = p.substr(0,i); t2 = p.substr(i, p.size()); k1 = tire.Find(t1.c_str()); k2 = tire.Find(t2.c_str()); //cout &lt;&lt; t1 &lt;&lt; " " &lt;&lt; k1 &lt;&lt; " " &lt;&lt; t2 &lt;&lt; " " &lt;&lt; k2 &lt;&lt; endl; if(k1 &amp;&amp; k2) return true; &#125; return false;&#125;int main()&#123; tire.init(); while(~scanf("%s", s[idx])) tire.add(s[idx++]); /*for(int i = 1; i &lt;= tire.tot; ++i) &#123; cout &lt;&lt; tire.cnt[i] &lt;&lt; endl; &#125;*/ /*for(int i = 0; i &lt; idx; ++i) &#123; cout &lt;&lt; tire.Find(s[i]) &lt;&lt; endl; &#125;*/ for(int i = 0; i &lt; idx; ++i) &#123; if(judge(s[i])) &#123; printf("%s\n", s[i]); &#125; &#125; return 0;&#125; J - Phone List HDU - 1671 【Easy】题目大意： 判断是否有前缀。 解题思路： 建树直接判。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5 + 5;struct Tire&#123; int tot, nex[MAX][11], pre[MAX], cnt[MAX]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre));// memset(cnt, 0, sizeof(cnt)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; &#125;// cnt[now]++; &#125; int Find(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; int t, n; char s[MAX][11]; scanf("%d",&amp;t); while(t--) &#123; tire.init(); scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", s[i]); tire.add(s[i]); &#125; bool flag = true; for(int i = 0; i &lt; n &amp;&amp; flag; ++i) &#123; if(tire.Find(s[i]) &gt; 1) flag = false; &#125; puts(flag ? "YES" : "NO"); &#125; return 0;&#125; K - Immediate Decodability HDU - 1305 【Easy】题目大意： 判断给出的字符串判断是否出现了某个串是另外一个的前缀。 解题思路： 建树直接判。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int MAX = 1e5 + 5;struct Tire&#123; int tot, nex[MAX][11], pre[MAX], cnt[MAX]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); memset(cnt, 0, sizeof(cnt)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; &#125; cnt[now]++; &#125; int Find(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; int cas = 0, idx = 0; char a[11]; char s[11][11]; tire.init(); while(~scanf("%s", a)) &#123; if(a[0] == '9') &#123; /*for(int i = 0; i &lt; idx; ++i) cout &lt;&lt; s[i] &lt;&lt; endl;*/ bool flag = true; for(int i = 0; i &lt; idx; ++i) &#123; if(tire.Find(s[i]) &gt; 1) &#123; //cout &lt;&lt; tire.Find(s[i]) &lt;&lt; " " &lt;&lt; s[i] &lt;&lt; endl; flag = false; break; &#125; &#125; printf("Set %d is ", ++cas); if(flag) puts("immediately decodable"); else puts("not immediately decodable"); tire.init(); idx = 0; memset(s, 0, sizeof(s)); &#125; strcpy(s[idx++], a); tire.add(a); &#125; return 0;&#125; L - 单词数 HDU - 2072 【Easy】题目大意： 给出一篇文章，问文中出现的不同单词的数量。 解题思路： 这个用map就可以，放到这里当做练习了。 PS：这题数据有点恶心，会出现开头空格、连续多个空格、全是空格等很XX的情况，这里我用stringstream处理的——STL大法好！ Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int MAX = 1e5 + 5;struct Tire&#123; int tot, nex[MAX][11], pre[MAX], cnt[MAX]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); memset(cnt, 0, sizeof(cnt)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; &#125; cnt[now]++; &#125; int Find(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; string s; char a[1111]; while(getline(cin, s)) &#123; if(s.size() == 1 &amp;&amp; s[0] == '#') break; tire.init(); stringstream ss(s); while(ss &gt;&gt; a) &#123; tire.add(a); &#125; int res = 0; for(int i = 1; i &lt;= tire.tot; ++i) if(tire.cnt[i]) ++res; cout &lt;&lt; res &lt;&lt; "\n"; &#125; return 0;&#125; M - T9 HDU - 1298题目大意： 解题思路： Mycode：12 N - DNA Prefix LightOJ - 1224 【Medium】题目大意： T组数据，每组有N个由ACGT组成的字符串，定义result为 某个前缀的长度 * 拥有这个前缀的字符串的数量，问最大的result是多少。 解题思路： 直接枚举每个前缀，看结果是多少。 枚举每个字符串的前缀，TLE。 从树上枚举。这里我想到了两种方法，一是在建树时记录答案并不断更新，二是建完树后从根结点向下搜索，答案就是 此时前缀数 * 此时的深度，计算并更新最大值就行了。 有点要注意的是只会出现ACGT四种字母，我们可以直接将他们标记为0123，这样省下了部分空间。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;const int MAX = 1e6+5;int t, n, res;char s[55];map&lt;char, int&gt; mapa;struct Tire&#123; int tot, nex[MAX][4], pre[MAX]; void init() &#123; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); tot = 1; &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][mapa[str[i]]]) nex[now][mapa[str[i]]] = ++tot; now = nex[now][mapa[str[i]]]; pre[now]++; &#125; &#125; void dfs(int now, int dep) &#123; for(int i = 0; i &lt; 4; ++i) &#123; if(nex[now][i]) dfs(nex[now][i], dep+1); &#125; if(pre[now] * dep &gt; res) res = pre[now] * dep; &#125; /*int Find(const char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][mapa[str[i]]]) return 0; now = nex[now][mapa[str[i]]]; &#125; return pre[now]; &#125;*/&#125;tire;void init()&#123; mapa['A'] = 0; mapa['C'] = 1; mapa['G'] = 2; mapa['T'] = 3;&#125;int main()&#123; init(); scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; res = 0; tire.init(); scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) scanf("%s", &amp;s), tire.add(s); //从根结点向下搜索，当前深度为0 tire.dfs(1,0); printf("Case %d: %d\n", cas, res); &#125; return 0;&#125; O - Consistency Checker LightOJ - 1129 【Easy】题目大意： 给出T个清单，每个清单上有n个互不相同的电话号码，每个电话号码长度在1 ~ 10之间，问这些清单是否具有一致性，即这张清单中的每个电话号码都不是其他某个号码的前缀。 解题思路： 建树，判断即可。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;int t, n;bool flag;char s[10010][11];struct Tire&#123; int nex[MAX][11], pre[MAX], cnt[MAX], tot; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre));// memset(cnt, 0, sizeof(cnt)); &#125; void add(char* str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; /*for(int j = 0; j &lt;= i; ++j) cout &lt;&lt; str[j]; cout &lt;&lt; " " &lt;&lt; pre[now] &lt;&lt; endl;*/ &#125;// cnt[now]++; &#125; int Find(char* str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125; tire;int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d",&amp;n); tire.init(); flag = true; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", s[i]); tire.add(s[i]); &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(tire.Find(s[i]) &gt; 1) &#123; flag = false; break; &#125; &#125; printf("Case %d: %s\n", cas, flag ? "YES" : "NO"); &#125; return 0;&#125; P - Consecutive Sum LightOJ - 1269题目大意： 解题思路： Mycode：12]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>HDU</tag>
        <tag>解题报告</tag>
        <tag>POJ</tag>
        <tag>LightOj</tag>
        <tag>专题训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6299 Balanced Sequence 【贪心】]]></title>
    <url>%2Fhdu-6299%2F</url>
    <content type="text"><![CDATA[题目大意：现有n个字符串，每个串均有若干个()左右括号构成，请你选择一个连接顺序将这些串连在一起，使得匹配的括号对数最多。括号匹配的定义为左括号在右括号左边，每个括号均有一次参与匹配的机会。 解题思路： 首先在输入时对串进行处理，将已经匹配的记录下来，这样剩下的串只有4种情况：1.空串 2.只有左括号 3.只有右括号 4.右括号和左括号的混合 &amp;&amp; 右括号一定在左括号前边。 首先第1种情况肯定不用管了，剩下的该如何安排他们的顺序使得配对的数目最大化呢？肯定是要左括号尽量往左靠，右括号尽量往右靠，这样第2、3种情况也解决了。 最后一种是情况最多的，可以分为 (1).右括号数 &gt; 左括号数 (2).左括号数 &gt; 右括号数 以及 (3).左括号数 == 右括号数。考虑我们最初的目的，左括号尽量往左是为了什么？是为了不“浪费”这些括号，但是当必须“牺牲”一部分括号时，应当将“浪费”降到最低。于是我们找出了排序的关键字key = 左括号数 - 右括号数。两个变量相比较共四种情况：1.key1 &gt; 0 &amp;&amp; key2 &gt; 0 2.key1 &gt; 0 &amp;&amp; key2 &lt; 0 3.key1 &lt; 0 &amp;&amp; key2 &gt; 0 4.key1 &lt; 0 &amp;&amp; key2 &lt; 0，再将相等的情况随便插到几组中所有情况就都有了。这时排序的规则是一正一负正的在前，都为正时右括号少的在前，都为负时左括号多的在前，根据这样排完序挨个取就可以了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;char s[MAX];int t, n, tem, res;struct node&#123; int l, r, sub;&#125;a[MAX];bool cmp(node u, node v)&#123; if(u.sub &gt;= 0 &amp;&amp; v.sub &lt; 0) return true; if(u.sub &lt; 0 &amp;&amp; v.sub &gt;= 0) return false; if(u.sub &gt;= 0 &amp;&amp; v.sub &gt;= 0) return u.r &lt; v.r; return u.l &gt; v.l;&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; res = 0; memset(a, 0, sizeof(a)); scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", s); tem = 0; for(int j = 0; s[j]; ++j) &#123; if(s[j] == '(') ++tem; else &#123; if(tem == 0) ++a[i].r; else &#123; --tem; ++res; &#125; &#125; &#125; a[i].l = tem; a[i].sub = a[i].l - a[i].r; &#125; sort(a, a + n, cmp); tem = a[0].l; for(int i = 1; i &lt; n; ++i) &#123; res += min(tem, a[i].r); tem -= a[i].r; if(tem &lt; 0) tem = 0; tem += a[i].l; &#125; printf("%d\n", res&lt;&lt;1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>HDU</tag>
        <tag>多校联合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6301 Distinct Values 【贪心】【模拟】]]></title>
    <url>%2Fhdu-6301%2F</url>
    <content type="text"><![CDATA[题目大意：找出n个数，满足给出的m个区间内的数都不相同。问满足条件的字典序最小的序列是多少。 解题思路：字典序最小，说明肯定要越小的越往前填，如果没有限制区间的话答案就是$n$个$1$啦，加上后最先出现的区间要最先考虑，即$l_1$ ~ $r_1$内的数为$1$ ~ $r_1 - l_1$，后面的根据出现的顺序(指填到x时最先覆盖x的区间)依次从小往大填就好了。题目的难点就是填数时保证不重复。为了改变区间的顺序，肯定要先排序，排序是根据$l_i$为关键字。排序后模拟填数的过程：碰到区间就改变填的数的值，填数时要记录用过的数字，区间结束记得将区间覆盖不到的点再“收回”。而这个所需要的容器可以用优先队列或者set，想到合适的容器就简单多了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int MAX = 1e5+5;int t, n, m, L, R, res[MAX];struct node&#123; int l, r;&#125;a[MAX];bool cmp(node u, node v)&#123; if(u.l == v.l) return u.r &lt; v.r; return u.l &lt; v.l;&#125;set&lt;int&gt; S;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;n,&amp;m); for(int i = 0; i &lt; m; ++i) scanf("%d%d", &amp;a[i].l, &amp;a[i].r); sort(a, a + m, cmp); S.clear(); for(int i = 1; i &lt;= n; ++i) &#123; res[i] = 1; S.insert(i); &#125; L = a[0].l, R = a[0].r; for(int i = L; i &lt;= R; ++i) &#123; res[i] = *S.begin(); S.erase(S.begin()); &#125; for(int i = 1; i &lt; m; ++i) &#123; while(L &lt; a[i].l) &#123; S.insert(res[L++]); &#125; while(R &lt; a[i].r) &#123; ++R; if(R &lt; L) continue; res[R] = *S.begin(); S.erase(S.begin()); &#125; &#125; for(int i = 1; i &lt;= n; ++i) printf("%d%c", res[i], i == n ? '\n' : ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>HDU</tag>
        <tag>多校联合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 979B Treasure Hunt 【模拟】]]></title>
    <url>%2Fcf-979b%2F</url>
    <content type="text"><![CDATA[题目大意：3个人做游戏，每人初始时拥有一个长度相同的字符串，现每人都要对自己的字符串进行变换操作，问经过n次变换操作后谁的字符串的value最大，value的计算方法是字符串中出现次数最的的字母的次数。变换操作是将自己字符串中的任意一个字母变成除这个字母外的任意一个字母。 解题思路：设初始时出现次数最多的字母为m，之后我们将所有字母变成这个字母就是最佳答案了。变换时要对n进行判断，当n大于非m的字母数量时，最终答案为字符串的长度(即可以将所有字母变为m)，反之，为m的数量+n。【注意：】这里要考虑一种情况，就是n = 1 &amp;&amp; 所有字母都相同的时候，这时答案为字符串长度 - 1。 关于代码：自己写的略微“丑陋”，std看起来是真的舒服，想写这样的代码。现在对“Think twice code once”又有了新的理解，不仅要写正确的代码，还要写在表述清楚的前提下的简洁的代码。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;char a[111111], b[111111], c[111111];map&lt;char, int&gt; ca, cb, cc;int t, la, lb, lc, ra, rb, rc;int main()&#123; scanf("%d%s%s%s",&amp;t,a, b, c); la = strlen(a), lb = strlen(b), lc = strlen(c); for(int i = 0; i &lt; la; ++i) ca[a[i]]++; for(int i = 0; i &lt; lb; ++i) cb[b[i]]++; for(int i = 0; i &lt; lc; ++i) cc[c[i]]++; for(char i = 'a'; i &lt;= 'z'; ++i) &#123; ra = max(ra, ca[i]); rb = max(rb, cb[i]); rc = max(rc, cc[i]); &#125; for(char i = 'A'; i &lt;= 'Z'; ++i) &#123; ra = max(ra, ca[i]); rb = max(rb, cb[i]); rc = max(rc, cc[i]); &#125; if(ra == la &amp;&amp; t == 1) ra--; else ra += t; if(rb == lb &amp;&amp; t == 1) rb--; else rb += t; if(rc == lc &amp;&amp; t == 1) rc--; else rc += t; ra = min(ra, la); rb = min(rb, lb); rc = min(rc, lc); if(ra &gt; rb &amp;&amp; ra &gt; rc) puts("Kuro"); else if(rb &gt; ra &amp;&amp; rb &gt; rc) puts("Shiro"); else if(rc &gt; ra &amp;&amp; rc &gt; rb) puts("Katie"); else puts("Draw"); return 0;&#125; Stdcode:123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int a[256], b[256], c[256], n, ma, mb, mc;string p, q, r;int main() &#123; cin &gt;&gt; n &gt;&gt; p &gt;&gt; q &gt;&gt; r; for (char x: p) ma = max(ma, ++a[x]); for (char x: q) mb = max(mb, ++b[x]); for (char x: r) mc = max(mc, ++c[x]); if (n == 1 &amp;&amp; ma == (int)p.length()) p.pop_back(); if (n == 1 &amp;&amp; mb == (int)q.length()) q.pop_back(); if (n == 1 &amp;&amp; mc == (int)r.length()) r.pop_back(); ma = min(ma + n, (int)p.length()); mb = min(mb + n, (int)q.length()); mc = min(mc + n, (int)r.length()); if (ma &gt; mb &amp;&amp; ma &gt; mc) &#123; puts("Kuro"); return 0; &#125; if (mb &gt; ma &amp;&amp; mb &gt; mc) &#123; puts("Shiro"); return 0; &#125; if (mc &gt; ma &amp;&amp; mc &gt; mb) &#123; puts("Katie"); return 0; &#125; puts("Draw"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 967C Stairs and Elevators 【二分】]]></title>
    <url>%2Fcf-967c%2F</url>
    <content type="text"><![CDATA[题目大意：在一个n层高的楼层里，有m块呈直线连在一起的区域，有cl个楼梯和ce个电梯分别在 $a_1$ ~ $a_{cl}$ 和 $b_1$ ~ $b_{ce}$的位置上，从这个位置可以上到上一层楼或者下一层楼。楼梯1s可以上|下一层楼，电梯1s可以上|下$\leq$ v个楼层，从一块到相邻的一块也需要1s的时间。有q个询问，问最少经过多少时间可以从$x1, y1$到达$x2, y2$。 解题思路： 首先想到的是看走楼梯和走电梯哪个时间最少。如果走楼梯，可以走靠近当前位置的左边最近的或者右边最近的，其他同方向位置的楼梯花费的时间一定大于等于这两个位置。电梯同理。 接下来就是找位置了。找这4个位置的时候，因为给出的电梯/楼梯位置是升序的，所以可以用二分查找。一开始写的是分别二分查这4个位置，后来发现只要查两个位置就好了，比如查电梯的第一个$\geq$y1的位置后，另一个要找的位置就是这个位置左边的那个(如果存在的话)。【注意：】这里有个细节问题不要忽略，就是两位置在一层楼的时候，这时既不需要走楼梯也不需要走电梯。 Mycode(手写二分)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;int n, m, c1, c2, v;int a1[MAX], a2[MAX];int stx, sty, enx, eny, tem;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; v; for(int i = 0; i &lt; c1; ++i) cin &gt;&gt; a1[i]; for(int i = 0; i &lt; c2; ++i) cin &gt;&gt; a2[i]; a2[c2] = a1[c1] = 1e9; int t; cin &gt;&gt; t; while(t--) &#123; int res = 1e9; cin &gt;&gt; stx &gt;&gt; sty &gt;&gt; enx &gt;&gt; eny; if(stx == enx) &#123; res = abs(sty - eny); cout &lt;&lt; res &lt;&lt; endl; continue; &#125; int l, r, m, pos; if(c1) &#123; pos = -1, l = 0, r = c1; while(l &lt;= r) &#123; m = (l + r) &gt;&gt; 1; if(a1[m] &gt;= sty) &#123; r = m - 1; pos = m; &#125; else l = m + 1; &#125; if(pos != -1) &#123; tem = abs(sty - a1[pos]); tem += abs(eny - a1[pos]); tem += abs(stx - enx); res = min(res, tem); &#125;// cout &lt;&lt; pos &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt;tem &lt;&lt; " " &lt;&lt; res &lt;&lt; endl; pos = -1, l = 0, r = c1; while(l &lt;= r) &#123; m = (l + r) &gt;&gt; 1; if(a1[m] &lt;= sty) &#123; l = m + 1; pos = m; &#125; else r = m - 1; &#125; if(pos != -1) &#123; tem = abs(sty - a1[pos]); tem += abs(eny - a1[pos]); tem += abs(stx - enx); res = min(res, tem); &#125; &#125;// cout &lt;&lt; pos &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt;tem &lt;&lt; " " &lt;&lt; res &lt;&lt; endl; if(c2) &#123; pos = -1, l = 0, r = c2; while(l &lt;= r) &#123; m = (l + r) &gt;&gt; 1; if(a2[m] &gt;= sty) &#123; r = m - 1; pos = m; &#125; else l = m + 1; &#125; if(pos != -1) &#123; tem = abs(sty - a2[pos]); tem += abs(eny - a2[pos]); int tt = abs(stx - enx); tem += tt / v; if(tt % v) tem++; res = min(res, tem); &#125;// cout &lt;&lt; pos &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt;tem &lt;&lt; " " &lt;&lt; res &lt;&lt; endl; pos = -1, l = 0, r = c2; while(l &lt;= r) &#123; m = (l + r) &gt;&gt; 1; if(a2[m] &lt;= sty) &#123; l = m + 1; pos = m; &#125; else r = m - 1; &#125; if(pos != -1) &#123; tem = abs(sty - a2[pos]); tem += abs(eny - a2[pos]); int tt = abs(stx - enx); tem += tt / v; if(tt % v) tem++; res = min(res, tem); &#125; &#125;// cout &lt;&lt; pos &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt;tem &lt;&lt; " " &lt;&lt; res &lt;&lt; endl; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; Mycode(stl二分):12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;int n, m, cl, ce, v;int a1[MAX], a2[MAX];int stx, sty, enx, eny, tem, res;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;cl,&amp;ce,&amp;v); for(int i = 0; i &lt; cl; ++i) scanf("%d",&amp;a1[i]); for(int i = 0; i &lt; ce; ++i) scanf("%d",&amp;a2[i]); a1[cl] = a2[ce] = 1e9; int t; scanf("%d",&amp;t); while(t--) &#123; res = 1111111111; scanf("%d%d%d%d",&amp;stx,&amp;sty,&amp;enx,&amp;eny); if(stx == enx) res = abs(sty - eny); else &#123; if(cl &gt; 0) &#123; int pos = lower_bound(a1, a1+cl, sty) - a1; if(a1[pos] != 1e9) &#123; tem = 0; tem += abs(sty-a1[pos]); tem += abs(eny-a1[pos]); tem += abs(stx-enx); res = min(res, tem); &#125; if(pos &gt; 0) &#123; --pos; tem = 0; tem += abs(sty-a1[pos]); tem += abs(eny-a1[pos]); tem += abs(stx-enx); res = min(res, tem); &#125; &#125; if(ce &gt; 0) &#123; int pos = lower_bound(a2, a2+ce, sty) - a2; if(a2[pos] != 1e9) &#123; tem = 0; tem += abs(sty-a2[pos]); tem += abs(eny-a2[pos]); tem += ceil((double)abs(stx-enx)/v); res = min(res, tem); &#125; if(pos &gt; 0) &#123; --pos; tem = 0; tem += abs(sty-a2[pos]); tem += abs(eny-a2[pos]); tem += ceil((double)abs(stx-enx)/v); res = min(res, tem); &#125; &#125; &#125; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018_SDNU_ACM-ICPC_Provincial_Team_Selection_Round_2【假装完结】]]></title>
    <url>%2Fsdnu-2018-2%2F</url>
    <content type="text"><![CDATA[山东省第九届acm大学程序设计竞赛山师选拔赛第二场(声明：标题是自己取的，如果有语法错误的话与他人无关) —————————————————————–分割线—————————————————————– Problem A. Alice and Bob(NimK博弈)题意：有N堆石子，每次可以取1~M堆中的任意多个石子，最后无石子可取的那个失败。Alice先手，问谁会赢。 思路：NimK博弈裸题，结论是当且仅当每一位二进制位上的数%(m+1)都是0的时候，先手必败，否则先手必胜。见识++。原理留坑待补。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int tem, tot;int u[MAX][55];int t, res, a, b, n, m;int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; memset(u, 0, sizeof(u)); scanf("%d%d",&amp;n,&amp;m); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;tem); tot = 0; while(tem) &#123; u[i][tot++] = tem &amp; 1; tem &gt;&gt;= 1; &#125; &#125; bool flag = true; for(int j = 0; j &lt; 32; ++j) &#123; int yy = 0; for(int i = 0; i &lt; n; ++i) &#123; yy += u[i][j]; &#125; if(yy % (m+1)) &#123; flag = false; break; &#125; &#125; printf("Case #%d: ", cas); puts(flag ? "Bob" : "Alice"); &#125; return 0;&#125; Problem B. SOS(基础)题意：已知gcd(a, c) = b， 给出a和b求满足条件的最小的不等于b的c。 思路：对式子变形得，gcd(a/b, c/b) = 1， 即求最小的与a/b互质的数。(之前做过一道一模一样的题SDNU-1132: 最大公约数改，枚举答案也能水过啦) Mycode：12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e6+7;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t, res, a, b;int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d%d",&amp;a,&amp;b); a /= b; for(int i = 2; ; ++i) &#123; if(gcd(a, i) == 1) &#123; res = i; break; &#125; &#125; printf("Case #%d: %d\n", cas, res * b); &#125; return 0;&#125; Problem C. Boooooooo(规律)题意：给出一个数N，找出最小的大于等于N的整数pp，其中pp满足存在整数hh使得2hh(hh + 1) = pp(pp + 1)。 思路：打表找规律。(找不出来怎么办？GG呗) Mycode：1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int t;long long n, res;long long a[30] = &#123;3,20&#125;;int main()&#123; for(int i = 2; i &lt; 25; ++i) &#123; a[i] = 6 * a[i-1] - a[i-2] + 2; //cout &lt;&lt; a[i] &lt;&lt; endl; &#125; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%lld", &amp;n); for(int i = 0; ; ++i) &#123; if(a[i] &gt;= n) &#123; printf("Case #%d: %lld\n", cas, a[i]); break; &#125; &#125; &#125; return 0;&#125; Problem D. XC’s pot(期望)题目原型：LightOJ-1027: A Dangerous Maze Problem E. SDNU ACM/ICPC TEAM(拓扑排序)题意不清，不如做这个吧：HDU-4857: 逃生 Problem F. The Avengers(最小生成树)队友补了，目前不想补。 Problem G. play the guitar(大数)题意：Calculate $n^k$ and change all 7,8,9 to 1,2,3(7 to 1, 8 to 2, 9 to 3). 思路：开上Java直接做。 Mycode：12345678910111213141516171819202122232425262728import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner scanner = new Scanner(System.in); int n, m; BigInteger res; String s; while(scanner.hasNext()) &#123; n = scanner.nextInt(); m = scanner.nextInt(); res = BigInteger.valueOf(1); for(int i = 1; i &lt;= m; ++i) &#123; res = res.multiply(BigInteger.valueOf(n)); &#125; s = res.toString(); s = s.replace('7','1'); s = s.replace('8','2'); s = s.replace('9','3'); System.out.println(s); &#125; &#125;&#125; Problem H. The chord(最长公共子串)题意：所有和弦中，伟大的歌手LHM只会其中的部分和弦，给出一个包含很多和弦的吉他谱，问LMH能弹奏的连续的最长的一段乐曲包含多少和弦。 思路：先将不同字符串转换，然后计算转换后的两个串的最长公共子串(套后缀数组的模板)。(转换时当然想到map，然而套各种模板都会超时，因此只好写个100+行的函数来转换。这个题目的idea还是不错的。) Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200000 + 10, INF = 0x3f3f3f3f;const char trans[] = &#123;'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r'&#125;;int sa[N], height[N], rnk[N], wa[N], wb[N], c[N];char str[N], S[N];int s[N], Q;bool cmp(int *r, int a, int b, int l)&#123; return r[a] == r[b] &amp;&amp; r[a+l] == r[b+l];&#125;void Rsort(int *x, int *y, int n, int m)&#123; for(int i = 0; i &lt; m; i++) c[i] = 0; for(int i = 0; i &lt; n; i++) c[x[y[i]]]++; for(int i = 1; i &lt; m; i++) c[i] += c[i-1]; for(int i = n-1; i &gt;= 0; i--) sa[--c[x[y[i]]]] = y[i];&#125;void da(int *s, int n, int m)&#123; int *x = wa, *y = wb; for(int i = 0; i &lt; n; i++) x[i] = s[i], y[i] = i; Rsort(x, y, n, m); for(int j = 1, p = 1; p &lt; n; j *= 2, m = p) &#123; p = 0; for(int i = n-j; i &lt; n; i++) y[p++] = i; for(int i = 0; i &lt; n; i++) if(sa[i] &gt;= j) y[p++] = sa[i] - j; Rsort(x, y, n, m); swap(x, y); p = 1; x[sa[0]] = 0; for(int i = 1; i &lt; n; i++) x[sa[i]] = cmp(y, sa[i-1], sa[i], j) ? p-1 : p++; &#125;&#125;void get_height(int *s, int n)&#123; int i, j, k = 0; for(i = 0; i &lt;= n; i++) rnk[sa[i]] = i; for(i = 0; i &lt; n; height[rnk[i++]] = k) for(k ? --k : 0, j = sa[rnk[i]-1]; s[i+k] == s[j+k]; k++);&#125;int change(int L)&#123; int res = 0; for(int i = 0; i &lt; L; ++i) &#123; if(str[i] == 'A') &#123; if(str[i+1] == '7') &#123; s[res++] = trans[1]; ++i; &#125; else if(str[i+1] == 'm') &#123; s[res++] = trans[2]; ++i; &#125; else if(str[i+1] == 's') &#123; s[res++] = trans[3]; i += 4; &#125; else s[res++] = trans[0]; &#125; else if(str[i] == 'B') &#123; if(str[i+1] == '7') s[res++] = trans[4]; else s[res++] = trans[5]; ++i; &#125; else if(str[i] == 'C') &#123; if(str[i+1] == '7') &#123; s[res++] = trans[7]; ++i; &#125; else s[res++] = trans[6]; &#125; else if(str[i] == 'D') &#123; if(str[i+1] == '7') &#123; s[res++] = trans[9]; ++i; &#125; else if(str[i+1] == 'm') &#123; if(str[i+2] == '7') &#123; s[res++] = trans[10]; i += 2; &#125; else &#123; s[res++] = trans[11]; i++; &#125; &#125; else s[res++] = trans[8]; &#125; else if(str[i] == 'E') &#123; if(str[i+1] == 'm') &#123; s[res++] = trans[13]; ++i; &#125; else s[res++] = trans[12]; &#125; else if(str[i] == 'F') &#123; if(str[i+1] == 'm') &#123; s[res++] = trans[14]; i += 4; &#125; else s[res++] = trans[15]; &#125; else if(str[i] == 'G') &#123; if(str[i+1] == '7') &#123; s[res++] = trans[16]; i++; &#125; else s[res++] = trans[17]; &#125; else &#123; Q = res; s[res++] = '$'; &#125; &#125; return res;&#125;int main()&#123; while(~scanf("%s", str)) &#123; int len = strlen(str); str[len] = '$'; scanf("%s", str + 1 + len); len = strlen(str); len = change(len); s[len] = 0; int len_1 = Q; da(s, len + 1, 130);//第二个参数，即长度比原数组大一，因为在末尾补了一个极小值，故+1 get_height(s, len);//此处传入原长度 int ans = 0; for(int i = 1; i &lt;= len; i++)//height[1]~height[len]，因为sa[0]是以极小值为起点的后缀，然后sa[1]~sa[len]，故height[1]~height[len] if(height[i] &gt; ans &amp;&amp; ((sa[i-1]&lt;len_1 &amp;&amp; sa[i]&gt;len_1) || (sa[i-1]&gt;len_1 &amp;&amp; sa[i]&lt;len_1))) ans = height[i]; printf("%d\n", ans); &#125; return 0;&#125; Problem I. Alice and Bob II(记忆化搜索)题意：N堆石子，Alice先手，每次两人都可以从石子的两端取任意一堆，问Alice最多能取多少石子。 思路：我觉得题目中这句they both smart不应该有，不然给出的正解讲不通。去掉这句话的话就是看Alice能取的石子最大值了。使Alice取最多即每次Alice往多了取，Bob往小了取。最多100堆，枚举每个状态的话肯定不能完成。采取记忆化搜索可以保留左右位置为l、r时的最优解，大大减少时间复杂度，任务完成。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 105;int a[MAX];int n, res, t;int dp[MAX][MAX];int DFS(int l, int r, bool flag)&#123; if(dp[l][r]) return dp[l][r]; int res = 0; if(flag) &#123; if(l == r) return a[l]; res = max(DFS(l+1, r, !flag) + a[l], DFS(l, r-1, !flag) + a[r]); &#125; else &#123; if(l == r) return 0; res = min(DFS(l+1, r, !flag), DFS(l, r-1, !flag)); &#125; dp[l][r] = res; return res;&#125;int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d",&amp;n); memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; ++i) scanf("%d",&amp;a[i]); int ans = DFS(1, n, true); printf("Case #%d: %d\n", cas, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018_SDNU_ACM-ICPC_Provincial_Team_Selection_Round_1【假装完结】]]></title>
    <url>%2Fsdnu-2018-1%2F</url>
    <content type="text"><![CDATA[山东省第九届acm大学程序设计竞赛山师选拔赛第一场(声明：标题是自己取的，如果有语法错误的话与他人无关) —————————————————————–分割线—————————————————————– A.网瘾少年周老灰(贪心)题意：周老灰玩炉石，场上目前有2 * n张牌，敌我各n张。发动进攻的方式是每张牌只能攻击一张牌，进攻完成后，敌方士兵生命值减少我方进攻士兵的攻击力，我方士兵生命值也要减少敌方进攻士兵的攻击力，当生命之小于等于0时，这张卡牌将消失。现在轮到我方发动进攻，问能否使得我方这一轮进行完后地方卡牌都被摧毁，而我方卡牌还都存活。 思路：考虑到数据范围，直接做就行了(数据范围再大点的话就是二分图匹配了)。每次贪心选取我方能打败的敌方选手中攻击力最高的，一直这样选直到全部选完||打败不了的情况。 碎碎念：数据出的太不负责了，出现了范围以外的数就不说了，TM除了一个本不该存在的n=0时输出Sorry about that!外，其他情况都输出Tell you a joke~？这种题目全随机数出现前一个答案的概率太小了，就不能手动出几组吗(没错我是因为他这个本不该出现的n=0浪费了近3小时的时间debug才如此气愤的)。UPD(04.18)：等了一周后还没改，自己出了几组随机数和手动出的数据传上去后rejudge，果然hack掉了几个。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 105;int t, n;struct node&#123; bool flag; int hp, mp;&#125;a[MAX], b[MAX];bool cmp(node u, node v)&#123; if(u.hp == v.hp) return u.mp &lt; v.mp; return u.hp &lt; v.hp;&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); bool flag; memset(b, 0, sizeof(b)); for(int i = 0; i &lt; n; ++i) scanf("%d%d",&amp;a[i].hp,&amp;a[i].mp); for(int i = 0; i &lt; n; ++i) scanf("%d%d",&amp;b[i].hp,&amp;b[i].mp); sort(a, a+n, cmp); sort(b, b+n, cmp); for(int i = 0; i &lt; n; ++i) &#123; flag = false; for(int j = n-1; j &gt;= 0; --j) &#123; if(b[j].flag == false &amp;&amp; a[i].hp &gt; b[j].mp &amp;&amp; a[i].mp &gt;= b[j].hp) &#123; flag = true; b[j].flag = true; break; &#125; &#125; if(!flag) break; &#125; if(flag) puts("Sorry about that!"); else puts("Tell you a joke~"); &#125; return 0;&#125; B.陆历川玩数位(数位DP)题目原型：HDU-4734: F(x) 队友补过了，目前不想补。 C.prime(素数筛)题意：给一个数n问n是否是素数，0 &lt; n &lt; 100000000。 思路：据说出题人本打算考察位图筛的，但没想到数组可以开到1e8这么大，于是让大家用素数筛水过去了。队友说素数筛会超时，于是我上的Miller-Rabin。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int S = 8;//随机算法判定次数，一般8~10次就够了//计算ret = (a*b)%c a, b, c &lt; 2^63long long mult_mod(long long a, long long b, long long c)&#123; a %= c; b %= c; long long ret = 0; long long tem = a; while(b) &#123; if(b &amp; 1) &#123; ret += tem; if(ret &gt; c) ret -= c;//直接取模慢很多 &#125; tem &lt;&lt;= 1; if(tem &gt; c) tem -= c; b &gt;&gt;= 1; &#125; return ret;&#125;//计算 ret = (a^n) % modlong long pow_mod(long long a, long long n, long long mod)&#123; long long ret = 1; long long tem = a % mod; while(n) &#123; if(n &amp; 1) ret = mult_mod(ret, tem, mod); tem = mult_mod(tem, tem, mod); n &gt;&gt;= 1; &#125; return ret;&#125;// 通过 a^(n-1)=1(mod n)来判断n是不是素数// n-1 = x * 2^t 中间使用二次判断// 是合数返回true，不一定是合数返回falsebool check(long long a, long long n, long long x, long long t)&#123; long long ret = pow_mod(a, x, n);//a^x % n long long last = ret; for(int i = 1; i &lt;= t; ++i)//进行t次(a^x % n)^2 % n &#123; ret = mult_mod(ret, ret, n); if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true;//合数 last = ret; &#125; if(ret != 1) return true; return false;//不一定是合数&#125;//**************************************************// Miller_Rabin算法// 是素数返回true,(可能是伪素数)// 不是素数返回false//**************************************************bool Miller_Rabin(long long n)&#123; if(n &lt; 2) return false; if(n == 2) return true; if( (n&amp;1) == 0) return false;//偶数 long long x = n - 1; long long t = 0; while( (x&amp;1) == 0) //将n分解为x*2^t; &#123; x &gt;&gt;= 1; t++; &#125; srand( time(NULL)); for(int i = 0; i &lt; S; ++i) &#123; long long a = rand()%(n-1) + 1;//产生随机数a(并控制其范围在1 ~ n-1之间) if(check(a, n, x, t))//是合数 return false; &#125; return true;&#125;int main()&#123; int T; long long n; scanf("%d", &amp;T); while(T--) &#123; scanf("%lld", &amp;n); if(Miller_Rabin(n)) cout &lt;&lt; "N" &lt;&lt; endl; else cout &lt;&lt; "Y" &lt;&lt; endl; &#125; return 0;&#125; D.陆历川爱合并(K叉哈夫曼树)题意：从n个元素中每次取不超过k个元素进行合并，合并时的花费为k个元素价值的总和，并且合并出的新元素价值为这k个元素的总和。问当最终花费不超过T时，最小的k是多少。 思路：0.当k=2时，这就是哈夫曼树，为使总花费最小，每次合并的两元素的价值最小。相关题目：SDNU-1412: Huffuman树。1.显然k越大总花费越小，满足单调性，因此我们可以采用二分的方法枚举k。2.因为每次取k个合并后变成一个总量其实减少了k-1个，每次减少这么多，再加上最后合并为1堆，因此当(n-1) % (k-1) == 0时，说明刚好能合并完成，否则会出现剩余的情况，如果最后合并这些多出来的部分的话会影响到上面1中的单调性，所以这种情况下要先合并多出来的这部分。3.合并时可以维护小的值一直在队列前面，省下了排序/查找的时间。 K叉哈夫曼树模板：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int Hafuman(int k) //返回总代价&#123; int ai, bi, blen; blen = 0; ai = bi = 0; int cost = 0; bool first = true; while (n - ai + blen - bi &gt; 1) &#123; int num = 0; if (first) &#123; if ((n - k) % (k - 1) == 0) num = k; else num = (n - k) % (k - 1) + 1; first = false; &#125; else num = k; int sum = 0; while (num--) &#123; if (ai == n) &#123; sum += b[bi]; bi++; &#125; else if (bi == blen) &#123; sum += a[ai]; ai++; &#125; else if (a[ai] &lt; b[bi]) &#123; sum += a[ai]; ai++; &#125; else &#123; sum += b[bi]; bi++; &#125; &#125; cost += sum; b[blen++] = sum; &#125; return cost;&#125; 题目原型：HDU-5884: Sort Mycode：(在HDU上过了，在这里T了，慢了200MS。自己将上面的模板套上后就能过了。)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 100005;int a[MAX];queue&lt;LL&gt; Q;int t, n, m, res;bool judge(int k)&#123; while(!Q.empty()) Q.pop(); LL tot = 0; LL tem = 0; int idx = 0; int lef = (n - 1) % (k - 1) + 1; if(lef) //多出的lef个先合并 &#123; while(idx &lt; lef) tem += a[idx++]; tot += tem; Q.push(tem); &#125; while(1) &#123; tem = 0; for(int i = 0; i &lt; k; ++i) &#123; if(idx &lt; n &amp;&amp; (Q.empty() || a[idx] &lt; Q.front())) tem += a[idx++]; else tem += Q.front(), Q.pop(); &#125; tot += tem; if(tot &gt; m) return false; if(idx &gt;= n &amp;&amp; Q.empty()) break; Q.push(tem); &#125; return tot &lt;= m;&#125;int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d%d",&amp;n, &amp;m); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); sort(a, a + n); int l = 2, r = n; int mid; while(l &lt;= r) &#123; mid = (l + r) / 2; if(judge(mid)) &#123; res = mid; r = mid - 1; &#125; else l = mid + 1; &#125; printf("Case #%d: %d\n", cas, res); &#125; return 0;&#125; E.Reasoning test(模拟)题意：给出10个问题，他们之间有相互限制的条件，问满足这些限制条件的每个问题的答案是多少。 思路：因为只要提交答案，本地枚举每种情况，然后把限制条件堆到一个函数里judge一下就好了。(比赛时都是手推的，这是江苏省公安厅网络安全小组的官方微博“江苏网警”发布的“2018年刑侦专题推理试题”，看来大家都有当刑警的潜力啊。) Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e6+7;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int a[15];char ch[] = &#123;'A','B','C','D'&#125;;void out()&#123; for(int i = 1; i &lt;= 10; ++i) cout &lt;&lt; ch[a[i]-1]; cout &lt;&lt; endl;&#125;bool judge()&#123; if(a[2] != (a[5]+1)%4+1) return false; if(a[3] == 1) &#123; if(a[3] == a[6]) return false; if(a[3] == a[2]) return false; if(a[3] == a[4]) return false; &#125; else if(a[3] == 2) &#123; if(a[6] == a[2]) return false; if(a[6] == a[3]) return false; if(a[6] == a[4]) return false; &#125; else if(a[3] == 3) &#123; if(a[2] == a[3]) return false; if(a[2] == a[4]) return false; if(a[2] == a[6]) return false; &#125; else if(a[3] == 4) &#123; if(a[4] == a[2]) return false; if(a[4] == a[3]) return false; if(a[4] == a[6]) return false; &#125; if(a[4] == 1 &amp;&amp; a[1] != a[5]) return false; if(a[4] == 2 &amp;&amp; a[2] != a[7]) return false; if(a[4] == 3 &amp;&amp; a[1] != a[9]) return false; if(a[4] == 4 &amp;&amp; a[6] != a[10]) return false; if(a[5] == 1 &amp;&amp; a[5] != a[8]) return false; if(a[5] == 2 &amp;&amp; a[5] != a[4]) return false; if(a[5] == 3 &amp;&amp; a[5] != a[9]) return false; if(a[5] == 4 &amp;&amp; a[5] != a[7]) return false; if(a[6] == 1) &#123; if(a[2] != a[4]) return false; if(a[2] != a[8]) return false; &#125; else if(a[6] == 2) &#123; if(a[1] != a[6]) return false; if(a[1] != a[8]) return false; &#125; else if(a[6] == 3) &#123; if(a[3] != a[10]) return false; if(a[3] != a[8]) return false; &#125; else if(a[6] == 4) &#123; if(a[5] != a[9]) return false; if(a[5] != a[8]) return false; &#125; int A, B, C, D; A = B = C = D = 0; for(int i = 1; i &lt;= 10; ++i) &#123; if(a[i] == 1) ++A; if(a[i] == 2) ++B; if(a[i] == 3) ++C; if(a[i] == 4) ++D; &#125; int minn = -1; if(A &lt; B &amp;&amp; A &lt; C &amp;&amp; A &lt; D) minn = 1; if(B &lt; A &amp;&amp; B &lt; C &amp;&amp; B &lt; D) minn = 2; if(C &lt; A &amp;&amp; C &lt; B &amp;&amp; C &lt; D) minn = 3; if(D &lt; A &amp;&amp; D &lt; B &amp;&amp; D &lt; C) minn = 4; if(a[7] == 1 &amp;&amp; minn != 3) return false; if(a[7] == 2 &amp;&amp; minn != 2) return false; if(a[7] == 3 &amp;&amp; minn != 1) return false; if(a[7] == 4 &amp;&amp; minn != 4) return false; if(a[8] == 1 &amp;&amp; abs(a[1]-a[7]) == 1) return false; if(a[8] == 2 &amp;&amp; abs(a[1]-a[5]) == 1) return false; if(a[8] == 3 &amp;&amp; abs(a[1]-a[2]) == 1) return false; if(a[8] == 4 &amp;&amp; abs(a[1]-a[10])== 1) return false; bool flag = (a[1] == a[6]); if(flag) &#123; if(a[9] == 1) &#123; if(a[6] == a[5]) return false; &#125; if(a[9] == 2) &#123; if(a[10] == a[5]) return false; &#125; if(a[9] == 3) &#123; if(a[2] == a[5]) return false; &#125; if(a[9] == 4) &#123; if(a[9] == a[5]) return false; &#125; &#125; else &#123; if(a[9] == 1) &#123; if(a[6] != a[5]) return false; &#125; if(a[9] == 2) &#123; if(a[10] != a[5]) return false; &#125; if(a[9] == 3) &#123; if(a[2] != a[5]) return false; &#125; if(a[9] == 4) &#123; if(a[9] != a[5]) return false; &#125; &#125; int maxx = -1; if(A &gt; B &amp;&amp; A &gt; C &amp;&amp; A &gt; D) maxx = 1; if(B &gt; A &amp;&amp; B &gt; C &amp;&amp; B &gt; D) maxx = 2; if(C &gt; A &amp;&amp; C &gt; B &amp;&amp; C &gt; D) maxx = 3; if(D &gt; A &amp;&amp; D &gt; B &amp;&amp; D &gt; C) maxx = 4; int dif = abs(maxx - minn); if(a[10] == 1 &amp;&amp; dif != 3) return false; if(a[10] == 2 &amp;&amp; dif != 2) return false; if(a[10] == 3 &amp;&amp; dif != 4) return false; if(a[10] == 4 &amp;&amp; dif != 1) return false; return true;&#125;void DFS(int idx, int val)&#123; a[idx] = val; if(idx == 10) &#123; if(judge()) out(); return ; &#125; for(int i = 1; i &lt;= 4; ++i) DFS(idx+1, i);&#125;int main()&#123; //DFS(0,0); cout &lt;&lt; "BCACACDABA" &lt;&lt; endl; return 0;&#125; F.陆历川让你A个题题意：问n的阶乘末尾有多少个0。 思路：将n的阶乘进行质因数分解后可以发现，实际影响末尾0的个数的只有因子2和5。而n的阶乘分解质因数后2的个数必定小于等于5的个数，因此只查询有多少个5就可以了。 Mycode：123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e6+7;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t, res, n;int main()&#123; cin &gt;&gt; t; while(t--) &#123; res = 0; cin &gt;&gt; n; while(n) &#123; n /= 5; res += n; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; G.请回答Alice和Bob请移步2017 省赛 山东 A Return of the Nim 【博弈】【Nim+Wythoff】。 H.强哥要置你于死地题意：强哥有n把枪，每个枪有3个属性，当一把枪的这三个属性都大于某一把枪的这三个属性时就称这把枪能完胜那把枪。问有这些枪分别能完胜多少把其他的枪。 思路：三位偏序裸题。 题目原型：BZOJ-3262: 陌上花开 队友补过了，目前不想补。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[山东省第八届ACM大学生程序设计竞赛解题报告【2/11】]]></title>
    <url>%2Fshandong-acm-8%2F</url>
    <content type="text"><![CDATA[A. Return of the Nim 【博弈】【Nim+Wythoff】题意：Sherlock 和 Watson 做游戏，游戏规则如下： 有n堆石子，第i堆石子的个数为pi， Sherlock 先取，有两种取法， 每次每人可取任意一石堆中的任意个数 (当然所取的个数不能超过石堆中石子的个数) 在没有出现空堆的情况下，每次每人可从所有石堆中取相同个数的石子 (当然所取的个数不能超过石堆中所含最少石子的个数) 谁先取完谁赢。告诉你石堆的个数及每堆所含石子的个数，要求你输出胜利者的姓名。 数据范围：$2≤n≤30$且n为素数，$1≤p_i≤10^5$ 解题思路：由数据范围可知n所有可能的取值为2、3、5、7、11、13、17、19、23、29 ①.当n==2时，这是一道典型的wythoff博弈 ②.其余情况，我们做如下讨论： 我们想到，如果把操作2去掉，那么这就是典型的nim博弈，而nim博弈判断先后手胜负是看当前状态是否是平衡态。 1.假设现在是平衡态，即所有数字^的结果为0，也就是先手必败态；执行操作1会破坏平衡态，这时后手只要根据先手所取的石子进行操作一就可使之恢复平衡态。 同样的执行操作二时，假设取走的石子个数为k，k转化为二进制最小的那位1所在位为x，取走k石子后，这位上的所有1都变为0，0都变为1，共n位，且n为奇数，所以这位的所有值^就变为了1；这样也会破坏平衡态，后手也能根据先手所取的石子进行操作使之恢复平衡态。 2.假设现在不是平衡态，则先手可以进行操作1，使现在转换为平衡态。这样不平衡态的先手就转换为了平衡态的后手，和1一样。 以上，符合nim博弈 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int main()&#123; int t, n; int x, y; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); if(n == 2) //Wythoff &#123; scanf("%d%d",&amp;x,&amp;y); if(x &lt; y) //x is the greater one swap(x, y); if(floor((sqrt(5.0) + 1.0) / 2.0 * (x - y)) == y) puts("Watson"); else puts("Sherlock"); &#125; else //Nim &#123; x = 0; while(n--) &#123; scanf("%d",&amp;y); x ^= y; &#125; if(x == 0) puts("Watson"); else puts("Sherlock"); &#125; &#125; return 0;&#125; B. Quadrat 【打表】【规律】题目大意：求满足以下条件 ①.这个数为n位(可以有前导零) ②.取它的平方的后n位，与它本身每一位对应之差≤d(这里的差指的是数字之间的距离，而这个距离是将数字按圈排列，0与9相邻所求得的)的数字的个数。 解题思路：实在是不知道怎么做，最后选择打表看看，然后写出了以下代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int a[15][15];/*&#123; &#123;0,1,2,3,4,5,4,3,2,1&#125;; &#123;1,0,1,2,3,4,5,4,3,2&#125;; &#123;2,1,0,1,2,3,4,5,4,3&#125;; &#123;3,2,1,0,1,2,3,4,5,4&#125;; &#123;4,3,2,1,0,1,2,3,4,5&#125;; &#123;5,4,3,2,1,0,1,2,3,4&#125;; &#123;4,5,4,3,2,1,0,1,2,3&#125;; &#123;3,4,5,4,3,2,1,0,1,2&#125;; &#123;2,3,4,5,4,3,2,1,0,1&#125;; &#123;1,2,3,4,5,4,3,2,1,0&#125;;&#125;;*/LL mypow[] = &#123;1, 10, 100, 1000, 10000, 100000, 1000000, 10000000&#125;;int main()&#123; memset(a, 0, sizeof(a)); for(int i = 0; i &lt;= 9; ++i) &#123; for(int j = 0; j &lt;= 9; ++j) &#123; a[i][j] = abs(i-j); if(a[i][j] &gt; 5) a[i][j] = 10 - a[i][j]; //cout &lt;&lt; a[i][j] &lt;&lt; " "; &#125; //puts(""); &#125; for(int n = 1; n &lt;= 7; ++n) &#123; for(int eps = 0; eps &lt;= 3; ++eps) &#123; int tot = 0; for(int i = 0; i &lt; mypow[n]; ++i) &#123; //cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; int tt = i; LL tm = (i%mypow[n])*(i%mypow[n]); tm %= mypow[n]; int j; for(j = 0; j &lt; n; ++j) &#123; if(a[tm%10][tt%10] &gt; eps) break; tm /= 10; tt /= 10; &#125; if(j == n) &#123; ++tot;// cout &lt;&lt; i &lt;&lt; endl; &#125; &#125; cout &lt;&lt; tot &lt;&lt; " "; //cout &lt;&lt; "tot=" &lt;&lt; tot &lt;&lt; endl; &#125; puts(""); &#125; return 0;&#125; 运行后的结果整理后是这样的：| n\d | 0 | 1 | 2 | 3 || :–: | :–: | :–: | :—-: | :—-: || 1 | 4 | 4 | 8 | 8 || 2 | 4 | 12 | 40 | 56 || 3 | 4 | 36 | 200 | 392 || 4 | 4 | 108 | 1000 | 2744 || 5 | 4 | 324 | 5000 | 192088 || 6 | 4 | 972 | 25000 | 134456 || 7 | 4 | 2916 | 125000 | 941192 | 观察发现，对应的【第i行的第j列的值】等于【第i-1行第j列的值】 $\times$ 【$(j \times 2)-1$】然后打表就可以了，要注意精度哦。 Mycode:123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;LL ans[20][5];void init()&#123; ans[1][0] = ans[1][1] = 4; ans[1][2] = ans[1][3] = 8; for(int n = 2; n &lt;= 18; ++n) for(int d = 0; d &lt;= 3; ++d) ans[n][d] = ans[n-1][d] * (d * 2 + 1);&#125;int main()&#123; init(); int t; int n, d; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d",&amp;n,&amp;d); printf("%lld\n", ans[n][d]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDUT</tag>
        <tag>山东省赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU 1147 Pythagoras's Revenge 【技巧暴力】]]></title>
    <url>%2Fsdnu-1147%2F</url>
    <content type="text"><![CDATA[题目链接：SDNU 1147 Pythagoras’s Revenge 题目大意：给定直角三角形的一直角边，求出各边均为整数的以它为最小边的直角三角形的个数 解题思路：一、【真丶暴力】根据勾股定理可知$a^2+b^2=c^2$我们试着让b从等于a+1开始枚举可能的解，如果枚举出来的c是整数的话，让ans++，最后输出ans。 然而这样枚举的终止条件是什么呢？$10 \times a$ ？ $100 \times a $？ $1000 \times a$ ？ 我一直试到了$10000 \times a​$还是求不全。 显然这样是不行的。 二、【技巧丶暴力】对于$a^2+b^2=c^2$，我们移项可得$a^2=c^2-b^2$，再化，可得$a^2 = (c-b) \times (c+b)$。根据三角形任意两边之和大于第三边、任意两边之差小于第三边可知，令$i=c-b$, $j=c+b$，即$i$ &lt; $a$、$j$ &gt; $a$，且$j - i = 2b$。接下来枚举i就可以了。 Mycode:123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int main()&#123; LL a, b, ans; while(scanf("%lld",&amp;a) &amp;&amp; a) &#123; ans = 0; for(LL i = 1; i &lt; a; ++i) &#123; if(a * a % i == 0) &#123; LL j = a * a / i; if((j-i) % 2 == 0) &#123; b = (j-i) / 2; if(b &gt; a) ++ans; &#125; &#125; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>SDNU</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识点】 ---寻找第n个素数]]></title>
    <url>%2Ffind-prime%2F</url>
    <content type="text"><![CDATA[如何快速找到第n个素数呢？看到这个问题后我的第一思路就是用筛法筛出素数数组。 Mycode:1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 5000005;int pri[MAX];int main()&#123; memset(pri, 0, sizeof(pri)); for(int i = 2; i &lt;= MAX; ++i) &#123; if(!pri[i]) pri[++pri[0]] = i; for(int j = 1; j &lt;= pri[0] &amp;&amp; pri[j] &lt;= MAX / i; ++j) &#123; pri[pri[j]*i] = 1; if(i % pri[j] == 0) break; &#125; &#125; int n; int cas = 0; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; printf("Case %d: %d\n",++cas,pri[n]); &#125; return 0;&#125; 这种方法在n比较小的时候还是快的，但是当n变得很大，比如当n达到3000000时，1s是跑不完的。在此基础上稍微优化一下，多交几遍说不定就卡过去了。经过优化，速度确实快了点： Code：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;using namespace std;typedef long long LL;const int MAX = 50000000;bool vis[MAX];int prim[3100005];int main()&#123; int d = sqrt(1.0*MAX); int s = 0; for(int i = 3; i &lt;= d; i += 2) if(!vis[i]) for(int j = 3*i; j &lt;= MAX; j += 2*i) vis[j] = true; int len = 0; prim[++len] = 2; for(int i = 3; i &lt;= MAX; i += 2) if(!vis[i]) prim[++len] = i; int cas = 0; int n; while(scanf("%d",&amp;n) &amp;&amp; n) printf("Case %d: %d\n",++cas, prim[n]); return 0;&#125; 但是还是达不到更快的要求。怎么办？原来有专门的一种算法，可以很快的解决此问题。原文链接。源代码链接：http://paste.ubuntu.com/24702943/ Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdtr1c++.h&gt;#define MAXN 100#define MAXM 10001#define MAXP 40000#define MAX 400000#define clr(ar) memset(ar, 0, sizeof(ar))#define read() freopen("lol.txt", "r", stdin)#define dbg(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl#define chkbit(ar, i) (((ar[(i) &gt;&gt; 6]) &amp; (1 &lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))#define setbit(ar, i) (((ar[(i) &gt;&gt; 6]) |= (1 &lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))#define isprime(x) (( (x) &amp;&amp; ((x)&amp;1) &amp;&amp; (!chkbit(ar, (x)))) || ((x) == 2))using namespace std;namespace pcf&#123;long long dp[MAXN][MAXM];unsigned int ar[(MAX &gt;&gt; 6) + 5] = &#123;0&#125;;int len = 0, primes[MAXP], counter[MAX];void Sieve()&#123; setbit(ar, 0), setbit(ar, 1); for (int i = 3; (i * i) &lt; MAX; i++, i++) &#123; if (!chkbit(ar, i)) &#123; int k = i &lt;&lt; 1; for (int j = (i * i); j &lt; MAX; j += k) setbit(ar, j); &#125; &#125; for (int i = 1; i &lt; MAX; i++) &#123; counter[i] = counter[i - 1]; if (isprime(i)) primes[len++] = i, counter[i]++; &#125;&#125;void init()&#123; Sieve(); for (int n = 0; n &lt; MAXN; n++) &#123; for (int m = 0; m &lt; MAXM; m++) &#123; if (!n) dp[n][m] = m; else dp[n][m] = dp[n - 1][m] - dp[n - 1][m / primes[n - 1]]; &#125; &#125;&#125;long long phi(long long m, int n)&#123; if (n == 0) return m; if (primes[n - 1] &gt;= m) return 1; if (m &lt; MAXM &amp;&amp; n &lt; MAXN) return dp[n][m]; return phi(m, n - 1) - phi(m / primes[n - 1], n - 1);&#125;long long Lehmer(long long m)&#123; if (m &lt; MAX) return counter[m]; long long w, res = 0; int i, a, s, c, x, y; s = sqrt(0.9 + m), y = c = cbrt(0.9 + m); a = counter[y], res = phi(m, a) + a - 1; for (i = a; primes[i] &lt;= s; i++) res = res - Lehmer(m / primes[i]) + Lehmer(primes[i]) - 1; return res;&#125;&#125;long long solve(long long n)&#123; int i, j, k, l; long long x, y, res = 0; for (i = 0; i &lt; pcf::len; i++) &#123; x = pcf::primes[i], y = n / x; if ((x * x) &gt; n) break; res += (pcf::Lehmer(y) - pcf::Lehmer(x)); &#125; for (i = 0; i &lt; pcf::len; i++) &#123; x = pcf::primes[i]; if ((x * x * x) &gt; n) break; res++; &#125; return res;&#125;int main()&#123; pcf::init(); long long n, res,L,R,M,ca=1; while (scanf("%lld", &amp;n) != EOF) &#123; if(n==0) break; L=2; R=1e8; while(L&lt;R) &#123; M=(L+R)/2; res=pcf::Lehmer(M); if(res&gt;=n) R=M; else L=M+1; &#125; printf("Case %lld: %lld\n",ca++,L); &#125; return 0;&#125; 当然还有大神用了分块筛的方法。那个pos数组是以50000为间隔的前面几个块素数个数，是用之前的代码本地跑出来的，就是说1-5W有多少个素数，1-10w有多少个素数这样子。然后每次输入n找到他在哪个区间内，再单独筛出这个区间内的素数就好了。真的很厉害Orz。源代码链接：http://paste.ubuntu.com/24702950/ Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;string.h&gt;#define MIN(a,b) (((a)&lt;(b))?(a):(b))using namespace std;int pos[1005]= &#123;-1,5133,9592,13848,17984,22044,25997,29977,33860,37706,41538,45322,49098,52831,56543,60238,63951,67617,71274,74907,78498,82134,85714,89302,92938,96469,100021,103544,107126,110630,114155,117663,121127,124634,128141,131608,135072,138542,142029,145502,148933,152382,155805,159250,162662,166081,169511,172873,176302,179684,183072,186462,189880,193256,196645,199993,203362,206789,210109,213453,216816,220136,223492,226835,230209,233577,236900,240230,243539,246909,250150,253412,256726,260064,263397,266717,269987,273322,276611,279921,283146,286490,289774,293010,296314,299583,302824,306084,309335,312666,315948,319164,322441,325706,328964,332219,335439,338694,341992,345235,348513,351715,354971,358198,361407,364685,367900,371131,374362,377574,380800,383979,387202,390378,393606,396826,399993,403204,406429,409672,412849,416040,419246,422449,425648,428816,432073,435265,438410,441562,444757,447955,451159,454337,457497,460707,463872,467055,470283,473470,476648,479864,483015,486167,489319,492494,495666,498797,501962,505147,508261,511417,514565,517740,520910,524026,527154,530334,533506,536652,539777,542898,546024,549150,552319,555479,558597,561766,564877,567967,571119,574274,577439,580566,583714,586850,590006,593112,596222,599355,602489,605556,608672,611788,614917,618057,621177,624298,627400,630495,633578,636697,639851,642962,646054,649175,652265,655355,658445,661520,664579,667709,670820,673927,676970,680063,683178,686262,689382,692486,695609,698703,701795,704895,708007,711108,714154,717257,720341,723457,726517,729577,732707,735767,738873,741941,745001,748066,751131,754189,757288,760391,763455,766554,769639,772706,775773,778818,781906,784991,788060,791111,794149,797261,800285,803358,806435,809487,812601,815674,818703,821750,824801,827884,830940,834026,837099,840169,843192,846205,849252,852291,855281,858338,861401,864446,867482,870532,873606,876616,879640,882652,885698,888762,891833,894877,897938,900996,904057,907101,910077,913098,916147,919203,922193,925237,928293,931330,934441,937446,940455,943484,946551,949506,952566,955599,958651,961694,964695,967720,970704,973739,976761,979764,982776,985807,988851,991880,994839,997817,1000862,1003926,1006966,1009985,1013012,1016026,1019012,1022057,1025092,1028089,1031130,1034115,1037119,1040144,1043113,1046152,1049172,1052140,1055139,1058173,1061198,1064162,1067185,1070198,1073198,1076221,1079266,1082255,1085243,1088266,1091314,1094330,1097360,1100328,1103258,1106267,1109288,1112328,1115323,1118354,1121389,1124405,1127407,1130388,1133364,1136320,1139344,1142298,1145305,1148316,1151367,1154307,1157275,1160273,1163205,1166251,1169267,1172264,1175214,1178218,1181158,1184128,1187148,1190171,1193122,1196133,1199102,1202080,1205065,1208078,1211050,1214027,1216988,1219966,1222953,1225900,1228861,1231859,1234873,1237894,1240833,1243787,1246718,1249710,1252693,1255682,1258685,1261660,1264617,1267631,1270607,1273599,1276577,1279531,1282513,1285456,1288409,1291373,1294356,1297270,1300243,1303229,1306226,1309152,1312179,1315161,1318125,1321065,1324046,1326975,1329943,1332935,1335881,1338865,1341795,1344716,1347749,1350691,1353661,1356600,1359631,1362538,1365511,1368447,1371432,1374421,1377385,1380343,1383291,1386325,1389261,1392272,1395148,1398094,1401007,1403922,1406874,1409821,1412758,1415679,1418640,1421620,1424606,1427535,1430531,1433481,1436398,1439367,1442335,1445279,1448221,1451219,1454144,1457067,1460019,1462950,1465935,1468883,1471822,1474757,1477731,1480683,1483609,1486531,1489509,1492408,1495350,1498253,1501220,1504189,1507122,1510064,1512992,1515935,1518898,1521859,1524831,1527768,1530729,1533657,1536569,1539541,1542459,1545372,1548366,1551302,1554245,1557132,1560093,1562976,1565927,1568845,1571812,1574749,1577649,1580509,1583439,1586387,1589324,1592219,1595177,1598118,1601049,1603985,1606876,1609825,1612775,1615749,1618668,1621590,1624527,1627444,1630379,1633312,1636202,1639094,1642052,1644964,1647911,1650840,1653807,1656761,1659690,1662600,1665517,1668413,1671330,1674240,1677200,1680120,1683065,1685964,1688960,1691876,1694762,1697663,1700558,1703469,1706405,1709342,1712204,1715158,1718134,1721034,1723913,1726899,1729764,1732641,1735590,1738531,1741430,1744400,1747297,1750204,1753058,1756025,1758964,1761886,1764767,1767691,1770613,1773526,1776430,1779363,1782260,1785173,1788065,1790930,1793863,1796762,1799676,1802593,1805472,1808374,1811272,1814112,1817102,1820026,1822944,1825792,1828703,1831616,1834530,1837416,1840359,1843275,1846115,1849029,1852006,1854941,1857859,1860788,1863719,1866645,1869536,1872441,1875367,1878295,1881199,1884021,1886923,1889855,1892785,1895702,1898632,1901520,1904396,1907306,1910248,1913136,1915979,1918857,1921714,1924643,1927488,1930397,1933290,1936209,1939089,1941982,1944833,1947684,1950638,1953525,1956440,1959308,1962184,1965111,1968015,1970912,1973815,1976668,1979564,1982509,1985372,1988254,1991162,1994051,1996958,1999823,2002749,2005638,2008561,2011422,2014337,2017231,2020103,2022944,2025864,2028764,2031667,2034522,2037385,2040293,2043192,2046087,2048989,2051891,2054802,2057701,2060577,2063430,2066324,2069193,2072084,2074966,2077862,2080771,2083678,2086529,2089379,2092244,2095092,2097961,2100791,2103648,2106544,2109362,2112215,2115089,2118001,2120897,2123788,2126637,2129473,2132329,2135232,2138061,2141013,2143883,2146775,2149635,2152470,2155359,2158233,2161146,2163998,2166906,2169775,2172667,2175518,2178423,2181266,2184161,2187043,2189920,2192806,2195671,2198505,2201356,2204262,2207150,2210026,2212915,2215731,2218609,2221543,2224435,2227279,2230137,2233036,2235899,2238778,2241626,2244473,2247300,2250226,2253061,2255897,2258731,2261623,2264514,2267395,2270349,2273189,2276042,2278857,2281732,2284633,2287447,2290350,2293262,2296101,2298985,2301840,2304721,2307562,2310419,2313254,2316107,2318966,2321832,2324728,2327619,2330509,2333367,2336299,2339147,2342005,2344890,2347727,2350582,2353448,2356279,2359142,2362051,2364953,2367814,2370696,2373590,2376402,2379261,2382120,2384990,2387828,2390737,2393630,2396534,2399359,2402242,2405101,2407984,2410827,2413749,2416624,2419434,2422305,2425151,2427981,2430806,2433654,2436487,2439371,2442235,2445078,2447902,2450819,2453695,2456577,2459382,2462273,2465109,2467902,2470746,2473603,2476509,2479409,2482267,2485075,2487886,2490756,2493597,2496476,2499337,2502205,2505030,2507850,2510721,2513534,2516394,2519246,2522092,2524898,2527696,2530575,2533422,2536286,2539186,2542018,2544808,2547620,2550462,2553305,2556175,2559020,2561921,2564807,2567637,2570490,2573319,2576200,2579019,2581841,2584684,2587550,2590386,2593245,2596089,2598870,2601721,2604535,2607331,2610226,2613067,2615907,2618758,2621566,2624440,2627281,2630152,2632997,2635866,2638710,2641508,2644301,2647127,2649982,2652825,2655643,2658487,2661384,2664228,2667036,2669841,2672702,2675523,2678429,2681216,2684053,2686906,2689717,2692570,2695450,2698298,2701159,2703995,2706858,2709644,2712494,2715332,2718160,2721011,2723886,2726718,2729508,2732389,2735255,2738140,2740985,2743838,2746679,2749526,2752380,2755215,2758056,2760896,2763691,2766522,2769407,2772249,2775053,2777902,2780731,2783526,2786355,2789189,2791974,2794837,2797652,2800483,2803324,2806163,2808976,2811853,2814698,2817518,2820355,2823178,2826040,2828852,2831693,2834491,2837271,2840147,2842995,2845792,2848642,2851461,2854302,2857087,2859963,2862777,2865596,2868399,2871207,2874012,2876824,2879677,2882545,2885338,2888144,2890939,2893763,2896598,2899408,2902191,2905025,2907902,2910714,2913488,2916338,2919190,2921977,2924773,2927626,2930404,2933208,2936067,2938896,2941732,2944531,2947349,2950188,2952990,2955834,2958685,2961491,2964316,2967186,2970001,2972862,2975681,2978556,2981364,2984185,2987006,2989825,2992648,2995509,2998299&#125;;bool prime[60000],seive[60000];void seg_seive(int L,int R) //区间筛法&#123; int len=R-L+1; for(int i=0; i&lt;len; i++) prime[i]=1; if(1-L&gt;=0) prime[1-L]=0; //易错因为1不是素数也不是合数，这也是区间筛的一个易错bug for(int i=2; i*i&lt;=R ; i++) &#123; if(seive[i]) &#123; for(int j=max(2,(L-1+i)/i)*i; j&lt;=R; j+=i) //第二个易错点，j必须从大于1，因为L可能小于i，但是seive[i]是素数。 prime[j-L]=false; &#125; &#125;&#125;int main()&#123; for(int i=2; i&lt;50001; i++) seive[i]=1; for(int i=2; i*i&lt;50001; i++) //预处理 if(seive[i]) for(int j=2*i; j&lt;50001; j+=i) seive[j]=false; int n,rl=1; while(~scanf("%d",&amp;n)) &#123; if(n==0)break; int l=0,r=1000; while(l+1&lt;r) &#123; int mid=(l+r)/2; if(pos[mid]&lt;n) l=mid; else r=mid; &#125; int left=l*50000,right=r*50000; int x=n-pos[l]; seg_seive(left,right); //printf("%d %d %d\n",left,right,x); for(int i=left; i&lt;=right; i++) &#123; if(prime[i-left]==1) &#123; x--; if(x==0) &#123; printf("Case %d: %d\n",rl++,i); break; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51Nod 1130 N的阶乘的长度 V2(斯特林近似) 【数学】【斯特林公式】]]></title>
    <url>%2F51nod-1130%2F</url>
    <content type="text"><![CDATA[在进入正试讲解之前我们先来看一道简单点的题目压压惊。 题目链接：51nod 1058 Description：输入N求N的阶乘的10进制表示的长度。例如$6! = 720$，长度为3。 Input输入N($1$ &lt;= $N$ &lt;= $10^6$) Output输出N的阶乘的长度 Input示例6 Output示例3 题目大意：很明确，就是求n！的长度 解题思路：我们知道，对于任意的数n，$len = log10(X) + 1$就是X这个数的长度。当N的值不超过10^6时，直接求的话N的阶乘长度$len = log10(1 \times 2 \times 3 \times 4 \times \ldots \times N) + 1$ $= log10(1) + log10(2) + log10(3) + log10(4) + …… + log10(N) + 1 $。这样实现看起来有点笨拙，不过是可以AC的。 Mycode: 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1005;int main()&#123; int n; cin &gt;&gt; n; double ans = 1; for(int i = 1; i &lt;= n; ++i) &#123; ans += (log10(i)); &#125; cout &lt;&lt; (int)ans &lt;&lt; endl; return 0;&#125; 而对于下面这道题目来说，因为数据范围变大了很多，所以需要考虑用更优的解法了。 题目链接：51nod 1130 Description：输入N求N的阶乘的10进制表示的长度。例如$6! = 720​$，长度为3。 Input第1行：一个数T，表示后面用作输入测试的数的数量。（$1 &lt;= T &lt;= 1000$)第2 - T + 1行：每行1个数N。（$1 &lt;= N &lt;= 10^9$) Output共T行，输出对应的阶乘的长度。 Input示例3456 Output示例233 题目大意：和上道题一样，就是求$n!$的长度，不过数据范围大了很多。 解题思路：有个叫作斯特林公式的神奇公式(可参考百度百科：斯特林公式)，可以利用它进行求解。注意，当$n=1$的时候，上面的公式不适用，所以要单独处理n=1的情况。 这种方法速度很快就可以得到结果。用它来求n!的位数就很easy了。 Mycode: 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1005;const double PI = acos(-1.0);const double EXP = 2.718281828459;int main()&#123; int T; long long n, ans; scanf("%d",&amp;T); while(T--) &#123; scanf("%lld",&amp;n); if(n == 1) &#123; puts("1"); continue; &#125; ans = 0.5*log10(2*PI*n) + n*log10(n*1.0/EXP) + 1; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>51Nod</tag>
        <tag>数学</tag>
        <tag>斯特林公式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EOJ 3256 拼音魔法 【模拟】]]></title>
    <url>%2Feoj-3256%2F</url>
    <content type="text"><![CDATA[Description：魔法学校小学一年级有一种题。就是给一个字的拼音，给一个声调，让你正确地注音。但魔法老师给了巨量的题，你不用魔法根本不可能做完。所以现在要让你发明一种魔法完成这个任务。问题已经讲完了，下面开始教授汉语。（会汉语或者自认为会汉语的可以自动跳过）汉语中一个字的拼音由声母和韵母两部分组成，在极少数情况下也会没有声母，但一定有韵母。一般认为，声母有 b, p, m, f, d, t, l, n, g, k, h, j, q, x, z, c, s, zh, ch, sh, r, y, w；韵母有：a, e, o, i, u, ü, ai, ei, ui, ao, ou, iu, ie, üe, er, an, en, in, un, ün, ang, eng, ing, ong。不是所有的字母都能组合的，组合的时候有时会发生一些神奇的事情，例如 üe 变成了 ue。但是标调规则有如下口诀：有 a 先找 a，没 a 找 o e，i u 并排标在后，这样标调不会错。只有下面列出的元素可能会被标调。请按照下表输出（尤其注意 a 不要输出成 ɑ 了）：第一声：ā ē ī ō ū ǖ。第二声：á é í ó ú ǘ。第三声：ǎ ě ǐ ǒ ǔ ǚ。第四声：à è ì ò ù ǜ。轻声：a e i o u ü。辅助材料：由教育部公布的拼音方案。如果有描述不一致的地方，请以本题描述为准。 Input第一行一个整数T(1≤T≤10^5)。下面T行，每行一个拼音：拼音声调在各个拼音之后，用数字 [1-4] 进行表示。例如 zhong1 guo2。没有数字的说明是轻声，不用标调。按照国际惯例，输入文件全部由 ASCII 编码组成。ü 用 v 来代替。但在输出中，应仍然用 ü 来表示。 Output对于每一组数据，输出 Case x: y。其中 x 是从 1 开始的测试数据编号，y 是一个拼音标调后的答案。注意：对于非 ASCII 字符的输出，请使用 UTF-8 编码。 ExamplesInput5zhong1guo2meque1nv3 OutputCase 1: zhōngCase 2: guóCase 3: meCase 4: quēCase 5: nǚ Note会 C/C++ 的魔法师最可爱了。 Source2017 华东师范大学网赛 题目大意：给你T个拼音以及此拼音的声调，让你对其进行音标的标注。 解题思路：就是按照其要求对将要标记声调的字符进行替换就好了。但是替换的字符有的非ASCII 编码，所以用一个char字符是存不下的，这里我用的string来实现相应的存储。还有几个小细节要注意一下，比如v换为ü，标声调时i u 并排标在后等。 Mycode:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1005;int main()&#123; string ty[5][6] = &#123; &#123;"a","o","e","i","u","ü"&#125;, &#123;"ā","ō","ē","ī","ū","ǖ"&#125;, &#123;"á","ó","é","í","ú","ǘ"&#125;, &#123;"ǎ","ǒ","ě","ǐ","ǔ","ǚ"&#125;, &#123;"à","ò","è","ì","ù","ǜ"&#125; &#125;; int T; int pos, neww, sd; string s; scanf("%d",&amp;T); for(int cas = 1; cas &lt;= T; ++cas) &#123; cin &gt;&gt; s; int len = s.length(); //判断声调 if(s[len-1] == '1') sd = 1; else if(s[len-1] == '2') sd = 2; else if(s[len-1] == '3') sd = 3; else if(s[len-1] == '4') sd = 4; else &#123;sd = 0;len++;&#125; len--; //找应该被标记声调的字母 neww = pos = -1; for(int i = 0; i &lt; len; ++i) &#123; if(s[i] == 'a') &#123; pos = i; neww = 0; break; &#125; else if(s[i] == 'o') &#123; pos = i; neww = 1; &#125; else if(s[i] == 'e' &amp;&amp; ((neww == -1) || (neww &gt;= 2))) &#123; pos = i; neww = 2; &#125; else if(s[i] == 'i' &amp;&amp; ((neww == -1) || (neww &gt;= 3))) &#123; pos = i; neww = 3; &#125; else if(s[i] == 'u' &amp;&amp; ((neww == -1) || (neww &gt;= 3))) &#123; pos = i; neww = 4; &#125; else if(s[i] == 'v' &amp;&amp; ((neww == -1) || (neww &gt;= 5))) &#123; pos = i; neww = 5; &#125; &#125; //开始输出 printf("Case %d: ",cas); for(int i = 0; i &lt; len; ++i) &#123; if(pos == i) &#123; cout &lt;&lt; ty[sd][neww]; &#125; else if(s[i] == 'v') &#123; cout &lt;&lt; "ü"; &#125; else &#123; cout &lt;&lt; s[i]; &#125; &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>EOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5937 Game of Taking Stones 【威佐夫博弈+大数+高精度】]]></title>
    <url>%2Fhdu-5937%2F</url>
    <content type="text"><![CDATA[Problem DescriptionTwo people face two piles of stones and make a game. They take turns to take stones. As game rules, there are two different methods of taking stones: One scheme is that you can take any number of stones in any one pile while the alternative is to take the same amount of stones at the same time in two piles. In the end, the first person taking all the stones is winner.Now,giving the initial number of two stones, can you win this game if you are the first to take stones and both sides have taken the best strategy? InputInput contains multiple sets of test data.Each test data occupies one line,containing two non-negative integers a andb,representing the number of two stones.a and b are not more than $10^{100}$. OutputFor each test data,output answer on one line.1 means you are the winner,otherwise output 0. Sample Input2 1 8 4 4 7 Sample Output0 1 0 Source2016ACM/ICPC亚洲区大连站-重现赛（感谢大连海事大学） 题意：全裸的威佐夫博弈，但是输入的两个数长度长达100位 思路：对于该题，数据范围是10的100次方，还有小数乘法 —-&gt; 黄金分割率需要精确到小数点后100位 —-&gt; 通过二分求解。 威佐夫博弈：a为a、b中较小的数，先手是否会赢 —–&gt; $ \frac{\sqrt5+1}{2} \times (b - a) $ == a ？ lose : win AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.math.BigInteger;import java.math.BigDecimal;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); BigDecimal TWO = BigDecimal.valueOf(2); BigDecimal FIVE = BigDecimal.valueOf(5); BigDecimal EPS = new BigDecimal("-0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"); BigDecimal L = new BigDecimal("2.2360679774997"); BigDecimal R = new BigDecimal("2.2360679774998"); BigDecimal mid = null; while(L.subtract(R).compareTo(EPS) &lt; 0) &#123; mid = L.add(R).divide(TWO); if(mid.multiply(mid).subtract(FIVE).abs().compareTo(EPS.abs()) &lt; 0) break; if(mid.multiply(mid).subtract(FIVE).compareTo(EPS) &lt; 0) L = mid; else R = mid; &#125; BigDecimal GOLD = mid.add(BigDecimal.ONE).divide(TWO); //System.out.println(GOLD); while(scanner.hasNext()) &#123; BigDecimal a = scanner.nextBigDecimal(); BigDecimal b = scanner.nextBigDecimal(); if(a.compareTo(b) &gt; 0) //保证a是小的 &#123; BigDecimal t = a; a = b; b = t; &#125; BigDecimal c = b.subtract(a).multiply(GOLD); BigInteger aa = a.toBigInteger(); BigInteger cc = c.toBigInteger(); if(aa.equals(cc)) System.out.println("0"); else System.out.println("1"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>ICPC</tag>
        <tag>大数</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017_SDNU_ACM-ICPC_Provincial_Team_Selection_Round_2【--完结--】]]></title>
    <url>%2Fsdnu-2017-4%2F</url>
    <content type="text"><![CDATA[山东省第八届acm大学程序设计竞赛山师选拔赛第二场(声明：标题是自己取的，如果有语法错误的话与他人无关) —————————————————————–分割线—————————————————————– Problem_A(最近公共祖先)题意：SDNU的ACM集训队陷入了混乱中，如果你加入，你要成为一个人的小跟班，我们把你跟着的那个人称为“dalao”(/doge)。例如有两个菜鸟C和D加入了，他们的dalao是A，我们就称A是C和D的最近公共dalao。再比如C是E和F的dalao，那么E和C的最近公共dalao就是A。一共n个人，给你n-1组关系，问输入的两个人的最近公共dalao是谁，有的话输出他的名字，没有输出“I am so bad.”(注意一下Hint里的提示：A也是A的daolao 思路：一开始考虑用map来记录这个点的根节点，关系记录完后，不断向上查询，直至找到它的祖先，然后必然的TLE。其实这个题就是个经过封装的求LCA的题目，套上模板就能A了(主要目的应该是让我们学一下LCA吧。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 10010;const int DEG = 20;struct Edge&#123; int to,next;&#125; edge[MAXN*2];int head[MAXN],tot;void addedge(int u,int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;int fa[MAXN][DEG];//fa[i][j]表示结点i的第2^j个祖先int deg[MAXN];//深度数组void BFS(int root)&#123; queue&lt;int&gt;que; deg[root] = 0; fa[root][0] = root; que.push(root); while(!que.empty()) &#123; int tmp = que.front(); que.pop(); for(int i = 1; i &lt; DEG; i++) fa[tmp][i] = fa[fa[tmp][i-1]][i-1]; for(int i = head[tmp]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(v == fa[tmp][0])continue; deg[v] = deg[tmp] + 1; fa[v][0] = tmp; que.push(v); &#125; &#125;&#125;int LCA(int u,int v)&#123; if(deg[u] &gt; deg[v])swap(u,v); int hu = deg[u], hv = deg[v]; int tu = u, tv = v; for(int det = hv-hu, i = 0; det ; det&gt;&gt;=1, i++) if(det&amp;1) tv = fa[tv][i]; if(tu == tv)return tu; for(int i = DEG-1; i &gt;= 0; i--) &#123; if(fa[tu][i] == fa[tv][i]) continue; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;bool flag[MAXN];int main()&#123; int T; int n; int u,v; while(~scanf("%d",&amp;n)) &#123; init(); memset(fa,0,sizeof(fa)); memset(deg,0,sizeof(deg)); memset(flag,false,sizeof(flag)); for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d",&amp;u,&amp;v); addedge(u,v); addedge(v,u); flag[v] = true; &#125; int root; for(int i = 1; i &lt;= n; i++) if(!flag[i]) &#123; root = i; break; &#125; BFS(root); scanf("%d%d",&amp;u,&amp;v); if(LCA(u,v)) printf("%d\n",LCA(u,v)); else puts("I am so bad."); &#125; return 0;&#125; Problem_B(矩阵快速幂)题意：对任意的$(1+\sqrt2) ^ n$我们是否能找到对应的m使得上式化简为$\sqrt{m} + \sqrt{m-1}$，如果有，请输出$m \mod (1e9+7)$的值，没有输出”I want to talk a joke.” 思路：先写几个数字看看什么情况。化简后会看出(整数部分)系数为1、3、7、17……带有$\sqrt{2}$的部分的系数为1、2、5、12……后者数值等于它上一个数的这两部分的系数之和(2=1+1,5=3+2,12=7+5……)，前者的数值等于和他一个数的$\sqrt{2}$的部分的系数+它上一个数的$\sqrt{2}$的部分的系数(3=2+1,7=5+2,17=12+5……)。根据这个规律构造一个四阶矩阵，然后套上模板就可以了。注意每次乘完都要%MOD一下，防止溢出。 关于输出：如果n是奇数的话，就输出(整数部分)系数的^2，否则输出它的^2+1(自己推一推便知道了。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 10010;const int MOD = 1e9 + 7;const int ch = 4;struct matrix&#123; long long mat[ch][ch];&#125;;matrix multiply(matrix a, matrix b) //构造矩阵乘法&#123; int i, j, k; matrix t; memset(t.mat, 0, sizeof(t. mat)); for(i = 0; i &lt; ch; ++i) for(j = 0; j &lt; ch; ++j) for(k = 0; k &lt; ch; ++k) t.mat[i][j] = (t.mat[i][j] + a.mat[i][k]*b.mat[k][j]%MOD) % MOD; return t;&#125;long long fibonacci(long long n)&#123; long long tem = n; n--; matrix base, ans; memset(base.mat, 0, sizeof(base.mat)); memset(ans.mat, 0, sizeof(ans.mat)); base.mat[2][0] = base.mat[2][2] = base.mat[3][1] = base.mat[3][2] = base.mat[3][3] = 1; base.mat[2][3] = 2; ans.mat[0][1] = ans.mat[0][0] = 1; ans.mat[0][2] = 2; ans.mat[0][3] = 3; while(n) &#123; if(n &amp; 1) ans = multiply(ans, base); base = multiply(base, base); n &gt;&gt;= 1; &#125; //cout &lt;&lt; tem &lt;&lt; endl; if(!(tem&amp;1)) return ans.mat[0][1]*ans.mat[0][1]%MOD; return (ans.mat[0][1]*ans.mat[0][1]+1)%MOD;&#125;int main()&#123; long long n; while(cin &gt;&gt; n) cout &lt;&lt; fibonacci(n) &lt;&lt; endl; return 0;&#125; Problem_C(签到题)题意：给定1-n个城市，你处在x位置，求出满足|x-i|&lt;=r的正整数i的可能取到的数。 思路：因为给定了n的范围，所以一共会有4种情况，即左越界，左不越界，右越界，右不越界。4个if，轻松搞定。(我这个人比较懒，用一个for遍历了一遍，符合条件就让ans++，否则不作操作。比较而言当然是前者时间复杂度更低了，比赛时当然是要选择最优解法。 AC代码：1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; double n, r, x; //用int就行 scanf("%d",&amp;t); while(t--) &#123; int ans = 0; scanf("%lf%lf%lf",&amp;n,&amp;r,&amp;x); for(int i = 1; i &lt;= n; ++i) &#123; if(fabs(x-i) &lt;= r) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem_D(线段树单点更新求和+期望公式)题意：在一个长度为n的数组里，分别执行两种操作，1是把位置为x的元素改为y;2是求出区间l到r的方差。 思路：线段树的单点更新及求和，直接套模板就可以。 期望公式：D(x) = E(x^2) - E(x)^2。而求区间的方差此公式经过化简可得，D(x) = num $\times$ sum2 - sum $\times$ sum，其中num是区间的元素总个数，sum2是区间内每个元素的平方求和，sum是区间内的每个元素的和。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1&lt;&lt;16;struct node&#123; int l, r; long long sum, sum2;&#125; tree[MAX&lt;&lt;2];long long a[MAX];long long sum, sum2;void pushup(int rt)&#123; tree[rt].sum = tree[rt&lt;&lt;1].sum + tree[rt&lt;&lt;1|1].sum; tree[rt].sum2 = tree[rt&lt;&lt;1].sum2 + tree[rt&lt;&lt;1|1].sum2;&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; tree[rt].sum = 0; if(l == r) &#123; tree[rt].sum = a[l]; tree[rt].sum2 = a[l]*a[l]; return ; &#125; int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; //递归建树 build(l, mid, rt&lt;&lt;1); build(mid+1, r, rt&lt;&lt;1|1); pushup(rt);&#125;void update(int x, int y, int rt)&#123; //更新这个区间的值 if(tree[rt].l == tree[rt].r) &#123; tree[rt].sum = y; tree[rt].sum2 = y*y; return ; &#125; int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(x &lt;= mid) update(x, y, rt&lt;&lt;1); else update(x, y, rt&lt;&lt;1|1); pushup(rt);&#125;void query(int x, int y, int rt)&#123; if(tree[rt].l == x &amp;&amp; tree[rt].r == y) &#123; sum += tree[rt].sum; sum2 += tree[rt].sum2; return ; &#125; int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(y &lt;= mid) query(x, y, rt&lt;&lt;1); else if(x &gt; mid) query(x, y, rt&lt;&lt;1|1); else &#123; query(x, mid, rt&lt;&lt;1); query(mid+1, y, rt&lt;&lt;1|1); &#125;&#125;int main()&#123; int n, m; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= n; ++i) scanf("%lld",&amp;a[i]); build(1, n, 1); while(m--) &#123; int q; scanf("%d",&amp;q); if(q == 1) &#123; int pos, num; scanf("%d%d",&amp;pos,&amp;num); update(pos, num, 1); &#125; else &#123; int l, r; sum = sum2 = 0; scanf("%d%d",&amp;l,&amp;r); query(l, r, 1); long long ans = (r-l+1)*sum2 - sum*sum; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; Problem_E(最短路)题意：告诉你一系列的公交线路，问能否从1号站到m号站，如果能，输出最少的换乘次数，不能输出-1。 思路：建图。把任一公交线路中任意两点能到达的位置距离设置为1，这样条件都结束后不能到达的位置距离就是INF。然后转化为最短路问题解决就行了。 对输入的处理：每行结束的标志是’\n’，可以用gets读入一行后把数字当作字符挨个处理；其他人也有用scanf(“%d%c”,&amp;d,&amp;ch)这样读入的，当ch==’\n’时break;也可以像我一样用stringstream。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 510;int n;int adj[MAX][MAX];int a[MAX], dis[MAX];bool vis[MAX];void init()&#123; for(int i = 1; i &lt;= 500; ++i) &#123; for(int j = 1; j &lt;= 500; ++j) &#123; if(i == j) adj[i][j] = 0; else adj[i][j] = INF; &#125; &#125;&#125;void Dij()&#123; int tem, minx; memset(vis, false, sizeof(vis)); for(int i = 0; i &lt;= n; ++i) dis[i] = adj[1][i]; dis[1] = 0; vis[1] = true; for(int i = 1; i &lt; n; ++i) &#123; minx = INF; for(int j = 1; j &lt;= n; ++j) &#123; if(!vis[j] &amp;&amp; dis[j] &lt; minx) &#123; minx = dis[j]; tem = j; &#125; &#125; if(minx == INF) break; vis[tem] = 1; for(int j = 1; j &lt;= n; ++j) &#123; if(!vis[j] &amp;&amp; adj[tem][j] != INF &amp;&amp; dis[tem] + adj[tem][j] &lt;dis[j]) &#123; dis[j] = adj[tem][j] + dis[tem]; &#125; &#125; &#125;&#125;int main()&#123; int t; int item; string stem, s; while(~scanf("%d",&amp;t)) &#123; init(); scanf("%d",&amp;n); getchar(); while(t--) &#123; int cou = 0; getline(cin, stem); stringstream ss (stem); while(ss &gt;&gt; item) &#123; a[cou++] = item; &#125; for(int i = 0; i &lt; cou-1; ++i) for(int j = i+1; j &lt; cou; ++j) &#123; adj[a[i]][a[j]] = 1; &#125; &#125; Dij(); if(dis[n] == INF) cout &lt;&lt; "-1" &lt;&lt; endl; else cout &lt;&lt; dis[n]-1 &lt;&lt; endl; &#125; return 0;&#125; Problem_F(思维)题意：一群美女排成一排，各有各的颜值。现在GOD超要从中选取一些连续排列的美女，要求他们的颜值满足先增大后减小。如果有，依次输出起点美女和重点美女的坐标；多组的话输出长度最长的那组的两个下标；没有符合题意的输出-1 -1。 思路：之前做过一个合唱队列的题目(要求求出最长先严格上升后严格下降的子序列的长度，我从头到尾求了每个点作为终点的最长上升子序列的长度，从尾往前求出了每个点作为终点的最长上升子序列的长度，然后遍历一遍求出最大的两者之和-1的值)，开始以为是类似的，觉得有点麻烦，就略过了(而队友一直在调E，以至于到了最后也没做)。赛后看了看发现一个for循环就能解决。具体做法是从前往后遍历，让起点定位在第一个位置，开始下降后把终点定位。碰到再上升，就把之前的符合条件的与当前已有的答案比较，保留最优解。重复此过程直至遍历结束。详见代码。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 5e6 + 5;int a[N];int main()&#123; int n; bool flag; int ans1, ans2, tem1, tem2; while(~scanf("%d",&amp;n)) &#123; flag = true; ans1 = ans2 = -1; tem1 = 0; tem2 = -1; for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); for(int i = 1; i &lt; n; ++i) &#123; if(a[i-1] == a[i]) &#123; if(tem2 - tem1 &gt; ans2 - ans1)//更新答案 &#123; ans2 = tem2; ans1 = tem1; &#125; tem1 = tem2 = -1; continue; &#125; if(a[i-1] &lt; a[i]) //上升 &#123; if(!flag) &#123; if(tem2 - tem1 &gt; ans2 - ans1)//更新答案 &#123; ans2 = tem2; ans1 = tem1; &#125; flag = 1; tem1 = tem2 = -1; &#125; if(tem1 == -1) tem1 = i-1; //cout &lt;&lt; i &lt;&lt; "--" &lt;&lt; tem1 &lt;&lt; endl; &#125; else &#123; flag = 0; if(tem1 != -1) tem2 = i; &#125; if(tem2 - tem1 &gt; ans2 - ans1)//更新答案 &#123; ans2 = tem2; ans1 = tem1; &#125; &#125; if(ans1 != -1 &amp;&amp; ans2 != -1) cout &lt;&lt; ans1 &lt;&lt; " " &lt;&lt; ans2 &lt;&lt; endl; else cout &lt;&lt; "-1 -1" &lt;&lt; endl; &#125; return 0;&#125; Problem_G(并查集)题意：在一块1000$\times$1000的土地上施工，每周选择一块土地使这块土地由海洋变为陆地。问经过n周后，一共有多少块岛屿(上下左右相连接的属于一块)，岛屿面积是多少以及岛屿的周长。 思路：施工n次，假设每次开辟的新岛屿周围都没有与之相连接的岛屿，所以岛屿个数+1，面积+1，周长+4。然后再判断它周围是否有可以与之相连的岛屿，上下左右四个方向逐个判断，再将相连接的个数相减就好了。具体减的方法很简单，此处不再赘述，如有疑问，欢迎私戳。 并查集：用来快速判断两者是否属于同一个集合的工具，因为所给的数据范围不是很大，所以可以用f[x$\times$MAX+y]来表示点(x,y)所属的集合，这里转化完后就与普通的并查集没啥区别了。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int MAX = 1000;int tot, area, peri, cou;int f[MAX*MAX+5]; //记录是否联通char mapa[MAX+5][MAX+5]; //存图int dir[][2] = &#123;0,1,0,-1,1,0,-1,0&#125;;void init()&#123; for(int i = 0; i &lt;= MAX*MAX; ++i) &#123; f[i] = i; &#125;&#125;int getf(int v)&#123; if(f[v] != v) f[v] = getf(f[v]); return f[v];&#125;int merg(int u, int v)&#123; int t1 = getf(u); int t2 = getf(v); /*cout &lt;&lt; u &lt;&lt; "--" &lt;&lt; v &lt;&lt; endl; cout &lt;&lt; t1 &lt;&lt; "----" &lt;&lt; t2 &lt;&lt; endl &lt;&lt; endl;*/ if(t1 != t2) &#123; f[t2] = t1; return 1; //与周围的岛屿之前不连通 &#125; return 0;&#125;void solve(int x, int y)&#123; int xx, yy; for(int i = 0; i &lt; 4; ++i) &#123; xx = x + dir[i][0]; yy = y + dir[i][1]; if(xx &lt; 0 || xx &gt;= MAX || yy &lt; 0 || yy &gt; MAX) continue; if(mapa[xx][yy] != '#') continue; //cout &lt;&lt; xx &lt;&lt; "---" &lt;&lt; yy &lt;&lt; endl; if(merg(x*MAX+y, xx*MAX+yy)) //联通成功，总岛屿数-1 &#123; tot--; &#125; peri -= 2; //周围有一个岛屿的话，周长-2 &#125;&#125;int main()&#123; int t; int x, y; while(~scanf("%d",&amp;t)) &#123; init(); tot = area = peri = 0; memset(mapa, 0, sizeof(mapa)); while(t--) &#123; scanf("%d%d",&amp;x,&amp;y); if(mapa[x][y] == '#') &#123; cout &lt;&lt; tot &lt;&lt; " " &lt;&lt; area &lt;&lt; " " &lt;&lt; peri &lt;&lt; endl; continue; &#125; //先假设新加入的岛屿与其他都不连通 tot++; area++; peri += 4; mapa[x][y] = '#'; //开始做减法 solve(x, y); cout &lt;&lt; tot &lt;&lt; " " &lt;&lt; area &lt;&lt; " " &lt;&lt; peri &lt;&lt; endl; &#125; &#125; return 0;&#125; Problem_H(博弈+大数)题意：理解后可以改为两个人取石子，规则是每次可以取1-4个，谁先取到最后一块谁就能赢，A先取。 思路：很显然，当n∈[1,4]时，A必赢；n=5时，A必输。因为两人都采取最优策略，所以当n∈[6,9]时，A可以取到使石子数目剩余为5，这样他就必赢，而当n=10时，B就必赢了……总结一下得出结论，所给的石子总数为5的倍数时，B必赢，否则A必赢。另外，数据有点大，考虑到了用JAVA。不过鉴于这个数据的特殊性，是5的倍数，用C++的话只要判断最后一位数是否是5或0就好了，想到了会更加轻松。(这里C++的就不贴了 AC代码(JAVA)：12345678910111213141516171819202122import java.math.BigInteger;import java.math.BigDecimal;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T; BigInteger n; BigInteger MOD = new BigInteger("5"); T = scanner.nextInt(); while((T--) &gt; 0) &#123; n = scanner.nextBigInteger(); if(n.mod(MOD).compareTo(BigInteger.ZERO) == 0) System.out.println("chaochao"); else System.out.println("huahua"); &#125; &#125;&#125; Problem_I(素数打表)题意：给你一个偶数x，让你判断这个偶数能否用两个素数(a、b)之差表示出来(a-b=x)，能的话根据b的大小输出最小的一组，不能的话输出FAIL 思路：任一大于2的偶数都可写成两个质数之和(哥德巴赫猜想)，这道题自己想一下就会知道不会出现FAIL的情况。因为数据比较大，所以打两个表：第一个vis判断是否是素数，第二个a记录可能用到的素数。然后对于给定的x，依次将a[i]从第一个往后遍历，如果x+a[i]是素数那就输出他们，结束遍历。(这里不得不单独吐槽一下出题人→_→，题面的数据范围给小了，比赛时改了数据。赛后改了题面，做了这两天，让我WA到怀疑人生。看别人过了，更忍不了了，下载测试数据对拍后才发现，出题人标程没改，那个A了的是错的。难受。。后来那个lazy的出题人把数据范围缩小了╮(╯_╰)╭rejudge后轻松AC) AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1500005;int a[MAX], tot;bool vis[MAX];void init()//筛法求a数组&#123; memset(vis, false, sizeof(vis)); //vis[0] = vis[1] = true; tot = 0; int M = sqrt(MAX+0.5); for(int i = 2; i &lt;= M; ++i) &#123; if(!vis[i]) &#123; a[tot++] = i; for(int j = i*i; j &lt;= MAX; j += i) &#123; vis[j] = true; &#125; &#125; &#125;&#125;int main()&#123; init(); int t, n; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); for(int i = 0; i &lt; tot; ++i) &#123; if(!vis[n+a[i]]) &#123; cout &lt;&lt; n+a[i] &lt;&lt; " " &lt;&lt; a[i] &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; Problem_J(贪心)题意：有一块肉重为n，每切一次消耗n的体力，要求切成所给的t块重为a[i]的肉，问消耗的最小体力是多少。 思路：倒着想，根据所给的每块小肉，将它们合并为一块大肉，每次合并消耗所要合并的两块肉的重量之和。因为求最小的消耗体力，而最小的两块合并后不一定是最小的了，所以每次取完后都得重新排一次序。因之前后面的序列都已有序，直接用sort会造成大量的时间浪费，所以我可以用依次往后交换直到后面的数大于等于要交换的这个数为止。当然能用上优先队列的话就不用每次都重新排序了。 相似(?：石子合并简化版，每次取最大的合并，这样合并完后不用再排序，直接继续取就OK。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 20005;long long a[MAX];int main()&#123; int n; long long ans; while(~scanf("%d",&amp;n)) &#123; ans = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a, a+n); int tot = 1; while(tot &lt; n) &#123; a[tot] = a[tot] + a[tot-1]; ans += a[tot]; for(int i = tot; i &lt; n-1; ++i) &#123; if(a[i] &lt;= a[i+1]) break; swap(a[i], a[i+1]); &#125; tot++; /*cout &lt;&lt; " tot=" &lt;&lt; tot &lt;&lt; endl; for(int i = 0; i &lt; n; ++i) cout &lt;&lt; a[i] &lt;&lt; " "; cout &lt;&lt; endl;*/ &#125; //cout &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; AC代码(priority_queue)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;struct cmp //自定义优先级&#123; bool operator () (long long &amp;a, long long &amp;b) const &#123; //最小值优先 return a &gt; b; &#125;&#125;;int main()&#123; int n; long long ans, tem; priority_queue&lt;long long, vector&lt;long long&gt;, cmp &gt;pq; //因为priority_queue中有已经定义好的越小的整数优先级越大，所以可以直接调用 //priority_queue&lt;long long, vector&lt;long long&gt;, greater&lt;long long&gt; &gt;pq; while(~scanf("%d",&amp;n)) &#123; ans = 0; while(!pq.empty()) pq.pop(); while(n--) &#123; scanf("%lld",&amp;tem); pq.push(tem); &#125; while(!pq.empty()) &#123; tem = pq.top(); pq.pop(); if(pq.empty()) break; //cout &lt;&lt; "tem=" &lt;&lt; tem &lt;&lt; endl; tem += pq.top(); pq.pop(); //cout &lt;&lt; "tem2=" &lt;&lt; tem &lt;&lt; endl; ans += tem; pq.push(tem); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; —————————————————————–分割线—————————————————————– 选拔赛结束了，虽然以排名比较靠前的成绩进了正式队，但是心里很是不甘，特别是这一次，很多能做的题都没做出来，还有一开始I的数据范围看错+打表打错，浪费了太多时间也影响了整体士气(我的锅。还剩25天了，多学知识的同时也要修炼自己沉稳的性格，不管结果如何，不留遗憾就好。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017_SDNU_ACM-ICPC_Provincial_Team_Selection_Round_1【--完结--】]]></title>
    <url>%2Fsdnu-2017-3%2F</url>
    <content type="text"><![CDATA[山东省第八届acm大学程序设计竞赛山师选拔赛第一场(声明：标题是自己取的，如果有语法错误的话与他人无关) —————————————————————–分割线—————————————————————– Problem_A(大数判定2幂数)题意：给定一个数，判断它是否是2的n次方(0 &lt; n &lt; $2 ^ {1000}$) 按二进制考虑的话，如果n&amp;(n-1)==0，则这个数就是2的n次方,等于1就不是。 AC代码(JAVA版)： 1234567891011121314151617181920212223import java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T; BigInteger N; BigInteger ZERO = new BigInteger("0"); BigInteger ONE = new BigInteger("1"); T = scanner.nextInt(); for(int i = 0; i &lt; T; ++i) &#123; N = scanner.nextBigInteger(); BigInteger M = N.subtract(ONE); if(N.and(M).compareTo(ZERO) == 0) System.out.println("Yes"); else System.out.println("No"); &#125; &#125;&#125; Problem_B(离散化裸题)有些数据本身很大，自身无法作为数组的下标保存对应的属性。如果这时只是需要这堆数据的相对属性时，那么就可以对其进行离散化。所谓离散化就是指当数据只与它们之间的相对大小有关，而与具体是多少无关时可以用到的一种方法(？ 举个例子来说，假设有4个数：1234567、123456789、12345678、123456排序后是123456＜1234567＜12345678＜123456789（只考虑他们相对大小可以想为1＜2＜3＜4），那么这四个数可以表示成：2、4、3、1。 对数据进行离散化如果用上STL会很棒棒哦（思路：先排序，再去重，然后索引元素离散化后对应的值，详见代码）。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 2002;bool flag[N][N];long long x[N], y[N];long long xx[N], yy[N];int main()&#123; int n; scanf("%d",&amp;n); memset(flag, false, sizeof(flag)); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%lld%lld%lld%lld",&amp;xx[i],&amp;yy[i],&amp;xx[i+n],&amp;yy[i+n]); //输入的同时对数据进行离散化 x[2*i] = xx[i+n]; y[2*i] = yy[i+n]; x[2*i-1] = xx[i]; y[2*i-1] = yy[i]; &#125; //排序去重 sort(x+1, x+1+2*n); sort(y+1, y+1+2*n); unique(x+1, x+1+2*n); unique(y+1, y+1+2*n); //索引元素离散化后对应的值 for(int i = 1; i &lt;= 2*n; ++i) &#123; xx[i] = upper_bound(x+1, x+1+2*n, xx[i]) - (x+1); yy[i] = upper_bound(y+1, y+1+2*n, yy[i]) - (y+1); &#125; for(int k = 1; k &lt;= n; ++k) for(int i = xx[k]+1; i &lt;= xx[k+n]; ++i) //从xx[k]+1开始 for(int j = yy[k]+1; j &lt;= yy[k+n]; ++j)//从yy[k]+1开始 flag[i][j] = true; long long ans = 0; for(int i = 2; i &lt;= 2*n; ++i) for(int j = 2; j &lt;= 2*n; ++j) if(flag[i][j]) ans += (x[i]-x[i-1])*(y[j]-y[j-1]);//是y[j]-y[j-1] cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Problem_C(最长回文子串)题意：给定一序列，输出其最长回文子序列的长度。 思路：没有思路，Manacher模板一套带走。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e6+5;char MA[MAX*2];int MP[MAX*2];void Manacher(char s[], int len)&#123; int l = 0; MA[l++] = '$'; MA[l++] = '#'; for(int i = 0; i &lt; len; ++i) &#123; MA[l++] = s[i]; MA[l++] = '#'; &#125; MA[l] = 0; int mx = 0, id = 0; for(int i = 0; i &lt; l; ++i) &#123; MP[i] = mx &gt; i ? min(MP[2*id-i], mx-i) : 1; while(MA[i+MP[i]] == MA[i-MP[i]]) MP[i]++; if(i+MP[i]&gt;mx) &#123; mx = i + MP[i]; id = i; &#125; &#125;&#125;char s[MAX];int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; scanf("%s",s); int len = strlen(s); Manacher(s, len); int ans = 0; for(int i = 0; i &lt; 2*len+2; ++i) ans = max(ans, MP[i]-1); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem_D(多重背包)题意：有n个面值为A1,A2,..An,数量为C1,C2,..Cn的n个硬币，问他们之间互相组合能凑出多少种总面额小于m的面值 (可参照POJ的男人八题之Coins AC代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100000 + 5;int A[105], C[105];int DP[MAX]; //面额为A[i]的硬币在DP[i]位置用过的个数bool vis[MAX];//能凑成的面额int main()&#123; int N, M; while(scanf("%d%d",&amp;N,&amp;M) &amp;&amp; (N||M)) &#123; memset(vis, false, sizeof(vis)); for(int i = 1; i &lt;= N; ++i) scanf("%d",&amp;A[i]); for(int i = 1; i &lt;= N; ++i) scanf("%d",&amp;C[i]); vis[0] = true; for(int i = 1; i &lt;= N; ++i) &#123; memset(DP, 0, sizeof(DP)); for(int j = 1; j &lt;= M; ++j) &#123; //没有凑成过并且现在硬币的面额比要凑的面额大 if(vis[j] || j &lt; A[i]) continue; if(vis[j-A[i]] &amp;&amp; DP[j-A[i]]&lt;C[i]) &#123; vis[j] = true; //cout &lt;&lt; j &lt;&lt; " "; DP[j] = DP[j-A[i]] + 1; &#125; &#125; &#125; //cout &lt;&lt; endl; int ans = 0; for(int i = 1; i &lt;= M; ++i) if(vis[i]) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem_E（思维 签到）题意：给定n个数，从中抽取3个，将它们分成4组，问能否使每组的和相同。能的话输出抽取的三个数的位置，不能就输出I am done. 思路：设置i,j,k三个指针，一开始放在2,4,6这三个位置，然后不断判断分成的四组数据和是否相同，不同就找出其中最小的那一组，让他后面的指针往后移动。还有些小细节，比如k指针到头了，四组的值都相同了等等，自己处理一下就好了。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1005;int a[MAX];int MIN(int a, int b, int c, int d)&#123; if(a &lt;= b &amp;&amp; a &lt;= c &amp;&amp; a &lt;= d) return 1; if(b &lt;= a &amp;&amp; b &lt;= c &amp;&amp; b &lt;= d) return 2; if(c &lt;= a &amp;&amp; c &lt;= b &amp;&amp; c &lt;= d) return 3; if(d &lt;= a &amp;&amp; d &lt;= b &amp;&amp; d &lt;= c) return 4; return 0;&#125;int main()&#123; int n; int x, y, z; int ans1, ans2, ans3, ans4; while(~scanf("%d",&amp;n)) &#123; for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); bool flag = 1; if(n &lt; 7) flag = 0; if(flag) &#123; ans1 = ans2 = ans3 = ans4 = 0; x = 1; y = 3; z = 5; ans1 = a[0]; ans2 = a[2]; ans3 = a[4]; for(int i = 6; i &lt; n; ++i) ans4 += a[i]; while(flag) &#123; if(ans1 == ans2 &amp;&amp; ans1 == ans3 &amp;&amp; ans1 == ans4) break; int ans = MIN(ans1, ans2, ans3, ans4); switch(ans) &#123; case 0: case 4: flag = 0; break; case 1: x++; case 2: y++; case 3: z++; break; &#125; ans1 = ans2 = ans3 = ans4 = 0; for(int i = 0; i &lt; x; ++i) ans1 += a[i]; for(int i = x+1; i &lt; y; ++i) ans2 += a[i]; for(int i = y+1; i &lt; z; ++i) ans3 += a[i]; for(int i = z+1; i &lt; n; ++i) ans4 += a[i]; &#125; &#125; if(flag) cout &lt;&lt; x+1 &lt;&lt; " " &lt;&lt; y+1 &lt;&lt; " " &lt;&lt; z+1 &lt;&lt; endl; else cout &lt;&lt; "I am done." &lt;&lt; endl; &#125; return 0;&#125; Problem_F(八进制减法)题意：八进制减法 AC代码(C++–模拟)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/*************Author:E6ther*************/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; while(~scanf("%d",&amp;t)) &#123; getchar(); for(int j=0;j&lt;t;++j) &#123; char a[105],b[105]; int len1=0,len2=0; bool flag=1; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); char c; while((c=getchar())!=' '&amp;&amp;c!='\n') &#123; a[len1]=c-'0'; len1++; &#125; a[len1]=0; while((c=getchar())!=' '&amp;&amp;c!='\n') &#123; b[len2]=c-'0'; len2++; &#125; b[len2]=0; /*for(int i=0;i&lt;len1;++i) &#123; printf("%d",a[i]); &#125;cout&lt;&lt;endl; for(int i=0;i&lt;len2;++i) &#123; printf("%d",b[i]); &#125;cout&lt;&lt;endl;*/ //printf("%s %s\n",a,b); if(len1&gt;len2) &#123; flag=1; &#125; else if(len1&lt;len2) &#123; flag=0; &#125; else &#123; for(int i=0;i&lt;len1;++i) &#123; if(a[i]&gt;b[i]) &#123; flag=1; break; &#125; else if(a[i]&lt;b[i]) &#123; flag=0; break; &#125; &#125; &#125; if(flag) &#123; for(int i=len2-1,j=len1-1;i&gt;=0;--i,--j) &#123; if(a[j]&gt;=b[i]) &#123; a[j]=a[j]-b[i]; &#125; else &#123; a[j]=a[j]+8-b[i]; if(a[j-1]) a[j-1]--; else &#123; int flag2=0; for(int x=j-2;x&gt;=0;--x) &#123; if(a[x]) &#123; a[x]--; flag2=1; &#125; a[x+1]=7; if(flag2) break; &#125; &#125; &#125; &#125; &#125; else &#123; for(int i=len1-1,j=len2-1;i&gt;=0;--i,--j) &#123; if(a[i]&lt;=b[j]) &#123; b[j]=b[j]-a[i]; &#125; else &#123; b[j]=b[j]+8-a[i]; if(b[j-1]) b[j-1]--; else &#123; int flag2=0; for(int x=j-2;x&gt;=0;--x) &#123; if(b[x]) &#123; b[x]--; flag2=1; &#125; b[x+1]=7; if(flag2) break; &#125; &#125; &#125; &#125; &#125; bool flag1=0; if(flag) &#123; for(int i=0;i&lt;len1;++i) &#123; if(a[i]) flag1=1; if(flag1) printf("%d",a[i]); &#125; if(!flag1) cout&lt;&lt;"0"; &#125; else &#123; cout&lt;&lt;"-"; for(int i=0;i&lt;len2;++i) &#123; if(b[i]) flag1=1; if(flag1) printf("%d",b[i]); &#125; &#125; cout&lt;&lt;endl; &#125; &#125; return 0;&#125; AC代码(JAVA):12345678910111213141516171819202122import java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int T; Scanner scanner = new Scanner(System.in); T = scanner.nextInt(); BigInteger N, M, X, Y; for(int i = 0; i &lt; T; ++i) &#123; N = scanner.nextBigInteger(); M = scanner.nextBigInteger(); X = new BigInteger(N.toString(),8); Y = new BigInteger(M.toString(),8); X = X.subtract(Y); System.out.println(X.toString(8)); &#125; &#125;&#125; Problem_G(模拟)题意：给你n个数，输出对他们进行第一次快速排序后的结果。不知道快速排序的话，自己去搜(其实不知道也没关系，题目里已经给出了排序的方式了，按照它的来就是了)。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 10005;int a[MAX];void solve(int n)&#123; int tem = a[0]; int l = 0, r = n; while(l &lt;= r) &#123; for(--r; l &lt;= r; --r) &#123; if(a[r] &lt; tem) &#123; a[l] = a[r]; break; &#125; &#125; for(++l; l &lt;= r; ++l) &#123; if(a[l] &gt; tem) &#123; a[r] = a[l]; break; &#125; &#125; &#125; a[--l] = tem;&#125;int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; memset(a, 0, sizeof(a)); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); solve(n); for(int i = 0; i &lt; n; ++i) &#123; if(i) cout &lt;&lt; " "; cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Problem_H(大素数判定)题意：给你n个数，输出他们中素数的个数。要用到Miller-rabin算法，套个模板就好了。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;using namespace std;const int S = 8;//随机算法判定次数，一般8~10次就够了//计算ret = (a*b)%c a, b, c &lt; 2^63long long mult_mod(long long a, long long b, long long c)&#123; a %= c; b %= c; long long ret = 0; long long tem = a; while(b) &#123; if(b &amp; 1) &#123; ret += tem; if(ret &gt; c) ret -= c;//直接取模慢很多 &#125; tem &lt;&lt;= 1; if(tem &gt; c) tem -= c; b &gt;&gt;= 1; &#125; return ret;&#125;//计算 ret = (a^n) % modlong long pow_mod(long long a, long long n, long long mod)&#123; long long ret = 1; long long tem = a % mod; while(n) &#123; if(n &amp; 1) ret = mult_mod(ret, tem, mod); tem = mult_mod(tem, tem, mod); n &gt;&gt;= 1; &#125; return ret;&#125;// 通过 a^(n-1)=1(mod n)来判断n是不是素数// n-1 = x * 2^t 中间使用二次判断// 是合数返回true，不一定是合数返回falsebool check(long long a, long long n, long long x, long long t)&#123; long long ret = pow_mod(a, x, n);//a^x % n long long last = ret; for(int i = 1; i &lt;= t; ++i)//进行t次(a^x % n)^2 % n &#123; ret = mult_mod(ret, ret, n); if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true;//合数 last = ret; &#125; if(ret != 1) return true; return false;//不一定是合数&#125;//**************************************************// Miller_Rabin算法// 是素数返回true,(可能是伪素数)// 不是素数返回false//**************************************************bool Miller_Rabin(long long n)&#123; if(n &lt; 2) return false; if(n == 2) return true; if( (n&amp;1) == 0) return false;//偶数 long long x = n - 1; long long t = 0; while( (x&amp;1) == 0) //将n分解为x*2^t; &#123; x &gt;&gt;= 1; t++; &#125; srand( time(NULL)); for(int i = 0; i &lt; S; ++i) &#123; long long a = rand()%(n-1) + 1;//产生随机数a(并控制其范围在1 ~ n-1之间) if(check(a, n, x, t))//是合数 return false; &#125; return true;&#125;int main()&#123; int t, ans; long long tem; scanf("%d",&amp;t); ans = 0; while(t--) &#123; scanf("%lld",&amp;tem); if(Miller_Rabin(tem)) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU ACM-ICPC 2016-2017 Training Weekly Contest 2 【--完结--】]]></title>
    <url>%2Fsdnu-2017-2%2F</url>
    <content type="text"><![CDATA[题目链接：https://vjudge.net/contest/153814 A - An ant’s story(思维)HDU - 3343 感觉特别坑的一道题目，只要蚂蚁爬的速度&gt;0，它就能到终点，用到了极限思想？不明觉厉..GG.. AC代码：1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; int a, b, c; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(b &gt; 0) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125; B - War Chess(BFS&lt;用到优先队列&gt;)HDU - 3345 BFS好题，当时做的时候不是TLE就是MLE。赛后我重新写还是MLE（喵喵喵？ 后来问了一下陆历川大哥，他说得用优先队列，能用优先队列的就别用队列，然后给我发了个优先队列的讲解博客地址。又学到了新东西啊.. AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int MAX = 105;int n, m, v;int dir[][2] = &#123;0,1,1,0,-1,0,0,-1&#125;;char mapa[MAX][MAX], newa[MAX][MAX];bool vis[MAX][MAX], eme[MAX][MAX];struct node&#123; int x, y, v; bool operator &lt; (const node &amp;a) const &#123; return v &lt; a.v;//v大的优先 &#125;&#125; q, p;bool ok()&#123; if(p.x &lt; 0 || p.y &lt; 0 || p.x &gt;= n || p.y &gt;= m) return false; if(!p.v || vis[p.x][p.y] || mapa[p.x][p.y] == '#' || mapa[p.x][p.y] == 'E') return false; if(mapa[p.x][p.y] == '.' || mapa[p.x][p.y] == 'P') p.v -= 1; else if(mapa[p.x][p.y] == 'T') p.v -= 2; else if(mapa[p.x][p.y] == 'R') p.v -= 3; if(p.v &lt; 0) return false; if(eme[p.x][p.y]) p.v = 0; return true;&#125;void bfs()&#123; priority_queue&lt;node&gt; Q; Q.push(q); while(!Q.empty()) &#123; q = Q.top(); Q.pop(); for(int i = 0; i &lt; 4; ++i) &#123; p.x = q.x + dir[i][0]; p.y = q.y + dir[i][1]; p.v = q.v; if(ok()) &#123; vis[p.x][p.y] = 1; if(mapa[p.x][p.y] != 'P') newa[p.x][p.y] = '*'; Q.push(p); &#125; &#125; &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; memset(vis, 0, sizeof(vis)); memset(eme, 0, sizeof(eme)); scanf("%d%d%d",&amp;n, &amp;m, &amp;v); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s",mapa[i]); strcpy(newa[i], mapa[i]); &#125; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) &#123; if(mapa[i][j] == 'Y') &#123; vis[i][j] = 1; q.x = i; q.y = j; q.v = v; &#125; if(mapa[i][j] == 'E') &#123; if(i - 1 &gt;= 0) eme[i-1][j] = 1; if(j - 1 &gt;= 0) eme[i][j-1] = 1; if(i + 1 &lt; n) eme[i+1][j] = 1; if(j + 1 &lt; m) eme[i][j+1] = 1; &#125; &#125; bfs(); for(int i = 0; i &lt; n; ++i) cout &lt;&lt; newa[i] &lt;&lt; endl; cout &lt;&lt; endl; &#125; return 0;&#125; C - Lucky Number(基础)HDU - 3346 这个不多说了，又是抢的一血。额..当时有点激动漏了个条件（当然样例是不会让你看出来的，细心一点就好了。 AC代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t, n, ans, ans2; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; ans = ans2 = 0; scanf("%d",&amp;n); if(n % 8 == 0) cout &lt;&lt; "Lucky number!" &lt;&lt; endl; else &#123; int tem = n; while(tem) &#123; int qq = tem % 10; ans += qq; tem /= 10; ans2 = ans2 + qq*qq; &#125; if(ans % 8 == 0 || ans2 % 8 == 0) cout &lt;&lt; "Lucky number!" &lt;&lt; endl; else cout &lt;&lt; "What a pity!" &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; D - Calculate the expression(模拟)HDU - 3347 模拟呀..今下午自己写了会，用了不少STL的东西，后来将表示数字的字符转换为数字时我想到了atoi函数，然而这个函数对string不适用，想着改为char数组后再用这个函数吧，改着改着把自己改迷糊了..去听完报告回来后全换为char数组，结果TLE了（如果用stringstream不就直接弄死我..问了问我兄弟，他说在打游戏让我去他博客找找看（→_→ 你很棒棒哦 对比后感觉自己写的略微“高级”，然后我把“高级”部分改为朴素的if – else if然后就过了，噫，看来能A题的代码才是好代码。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;char s[105];char k[25];int main()&#123; int t, n, flag, tem, ans; scanf("%d",&amp;t); while(t--) &#123; flag = 1; ans = 0; map&lt;string, int&gt; ss; scanf("%d",&amp;n); //cout &lt;&lt; "n= " &lt;&lt; n &lt;&lt; endl; for(int i = 1; i &lt; n; ++i) &#123; scanf("%s = %d",s, &amp;tem); ss[s] = tem; //cout &lt;&lt; "s= " &lt;&lt; s &lt;&lt; " tem= " &lt;&lt; tem &lt;&lt; endl; //cout &lt;&lt; "???" &lt;&lt; endl; &#125; while(1) &#123; scanf("%s",s); tem = 0; if(s[0] &gt;= '0' &amp;&amp; s[0] &lt;= '9')//是正数 数字 &#123; for(int i = 0; i &lt; strlen(s); ++i) &#123; tem *= 10; tem += (s[i] - '0'); &#125; if(flag == 0) ans = ans - tem; else ans = ans + tem; &#125; else if(s[0] == '-') //这里注意一下 表达式中出现-号一定是常数 （我之前还以为会有 1 + -aa的情况.. &#123; for(int i = 1; i &lt; strlen(s); ++i) &#123; tem *= 10; tem += (s[i] - '0'); &#125; if(flag == 1) ans = ans - tem; else ans = ans + tem; &#125; else if(flag == 0) ans = ans - ss[s]; else ans = ans + ss[s]; scanf("%s",k); if(k[0] == '=') break; if(k[0] == '+') flag = 1; else flag = 0; &#125; scanf("%s",k);//处理最后剩下的"？" //cout &lt;&lt; "ans= " &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 写完这篇博客的第二天发现了个有趣的函数——c_str()，这个函数会生成一个const char*指针，指向以空字符终止的数组，有了它我们就可以对string使用atoi函数了。马上去写了一下，觉得爽的同时也觉得自己还是图样图森破。 （我发现的问题，那些前辈们肯定早就知道了，还有的早就在函数库里添加了相应的函数，只是我不知道而已(￣ε(#￣)☆╰╮(￣▽￣///) 最后再说一句——STL大法好 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;sstream&gt;using namespace std;int main()&#123; int t, n, tem, flag, ans; string s, stem; scanf("%d",&amp;t); while(t--) &#123; map&lt;string, int&gt; num; scanf("%d",&amp;n); for(int i = 1; i &lt; n; ++i) &#123; cin &gt;&gt; s; scanf(" = %d",&amp;tem); num[s] = tem; //cout &lt;&lt; s &lt;&lt; " " &lt;&lt; tem; &#125; getchar();//接收一个换行符 这里要注意一下 getline(cin, stem); stringstream ss(stem); ans = 0; flag = 1; while(ss &gt;&gt; s) &#123; if(s == "=") break; if(s == "-") flag = -1; else if(s == "+") flag = 1; else &#123; if(isalpha(s[0])) &#123; tem = num[s]; &#125; else &#123; tem = atoi(s.c_str());//666 &#125; ans += (tem*flag); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; E - coins(贪心)HDU - 3348 贪一贪。（代码写的通俗易懂，至于别人的空间复杂度低的我也不去管了，反正能A题的代码都是好代码(⊙v⊙) 明明很好解决的问题，却只有我和我兄弟做出来了。啧啧啧，队友瑕还说这个和上次做的多重背包的很像，受背包毒害不浅啊..还有通过这次训练，我决定我来作主代码手，毕竟我刷的（基础）题多，见识的（无用）知识点多，还有单身19年+的手速。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int a[5], b[5]; //面值为1 5 10 50 100的钞票个数int main()&#123; int t, p, ans1, ans2;; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;p); ans1 = ans2 = 0; for(int i = 0; i &lt; 5; ++i) scanf("%d",&amp;a[i]); for(int i = 0; i &lt; 5; ++i) b[i] = a[i]; int tem = p; while(tem &gt;= 100 &amp;&amp; a[4]) &#123; tem -= 100; a[4]--; ans2++; &#125; while(tem &gt;= 50 &amp;&amp; a[3]) &#123; tem -= 50; a[3]--; ans2++; &#125; while(tem &gt;= 10 &amp;&amp; a[2]) &#123; tem -= 10; a[2]--; ans2++; &#125; while(tem &gt;= 5 &amp;&amp; a[1]) &#123; tem -= 5; a[1]--; ans2++; &#125; while(tem &gt;= 1 &amp;&amp; a[0]) &#123; tem -= 1; a[0]--; ans2++; &#125; if(tem &gt; 0) &#123; ans2 = ans1 = -1; cout &lt;&lt; "-1 -1" &lt;&lt; endl; &#125; else &#123; while(b[0] + b[1] * 5 + b[2] * 10 + b[3] * 50 &lt; p) &#123; p -= 100; ans1++; &#125; while(b[0] + b[1] * 5 + b[2] * 10 &lt; p) &#123; p -= 50; ans1++; &#125; while(b[0] + b[1] * 5 &lt; p) &#123; p -= 10; ans1++; &#125; while(b[0] &lt; p) &#123; p -= 5; ans1++; &#125; ans1 += p; cout &lt;&lt; ans2 &lt;&lt; " " &lt;&lt; ans1 &lt;&lt; endl; &#125; &#125; return 0;&#125; F - lazy gege(数学)HDU - 3349 平面几何，找长方形的重心—&gt;看正方形的对角线长度和长方形中较短的边的关系，一共有三种情况，自己画个图就很好理解了。计算几何主要就是看思维了，代码实现并没有什么难度，注释的挺详细了，注意一下三个if的顺序。 AC代码：1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; double l, a, b, ans; scanf("%d",&amp;t); while(t--) &#123; scanf("%lf%lf%lf",&amp;l,&amp;a,&amp;b); if(a &gt; b) swap(a, b); //保证a为长方形的较小边 double tem = sqrt(2.0) * l; //正方形的对角线长度 if(a &lt; tem) ans = a*a/4.0; //放在正方形上的部分为等腰△ else if(a &gt; tem &amp;&amp; a &lt; 2.0*tem) ans = l*l - (tem - a/2)*(tem - a/2); //正方形面积减去等腰三角形面积 else ans = l*l; //覆盖正方形 printf("%.4lf\n",ans); &#125; return 0;&#125; G - #define is unsafe(模拟)HDU - 3350 用栈实现的模拟题，这里我用vector数组模拟了个栈。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int val;//值 int add;//+的次数&#125;;//用vector实现模拟栈的FILOvector&lt;node&gt; ans;//数值栈vector&lt;char&gt; sig;//符号栈int main()&#123; int T; string str; node tem, tem2; scanf("%d",&amp;T); while(T--) &#123; cin &gt;&gt; str; //不要忘记初始化 tem.val = tem.add = 0; ans.clear(); sig.clear(); for(int i = 0; i &lt; str.length(); ++i) &#123; //逐字扫描，只有'('、'+'、','、')'和数字是有用的 //"MAX"不做处理 //优先级：'(' &gt; '+' &gt; ',' &gt; ')' switch(str[i]) &#123; case '(': sig.push_back(str[i]); tem.val = tem.add = 0; break; case '+': ans.push_back(tem); sig.push_back(str[i]); tem.val = tem.add = 0; //每次push后都要初始化tem break; case ',': while(!sig.empty() &amp;&amp; sig.back() == '+') &#123; tem2 = ans.back(); tem.val += tem2.val; tem.add += tem2.add + 1; ans.pop_back(); sig.pop_back(); &#125; ans.push_back(tem); sig.push_back(str[i]); tem.val = tem.add = 0; //初始化tem break; case ')': while(!sig.empty() &amp;&amp; sig.back() == '+') &#123; tem2 = ans.back(); tem.val += tem2.val; tem.add += tem2.add + 1; ans.pop_back(); sig.pop_back(); &#125; tem2 = ans.back(); if(tem.val &lt; tem2.val) &#123; tem.val = tem2.val; tem.add = tem2.add*2 + tem.add; &#125; else &#123; tem.add = tem.add*2 + tem2.add; &#125; sig.pop_back(); sig.pop_back(); ans.pop_back(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': tem.val = tem.val*10 + str[i] - '0'; break; &#125; &#125; while(!sig.empty() &amp;&amp; sig.back() == '+') &#123; tem2 = ans.back(); tem.val += tem2.val; tem.add += tem2.add + 1; ans.pop_back(); sig.pop_back(); &#125; cout &lt;&lt; tem.val &lt;&lt; " " &lt;&lt; tem.add &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识点】大数分解与素数判定 --- 【Miller-rabin算法】【pollard-rho算法】]]></title>
    <url>%2Fmr-pr%2F</url>
    <content type="text"><![CDATA[1.Miller-rabin算法：Miller-rabin算法是一个用来快速判断一个正整数是否为素数的算法。 根据费马小定理，如果p是素数，则a^(p-1)≡1(mod p)对所有的a∈[1,n-1]成立。所以如果在[1,n-1]中随机取出一个a，发现不满足费马小定理，则证明n必为合数。 【但是每次尝试过程中还做了一个优化操作，以提高用少量的a检测出p不是素数的概率。这个优化叫做二次探测。它是根据这个定理：如果p是一个素数，那么对于x(0&lt;x&lt;p)，若x^2%p=1，则x=1或p-1。】 为了计算a^(n-1)mod n，我们把n-1分解为x* 2^t的形式，其中t&gt;=1且x是奇数；因此，a^(n-1)≡(a^x)^(2^t)(mod n),所以可以通过先计算a^x mod n,然后对结果连续平方t次来计算a^(n-1) mod n。一旦发现某次平方后mod n等于1了，那么说明符合了二次探测定理的逆否命题使用条件，立即检查x是否等于1或n-1，如果不等于1也不等于n-1则可直接判定p为合数。 2.pollard-rho算法：这是一个用来快速对整数进行质因数分解的算法，需要与Miller-rabin共同使用。 算法原理： 1.通过某种方法得到两个整数a和b，而待分解的大整数为n。 2.计算p=gcd(a-b,n)，直到p不为1(就是a-b与n不是互质)，或者a，b出现循环为止。 3.然后再判断p=n？ 4.如果p=n，那么返回n是一个质数。 5.否则返回p是n的一个因子，那么我们又可以递归的计算Pollard(p)和Pollard(n/p)，这样，我们就可以求出n的所有质因子。 算法步骤：选取一个小的随机数x1，迭代生成x[i] = x[i-1]^2+c，一般取c=1，若序列出现循环则退出，计算p=gcd(x[i-1]-x[i],n)，若p=1则返回上一步继续迭代，否则跳出迭代过程。若p=n，则n为素数，否则p为n的一个约数，并递归分解p和n/p。 【小知识】：随机数生成C++中函数srand（），可以指定不同的数（无符号整数变元）为种子。但是如果种子相同，伪随机数列也相同。 比较理想的是用变化的数，比如时间来作为随机数生成器的种子。 time的值每时每刻都不同，即种子不同，所以，产生的随机数也不同。 用法什么的想深入了解自己去搜吧，这里只要明白下面的程序中随机数是这样产生的就行了。然后，在这里再举个小栗子以加深一下对它的理解： 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;//这个必须有using namespace std;int main()&#123; int a = 100; srand( time(NULL)); while(a--) cout &lt;&lt; rand() &lt;&lt; endl; return 0;&#125;//这个程序的作用是产生100个随机数//如果你和我一样有颗童心去多试几次的话你会发现——每次产生的随机数都不一样//噫 是不是狠有趣(。＾▽＾) 学了这么多是不是手痒了？别着急，点我有惊喜。AC代码（C++【因为涉及到ctime，所以G++会RE的】）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177/* ************************************************* * * Miller_Rabin 算法进行素数测试 * 速度快，可以判断一个 &lt; 2^63 的数是不是素数 * **************************************************/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;using namespace std;const int S = 8;//随机算法判定次数，一般8~10次就够了//计算ret = (a*b)%c a, b, c &lt; 2^63long long mult_mod(long long a, long long b, long long c)&#123; a %= c; b %= c; long long ret = 0; long long tem = a; while(b) &#123; if(b &amp; 1) &#123; ret += tem; if(ret &gt; c) ret -= c;//直接取模慢很多 &#125; tem &lt;&lt;= 1; if(tem &gt; c) tem -= c; b &gt;&gt;= 1; &#125; return ret;&#125;//计算 ret = (a^n) % modlong long pow_mod(long long a, long long n, long long mod)&#123; long long ret = 1; long long tem = a % mod; while(n) &#123; if(n &amp; 1) ret = mult_mod(ret, tem, mod); tem = mult_mod(tem, tem, mod); n &gt;&gt;= 1; &#125; return ret;&#125;// 通过 a^(n-1)=1(mod n)来判断n是不是素数// n-1 = x * 2^t 中间使用二次判断// 是合数返回true，不一定是合数返回falsebool check(long long a, long long n, long long x, long long t)&#123; long long ret = pow_mod(a, x, n);//a^x % n long long last = ret; for(int i = 1; i &lt;= t; ++i)//进行t次(a^x % n)^2 % n &#123; ret = mult_mod(ret, ret, n); if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true;//合数 last = ret; &#125; if(ret != 1) return true; return false;//不一定是合数&#125;//**************************************************// Miller_Rabin算法// 是素数返回true,(可能是伪素数)// 不是素数返回false//**************************************************bool Miller_Rabin(long long n)&#123; if(n &lt; 2) return false; if(n == 2) return true; if( (n&amp;1) == 0) return false;//偶数 long long x = n - 1; long long t = 0; while( (x&amp;1) == 0) //将n分解为x*2^t; &#123; x &gt;&gt;= 1; t++; &#125; srand( time(NULL)); for(int i = 0; i &lt; S; ++i) &#123; long long a = rand()%(n-1) + 1;//产生随机数a(并控制其范围在1 ~ n-1之间) if(check(a, n, x, t))//是合数 return false; &#125; return true;&#125;//********************************************** // // pollard_rho 算法进行质因素分解 // //********************************************* int tol;//质因数的个数，编号为0~tol-1long long factor[100];//质因素分解结果(刚返回时是无序的)long long gcd(long long a, long long b)&#123; long long t; while(b) &#123; t = a; a = b; b = t % b; &#125; if(a &gt;= 0) return a; return -a;&#125;//找出一个因子long long pollard_rho(long long x, long long c)&#123; long long i = 1, k = 2; srand( time(NULL)); long long x0 = rand()%(x-1) + 1;//产生随机数x0(并控制其范围在1 ~ x-1之间) long long y = x0; while(1) &#123; i++; x0 = (mult_mod(x0, x0, x) + c) % x; long long d = gcd(y - x0, x); if(d != 1 &amp;&amp; d != x) return d; if(y == x0) return x; if(i == k) &#123; y = x0; k += k; &#125; &#125;&#125;//对n进行素因子分解，存入factor。 k设置为107左右即可void findfac(long long n, int k)&#123; if(n == 1) return ; if(Miller_Rabin(n))//是素数就把这个素因子存起来 &#123; factor[tol++] = n; return ; &#125; int c = k; long long p = n; while(p &gt;= n) p = pollard_rho(p, c--);//值变化，防止陷入死循环k findfac(p, k); findfac(n/p, k);&#125;int main()&#123; int T; long long n; scanf("%d",&amp;T); while(T--) &#123; scanf("%lld",&amp;n); if(Miller_Rabin(n)) cout &lt;&lt; "Prime" &lt;&lt; endl; else &#123; tol = 0; findfac(n, 107); long long ans = factor[0]; for(int i = 1; i &lt; tol; ++i) ans = min(ans, factor[i]); cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; 经过了“几天”的学习，终于能明白M-r,p-r算法是怎么实现的了（吐槽一下那三位对我关爱有加的兄弟，给我留了个这么有用的知识点让我讲），然后对着板子敲了几遍熟悉了一下。可能是还没碰到这种题目吧，内心里总觉得。。？总之也算是没浪费这些时间，至少我可以对着板子来对这知识点进行自在应用了（比如用朴素算法一不小心就会超时的一道题目。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>Miller-rabin</tag>
        <tag>pollard-rho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[White_Society_March_9 【小组练习】【--完结--】]]></title>
    <url>%2Fsdnu-white-society%2F</url>
    <content type="text"><![CDATA[前言：今天下午14：00小组举行了第一次磨合赛，总体配合的感觉还可以，相信还有很多问题没暴露出来，还有不到两个月，把握好每次练习的机会，争取这方面不会有太大失分点。 感谢：在此特意感谢熬夜为我们准备题目的超哥，还有两位带我飞的队友。然后，先定个小目标——坐上山师4队的位置。 推荐题目：A、E A - AHDU - 1131 卡特兰数的应用。 在不考虑顺序的前提下，将节点编号为0~n-1，任取一个节点k作为根节点，从而衍生出两个子问题$f(k-1)$和$f(n-k)$，有$f(k-1) \times f(n-k)$棵树， 则$f(n) = f(0) \times f(n-1) + f(1) \times f(n-2) + \ldots + f(n-1) \times f(0)$,符合卡特兰数的递推公式。由该递推公式可以推出$f(n) = \frac{f(n-1) \times (4n-2)}{(n+1)}$。至此，卡特兰数的问题已经解决。 加入字母顺序以后，这可以看成已经准备好了n个位置，现在来安排座位，排序总数为$n!$种。所以数的数量就等于$f(n) \times n!$ 这里如果分别计算再相乘的话会很麻烦，所以直接令答案$h(n) = \frac{h(n-1) \times n \times (4n-2)}{(n+1)}$ 卡特兰数：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100;const int XX = 10000;int katelan[MAX+5][MAX+5];int main()&#123; katelan[0][1] = 1; for(int i = 1; i &lt;= MAX; ++i) &#123; for(int j = 1; j &lt;= MAX; ++j) &#123; katelan[i][j] += katelan[i-1][j]*(4*i-2); katelan[i][j+1] += katelan[i][j]/XX; katelan[i][j] %= XX; &#125; int tem; for(int j = MAX; j &gt; 0; --j) &#123; tem = katelan[i][j] % (i+1); katelan[i][j-1] += tem*XX; katelan[i][j] /= (i+1); &#125; &#125; int n; while(~scanf("%d",&amp;n)) &#123; int i = MAX; while(katelan[n][i] == 0) i--; cout &lt;&lt; katelan[n][i--]; while(i &gt; 0) &#123; printf("%04d",katelan[n][i--]); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100;const int XX = 10000;int katelan[MAX+5][MAX+5];int main()&#123; katelan[0][1] = 1; for(int i = 1; i &lt;= MAX; ++i) &#123; for(int j = 1; j &lt;= MAX; ++j) &#123; katelan[i][j] += katelan[i-1][j]*i*(4*i-2); katelan[i][j+1] += katelan[i][j]/XX; katelan[i][j] %= XX; &#125; int tem; for(int j = MAX; j &gt; 0; --j) &#123; tem = katelan[i][j] % (i+1); katelan[i][j-1] += tem*XX; katelan[i][j] /= (i+1); &#125; &#125; int n; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; int i = MAX; while(katelan[n][i] == 0) i--; cout &lt;&lt; katelan[n][i--]; while(i &gt; 0) &#123; printf("%04d",katelan[n][i--]); //%04d 表示在输出一个小于4位的数值时 //将在前面补0使其总宽度为4位 &#125; cout &lt;&lt; endl; &#125; return 0;&#125; B - BHDU - 1087 最长上升子序列。之前的博客也写过。 （队友及）AC代码：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1005;int a[MAX], dp[MAX];bool cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int n, ans; while(~scanf("%d",&amp;n) &amp;&amp; n) &#123; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;a[i]); dp[i]=a[i]; &#125; for(int i = 0; i &lt; n; ++i) &#123; for(int i1=i-1; i1&gt;=0; --i1) &#123; if(a[i]&gt;a[i1]&amp;&amp;dp[i]&lt;dp[i1]+a[i]) &#123; dp[i]=dp[i1]+a[i]; &#125; &#125; &#125; sort(dp,dp+n,cmp); cout&lt;&lt;dp[0]&lt;&lt;endl; &#125; return 0;&#125; C - CHDU - 1045 DFS。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char mapa[5][5];int vis[5][5];int n, ans;void init()&#123; ans = 0; memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) if(mapa[i][j] == 'X') vis[i][j] = 2;&#125;bool ok(int x, int y)&#123; if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n) return false; return true;&#125;bool okok(int x, int y)&#123; if(vis[x][y] == 2) return false; for(int i = x; ok(i, y); ++i)//右 &#123; if(vis[i][y] == 2) break;//如果碰到X直接退出 if(vis[i][y] == 1) return false; &#125; for(int i = x; ok(i, y); --i)//左 &#123; if(vis[i][y] == 2) break; if(vis[i][y] == 1) return false; &#125; for(int i = y; ok(x, i); ++i)//上 &#123; if(vis[x][i] == 2) break; if(vis[x][i] == 1) return false; &#125; for(int i = y; ok(x, i); --i)//下 &#123; if(vis[x][i] == 2) break; if(vis[x][i] == 1) return false; &#125; return true;&#125;void dfs(int num)&#123; if(num &gt; ans) ans = num; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) &#123; if(okok(i, j)) &#123; vis[i][j] = 1; dfs(num + 1); vis[i][j] = 0; &#125; &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n) &amp;&amp; n) &#123; for(int i = 0; i &lt; n; ++i) scanf("%s", mapa[i]); init(); dfs(0); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D - DHDU - 2052 额..打印图形..手速还是不够啊，交上时已经3分1秒了.. AC代码：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;int main()&#123; int n, m; while(~scanf("%d%d",&amp;n, &amp;m)) &#123; cout &lt;&lt; "+"; for(int i = 0; i &lt; n; ++i) cout &lt;&lt; "-"; cout &lt;&lt; "+" &lt;&lt; endl; for(int i = 0; i &lt; m; ++i) &#123; cout &lt;&lt; "|"; for(int j = 0; j &lt; n; ++j) cout &lt;&lt; " "; cout &lt;&lt; "|" &lt;&lt; endl; &#125; cout &lt;&lt; "+"; for(int i = 0; i &lt; n; ++i) cout &lt;&lt; "-"; cout &lt;&lt; "+" &lt;&lt; endl; cout &lt;&lt; endl; &#125; return 0;&#125; E - EHDU - 1060 给你一个数N（$0&lt;N&lt;1,000,000,000$）， 让你求$N^N$的最高位数字。 一开始找规律，找啊找，就是找不到。后来发现有公式。（这道题还是挺不错的） 假设最高位数字为a，则用科学计数法表示就可以表示为$N^N = a \times 10^x$，同时取对数，移项，化简，得$a = 10^{(N \times lgN - x)}$，而这里的x就是​$lg(N^N)$向下取整（别问我为什么）。 到这里答案就可以得出来了，注意一下强制类型转换。 (队友瑕)AC代码：12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; long long n; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; scanf("%lld",&amp;n); double b = pow(10, n*log10(n) - (long long)(n * (log10(n)))); cout &lt;&lt; (int)b &lt;&lt; endl; &#125; &#125; return 0;&#125; F - FHDU - 5578 两只小青蛙？呱呱呱？然而这些情景并没有什么用，主要是问给出的字符串中，找到两个相同的字符最小的距离，没有相同的字符就输出-1 （队友及）AC代码：12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1005;int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; for(int j=1;j&lt;=n;++j) &#123; char a[1005]; scanf("%s",a); int len=strlen(a),num=2000; for(int i=0;i&lt;len-1;++i) &#123; for(int i1=i+1;i1&lt;len;++i1) &#123; if(a[i]==a[i1]) &#123; if(num&gt;i1-i) &#123; num=i1-i; &#125; &#125; &#125; &#125; if(num!=2000) printf("Case #%d: %d\n",j,num); else printf("Case #%d: %d\n",j,-1); &#125; &#125; return 0;&#125; G - GHDU - 1097 这个是求$x^y$的个位数，可以用快速幂一套带走，也可以找规律，之前的博客也写过这个题.. （队友及）AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; long long a,b; while(~scanf("%lld%lld",&amp;a,&amp;b)) &#123; if(a%10==0) a=0; else if(a%10==1) a=1; else if(a%10==2) &#123; switch(b%4) &#123; case 1:a=2;break; case 2:a=4;break; case 3:a=8;break; case 0:a=6;break; &#125; &#125; else if(a%10==3) &#123; switch(b%4) &#123; case 1:a=3;break; case 2:a=9;break; case 3:a=7;break; case 0:a=1;break; &#125; &#125; else if(a%10==4) &#123; switch(b%2) &#123; case 1:a=4;break; case 0:a=6;break; &#125; &#125; else if(a%10==5) &#123; a=5; &#125; else if(a%10==6) &#123; a=6; &#125; else if(a%10==7) &#123; switch(b%4) &#123; case 1:a=7;break; case 2:a=9;break; case 3:a=3;break; case 0:a=1;break; &#125; &#125; else if(a%10==8) &#123; switch(b%4) &#123; case 1:a=8;break; case 2:a=4;break; case 3:a=2;break; case 0:a=6;break; &#125; &#125; else if(a%10==9) &#123; switch(b%2) &#123; case 1:a=9;break; case 0:a=1;break; &#125; &#125; cout&lt;&lt;a&lt;&lt;endl; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1005;long long quickpow(long long a, long long b, long long c)&#123; long long ans = 1; a = a % c; while(b) &#123; if(b &amp; 1) ans = ans * a % c; b &gt;&gt;= 1; a = a*a%c; &#125; return ans;&#125;int main()&#123; long long n, m; while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; long long ans = quickpow(n, m, 10); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU ACM-ICPC 2016-2017 Training Weekly Contest 1 【--完结--】]]></title>
    <url>%2Fsdnu-2017-1%2F</url>
    <content type="text"><![CDATA[题目链接：https://vjudge.net/contest/152755#overview A - Skip the ClassHDU - 6015 思路：贪一贪 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;struct ss&#123; string les; int val;&#125;;int cmp(ss x, ss y)&#123; if(x.les == y.les) return x.val &gt; y.val; return x.les &gt; y.les;&#125;int main()&#123; int t, n, ans, flag; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; map&lt;string, int&gt; qq; ss f[105]; ans = flag = 0; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) cin &gt;&gt; f[i].les &gt;&gt; f[i].val; sort(f, f+n, cmp); for(int i = 0; i &lt; n; ++i) &#123; //cout &lt;&lt; f[i].les &lt;&lt; endl; //cout &lt;&lt; f[i].val &lt;&lt; endl; qq[f[i].les]++; if(qq[f[i].les] &lt;= 2) ans += f[i].val; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; B - Count the SheepHDU - 6016 思维练习。（数据比较大，用cin会超时） 题意：有n只公羊和m只母羊，以及k个关系，k个关系为编号为x的公羊和编号为y的母羊是好朋友。问从任意一只羊开始沿着朋友关系数够4只羊的方法有多少种。 思路：可以把给出的关系构造成一个图来看，从任意一点出发，沿着关系网找到目标。拿第一个样例来说，（为方便观察把母羊编号为3和4）从公羊出发的不同方式为1324，1423，2314，2413共四种，同理，从母羊出发也是四种（把母羊看作1，2，把公羊看作3，4），到这里，我们能看出：从公羊出发的情况乘以二就是答案。而从公羊出发到不同母羊的情况数就等于（这个公羊的度-1）*（母羊的度-1）（度是指与这个点相连的点的个数）. AC代码：1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;const int maxn = 100005;LL a[maxn], b[maxn], na[maxn], nb[maxn];int main()&#123; int t; int n, m, k; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); for(int i = 0; i &lt; k; ++i) &#123; scanf("%lld%lld",&amp;a[i],&amp;b[i]); na[a[i]]++; nb[b[i]]++; &#125; LL sum = 0; for(int i = 0; i &lt; k; ++i) sum += (na[a[i]] - 1) * (nb[b[i]] - 1); printf("%lld\n",sum &lt;&lt; 1); &#125; return 0;&#125; C - Lotus and CharactersHDU - 6011 开始以为是不要负数，自始至终一直在这样做。看两队1A了，继续提交，继续WA。 这道题看完样例后很多人会和我一样误认为把负数都不算上才能得出最优解，其实不然。给出两组测试数据就知道了： 123 -1 3 2 1 1 1 答案:82 -1 5 4 2 答案:27 正确的做法是把所有数据从大到小排序，然后从前往后加，直到新加的数小于0时停止相加。其实理解了就很简单。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct ss&#123; int val; int amo;&#125;;int cmp(ss x, ss y)&#123; return x. val &gt; y.val;&#125;int main()&#123; int t, n; long long cnt, ans; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; cnt = ans = 0; ss f[30]; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d%d",&amp;f[i].val, &amp;f[i].amo); sort(f, f+n, cmp); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; f[i].amo; ++j) &#123; cnt += f[i].val; if(cnt &lt; 0) break; ans += cnt; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; D - Lotus and HorticultureHDU - 6012 思维。 在温室里种花，给出n朵花的适宜生长温度，如果温室温度在这范围内的话，成熟后的每朵花价值为a，高于所给温度，价值为b，低于所给温度，价值为c。问需要让温室温度为多少才能获得最大价值。 一开始让室内温度为-inf,此时答案为∑c，然后模拟温度上升，不断更新最大价值，直到达到所给的最大温度。 这个过程可以用map来实现，first为温度，second为价值。 （这里的温度可以是实数，所以用到了点小技巧：让温度都扩大两倍避免了出现小数的情况） AC代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;typedef long long LL;const int maxn = 50005;int main()&#123; int t, n; int l, r, x, y, z; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); map&lt;int, LL&gt; s; while(n--) &#123; scanf("%d%d%d%d%d",&amp;l,&amp;r,&amp;x,&amp;y,&amp;z); s[0] += z; s[l * 2] += x - z; s[r * 2 + 1] += y - x; &#125; LL ans = 0; LL tem = 0; for(map&lt;int,LL&gt;::iterator it = s.begin(); it != s.end(); ++it) &#123; tem += it -&gt; second; ans = max(ans, tem); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; E - The Third Cup is FreeHDU - 5999 一眼看出是贪心，然后全部浏览完一遍题目后，把这道题敲完交上，9minA了全场第一题。 AC代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int a[100005];int main()&#123; int t, n, ans, flag, cou = 0; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; ans = flag = 0; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); sort(a, a+n); for(int i = n-1; i &gt;= 0; --i) &#123; if(flag == 2) &#123; flag = 0; continue; &#125; flag++; ans += a[i]; &#125; printf("Case #%d: ",++cou); cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; F - Pseudoprime numbersHDU - 1905 数论。 题目解法：先判断p是不是合数，是的话再判断a的p次方%p是否等于a，是输出yes，否输出no，简单地题套个快速幂模板一套带走.. AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;long long quickpow(long long a, long long b, long long c)&#123; long long ans = 1; a = a % c; while(b) &#123; if(b &amp; 1) ans = ans * a % c; b &gt;&gt;= 1; a = a*a % c; &#125; return ans;&#125;int main()&#123; int flag; long long a, p; while(~scanf("%lld%lld",&amp;p,&amp;a) &amp;&amp; (a || p)) &#123; flag = 0; for(int i = 2; i * i &lt; p; ++i) if(p % i == 0) &#123; flag = 1; break; &#125; if(flag == 0) cout &lt;&lt; "no" &lt;&lt; endl; else &#123; long long tem = quickpow(a, p, p); //cout &lt;&lt; tem &lt;&lt; endl; if(tem == a) cout &lt;&lt; "yes" &lt;&lt; endl; else cout &lt;&lt; "no" &lt;&lt; endl; &#125; &#125; return 0;&#125; G - 小明系列问题――小明序列HDU - 4521 最长上升子序列的O(nlogn)算法。 AC代码： 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1e5 + 10;int a[MAX], b[MAX], DP[MAX];int n, m;int main()&#123; int ans; while(~scanf("%d%d",&amp;n, &amp;m)) &#123; ans = 1; fill(DP, DP + MAX, INF); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;a[i]); b[i] = 1; &#125; for(int i = m; i &lt; n; ++i) &#123; b[i] = lower_bound(DP, DP + MAX, a[i]) - DP + 1; if(b[i] &gt; ans) ans = b[i]; if(DP[b[i-m]-1] &gt; a[i-m]) DP[b[i-m]-1] = a[i-m]; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; H - Doing Homework againHDU - 1789 上学期，江西师范新生赛见过这道题，当时排序是按的时间优先，后来看题解知道应该分数优先。这也是道贪心哦。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 1005;int a[10005];struct node&#123; int sco, ded;&#125;;int cmp(node x, node y)&#123; if(x.sco == y.sco) return x.ded &lt; y.ded; return x.sco &gt; y.sco;&#125;int main()&#123; int t, n; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; node f[maxn]; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;f[i].ded); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;f[i].sco); sort(f, f+n, cmp); int ans = 0; memset(a, 0, sizeof(a)); for(int i = 0; i &lt; n; ++i) &#123; int tem; for(tem = f[i].ded; tem &gt; 0; --tem) &#123; if(a[tem] == 0) &#123; a[tem] = 1; break; &#125; &#125; if(tem == 0) ans += f[i].sco; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; I - 敌兵布阵HDU - 1166 这个以为是模拟，结果TLE，赛后得知要用线段树或树状数组，会了的话这就是道裸题。 【补】AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 50010;long long ans;struct node&#123; int l, r; int sum;&#125; tree[MAX&lt;&lt;2];void pushup(int rt)&#123; tree[rt].sum = tree[rt&lt;&lt;1].sum + tree[rt&lt;&lt;1|1].sum;&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; tree[rt].sum = 0; if(l == r) //叶子结点 &#123; scanf("%d",&amp;tree[rt].sum); return ; &#125; int mid = (l+r)&gt;&gt;1; //递归建树 build(l, mid, rt&lt;&lt;1); build(mid+1, r, rt&lt;&lt;1|1); pushup(rt);&#125;void update(int pos, int val, int rt)&#123; //更新这个区间的值 if(tree[rt].l == tree[rt].r) &#123; tree[rt].sum += val; return ; &#125; int mid = (tree[rt].l+tree[rt].r)&gt;&gt;1; if(pos &lt;= mid) update(pos, val, rt&lt;&lt;1); else update(pos, val, rt&lt;&lt;1|1); pushup(rt);&#125;void query(int x, int y, int rt)&#123; if(x == tree[rt].l &amp;&amp; y == tree[rt].r) &#123; ans += tree[rt].sum; return ; &#125; int mid = (tree[rt].l+tree[rt].r)&gt;&gt;1; if(y &lt;= mid) query(x, y, rt&lt;&lt;1); else if(x &gt; mid) query(x, y, rt&lt;&lt;1|1); else &#123; query(x, mid, rt&lt;&lt;1); query(mid+1, y, rt&lt;&lt;1|1); &#125;&#125;int main()&#123; int T; int n, pos, val; string s; scanf("%d",&amp;T); for(int cas = 1; cas &lt;= T; ++cas) &#123; printf("Case %d:\n",cas); scanf("%d",&amp;n); build(1, n, 1); while(cin &gt;&gt; s) &#123; if(s == "End") break; scanf("%d%d",&amp;pos,&amp;val); if(s == "Add") &#123; update(pos, val, 1); &#125; else if(s == "Sub") &#123; update(pos, -val, 1); &#125; else if(s == "Query") &#123; ans = 0; int x = pos; int y = val; if(x &gt; y) swap(x, y); query(x, y, 1); cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第三章习题】【5/12】]]></title>
    <url>%2Flrj-ch3-1%2F</url>
    <content type="text"><![CDATA[UVa 1585 Score 【字符串】【模拟】【基础】题目大意：给定一个由O和X组成的字符串，每个O都有一定的分数，是目前连续出现的O的个数，问这个字符串的得分是多少。 解题思路：直接做。 Mycode：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, res, tem;string s;int main()&#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; s; res = 0; tem = 0; for(int i = 0; i &lt; s.size(); ++i) &#123; if(s[i] == 'O') ++tem; else tem = 0; res += tem; &#125; cout &lt;&lt; res &lt;&lt; "\n"; &#125; return 0;&#125; UVa 1586 Molar mass【字符串】【模拟】【基础】题目大意：给出一个物质的分子式，求分子量。 解题思路：直接做。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;string s;int t, tem;double res;double Q(char ch)&#123; if(ch == 'C') return 12.01; if(ch == 'H') return 1.008; if(ch == 'O') return 16.00; return 14.01;&#125;int main()&#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; s; res = 0; tem = 0; for(int i = 0; i &lt; s.size(); ++i) &#123; if(isalpha(s[i])) &#123; tem = 1; int j = 1; while(isdigit(s[i + j])) &#123; if(j == 1) tem = 0; tem = tem * 10 + (s[i + j] - '0'); ++j; &#125; res += Q(s[i]) * tem; &#125; &#125; printf("%.3f\n", res); &#125; return 0;&#125; UVa 1225 Digit Counting【模拟】【基础】题目大意：将前n个数字顺次写到一起，问1 ~ 9 各出现多少次。 解题思路：直接做。 Mycode：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, a[11];void solve(int x)&#123; while(x) &#123; ++a[x % 10]; x /= 10; &#125;&#125;int main()&#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; n; memset(a, 0, sizeof(a)); for(int i = 1; i &lt;= n; ++i) solve(i); for(int i = 0; i &lt; 10; ++i) printf("%d%c", a[i], i == 9 ? '\n' : ' '); &#125; return 0;&#125; UVa 455 Periodic Strings【字符串】【模拟】【基础】题目大意：如果一个字符串可以通过某个长度为k的字符串多次重复得到，那么称该串以k为周期。给一个字符串，问其最小周期是多少。 解题思路：直接做。枚举答案。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;string s;int t, res, len;bool judge(int x)&#123; for(int i = x; i &lt; len; ++i) &#123; if(s[i] != s[i % x]) return false; &#125; return true;&#125;int main()&#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; s; len = s.size(); res = len; for(int i = 1; i &lt; len; ++i) &#123; if((len % i == 0) &amp;&amp; judge(i)) &#123; res = i; break; &#125; &#125; cout &lt;&lt; res &lt;&lt; "\n"; if(t) cout &lt;&lt; "\n"; &#125; return 0;&#125; UVa 227 Puzzle【字符串】【模拟】【基础】题目大意：根据指令完成对应操作。注意字符的读入。 解题思路：直接做。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char op;string s[6];int nowx, nowy;void FindNowIdx()&#123; for(int i = 0; i &lt; 5; ++i) for(int j = 0; j &lt; 5; ++j) if(s[i][j] == ' ' || s[i][j] == '\0') &#123; nowx = i; nowy = j; return ; &#125;&#125;void Debug()&#123; cout &lt;&lt; "\n\n******Debug******\n"; for(int i = 0; i &lt; 5; ++i) cout &lt;&lt; s[i] &lt;&lt; "\n"; cout &lt;&lt; nowx &lt;&lt; " " &lt;&lt; nowy &lt;&lt; "\n"; cout &lt;&lt; "******Debug******\n\n";&#125;int main()&#123; int cas = 0; while(getline(cin, s[0]) &amp;&amp; s[0][0] != 'Z') &#123; for(int i = 1; i &lt; 5; ++i) getline(cin, s[i]); FindNowIdx();// Debug(); bool flag = true; while(cin &gt;&gt; op &amp;&amp; op != '0') &#123;// cout &lt;&lt; "op = " &lt;&lt; op &lt;&lt; "\n"; if(op == 'A') &#123; if(nowx == 0) flag = false; else &#123; swap(s[nowx][nowy], s[nowx-1][nowy]); --nowx; &#125; &#125; else if(op == 'B') &#123; if(nowx == 4) flag = false; else &#123; swap(s[nowx][nowy], s[nowx+1][nowy]); ++nowx; &#125; &#125; else if(op == 'L') &#123; if(nowy == 0) flag = false; else &#123; swap(s[nowx][nowy], s[nowx][nowy-1]); --nowy; &#125; &#125; else if(op == 'R') &#123; if(nowy == 4) flag = false; else &#123; swap(s[nowx][nowy], s[nowx][nowy+1]); ++nowy; &#125; &#125; &#125; if(cas) cout &lt;&lt; "\n"; printf("Puzzle #%d:\n", ++cas); if(flag) &#123; for(int i = 0; i &lt; 5; ++i) &#123; for(int j = 0; j &lt; 5; ++j) &#123; if(j) cout &lt;&lt; " "; cout &lt;&lt; s[i][j]; &#125; cout &lt;&lt; "\n"; &#125; &#125; else cout &lt;&lt; "This puzzle has no final configuration.\n"; getchar(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>解题报告</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第三章例题】]]></title>
    <url>%2Flrj-ch3-0%2F</url>
    <content type="text"><![CDATA[例题 3-112345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int flag=1; int c; while((c = getchar()) != EOF) &#123; if(c == '"') &#123; if(flag) cout &lt;&lt; "``"; else cout &lt;&lt; "''"; flag = !flag; &#125; else printf("%c", c); &#125; return 0;&#125; 例题 3-2123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char s[] = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./";int main()&#123; int i, c; while((c = getchar()) != EOF) &#123; for(i = 1; s[i] &amp;&amp; s[i] != c; ++i); if(s[i]) putchar(s[i-1]); else putchar(c); &#125; return 0;&#125; 例题 3-3123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const char* rev = "A 3 HIL JM O 2TUVWXY51SE Z 8 ";const char* res[] = &#123;"not a palindrome", "a regular palindrome", "a mirrored string", "a mirrored palindrome"&#125;;char r(char ch)&#123; if(ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') return rev[ch - 'A']; else return rev[ch - '0' + 25];&#125;int main()&#123; char s[30]; while(~scanf("%s", s)) &#123; int len = strlen(s); int p = 1, m = 1; for(int i = 0; i &lt; (len + 1) / 2; ++i) &#123; if(s[i] != s[len - 1 - i]) p = 0; if(r(s[i]) != s[len-1-i]) m = 0; &#125; printf("%s -- is %s.\n\n", s, res[m * 2 + p]); &#125; return 0;&#125; 例题 3-4123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1010;int n, cnt1, cnt2;int a[MAX], b[MAX];int main()&#123; for(int cas = 1; scanf("%d",&amp;n) &amp;&amp; n; ++cas) &#123; printf("Game %d:\n", cas); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); while(true) &#123; cnt1 = cnt2 = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;b[i]); if(a[i] == b[i]) ++cnt1; &#125; if(b[0] == 0) break; for(int d = 1; d &lt;= 9; ++d) &#123; int c1 = 0, c2 = 0; for(int i = 0; i &lt; n; ++i) &#123; if(a[i] == d) ++c1; if(b[i] == d) ++c2; &#125; cnt2 += min(c1, c2); &#125; printf(" (%d,%d)\n", cnt1, cnt2 - cnt1); &#125; &#125; return 0;&#125; 例题 3-512345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100010;int t, n;int res[MAX];void init()&#123; for(int i = 1; i &lt; MAX; ++i) &#123; int x = i, y = i; while(x) &#123; y += x % 10; x /= 10; &#125; if(res[y] == 0 || i &lt; res[y]) res[y] = i; &#125;&#125;int main()&#123; init(); scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); printf("%d\n", res[n]); &#125; return 0;&#125; 例题 3-612345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int les(char* s, int p, int q)&#123; int n = strlen(s); for(int i = 0; i &lt; n; ++i) &#123; if(s[(p+i)%n] != s[(q+i)%n]) return s[(p+i)%n] &lt; s[(q+i)%n]; &#125; return 0;&#125;int main()&#123; char s[105]; int n, ans, len; while(~scanf("%d",&amp;n)) &#123; while(n--) &#123; ans = 0; scanf("%s",s); len = strlen(s); for(int i = 0; i &lt; len; ++i) if(les(s, i, ans)) ans = i; for(int i = 0; i &lt; len; ++i) cout &lt;&lt; s[(ans+i)%len]; cout &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>解题报告</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
</search>
