<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SDNU_ACM_ICPC_2019_Winter_Practice_2nd【解题报告】]]></title>
    <url>%2Fsdnu-2019-2%2F</url>
    <content type="text"><![CDATA[嗯？F怎么没人做？我看一下吧。 ？？？这是什么东西？？？ 妈耶添加题目后忘记改题号了。打扰了。。。 这次题解给Forsaken写了，还是都很基础的题目，除了F都可以做哦。 (UPD:真正的题解已写完，点击打开对应网址) 哦还有，大家可以趁此机会学习一下逆元，多么充实的寒假呀，加油ヾ(◍°∇°◍)ﾉﾞ。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>DFS</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
        <tag>寒假集训</tag>
        <tag>快速幂</tag>
        <tag>map</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU_ACM_ICPC_2019_Winter_Practice_1st【解题报告】]]></title>
    <url>%2Fsdnu-2019-1%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-zuqwqTHm"), narrow: false, autoplay: false, showlrc: false, music: { title: "可能否", author: "木小雅", url: "http://music.163.com/song/media/outer/url?id=569214126.mp3", pic: "http://p1.music.126.net/SJYnDay7wgewU3O7tPfmOQ==/109951163322541581.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); A - The kth great number【模拟】【vector】[HDU - 4006 ] 一看这个题，求第k大数，以为是主席树呢。仔细一看，哦，用vector模拟一下就行了。 后来看其他队员也有用multiset和priority_queue的，嗯，可以趁这个机会学习一下它们的用法。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;char op;int n, k, t;int main()&#123; while(~scanf("%d%d", &amp;n,&amp;k)) &#123; vector&lt;int&gt; G; while(n--) &#123; cin &gt;&gt; op; if(op == 'I') &#123; scanf("%d", &amp;t); int pos = lower_bound(G.begin(), G.end(), t) - G.begin(); G.insert(G.begin() + pos, t); &#125; else &#123; printf("%d\n", G[G.size() - k]); &#125; /* for(int i = 0; i &lt; G.size(); ++i) cout &lt;&lt; G[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; */ &#125; &#125; return 0;&#125; B - A Trivial Problem【数学】CodeForces - 633B 题意：给出一个数m，求阶乘末尾有m个0的数的个数及这些数。 思路：一眼望去，以为是这个题，又读了一遍发现这个是“反着求”。 以为是规律，然后写几项看看吧，写了m = 30多时的答案还是没看出什么来。 休息了一会想到还是用上面那个题的代码，因为要求的序列和m的关系是单调的，所以或许可以通过二分枚举答案，接着试了试上界，序列中的数最大到400009，好了可以二分了。最后只要把符合要求的存一下，问题就解决了。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int n;int solve(int t)&#123; int cnt = 0; while(t) &#123; t /= 5; cnt += t; &#125; return cnt;&#125;int main()&#123; scanf("%d", &amp;n); int r = 400010, l = 0, m; int idx = 0; while(l &lt;= r) &#123; m = (r + l) &gt;&gt; 1; if(solve(m) &lt; n) &#123; idx = m; l = m + 1; &#125; else r = m - 1; &#125; vector&lt;int&gt; res; for(int i = idx; ; ++i) &#123; if(solve(i) == n) res.push_back(i); else if(solve(i) &gt; n) break; &#125; printf("%d\n", res.size()); for(int i = 0; i &lt; res.size(); ++i) printf("%d ", res[i]); return 0;&#125; C - New Skateboard【模拟】【分类讨论】CodeForces - 628B 题意：给出一个字符串，求出其中的连续&amp;&amp;满足“数值”为4的倍数的子序列的数量。 思路：纸上写一写，然后分类讨论一下就行了。 MyCode：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 300010;int len;char s[N];long long res;int main()&#123; scanf("%s", s); len = strlen(s); for(int i = len - 1; i &gt;= 0; --i) &#123; if((s[i] - '0') % 4 == 0) //0、4、8 &#123; ++res; if(i &gt; 0) &#123; res += ((s[i-1] - '0') % 2 == 0) ? i : 0; &#125; &#125; else if((s[i] - '0') % 2 == 0) //2、6 &#123; if(i &gt; 0) &#123; res += ((s[i-1] - '0') % 2 != 0) ? i : 0; &#125; &#125; &#125; printf("%lld\n", res); return 0;&#125; D - Color the ball【前缀和或线段树】HDU - 1556 一眼望去线段树。观察选手代码长度，自信$n^2​$莽了一发，收获TLE。老老实实上线段树AC。 AC后发觉事情不太对，这个前缀和应该也可以的，但一时没想起来怎么写。赛后搜了一下不由感叹：秒啊秒啊。 具体一点就是在增加数字的区间两端进行标记，左端点+1右端点的右边坐标-1，这样某个区间的次数就是从1坐标到这个位置的数值之和了。 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 100010;int n, x, y, a[N];int main()&#123; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; memset(a, 0, sizeof(a)); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d", &amp;x,&amp;y); ++a[x]; --a[y + 1]; &#125; for(int i = 1; i &lt;= n; ++i) &#123; a[i] += a[i-1]; printf("%d%c", a[i], i == n ? '\n' : ' '); &#125; &#125; return 0;&#125; E - 非常可乐【BFS或数学】HDU - 1495 kuangbin专题一做过，当时BFS过的，看选手代码发现怎有如此短的代码？打开一看用了gcd什么的，不太懂，等督促数学选手水哥写完博客后大家可直接去访问他的博客(UPD:已更新，点击打开对应文章链接)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int N = 111;int s, n, m, rq[5];bool vis[N][N][N];struct node&#123; int num[3], out;&#125; now, nex;void BFS(int s, int n, int m)&#123; memset(vis, 0, sizeof(vis)); queue&lt;node&gt; Q; now.num[0] = s; now.num[1] = n; now.num[2] = m; now.out = 0; Q.push(now); vis[s][n][m] = 1; while(!Q.empty()) &#123; now = Q.front(); Q.pop(); for(int i = 0; i &lt; 2; ++i) for(int j = 0; j &lt; 3; ++j) &#123; if(i == j) continue; if(now.num[i] == now.num[j] &amp;&amp; now.num[3-i-j] == 0) &#123; printf("%d\n", now.out); return ; &#125; &#125; for(int i = 0; i &lt; 3; ++i) &#123; for(int j = 0; j &lt; 3; ++j) &#123; if(i == j) continue; if(now.num[i] + now.num[j] &lt;= rq[j]) &#123; nex.num[j] = now.num[j] + now.num[i]; nex.num[i] = 0; &#125; else &#123; nex.num[i] = now.num[i] - (rq[j] - now.num[j]); nex.num[j] = rq[j]; &#125; for(int k = 0; k &lt; 3; ++k) &#123; if(k == i || k == j) continue; nex.num[k] = now.num[k]; &#125; nex.out = now.out + 1; if(vis[nex.num[0]][nex.num[1]][nex.num[2]] == 0) &#123; vis[nex.num[0]][nex.num[1]][nex.num[2]] = 1; Q.push(nex); &#125; &#125; &#125; &#125; puts("NO");&#125;int main()&#123; int s, n, m; while(scanf("%d%d%d", &amp;s,&amp;n,&amp;m) &amp;&amp; s) &#123; rq[0] = s, rq[1] = n, rq[2] = m; BFS(s, 0, 0); &#125; return 0;&#125; F - 今夕何夕【模拟】HDU - 6112 2017百度之星初赛签到题。。其实并不难的，就是模拟一下日期，注意一下闰年就完了，不知道为啥做的人这么少。 记得有个公式(蔡勒公式)直接算日期的，找之前的板子没找到，然后直接按百度百科的抄上了，结果姿势有点不太对TLE了两次，最后老老实实模拟了。 哦对了，这题的输入格式，还有大爷直接字符串 + gets然后再转化为int变量，为啥不直接格式读入。。？？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, yy, mm, dd, res;bool leap(int year)&#123; if(year % 400 == 0) return 1; if(year % 100 == 0) return 0; return year % 4 == 0;&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d-%d-%d", &amp;yy,&amp;mm,&amp;dd); int sum = 0; if(mm == 2 &amp;&amp; dd == 29) &#123; for(int i = yy + 1; ; ++i) &#123; sum += 365; if(leap(i)) ++sum; sum %= 7; if(leap(i) &amp;&amp; !sum) &#123; res = i; break; &#125; &#125; &#125; else if(mm &lt; 3) &#123; for(int i = yy + 1; ; ++i) &#123; sum += 365; if(leap(i - 1)) ++sum; sum %= 7; if(!sum) &#123; res = i; break; &#125; &#125; &#125; else &#123; for(int i = yy + 1; ; ++i) &#123; sum += 365; if(leap(i)) ++sum; sum %= 7; if(!sum) &#123; res = i; break; &#125; &#125; &#125; printf("%d\n", res); &#125; return 0;&#125; G - 第几天？【模拟】HDU - 2005 签到题，判断闰年。简单提一点，还是上面说的，注意格式读入。。 等会，有人写了好几kb的代码，打开一看十几个if-else，我哭了。。你们通过这种写法A掉的，再按照下面的重新写一遍吧。。 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int yy, mm, dd, res;int a[] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;bool leap(int year)&#123; if(year % 400 == 0) return 1; if(year % 100 == 0) return 0; return year % 4 == 0;&#125;int main()&#123; while(~scanf("%d/%d/%d", &amp;yy,&amp;mm,&amp;dd)) &#123; res = dd; for(int i = 1; i &lt; mm; ++i) res += a[i]; if(mm &gt; 2 &amp;&amp; leap(yy)) ++res; printf("%d\n", res); &#125; return 0;&#125; H - 最大子矩阵【二维前缀和】HDU - 1559 典型的动态规划问题，也是利用前缀和进行求解。 用$sum[i][j]$表示起点为矩形左上角这个点为右下角的矩阵的元素之和，最后枚举大小为$x \times y$的矩阵时枚举左上角位置后，右下角的位置就是$(i+x-1,j+x-1)$，自己画图减一下就能看出来，最后的答案就是： $sum[i+x-1][j+y-1] - sum[i+x-1][j-1] - sum[i-1][j+y-1] + sum[i-1][j-1]$， 为了避免数组下标出现负数的情况，我存图用的下标是从1开始的。 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1111;int t, n, m, x, y, a[N][N], sum[N][N];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d%d%d", &amp;n,&amp;m,&amp;x,&amp;y); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) scanf("%d", &amp;a[i][j]); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) sum[i][j] = a[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]; int res = -1; for(int i = 1; i + x &lt;= n; ++i) for(int j = 1; j + y &lt;= m; ++j) res = max(res, sum[i+x-1][j+y-1] - sum[i+x-1][j-1] - sum[i-1][j+y-1] + sum[i-1][j-1]); printf("%d\n", res); &#125; return 0;&#125; I - Help is needed for Dexter【规律】UVA - 11384 不知道如此简单的一道题为啥没人做。。 题目大意：这里有1~n共n个数，你每次可以选取其中的若干数个让他们减去一个你指定的数(中途不得出现负数)，问最少经过多少次操作能使得所有的数变为0。 解题思路：找了几个数写出来看了看，很显然的规律题。 具体过程： 1 1次 1 2 经过一次变换可以转化为1 1 共需要2次 1 2 3 经过一次变换可以转化为1 2 2 共需要3次 1 2 3 4 经过一次变换可以转化为1 2 1 2 共需要3次 1 2 3 4 5 经过一次变换可以转化为1 2 0 1 2 共需要3次 ………… 就是经过尽量少次数的变换让他们变成前面出现过的就行了，就提示到这，一定要自己推出来并AC掉呀。 MyCode：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n;int res[33] = &#123;1, 2&#125;;void init()&#123; for(int i = 2; i &lt;= 32; ++i) res[i] = res[i - 1] * 2;&#125;int main()&#123; init(); while(~scanf("%d", &amp;n)) &#123; for(int i = 1; ; ++i) &#123; if(res[i] &gt; n) &#123; printf("%d\n", i); break; &#125; &#125; &#125; return 0;&#125; J - find your present (2)【二进制】HDU - 2095 签到题，可以直接stl容器存，也可以直接利用异或的性质进行求解。 这个题开场4分钟就被A掉，看来确实是有人对学过的知识还有印象。 代码还是不够精简啊，根本不需要数组，直接三个变量就能A掉，精简代码也是挺重要的。。 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, res, tem;int main()&#123; while(scanf("%d", &amp;t) &amp;&amp; t) &#123; res = 0; for(int i = 0; i &lt; t; ++i) &#123; scanf("%d", &amp;tem); res ^= tem; &#125; printf("%d\n", res); &#125; return 0;&#125; END：这里面大部分是QDU去年算法协会给17级的出的题目，所以并不难，大家做成这样emmm。总之还差得远呢，好好利用寒假吧，开学后各种事又会忙起来，争取这个假期能有质的飞跃。 自己还感受到好久不打比赛后，这样一做还真有些吃力，这个东西，还是不要放下太久，不然要重新捡起来又要费好大劲。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>vector</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
        <tag>寒假集训</tag>
        <tag>前缀和</tag>
        <tag>位运算</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNUOJ题目分类【Overview】]]></title>
    <url>%2Fsdnuoj-problem-categories%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-CRXufJkK"), narrow: false, autoplay: false, showlrc: false, music: { title: "我的天空", author: "南征北战nzbz", url: "http://music.163.com/song/media/outer/url?id=28892408.mp3", pic: "http://p1.music.126.net/09FsXnIw8EmAqkb7LwiCOw==/1410673435521373.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 写在前面：About：这是一篇关于SDNUOJ题目分类的文章，内容是各题目的难度标记及题目分类。以下是几个关于对这篇文章的疑问，大家有什么疑问可以在文章最下面留言或者直接联系我，我会一一解答(如果看到的话)。 Q&amp;A：Q：为什么要写这样一篇文章？ A：自己刚入坑时不会的太多而且一直找不到合适的做题顺序，如无头苍蝇一般，其中尝试各种道路便浪费了好多时间。入坑入得很难受。所以现在要写这样一篇文章，主要是帮助刚入坑的萌新，能让你们有个良好的入坑体验。至于入坑成功后的路，就需要你们自己走了。 Q：啊啊啊，为什么不早写呢？我大一上学期都结束了。 A：其实自己在大一省赛结束后就想写了，因为那时简单题目就已经被solve的差不多了，然后由于感觉这事并不紧急，就一拖再拖，加上有SDNU作弊码的存在，感觉自己再整理一遍有些“抢生意”的感觉，再加上后面作弊码的完善，这件事就搁浅了。 Q：那为什么现在要写了？ A：因为感觉作弊码写的不好，而且作弊码的作者码风…… &amp;&amp; 部分题解并不好，不适合作为教程。咳咳，这个嘛，一方面是兑现去年9月份(捂脸)对教练的承诺，为SDNU-ACM的发展贡献一份自己的力量——帮助萌新入门；另一方面自己期末考完试早早结束暂时没做其他事，后面也没课了，整理这个的同时也可以回忆一下自己的大学生活。 Q：感觉好棒(×)，会不会写关于其他OJ的类似文章呢？ A：不会。。自己太菜了，也就能水水本校OJ。不过已经有了很多其他OJ的类似文章了，如POJ的题目分类，kuangbin专题一览，BZOJ一句话题解，Codeforces自带的分类功能…… Q：阳神你真帅 A：废话，还用你说 最后附自拍一张 正文：几点注意事项： 这里按照题目顺序进行整理，格式为题目序号、【难度】 题目类型 (特别标记) 难度针对萌新分级为【入门】、【初级】、【中等】、【困难】对柳总这样的dalao来说都是【入门】QAQ。 这以后你就可以根据自己的需求Ctrl + F搜索你想要的难度 || 类型的题目进行AC了。 因为是个人整理嘛，所以可能在题目难度的感觉上及tags的标记上不是很准确，有疑问的欢迎与我交流，希望这篇文章在大家的共同努力下越来越完善（づ￣3￣）づ╭❤～。 第一页：1000 ~ 1009、【入门】 输入输出练习 + 循环语句 + 读到文件结束 1010、【入门】 打印图形 (初学者的第一个槛，一定要自己写出来) 1011、【中等】 排列组合 (第二类stirling数) 1012、【初级】 结构体排序 1013、【初级】 贪心 1014、【入门】 数组 + 循环语句 1015、【中等】 DFS 1016、【中等】 思维 || 并查集 1017、【入门】 贪心 1018、【入门】 模拟 1019、【初级】 模拟 1020、【入门】 选择语句 1021、【入门】 模拟 1022、【困难】 DFS 1023、【入门】 贪心 1024、【入门】 模拟 (1014简化版) 1025、【初级】 DFS || BFS 1026、【中等】 贪心 (仔细读题) 1027、【中等】 BFS (1025升级版) 1028、【初级】 结构体排序 1029、【中等】 动态规划 1030、【困难】 最短路 1031、【困难】 拓扑排序 1032、【中等】 双线程DP 1033、【初级】 背包 1034、【入门】 同1020 1035、【入门】 模拟 || 规律 1036、【入门】 浮点数处理 1037、【入门】 模拟 1038、【初级】 递推 1039、【入门】 递推 1040、【初级】 DP之LIS 1041 ~ 1042、【入门】 模拟 1043、【初级】 背包 1044、【中等】 DP 1045、【中等】 DP 1046、【入门】 模拟 1047、【中等】 模拟 1048、【中等】 DP 1049 ~ 1055、【入门】 模拟 1056、【初级】 快速幂 1057、【初级】 模拟 (可练习vector用法) 1058、【初级】 模拟 (可练习map用法) 1059、【入门】 模拟 1060、【入门】 模拟 || 排序 1061、【初级】 背包 1062、【中等】 矩阵快速幂 (模板题) 1063、【困难】 模拟 + LCA 1064、【入门】 模拟 1065、【入门】 模拟 1066、【入门】 排序 1067 ~ 1070、【入门】 模拟 1071 ~ 1074、【入门】 递归 1076、【初级】 并查集 1077、【初级】 背包 1078、【中等】 并查集应用 1079、【入门】 模拟 1080、【入门】 数学 1081、【初级】 快速幂(模板) 1082、【初级】 规律 1083、【入门】 规律 (递归即可AC) 1084、【初级】 规律 (需递推才可AC) 1085、【中等】 规律 (需矩阵快速幂) 1086、【中等】 BFS 1087、【中等】 离散化 + DP 1088、【初级】 欧拉路 1089、【初级】 直接判断度数 || 拓扑排序 1090、【入门】 模拟 1091、【初级】 贪心 1092、【入门】 模拟 1093 ~ 1094、【初级】 结构体排序 1095 ~ 1096、【入门】 模拟 1097、【初级】 LCM 1098 ~ 1101、【初级】 字符串 第二页：1102、【初级】 模拟 1103、【初级】 排列组合 1104、【初级】 结构体排序 1105、【入门】 数学 1106、【入门】 模拟 1107、【初级】 贪心 1108 ~ 1109、【入门】 模拟 1110 ~ 1111、【中等】 模拟 1112、【入门】 同1020 1113、【初级】 模拟 (高精度) 1114 ~ 1115、【初级】 模拟 1116、【中等】 AC自动机(模板题) 1117、【困难】 高精度 1118、【困难】 AC自动机 (模板题)，可用Java水过 1119、【初级】 模拟 1120、【入门】 模拟 1121 ~ 1127、【初级】 模拟 1128 ~ 1130、【困难】 SDNU ACM-ICPC 2013省队选拔赛 1134、【困难】 Floyd闭包 1135 ~ 1144、【初级 + 中等 + 困难】 山东省第一届ACM大学生程序设计竞赛 1145 ~ 1152、【初级 + 中等 + 困难】 Mid-Central USA 2012 1153 ~ 1160、【初级 + 中等 + 困难】 Mid-Central USA 2011 1161 ~ 1162、【中等】 模拟 1163、【入门】 模拟 1164 ~ 1165、【困难】 思维 模拟 1166 ~ 1169、【入门 + 中等】 NOIP 2004 普及组 1170 ~ 1171、【入门 + 中等 + 困难】 NOIP 2004 提高组 1174 ~ 1177、【入门 + 初级 + 中等 + 困难】 NOIP 2006 普及组 1178 ~ 1181、【中等 + 困难】 NOIP 2006 提高组 1182 ~ 1184、【初级 + 中等】 NOIP 2007 普及组 1185 ~ 1188、【初级 + 困难】 NOIP 2007 提高组 1189 ~ 1191、【初级 + 困难】 NOIP 2008 普及组 1192 ~ 1195、【初级 + 中等 + 困难】 NOIP 2008 提高组 1196、【困难】 矩阵快速幂 1197、【困难】 思维 1198、【困难】 DP 1199、【入门】 数学 第三页：1200、【中等】 模拟 || 中缀转后缀 1201、【初级】 模拟 1202、【初级】 规律 1203、【初级】 模拟 1204、【初级】 规律 1205、【入门】 递推 1206、【初级】 思维 1207 ~ 1208、【中等】 模拟 1209、【初级】 排序 + 去重 (可练习set用法) 1210、【初级】 排序 (可练习stack用法) 1211、【初级】 进制转换 1212、【入门】 判断升序 1213、【中等】 模拟 1214 ~ 1216、【入门】 模拟 1217、【初级】 并查集 (模板题) 1218、【初级】 最小生成树 (模板题) 1219、【入门】 输入输出练习 1220、【中等】 BFS记录路径 1221、【初级】 DP (LIS模板题) 1222、【困难】 KMP 1223 ~ 1224、【中等】 最短路 1225、【中等】 数学 1226、【困难】 数学 (扩展欧几里得) 1227 ~ 1228、【中等】 数学 1229、【中等】 最小生成树 (稠密图用Prim) 1230、【困难】 并查集 1231、【入门】 输出 1232、【初级】 模拟 1233、【???】 隐藏题目 1234、【中等】 贪心 1235 ~ 1238、【???】 隐藏题目 1239、【中等】 数学 (线性筛) 1240 ~ 1244、【中等 + 困难】 17新生期末赛部分题目 1245、【初级】 快速幂 1246 ~ 1252、【初级 + 中等 + 困难】 山东省第九届acm大学程序设计竞赛山师选拔赛第一场部分题目 (题解) 1253 ~ 1261、【初级 + 中等 + 困难】 山东省第九届acm大学程序设计竞赛山师选拔赛第二场部分题目 (题解) 1262 ~ 1266、【???】 隐藏题目 1267、【初级】 模拟 1268、【初级】 链表 || 结构体排序 1269、【入门】 模拟 1270、【中等】 思维 1271、【初级】 模拟 1272、【初级】 思维 1273、【中等】 DP 1274 ~ 1277、【入门】 模拟 1278、【初级】 排序 1279、【入门】 模拟 1280 ~ 1281、【初级】 模拟 1282、【中等】 数学 1283、【初级】 规律 1284、【中等】 模拟 1285、【初级】 规律 1286、【初级】 数学 (素数) 1287、【初级】 数学 (欧拉函数) 1288 ~ 1289、【困难】 ??? 1290、【中等】 模拟 1291、【困难】 ??? 1292、【初级】 DP (LIS) 1293 ~ 1294、【中等】 规律 1295、【困难】 ??? 1296、【困难】 模拟 1297 ~ 1299、【困难】 ??? 第四页：1300、【中等】 规律 1301、【初级】 模拟 (高精度) 1302、【初级】 规律 1303、【初级】 模拟 (高精度) 1304、【中等】 规律 1305、【中等】 模拟 1306、【初级】 模拟 1307 ~ 1308、【困难】 ??? 1309、【入门】 数学 1310、【初级】 线段合并 1311、【初级】 计算组合数 1312、【初级】 模拟 (摩斯密码转换) 1313、【困难】 规律 + 矩阵快速幂 1314、【初级】 规律 1315、【???】 隐藏题目 1316、【初级】 DFS || 打表 1317、【初级】 模拟 1318、【初级】 直接做 || 数位DP 1319 ~ 1320、【中等】 数学 概率期望 1321、【入门】 C语言 1322、【初级】 数学 概率 1323 ~ 1329、【困难】 数学 1330、【初级+】 DP 1331、【初级+】 二分 1332、【初级】 模拟 1333 ~ 1340、【中等 + 困难】 某场选拔赛题目 1341、【初级】 模拟 日期转换 1342 ~ 1348【???】 隐藏题目 1349、【初级】 快速幂 1350、【初级】 区间覆盖 1351、【初级】 并查集 1352、【困难】 ??? 1353、【入门】 简单计算 1354、【初级】 gcd 1355、【???】 隐藏题目 1356 ~ 1363、【入门 + 初级】 新生周赛题目 1364 ~ 1369、【初级 + 中等 + 困难】 NOIP2014提高组 1370 ~ 1374、【中等 + 困难】 Waterloo local 2000.09.23 1375 ~ 1379、【初级 + 困难】 Waterloo local 2000.09.30 1380 ~ 1384、【初级 + 困难】 Waterloo local 2001.01.27 1385 ~ 1389、【中等 + 困难】 ??? 1390 ~ 1403、【困难】 ??? 第五页：1401 ~ 1482、【入门 + 初级 + 中等 + 困难】 蓝桥杯往年试题 1483 ~ 1490、【初级 + 中等 + 困难】 山东省第八届acm大学程序设计竞赛山师选拔赛第一场 题解 1491、【困难】 DP 1492 ~ 1501、【初级 + 中等 + 困难】 山东省第八届acm大学程序设计竞赛山师选拔赛第二场 题解 第六页：1502、【中等】 DP (状压DP模板) 1503 ~ 1514、【初级 + 中等 + 困难】 山东省第七届acm大学程序设计竞赛 1515 ~ 1518、【入门 + 初级】 山东省第八届acm大学程序设计竞赛赛前娱乐 1520、【初级】 背包 (多重背包) 1521、【入门】 排序 1522、【中等】 数学 (线性筛) 1523、【初级】 快速幂 || for循环 1524、【???】 隐藏题目 1525、【初级】 次小生成树模板 1526、【困难】 贪心 1527、【中等】 打表 1528、【初级】 DFS枚举答案 || 手推 1529、【困难】 数学 (容斥) 1530、【入门】 return 0; 1531、【困难】 FFT 1532、【困难】 NNT 1533、【初级】 模拟 1534 ~ 1543、【入门 + 初级 + 中等 + 困难】 18期末总结赛部分题目 (题解) END：回首大学里已经过去的两年半的时间，自己的大一过的还是很满意的，虽然那时的付出没能得到即时的反馈，但我可以毫不客气的说，后面的惊喜几乎都是那一年的付出所埋下的铺垫。从大二开始，迷茫犹豫的次数太多，在反复试错的过程中失去了很多本可以变得更好的机会。大三的这一学期尝试着弥补，虽然有所收获，但想想大二废掉的一年总是觉得很遗憾。 有时也总想着如果能回到过去重来一遍该多好，可是就算时光可以倒流，自己也还是会犯同样的错误，到最后还是过着和现在一样的生活，不是吗？ 如果你看到了这里，那恭喜你，你将获得我最想和两年前的我说的一句话——“不要等没机会搞acm的时候，再后悔没有全身心的投入。” 最后，就以泰戈尔诗句作为结尾好了——“只管走过去，不必逗留着采了花朵来保存，因为一路上花朵自会继续开放的。”]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>SDNU</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU ACM-ICPC 2018 Final Summary Contest(12-16)【解题报告】]]></title>
    <url>%2Fsdnu-2018-4%2F</url>
    <content type="text"><![CDATA[前言：激动人心(×)的期末总结赛终于来了！经过断断续续的三周的准备，这套题目终于完整(×)的出现在了大家面前。虽然此次13道题全是英文题面，但命题组尽可能的保证了题目的通俗易懂……如果还是有读不懂的地方的话就来喷我吧，我太菜了o(╥﹏╥)o。 另外，感觉到了造数据的不易，找的两个验题人一直忙着各种事咕咕咕，终于在昨晚把他们骗到集训室帮忙验了下题，改了些题面描述的语法错误，果然有道题数据出问题了。原来自己随机程序写的有问题，emmm。抓紧修锅，最终赶在封楼前修完，安心回宿舍了(要是今天现场出锅就刺激了)。 UPD：MD，今天果然还是出锅了。 题解：说明：以下内容为现场赛时写的，一边看榜，一边写，所以是按照每道题被拿走FB的顺序写的。 1231.Why choose ACM?【签到】最后加的签到题，没想到00:03:09被QLU的抢了一血(By:QLUZhouXiang)，以为这个签到题伪装的挺好的了。 另外，感觉自己已经描述的够详细了，所以WA了的…emmm，求轻喷吧。 MyCode: 1234567891011121314#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; string s = "always challenge miracles"; s[0] = toupper(s[0]); cout &lt;&lt; s &lt;&lt; '\n'; return 0;&#125; 1536.How many users on SDNU OJ【签到】【stl】一血时间00:05:30，By:songjian。肯定是发现了这个题题面的提示(签到成功.jpg)。 也没啥好说的，就是直接map|set标记，然后输出就好了。 另外：输出Case这样的比较恶心的&amp;无用的东西的时候，直接按照下面的写法比较方便，可以学习一下。 MyCode： 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;int t, n;string s;map&lt;string, bool&gt; MP;int main()&#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d", &amp;n); MP.clear(); while(n--) &#123; cin &gt;&gt; s; MP[s] = 1; &#125; printf("Case #%d: %d\n", cas, MP.size()); &#125; return 0;&#125; 1534.Single Dog【签到】签到题，再次被QLU参赛选手发现，00:19:38FB诞生，By: QLUZhouXiang。 这个恶意卡了一下int，n的最大范围是INT_MAX + 1(果然卡了很多人)，其他没什么好说的。 MyCode： 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t;long long n;char name[111];int main()&#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%s%lld", name, &amp;n); printf("Case #%d: %s is %s.\n", cas, name, (n &gt;= 10000) ? "Life Winner" : "Single Dog"); &#125; return 0;&#125; 1541.Your Code Is Awesome【二进制异或】【思维】00:33:42FB诞生，By:18XiWenjuan。 看到她AC后，心里一阵窃喜，原来我讲过的异或的性质她认真学了啊，打开AC代码一看，笑容渐渐消失。 WTF？排了个序，然后相邻两个查了一下，过了？本着赛中不能把AC过的进行重判的原则，就勉强让她AC吧。But，这不是正解，这次卡过去了就卡过去吧，连夜修锅最后还是输了。赛后再加强数据嘻嘻。 ？？？怎么都知道用排序水过去？不行不行，忍不了，现场加强数据，rejudge，尽情的喷我吧，告辞。 UPD：03:06:02这道题又被卡过去了，打开AC代码看了一下，原来是加上了读入挂，心态爆炸。不想再改了，我二十几岁，我好累。对于卡过去的柳总，如果你看到这里，我要送你下面这句话： AC代码： 参考https://blog.csdn.net/ccutyear/article/details/53456571 1537.Tiger Eat People【组合数学】【大数或模拟】00:34:38FB诞生，By:2017luoxingcheng。 没想到这道题在所有签到题没签完的前提下被秒了，这样很容易歪榜啊喂(#`O′)(其实如果不是卡高精度了这题也是道水题)。 解析：这道题相当于6进制下选数，很容易看出答案就是$2^n(C_n^0 + C_n^1 + C_n^2 + \ldots + C_n^n)$，因为最后答案比较大，所以可以用c++模拟或者直接上Java(还有人用的Python？tql)。 MyCode(Java)： 1234567891011121314151617181920import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int t = cin.nextInt(); BigInteger TWO = BigInteger.valueOf(2); while((t--) &gt; 0) &#123; int n = cin.nextInt(); BigInteger res = BigInteger.ONE; for(int i = 0; i &lt; n; ++i) &#123; res = res.multiply(TWO); &#125; System.out.println(res); &#125; &#125;&#125; 1539.Do you like Hot Dog ?【01背包】【W超大】00:38:37 QLU抢走一血，By:QLUzhengzehao。 就是01背包问题，小白书上写的很详细，这个价值范围小，所以用DP针对不同的价值计算最小重量。详见P61。 MyCode： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 10010;const int INF = 0x3f3f3f3f;int n, limit;int we[500 + 5];int vi[500 + 5];int dp[505][5005];void solve()&#123; fill(dp[0], dp[0] + 5005, INF); dp[0][0] = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt;= 5001; ++j) &#123; if(j &lt; vi[i]) dp[i+1][j] = dp[i][j]; else dp[i+1][j] = min(dp[i][j], dp[i][j-vi[i]]+we[i]); &#125; int res = 0; for(int i = 0; i &lt;= 5001; ++i) if(dp[n][i] &lt;= limit) res = i; printf("%d\n",res);&#125;int main()&#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); int nCase; scanf("%d", &amp;nCase); while(nCase--) &#123; memset(we, 0, sizeof we); memset(vi, 0, sizeof vi);// memset(dp, 0, sizeof dp); scanf("%d %d", &amp;n, &amp;limit); for(int q = 0; q &lt; n; ++q) &#123; scanf("%d %d", &amp;we[q], &amp;vi[q]); &#125; solve();// cout &lt;&lt; "limit=" &lt;&lt; limit &lt;&lt;endl; //cout &lt;&lt; rec(0, limit) &lt;&lt; endl; &#125; return 0;&#125; 1331.Kick Veges’ Ass【二分】01:55:50FB诞生，By:2017luoxingcheng 题意：n个菜鸟站一排，我要按顺序虐他们。虐第i个菜鸟需要花费掉A[i]点RP，现在我打算分k天虐完这些菜鸟。我每天的RP总数是固定的，为了使RP最低的时候不会过低导致杯具，我希望这k天中虐菜花费RP最多的一天，花费的RP尽量少。求我在花费RP最多那天花费了多少RP。 思路：二分枚举答案就好了，最基础的二分。 MyCode：(一年半前写的，比较丑陋，不要参考) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 100005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, k;int l, r, mid, sum;int a[MAX];bool judge(int rp)&#123; int tot = 1; //全部虐完需要的天数 int now = 0; //现在已经花费的RP for(int i = 0; i &lt; n; ++i) &#123; now += a[i]; if(now &gt; rp) &#123; now = a[i]; ++tot; &#125; &#125;// cout &lt;&lt; "tot=" &lt;&lt; tot &lt;&lt; endl; return tot &gt; k;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i]; l = max(l, a[i]); r += a[i]; &#125; while(l &lt; r) &#123; int mid = (l + r) / 2; if(judge(mid)) l = mid + 1; else r = mid;// cout &lt;&lt; l &lt;&lt; "--" &lt;&lt; r &lt;&lt; "--" &lt;&lt; mid &lt;&lt; endl; &#125; cout &lt;&lt; r &lt;&lt;endl; return 0;&#125; 1220.Look for homework【BFS记录路径】01:56:02FB诞生，By:2018lihaoran BFS + 记录路径。确实还是没啥好说的。。。 MyCode(两年前的，现在看起来很丑陋，不要参考)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, m;int fir, las;int dir[4][2] = &#123;&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0, 1&#125;,&#123;-1, 0&#125; &#125;;//D,L,R,Uchar T[4] = &#123;'D', 'L', 'R', 'U'&#125;;int mapa[15][15];string str[105];char c[105];struct node&#123; int x, y; int pre; char ch;&#125; q[105];void print(int i, int j)&#123; int tem, tot = 0; c[tot] = q[j].ch; tot++; tem = i; while(q[tem].pre != -1) &#123; c[tot] = q[tem].ch; tot++; tem = q[tem].pre; &#125; cout &lt;&lt; tot &lt;&lt; endl; for(tem = tot-1; tem &gt;= 0; --tem) cout &lt;&lt; c[tem]; cout &lt;&lt; endl;&#125;void bfs(int x, int y)&#123; int x1, y1; fir = 0; las = 1; q[fir].x = x; q[fir].y = y; q[fir].pre = -1; mapa[x][y] = 1; while(fir &lt; las) &#123; for(int i = 0; i &lt; 4; ++i) &#123; x1 = q[fir].x + dir[i][0]; y1 = q[fir].y + dir[i][1]; if(x1 &lt; 0 || x1 &gt;= n || y1 &lt; 0 || y1 &gt;= m || mapa[x1][y1]) continue; mapa[x1][y1] = 1; q[las].pre = fir; q[las].x = x1; q[las].y = y1; q[las].ch = T[i]; las++; if(x1 == n-1 &amp;&amp; y1 == m-1) &#123; print(fir, las-1); return ; &#125; &#125; fir++; &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;n, &amp;m)) &#123; for(int i = 0; i &lt; n; ++i) &#123; cin&gt;&gt;str[i]; for(int j=0; j&lt;=m-1; j++) &#123; if(str[i][j]=='1') mapa[i][j]=1; else mapa[i][j]=0; &#125; &#125; bfs(0, 0); &#125; return 0;&#125; 1542.Liu Yuxin was insulted【状压DP】02:16:51 FB诞生，By:18LiuJunxiang 出题人说是状压DP，但是状态太少，直接枚举也能过，看了一下柳总的AC代码，近3kb，真猛啊。。 ACCode(By LiuYuxin): 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;int m[1005][10], n;int main() &#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); memset(m, inf, sizeof m); scanf("%d", &amp;n); m[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; 8; j++) m[i][j] = m[i - 1][j]; int v, kind = 0, len; char r[100]; scanf("%d", &amp;v);scanf("%s", r); len = strlen(r); int now = 0; while (now &lt; len) &#123; if (r[now] == 'O') &#123; kind |= (1 &lt;&lt; 0); now += 4; &#125; else if (r[now] == 'G') &#123; kind |= (1 &lt;&lt; 1); now += 9; &#125; else if (r[now] == 'P') &#123; kind |= (1 &lt;&lt; 2); now += 10; &#125; &#125; for (int j = 0; j &lt; 8; j++) &#123; int t = (kind | j); m[i][t] = min(m[i][t], m[i - 1][j] + v); &#125; &#125; if (m[n][7] &lt; inf) printf("%d\n", m[n][7]); else cout &lt;&lt; "Where are you? My beloved." &lt;&lt; endl; return 0;&#125; 1543.Happy Salted Fish Every Day【签到】【模拟】02:36:19 FB诞生，By:2017liruoshui 2个半小时了，签到题终于全被签完了，不知道是不是我暗示了一下的原因(我说其实还有好多题可以做的)。。另外，不明白为啥昌写了1600+b代码而且还WA了。 题意：告诉你一个序列的生成方式，问这个序列的第n项是几。 思路：直接模拟，还原序列后，$O(1)$输出。 ACCode(From 多校std)： 123456789101112131415//17多校 第七场K题#include &lt;cstdio&gt;int k[10000005],a,i,j,ii,T,n;int main()&#123; k[1]=a=1;k[2]=k[3]=2;i=3;j=4; while(j&lt;=10000000)&#123; for(ii=1;ii&lt;=k[i];ii++) k[j++]=a; i++;a=3-a; &#125; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); printf("%d\n",k[n]); &#125;&#125; 1535.Math【质因数分解】【贪心】Codeforces Round #520 (Div. 2) B题。 这都做不出来，我真是无话可说。。可能是被题面里出现的YC给吓到了？其实还是菜。 题意：给你一个数$n$，要你输出经过若干次操作能得到最小的值和操作的最少次数。 一共有两种操作：1. 让$n = n \times x$，$x$必须是正数。 2. 让$n = \sqrt{n}$，$n$必须是个平方数。 思路：最后能得到的最小的数一定是将$n$进行质因数分解后各质因子的乘积(通过操作2使他们的幂次都降为1)。为了使操作次数最小，我们可以一次乘上个很大的数，使得所有质因子都可以不断进行开方操作直到开到幂次为1，而能开直接到1的前提是让幂次变为$2^n$，具体细节见代码吧。 MyCode： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 111;int n, p[N], num[N];int main()&#123; while(~scanf("%d", &amp;n)) &#123; if(n == 1) &#123; puts("1 0"); continue; &#125; memset(p, 0, sizeof(p)); memset(num, 0, sizeof(num)); int cou = 0; for(int i = 2; i &lt;= sqrt(n); ++i) &#123; if(n % i == 0) &#123; ++cou; p[cou] = i; num[cou] = 0; while(n % i ==0) &#123; num[cou]++; n /= i; &#125; &#125; &#125; if(n &gt; 1) &#123; p[++cou] = n; num[cou] = 1; &#125; int maxx = num[1], res1 = p[1], res2 = 0; for(int i = 2; i &lt;= cou; ++i) &#123; maxx = max(maxx, num[i]); res1 = res1 * p[i]; &#125; if(maxx == 1) res2 = 0; else &#123; bool f = 0; for(int i = 2, j = 1; ; i *= 2, ++j) &#123; if(maxx &lt;= i) &#123; res2 = j; if(maxx &lt; i) &#123; f = 1; ++res2; &#125; break; &#125; &#125;// cout &lt;&lt; maxx &lt;&lt; ' ' &lt;&lt; res2 &lt;&lt; '\n'; if(!f) for(int i = 1; i &lt;= cou; ++i) if(num[i] != maxx) &#123; ++res2; break; &#125; &#125; printf("%d %d\n", res1, res2); &#125; return 0;&#125; 1538.GTMDDLY【贪心】【模拟】 ACCode(出题人提供)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Created by SWT#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int x,n; freopen("input.txt","r",stdin); freopen("output.txt","w",stdout); while(~scanf("%d %d",&amp;x,&amp;n)) &#123; int part1 = n*3,my_lose = 0,her_lose = 0; her_lose += (1 + 2*part1) * part1 - 3*part1; my_lose += (1 + part1) * part1 / 2; my_lose += 3*(1 + n) * n / 2; int flag = 0; if(x &gt; max(my_lose,her_lose)) &#123; int my_hurt = part1 + 1; int her_hurt = 2 * part1 - 1; while (1) &#123; my_lose += my_hurt; if(my_lose &gt;= x) &#123; flag = -1; break; &#125; her_lose += her_hurt; if(her_lose &gt;= x) &#123; flag = 1; break; &#125; my_hurt++; her_hurt++; &#125; &#125; else &#123; int attack = n,her_hurt = 1; my_lose = her_lose = 0; for (int i = 1; i &lt;= 3*n; i++) &#123; if(i != 1 &amp;&amp; i % 3 == 0)attack--; my_lose += i; if(my_lose &gt;= x) &#123; flag = -1;break; &#125; her_lose += her_hurt; her_hurt++; if(her_lose &gt;= x) &#123; flag = 1;break; &#125; her_lose += her_hurt; her_hurt++; if(her_lose &gt;= x) &#123; flag = 1;break; &#125; my_lose += attack; her_lose -= 3; if(my_lose &gt;= x) &#123; flag = -1;break; &#125; &#125; &#125; if(flag &gt; 0)printf("skirt!\n"); else printf("Damn it!\n"); &#125;&#125; 1540.A list generated by a wrong list【思维+NNT+二分】【防AK】0提交，太真实了。 以下内容由出题人(Forsaken)提供：考察范围：欧拉筛的深入理解、二分、NTT 题意：题目中告知我们运行的欧拉筛中的内层循环由于少了一个等号导致每次枚举都会少枚举已经得到的数，注意“少了一个等号会导致每次都少枚举已经得到的数字”，由缺少一个等号可以自然想到每次都少枚举了最后一个已经得到的数字，那么就是外层循环刚刚得到的最新的这个素数！因此整个欧拉筛误判了所有的素数的平方并把它们当成了素数，因此筛出1e6以内的所有素数并取平方就得到了LIST！对于给出的n和m，利用二分查找找到位置即可，然后的操作进行NTT对于998244353取模（原根为3）就得到了答案。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mann = 1e7+5;int tot;ll pri[mann];bool is[mann];void init () &#123; is[0] = is[1] = 1; for (int i = 2; i &lt; mann; ++i) &#123; if (!is[i]) &#123; pri[++tot] = i; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i*pri[j] &lt; mann; ++j) &#123; is[i*pri[j]] = 1; if (i % pri[j] == 0) &#123; break; &#125; &#125; &#125; for (int i = 1; i &lt;= tot; ++i) &#123; pri[i] *= pri[i]; &#125;&#125;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return; &#125; ll x0, y0; exgcd(b, a % b, x0, y0); x = y0; y = x0 - (ll)(a / b) * y0;&#125;ll Inv(ll a, ll p) &#123; ll x, y; exgcd(a, p, x, y); x %= p; while (x &lt; 0) &#123; x += p; &#125; return x;&#125;ll qpow(ll a, ll b, ll p) &#123; if (b &lt; 0) &#123; b = -b; a = Inv(a, p); &#125; ll ans = 1, mul = a % p; while (b) &#123; if (b &amp; 1) &#123; ans = ans * mul % p; &#125; mul = mul * mul % p; b &gt;&gt;= 1; &#125; return ans;&#125;#define maxn (65537*2)const int MOD = 998244353, G = 3;ll rev[maxn];void get_rev(ll bit) &#123; for (ll i = 0; i &lt; (1 &lt;&lt; bit); i++) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (bit - 1)); &#125;&#125;ll ar[maxn], br[maxn];void ntt(ll *a, ll n, ll dft) &#123; for (ll i = 0; i &lt; n; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; for (ll step = 1; step &lt; n; step &lt;&lt;= 1) &#123; ll wn; wn = qpow(G, dft * (MOD - 1) / (step*2), MOD); for (ll j = 0; j &lt; n; j += (step&lt;&lt;1)) &#123; ll wnk = 1; for (ll k = j; k &lt; j + step; k++) &#123; ll x = a[k] % MOD, y = (wnk * a[k + step]) % MOD; a[k] = (x + y) % MOD; a[k + step] = ((x - y) % MOD + MOD) % MOD; wnk = (wnk * wn) % MOD; &#125; &#125; &#125; if (dft == -1) &#123; ll nI = Inv(n, MOD); for (ll i = 0; i &lt; n; i++) &#123; a[i] = a[i] * nI % MOD; &#125; &#125;&#125;int main() &#123; init(); ll n, m; while (scanf("%lld %lld", &amp;n, &amp;m) != EOF) &#123; memset(ar, 0, sizeof(ar)); memset(br, 0, sizeof(br)); memset(rev, 0, sizeof(rev)); int pos1 = lower_bound(pri+1, pri+1+tot, n)-pri; int pos2 = upper_bound(pri+1, pri+1+tot, m)-pri-1; int len = pos2-pos1+1; for (int i = 0; i &lt; len; ++i) &#123; ar[i] = br[i] = pri[pos2-i]; &#125; ll bit, s = 2; for (bit = 1; (1 &lt;&lt; bit) &lt; 2*len-1; ++bit) &#123; s &lt;&lt;= 1; &#125; get_rev(bit); ntt(ar, s, 1); ntt(br, s, 1); for (ll i = 0; i &lt; s; i++) &#123; ar[i] = ar[i] * br[i] % MOD; &#125; ntt(ar, s, -1); for (int i = 0; i &lt; 2*len-2; ++i) &#123; cout &lt;&lt; ar[i] &lt;&lt; ' '; &#125; cout &lt;&lt; ar[2*len-2] &lt;&lt; '\n'; &#125; return 0;&#125; 吐槽： 办比赛真麻烦，以后不想搞了。。 这些人怎么回事？学了这么久，除了暴力啥也不会？这样子别说区域赛了，省赛都打不了 头真铁啊，最后一题都加强数据rejudge了还想着莽过去。。 大家好像都很喜欢排序？异或的题我排序，二分的题我排序，模拟的题我也排序…… 这次17的整体表现令人害怕，这样下去怕要被18踩爆；18也就前几各成绩还行，不过也合乎常理，毕竟走到最后的大概率都是这些人中的吧；柳总还是强啊；李浩然这小伙子不错.jpg，虽然这次比赛打的和狗屎一样，李浩然怎么起伏这么大.jpg。 这学期的训练就此结束了，总的来说确实比之前累了不少，不过同时也是收获满满，特别是……hhhhhhhhhh不说了，你懂得。Hint：Solution里的数据里有彩蛋哦。 END：所以说，知道自己的真实实力最重要，不要因为一时的失败就觉得自己不行。 一定要多试几次你才会知道，自己真的不行。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QLU ACM-ICPC大学生程序设计迎新赛-正式赛【解题报告】]]></title>
    <url>%2Fqlu-2018-2%2F</url>
    <content type="text"><![CDATA[前言：再次作为吃瓜群众围观4小时，之前一直作为参赛选手参加比赛，从来没想到边缘ob也可以如此精彩。这次还和swt一起“解说”了这场比赛，感觉好有意思，解说真好玩.jpg 因为赛中L题数据出了问题，所以最后一直没人能AK，赛后rejudge时发现崔健聪其实早就在比赛过去$\frac{3}{4}$时AK了，而柳总是第一个过L的，宋健、刘陶然也都1A了。 此次比赛共13题，去掉最后一道直接输出答案的，还剩12道，正好请3位现场AK的队员分工写了下题解，这样我只需要整理一下，不用亲自去做每个题了hhhhh，在此表示一下感谢（づ￣3￣）づ╭❤～。 题解：崔健聪：A、B、C、DA、约数个数题目大意：输入$n$和$g$，$g$是一个质数，输入$n$行表示$n$个质数$p_1 \ldots p_n$，输入$n$行表示$n$个质数的幂次$ a_1 \ldots a_n$，构成一个$num = p_1^{a_1} \times p_2 ^ {a_2} \ldots p_n^{a_n}$，问你$num$的约数中有多少可以被$g$整除。 解题思路：因为$g$是质数，所以如果所给的$p$没有$g$那么就不会存在能被$g$整除的$num$的约数，有$g$的话，就是一个排列组合问题。除了$p_i == g$的那个质数外，其余被分解出来的质数都可以取$0$ ~ $a_i$个，所以最后的结果就是： $a_i（p_i == g）\times (a_1 + 1) \times (a_2+1) \times \ldots \times(a_{i-1} + 1) \times (a_{i+1} + 1) \times \ldots \times (a_{n}+1)$。 Code：12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 1e2;int p[maxn];int a[maxn];int cnt[maxn];int main()&#123; int n,g; scanf("%d%d",&amp;n,&amp;g); for(int i = 1;i &lt;= n;++i) scanf("%d",&amp;p[i]); memset(cnt,0,sizeof(cnt)); for(int i = 1;i &lt;= n;++i) &#123; scanf("%d",&amp;a[i]); cnt[p[i]] = a[i]; &#125; if(cnt[g] == 0) printf("0\n"); else &#123; ll ret = cnt[g]; for(int i = 1;i &lt;= n;++i) &#123; if(p[i] == g)continue; ret *= (ll)(a[i] + 1); &#125; printf("%lld\n",ret); &#125; return 0;&#125; B、Alice and Bob题目大意：输入n表示有n堆数，输入n个数，表示数的大小。 游戏规则，Alice先手，Bob后手，先手后手轮流取，一次只能拿光一堆数，最后所得到的数的和最大者获胜。 解题思路：为了获胜，Alice和Bob肯定都从当前所有数中拿最大的。 所以排序，Alice拿偶数位，Bob拿奇数位，计算sum1，sum2，比较输出即可。 局面只有平局和Alice胜利。 Code：1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 1e2;int cnt[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;++i) scanf("%d",&amp;cnt[i]); ll sum1 = 0,sum2 = 0; sort(cnt+1,cnt + n + 1); for(int i = n;i &gt;= 0;--i) &#123; if((n - i) % 2 == 0) &#123; sum1 += cnt[i]; &#125; else &#123; sum2 += cnt[i]; &#125; &#125; if(sum1 == sum2) printf("again\n"); else printf("A\n"); return 0;&#125; C、黑白黑题目大意：两种选择，少数为败，存在平局。 输出平局aha或者失败的名字。 解题思路：if判断就好吧。 Code：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;#define read(n) scanf("%d",&amp;n);#define readll(n) sacnf("%lld",&amp;n);const int maxn = 1e4 + 1e3;int main()&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(a == b &amp;&amp; b == c)&#123; printf("aha\n"); &#125; else if(a == b) &#123; printf("C\n"); &#125; else if(a == c) &#123; printf("B\n"); &#125; else if(b == c) &#123; printf("A\n"); &#125; return 0;&#125; D、GPA题目大意：输入7门成绩和对应的学分，给你平均绩点的计算方法，根据该方法进行计算即可。 解题思路：浮点运算，输出两位小数。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;#define read(n) scanf("%d",&amp;n);#define readll(n) sacnf("%lld",&amp;n);const int maxn = 1e4 + 1e3;int cost[100];int fen[100];double getfen(int x)&#123; double ret; if(x &gt;= 91)ret = 4.0; else if(x &gt;= 86)ret = 3.5; else if(x &gt;= 81)ret = 3.0; else if(x &gt;= 76)ret = 2.5; else if(x &gt;= 71)ret = 2.0; else if(x &gt;= 66)ret = 1.5; else if(x &gt;= 60)ret = 1.0; else ret = 0; return ret;&#125;int main()&#123; for(int i = 1;i &lt;= 7;i++) &#123; scanf("%d",&amp;cost[i]); &#125; int sum = 0; for(int i = 1;i &lt;= 7;i++) &#123; scanf("%d",&amp;fen[i]); sum += fen[i]; &#125; double ret = 0; for(int i = 1;i &lt;= 7;i++) &#123; ret += getfen(cost[i]) * 1.0 * fen[i]; &#125; ret = ret / (sum * 1.0); printf("%.2lf\n",ret); return 0;&#125; 刘陶然：E、F、G、HE、are you ok?题目大意：给你一个数据的数目大小 n ($2 &lt;= n &lt;= 100$)，然后给你两行数据，每行有n个，第一行每个数据是字符串（长度不超过10），第二行是对应字符串的个数，拿样例来说，代表apple这个字符串有0个，milk这个字符串有2个。 当所有的字符串的个数为0时就输出are you ok?，否者就出数目不为0 的字符串与其对应的数目。 解题思路：可以用两个数组分别保存字符串还有相应字符串对应的数字，先特判一下是否都为0，是就输出are you ok?否者就按顺序输出字符串的数目不为0的那些。 Code： F、折纸达人题目大意：先输入一个数代表有几组样例($1&lt;= t &lt;= 100$)，对于每组样例，第一行是有几个操作数($1&lt;=n&lt;=10^5$)（L,R,T,B L表示从左向右折……）一个字幕为一次操作，第二行就是给你说具体的操作了，第三行是询问，共四种询问LR, RL, TB, BT，LR表示从左向右剪,依次类推。（Left，Right ，Top ，Bottom）。 解题思路：​ 你可以先拿一张纸出来，你会发现往左与往右折是一回事，同样往上往下也是，就是左右对折一下或者上下对折一下。从左往右还有从右往左剪开也是一样的，同理上下减也一样。所以问题就是说：左右折几下，上下折几下，然后问你上下剪，或者左右剪开之后有几张纸。 ​ 可以再想一下，咱们先就针对上下剪的情况进行讨论一下： ​ 仅上下对折的情况：你会发现你上下对折无数次，剪开仅剩下两张纸。（其实想明白了上下对折对上下剪，没有任何影响,想不明白没关系，继续看）。 ​ 仅仅左右对折的情况：你会发现对折0次的时候剪开是$1+1$张，对折1次剪开是$2+1$张，对折3次剪开是$4+1$张，对折4次是$8+1$张，……（大家可以动手试一下）对折n次是$2^n + 1$张。 ​ 即上下对折也左右对折的情况：你会发现只要是你是上下剪开的和你上下对折多少次都没有关系（你可以试一下，你会发现你上下对折影响的其实就是，你还是折下看下把，试一下都明白了）。 ​ 所以总结规律当你上下剪的时候只需要看左右对折的次数，$剪开纸的数目==2^n + 1$ 张。 同理当你左右剪的时候，只需要看上下对折的次数，规律一样。 Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#define INF 0x3f3f3f3f//大家设置int类型最大值的时候可以设置为这个数，将近int类型最大数的一半，而且乘2还不会爆int//(这里好像用不到，习惯了，一般都会打上)using namespace std;typedef long long ll;int T;ll lr, tb;//这里用快速幂写了一下，算帮大家复习一下了。//其实for循环也可以过，因为n最大10^5，所以不会超时。//但是最好不要用c/c++自带的pow(a, b),他会损失精度，int类型的也会损失导致结果错误。ll power(ll a, ll b) &#123; ll ans = 1, base = a; while(b != 0)&#123; if(b&amp;1 != 0)&#123; ans = base * ans % 1000000007; &#125; base = base * base % 1000000007; b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; lr = 0; tb = 0; ll n; scanf("%lld", &amp;n); string c; cin&gt;&gt;c; for(int i = 0; i &lt; n; i++)&#123; //统计一下左右折 与 上下折的次数 if(c[i] == 'B' || c[i] == 'T') tb++; else lr++; &#125; string s; cin&gt;&gt;s; if(s == "TB" || s == "BT" )&#123; printf("%lld\n", ( power(2, lr) + 1 )% 1000000007 ); //结果输出之前记得再模一下，有可能加1正好等于1000000007，那就尴尬了。 &#125; else&#123; printf("%lld\n", ( power(2, tb) + 1 )% 1000000007 ); &#125; &#125; return 0;&#125; G、数数题目大意： 题意题目描述说的比较清楚了，这里就不在赘述了，简单说就是给你一个串，按照规则翻译成一个别的串，规则题目说的很清楚。 解题思路： 把这个串存起来，然后从头往后找，看有几个连续的，如果就它自己连续，那么输出1x，x就是对应的字符，如果连续n个为它就输出nx。 Code： H、神奇老虎机题目大意：先给你一个样例的个数，然后对于每一个样例，第一行轮子的个数n（$1&lt;=n &lt;=1000$），第二行为n个整数（$1 &lt;= 每个数大小 &lt;= 100$），他让你每组输入对应一行输出，输出字典序最小时老虎机滚轮上显示的数字 解题思路：​ 贪心，你让每个轮子的字典序都最小，那么整个字典序不就最小么？其实不是这样的，如果让每个轮子的字典序最小，那么又因为每个轮子上数据的范围都是大于等于1的，所以让所有的轮子都直接是1就可以了吗？​ 你会发现假设给你3个数：​ 2 20 9 这三个数对应是每个轮子上面最大的数，那么由这三个轮子组成的最小字典序是 1 1 1 吗？ 1 10 1 是不是比 1 1 1 这个字典序更小了，所以呢。除了最后一个轮子，前面的轮子，如果:​ 当$1 &lt;= a_i &lt;= 9$时，那么该轮子字典序应取1。​ 当$10 &lt;= a_i &lt;= 99$时 那么该轮子字典序应取10​ 当$a_i == 100​$时 那么该轮子字典序应取100​ 但是要注意最后一个轮子，由于它规定了(220的字典序比22的大，因为22是220的一个前缀)所以最后一个轮子一定要是1，才可以保证字典序最小。 举个栗子：样例输入： 162 9 11 59 100 63 那么其最小字典序应该对应为： 1 1 10 10 100 1 你可以试一下，不会有比这个更小的了，如果不理解可以找找看有没有比它更小的，找一下，你就理解了。 Code： 宋健：I、J、K、LI、五环题目大意：输入一个串，输出一个串； 解题思路：可以用if else 暴力来做，或者采用Map； map&lt;string,string&gt;_map; Code：123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;map&lt;string,string&gt;T;int main()&#123; T["Blue"]="Europe"; T["Europe"]="Blue"; //// T["Yellow"]="Asia"; T["Asia"]="Yellow"; //// T["Black"]="Africa"; T["Africa"]="Black"; //// T["Green"]="Oceania"; T["Oceania"]="Green"; //// T["Red"]="America"; T["America"]="Red"; string sh;cin&gt;&gt;sh; cout&lt;&lt;T[sh]&lt;&lt;endl;&#125; J、开挂的小洋题目大意：给你N个地鼠出现的时间，在一秒钟最多砸死两个地鼠。求在m时间内最多可以砸死多少只地鼠； 解题思路：可以定义一个vis数组记录第i秒内出现的地鼠的数量，ans记录最后的结果。 Code：1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define maxn (int)1e5+100int vis[maxn];int main()&#123; int n,m;cin&gt;&gt;n&gt;&gt;m; long long ans=0; for(int i=0;i&lt;n;i++) &#123; int x;scanf("%d",&amp;x); if(vis[x]&lt;2) &#123; vis[x]++; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; K、数字匹配题目大意：给你一个长度为n的a数组和长度为n的b数组，求两者匹配之后求和的最大和最小； 解题思路：先对两者进行排序，a最大的乘以b最大的为最大； maxx=sum(a[i]*b[i])，a,b都是从小到大排序，a最小的乘以b最大的为最小； Minn=sum(a[i]*b[i])，a从小到大排序，b从大到小排序。 下证： 强强联合，弱弱联合 负数的时候也符合此规律 可以参考白皮书P126页、 Code：123456789101112131415161718#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000+100int a[maxn];int b[maxn];int main()&#123; int n;cin&gt;&gt;n; for(int i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(int i=0;i&lt;n;i++)scanf("%d",&amp;b[i]); sort(a,a+n);sort(b,b+n); int ans1=0,ans2=0; for(int i=0;i&lt;n;i++)ans1+=a[i]*b[i]; for(int i=0;i&lt;n;i++)ans2+=a[i]*b[n-1-i]; printf("%d %d\n",ans1,ans2);&#125; L、寄蒜几盒题目大意：输入一个n;然后输入n段距离，表示第1个点与第2个点之间圆弧的长度、第2个点与第3个点之间圆弧的长度······第n个点与第1个点之间圆弧的长度。 解：转化问题求在n条线段，分成三段完全相等的线段。 解题思路一：参考白皮书P146。 开2倍的数组，能够实现以任意点为起点的一个环。 尺取：定义c为环的长度/3。 以1为起点开始尺取，取s为头，t为结尾后的第一个节点。 定义sum为第一段的长度，因为环的长度为3*c，若尺取的第一段长度等于c,这时特判从t（t为第一段之后的第一个节点）向后加一直到大于等于c，若有等于c的情况，说明第一段和第二段都满足c，此时可以输出yes； 若此时的第一段长度大于c，则sum减去s的长度，s++; 若s&gt;n，则表示以1到n的节点为头指针的每一段，都不满足情况，输出no; Code1：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;int a[(int)1e7+1000];int main()&#123; int n;scanf("%d",&amp;n); int sum=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); sum+=a[i]; a[n+i]=a[i]; &#125; if(sum%3!=0)puts("No"); else &#123; int c=sum/3; int s=1,t=1,sum=0; bool flg=0; while(1) &#123; while(sum&lt;c) sum+=a[t++]; if(sum==c) &#123; int temp=t; int ff=0; while(ff&lt;c)ff+=a[temp++]; if(ff==c) &#123; flg=1; break; &#125; &#125; sum-=a[s++]; if(s&gt;n) break; &#125; if(flg==1)puts("Yes"); else puts("No"); &#125;&#125; 解题思路二：n的数据范围为1e6 ，每个数据从(1，1000)相乘不会爆int，可以用set集合存数据，二分来取数据（三个点），看是否成立。 可以把环看出一条循环的线，从坐标0出发，第一个点的坐标为0+a[1],第二个坐标为0+a[1]+a[2]…… 因为是循环的一个环，所以要增加一倍的坐标放入set容器里，然后用set容器的find函数进行查找； 定义c为环长度的1/3； 从每一个点开始，例如d坐标 ,查找d+c ,d+2*c的坐标是否存在。 若存在，则输出yes,否则以下一个点为起点继续查找，一直找不到输出no; Code2： 某不愿透露姓名的帅哥：MM、签到题题目大意：略。 解题思路：略。 Mycode：略。 碎碎念：三位队员都给我发的word文档！！而且仅有一位主动附了代码。。Markdown这么好用为啥不用啊喂，好多公式还要手动调整(╯‵□′)╯︵┻━┻(没想到整理出来也用了1h+)。用word就用word吧，代码还以图片的形式放到里面…emmm…后面是不是该安利一波Markdown了。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>QLU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QLU ACM-ICPC大学生程序设计迎新赛-热身赛【解题报告】]]></title>
    <url>%2Fqlu-2018-1%2F</url>
    <content type="text"><![CDATA[前言：作为吃瓜群众围观两小时，见证了昌38s1A猜数题(太欧了吧)，中途lzw登顶，柳总封榜前7秒AK等精彩刺激的环节，感觉2小时也并不漫长。 赛后和大家一起讨论了下题目，感觉都是可做的，预备队员最低要求为4题(D和F可能费点事)，正式队员应该AK。 可能之前有没接触过猜答案的题目的，权当娱乐吧。 题解说明仅附代码，因为题面都是中文且思路都很明显。 题目序号 问题 A: 寻找欧皇123456789101112#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; printf("7\n"); return 0;&#125; 问题 B: 人类的本质1234567891011121314151617#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n;string s;int main()&#123; while(cin &gt;&gt; s &gt;&gt; n) &#123; while(n--) cout &lt;&lt; s &lt;&lt; '\n'; &#125; return 0;&#125; 问题 C: 数的价值1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;string s;long long res;int main()&#123; while(cin &gt;&gt; s) &#123; res = 1; for(int i = 0; i &lt; s.size(); ++i) if(s[i] != '0') res = res * (s[i] - '0'); if(s == "0") res = 0; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125; 问题 D: 方格填充1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, x, y;int res[7][7] =&#123; &#123;1, 1, 1, 2, 2, 2, 3&#125;, &#123;1, 2, 2, 2, 3, 4, 4&#125;, &#123;1, 2, 3, 4, 4, 5, 6&#125;, &#123;2, 2, 4, 4, 6, 6, 8&#125;, &#123;2, 3, 4, 6, 7, 8, 9&#125;, &#123;2, 4, 5, 6, 8, 10, 11&#125;, &#123;3, 4, 6, 8, 9, 11, 13&#125;,&#125;;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", res[x-1][y-1]); &#125; return 0;&#125; 问题 E: 买铅笔12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, num, price, res[3];int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; 3; ++i) &#123; scanf("%d%d", &amp;num, &amp;price); int need = n / num + ((n % num) ? 1 : 0); res[i] = need * price; &#125; res[0] = min(res[0], res[1]); res[0] = min(res[0], res[2]); printf("%d\n", res[0]); return 0;&#125; 问题 F: 图书管理员12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1010;int n, t, x, q, a[N];int len[] = &#123;0,10,100,1000,10000,100000,1000000,10000000&#125;;int main()&#123; scanf("%d%d", &amp;n,&amp;q); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); sort(a, a + n); while(q--) &#123; bool flag = 0; scanf("%d%d", &amp;t, &amp;x); for(int i = 0; i &lt; n; ++i) &#123; if(a[i] % len[t] == x) &#123; flag = 1; printf("%d\n", a[i]); break; &#125; &#125; if(!flag) puts("-1"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>QLU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU ACM-ICPC 2018 Training Weekly Contest(Freshman/11-11)【解题报告】]]></title>
    <url>%2Fsdnu-2018-3%2F</url>
    <content type="text"><![CDATA[题目难度分析及考察内容：easy：1004(C语言)1001(快速幂模板，周五晚刚讲的)1005(简单字符串处理)1006(模拟 + 细节)medium：1002(规律||直接做&lt;数组开全局就能开的下了&gt;)1003(中等字符串处理)1008(结构体排序&lt;课上没讲吗?那就趁这个机会学一下&gt;)1007(题意理解)hard：1009(map + 题意)发现的问题： 乱加getchar()。(王某) 数组不开全局，导致RE。(孙某) 8102年了，不知道递推，求fibonacci数列还用递归(第二题没做出来的xxxxxxx) 不跟榜，在一个题上从开场WA到结束。 对罚时还没概念，这个慢慢培养吧，身处弱校 + 自身菜鸡很多时候都靠罚时蹭个牌。。 说明：这些题目一周内完全可以补完，下周一至周四尽量补完。 充分思考后再看思路，最后再看代码。AC过也最好看看，说不定就学到新知识了呢。 一定要保证最后能自己写出来并AC掉。 题解1349.快速幂入门快速幂模板题，签到 Code:无。 1356.Fibonacci题意：给出一个序列，序列的定义为 $\operatorname{F[i]}=\begin{cases}7 &amp; \text{i = 0 } \\text 11 &amp; \text{i = 1}\ F[n-1] + F[n-2] &amp; \text{i $\geq$ 2 } \\end{cases}$ 问F[n] % 3 是否等于 0 思路： 直接做(怎么还有人用递归？这种可以递推的别递归啊，看一下n的范围，递归这不明摆着过不了吗) 可以直接做的原因是 $(a + b) \% m = ((a \% m) + (b \% m)) \% m$。 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1000010;int f[N], n;void init()&#123; f[0] = 7, f[1] = 11; for(int i = 2; i &lt; N; ++i) f[i] = (f[i - 1] + f[i - 2]) % 3;&#125;int main()&#123; init(); while(~scanf("%d", &amp;n)) puts(f[n] ? "no" : "yes"); return 0;&#125; 找规律(写出几项来就发现了) 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;//int f[111];int main()&#123; /* f[0] = 7, f[1] = 11; for(int i = 2; i &lt;= 20; ++i) f[i] = f[i - 1] + f[i - 2]; for(int i = 0; i &lt;= 20; ++i) cout &lt;&lt; f[i] % 3 &lt;&lt; ' '; cout &lt;&lt; '\n'; */ int n; while(~scanf("%d", &amp;n)) puts((n - 2) % 4 ? "no" : "yes"); return 0;&#125; 1357.Text Reverse题意：将输入的每个字符进行翻转。 思路：直接做 代码：用string的reverse函数可以简单快速的实现 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int t;string a, s;int main()&#123; scanf("%d", &amp;t); getchar(); while(t--) &#123; getline(cin, s); //读取一行 stringstream ss(s); //创建一个“字符串流” bool flag = 0; //控制空格 while(ss &gt;&gt; a) &#123; if(flag) cout &lt;&lt; ' '; flag = 1; reverse(a.begin(), a.end()); cout &lt;&lt; a; &#125; cout &lt;&lt; '\n'; &#125; return 0;&#125; 1358.Buildings题意：记录只有0和1构成的$N \times M$的矩阵中有多少个1。 思路：直接做(疑问：用数组干啥啊？)。 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, m, tem, res;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; res = 0; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; n * m; ++i) &#123; scanf("%d", &amp;tem); res += tem; &#125; printf("%d\n", res); &#125; return 0;&#125; 1359.GPA题意：自己翻译。 思路：直接做。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;bool flag;int val[256];char s[1111];int cnt, len, sum;void init()&#123; memset(val, -1, sizeof(val)); val['A'] = 4; val['B'] = 3; val['C'] = 2; val['D'] = 1; val['F'] = 0;&#125;int main()&#123; init(); while(gets(s)) &#123; flag = 1; sum = cnt = 0; len = strlen(s); for(int i = 0; i &lt; len; ++i) &#123; if(s[i] == ' ') continue; if(val[s[i]] == -1) &#123; flag = 0; break; &#125; ++cnt; sum += val[s[i]]; &#125; if(!flag) puts("Unknown letter grade in input"); else printf("%.2f\n", (double)sum / cnt); &#125; return 0;&#125; 1361.Grasshopper And the String题意：找出一个字符串的两个相邻的元音字母(‘A’, ‘E’, ‘I’, ‘O’, ‘U’ and ‘Y’)的最大位置。 思路：直接做。记得初始位置和结束位置特判。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char s[111];bool judge(char ch)&#123; if(ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' || ch =='Y') return true; return false;&#125;int main()&#123; while(~scanf("%s", s)) &#123; int len = strlen(s); int res = 0, tmp = -1; for(int i = 0; i &lt; len; ++i) &#123; if(judge(s[i])) &#123; res = max(res, i - tmp); tmp = i; &#125; &#125; res = max(res, len - tmp); printf("%d\n", res); &#125; return 0;&#125; 1362.Parade题意：阅读理解题，这里不写了，自己细细品味。 思路：嗯。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 100010;int n, res, sum1, sum2, a[N], b[N];int t1, t2, best;int main()&#123; while(~scanf("%d", &amp;n)) &#123; sum1 = sum2 = 0; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d", &amp;a[i], &amp;b[i]); sum1 += a[i]; sum2 += b[i]; &#125; res = 0; best = abs(sum1 - sum2); for(int i = 1; i &lt;= n; ++i) &#123; t1 = sum1 - a[i] + b[i]; t2 = sum2 - b[i] + a[i]; if(abs(t1 - t2) &gt; best) &#123; best = abs(t1 - t2); res = i; &#125; &#125; printf("%d\n", res); &#125; return 0;&#125; 1363.Solving Order题意：嗯。 思路：结构体排序。 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, m;struct node&#123; int cnt; char color[11];&#125; a[11];bool cmp(node u, node v)&#123; return u.cnt &gt; v.cnt;&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%s%d", &amp;a[i].color, &amp;a[i].cnt); sort(a + 1, a + n + 1, cmp); for(int i = 1; i &lt;= n; ++i) printf("%s%c", a[i].color, i == n ? '\n' : ' '); &#125; return 0;&#125; 1533.寻找复读机题意：中文题面。 思路：map标记，直接找。 坑点： 1. 卡PE 2. `找出所有可能是复读机的群友`(我们只能确定出明确不是复读机的群友，剩下的不确定的都可能是)。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;const int N = 1111;string s[N];int n, m, a[N];map&lt;int, bool&gt; MP;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m) &#123; for(int i = 1; i &lt;= m; ++i) cin &gt;&gt; a[i] &gt;&gt; s[i]; for(int i = 1; i &lt;= n; ++i) MP[i] = 1; MP[a[1]] = 0; for(int i = 2; i &lt;= m; ++i) if(s[i] != s[i - 1]) MP[a[i]] = 0; bool flag = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(!MP[i]) continue; if(flag) cout &lt;&lt; ' '; flag = 1; cout &lt;&lt; i; &#125; cout &lt;&lt; '\n'; &#125; return 0;&#125; END： 每当在书中读及那些卑微的努力，都觉得感动且受震撼。也许每个人在发出属于自己的光芒之前，都经历了无数的煎熬，漫长的黑夜，无尽的孤独，甚至不断的嘲讽和否定，但好在那些踮脚的少年，最后都得到了自己想要的一切。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第八章习题】]]></title>
    <url>%2Flrj-ch8-1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第八章例题】]]></title>
    <url>%2Flrj-ch8-0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU 5527 Too Rich【思维】【贪心】]]></title>
    <url>%2Fhdu-5527%2F</url>
    <content type="text"><![CDATA[题目大意：给你面值为1，5，10，20，50，100，200，500，1000，2000的钞票$c_1、c_2 \ldots c_{10}$，问你给出的这些钱能否恰好凑出p元来，如果可以，最多的数量是多少。 解题思路：用给出的钱从大到小比较和p的关系凑很容易检查能否凑出p元来，这时是用的最少的数量凑的。 用最多的数量的话就是用tot - (最少的钱数凑的sum - p的数量)，tot是总数量，sum是总面值和。本来以为到这里就结束了，然而满足上面这是最少使用量的前提是小面额是大面额的因子，即任意数量的大面额总能用若干小面额凑出来，而在本题中20、50，200、500不满足。对于这种情况的解法，我们可以将两个50的合成一个100的，两个500的合成一个1000的来算，但是答案可能还有用到1个50/500的情况。好在他们的搭配只有4种，这时我们只要枚举这4种情况就好了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;int t, p, tot, sum;int a[11], b[11], val[11];void init()&#123; val[0] = 1, val[1] = 5, val[2] = 10; val[3] = 20, val[4] = 50, val[5] = 100; val[6] = 200, val[7] = 500, val[8] = 1000; val[9] = 2000;&#125;void init2()&#123; for(int i = 0; i &lt; 10; ++i) b[i] = a[i];&#125;int solve(int num)&#123; int ans = 0, tem; for(int i = 9; i &gt;= 0; --i) &#123; if(i == 4 || i == 7) &#123; tem = min(num / (val[i] * 2), b[i] / 2); num -= tem * val[i] * 2; ans += tem * 2; &#125; else &#123; tem = min(num / val[i], b[i]); num -= tem * val[i]; ans += tem; &#125;// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; tem &lt;&lt; endl; &#125; //cout &lt;&lt; "ans = " &lt;&lt; ans &lt;&lt; '\n'; if(num) return INF; return ans;&#125;int main()&#123; init(); scanf("%d", &amp;t); while(t--) &#123; tot = sum = 0; scanf("%d", &amp;p); for(int i = 0; i &lt; 10; ++i) &#123; scanf("%d", &amp;a[i]); tot += a[i]; sum += a[i] * val[i]; &#125; //cout &lt;&lt; "tot = " &lt;&lt; tot &lt;&lt; " sum = " &lt;&lt; sum &lt;&lt; '\n'; if(sum &lt; p) &#123; puts("-1"); continue; &#125; //凑组成p最多的，就是sum - p最少的，tot - res就是答案 p = sum - p; int res = INF; for(int i = 0; i &lt; 2; ++i) &#123; for(int j = 0; j &lt; 2; ++j) &#123; init2(); int tem = p; if(i &amp;&amp; b[4]) &#123; --b[4]; tem -= 50; &#125; if(j &amp;&amp; b[7]) &#123; --b[7]; tem -= 500; &#125; if(tem &lt; 0) continue;// cout &lt;&lt; "res = " &lt;&lt; res &lt;&lt; endl; res = min(res, solve(tem) + i + j); &#125; &#125; printf("%d\n", (res == INF ? -1 : tot - res)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>HDU</tag>
        <tag>ICPC</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6435 Problem J.CSGO【思维】【二进制枚举】]]></title>
    <url>%2Fhdu-6435%2F</url>
    <content type="text"><![CDATA[题目大意：现在有n把主武器和m把副武器，每个武器除了有1个固定属性外，还有k个能互相影响的属性，具体体现在当你选择两把武器时，固定属性带给你的加成是两者的固定属性值之和，而这k个属性带给你的加成是两武器的对应各属性差的绝对值之和。 现在要你选择一把主武器和一把副武器，使得两武器配合带来的加成最大。 解题思路：考虑到n和m的范围最大值都是100000，所以直接看搭配方案是不可行的，而属性k最大只有5，我们可以从这里入手。两武器搭配，对应的k个属性要么是加上带来的加成，要么是减去带来的加成，所以我们可以把每一把武器的每一种状态都枚举出来，就是$2^k$种加减组合，枚举的同时更新此状态下的最大值，对于最后的答案就是将主武器的这个集合和副武器的补集求和。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;int t, n, m, k, up;ll v, a[6], MW[44], SW[44];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); up = 1 &lt;&lt; k; memset(MW, -INF, sizeof(MW)); memset(SW, -INF, sizeof(SW)); for(int o = 0; o &lt; n; ++o) &#123; scanf("%lld", &amp;v); for(int i = 0; i &lt; k; ++i) scanf("%lld", &amp;a[i]); for(int i = 0; i &lt; up; ++i) &#123; ll tem = v; for(int j = 0; j &lt; k; ++j) &#123; if(i &amp; (1 &lt;&lt; j)) tem += a[j]; else tem -= a[j]; &#125; MW[i] = max(MW[i], tem); &#125; &#125; /*for(int o = 0; o &lt; up; ++o) cout &lt;&lt; MW[o] &lt;&lt; " "; cout &lt;&lt; '\n';*/ for(int o = 0; o &lt; m; ++o) &#123; scanf("%lld", &amp;v); for(int i = 0; i &lt; k; ++i) scanf("%lld", &amp;a[i]); for(int i = 0; i &lt; up; ++i) &#123; ll tem = v; for(int j = 0; j &lt; k; ++j) &#123; if(i &amp; (1 &lt;&lt; j)) tem += a[j]; else tem -= a[j]; &#125; SW[i] = max(SW[i], tem); &#125; &#125; /*for(int o = 0; o &lt; up; ++o) cout &lt;&lt; SW[o] &lt;&lt; " "; cout &lt;&lt; '\n';*/ ll res = -INF; for(int o = 0; o &lt; up; ++o) res = max(res, MW[o] + SW[up - o - 1]); printf("%lld\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>思维</tag>
        <tag>多校联合</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6266 Hakase and Nano【规律】]]></title>
    <url>%2Fhdu-6266%2F</url>
    <content type="text"><![CDATA[题目大意：H和N玩取石子游戏，给出n堆石子，每堆$a_i$个，H每回合取两次，N每回合取一次，每次都只能从某一堆石子中取出至少一个石子，取走最后一个(堆)石子的获得胜利。 规定先后手，两者都采取最佳策略，问最后H能否获胜。 解题思路：H先手时，经过手算(?)我们发现当n % 3 == 0 &amp;&amp; n个石子全为1的时候先手必输。所以当H后手的时候，只要先手通过一步操作使当前局面变成上述局面H就输了。 这样只需要记录一下所给石子中不为0的石子堆的数目，根据这个输出答案就可以了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, k, a, o;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d",&amp;n,&amp;k); o = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;a); o += (a &gt; 1); &#125; if(k == 1) &#123; if(n % 3 == 0 &amp;&amp; o == 0) puts("No"); else puts("Yes"); &#125; else &#123; if((n - 1) % 3 == 0 &amp;&amp; o &lt;= 1) puts("No"); else if(n % 3 == 0 &amp;&amp; o == 1) puts("No"); else puts("Yes"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>CCPC</tag>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6418 Rikka with Stone-Paper-Scissors【思维】【期望】]]></title>
    <url>%2Fhdu-6418%2F</url>
    <content type="text"><![CDATA[题目大意：现在A和B进行剪刀石头布的游戏，两者中赢得一方会+1分，输得一方-1分，平局分不变。已知A的剪刀石头布各出的次数为a、b、c，B的为a’、b‘、c’(保证A和B出的总次数相同)，B知道A的牌组组成，求当B按照最优策略出牌时，B最大的得分期望。 解题思路：得分期望 = $\sum_{k=1}^n​$ 得分 * 得分概率。 B要获得最大分数，当A出剪刀时，B要出石头，此时B可以得到A出剪刀的分数，也可以失去A出布的分数，则A出剪刀时，B的得分期望为$ b’ \times \frac{a}{a + b + c} - b’ \times \frac{c}{a + b + c} $，依次类推，可以得出答案为$\frac{a’ \times (c - b) + b’ \times (a - c) + c’ \times (b - a)}{a + b + c}$。 最后注意化简一下就好了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll a, b, c, a1, b1, c1;ll gcd(ll a, ll b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; int t; scanf("%d", &amp;t); while(t--) &#123; scanf("%lld%lld%lld%lld%lld%lld", &amp;a, &amp;b, &amp;c, &amp;a1, &amp;b1, &amp;c1); ll mu = a + b + c; ll zi = a1 * (c - b) + b1 * (a - c) + c1 * (b - a); if(zi == 0) puts("0"); else &#123; bool f = 0; if(zi &lt; 0) &#123; zi = -zi; f = 1; &#125; ll g = gcd(zi, mu); zi /= g; mu /= g; if(f) putchar('-'); if(mu == 1) printf("%lld\n", zi); else printf("%lld/%lld\n", zi, mu); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>思维</tag>
        <tag>多校联合</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6406 Taotao Picks Apples【思维】【线段树】]]></title>
    <url>%2Fhdu-6406%2F</url>
    <content type="text"><![CDATA[题目大意：现在有一个长度为n的序列，给出m个操作，每次操作都是将第p个位置处的数值替换为q，问每次操作后以第一个元素为起点的LIS的长度是多少。 解题思路：利用线段树维护区间最大值 &amp;&amp; 以区间左端点为起点的LIS的长度，这样答案就是以1为起点的LIS长度。对于每次查询只要替换对应位置上的值和更新树就好了，查询完后记得改回来。 有几点比较巧妙的地方稍微写一下： 区间的LIS长度 = 左子树的LIS长度 + 以左子树最大值为起点的右子树的LIS长度。 计算以某个值为起点的LIS长度时，继续比较这个值和此区间的左子树的最大值，大于等于就查询右子树，否则就返回继续查询左子树的LIS长度 + 用左子树的最大值查询右子树的LIS长度(写的很乱，直接看代码的calc函数和pushup函数好了)。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1e5+5;int t, n, m, pos, val, a[N];struct node&#123; int l, r; int maxx, val;&#125; tree[N&lt;&lt;2];int calc(int val, int rt)&#123; if(tree[rt].l == tree[rt].r) return val &lt; tree[rt].maxx; if(tree[rt&lt;&lt;1].maxx &lt;= val) return calc(val, rt&lt;&lt;1|1); else return calc(val, rt&lt;&lt;1) + (tree[rt].val - tree[rt&lt;&lt;1].val);&#125;void pushup(int rt)&#123; tree[rt].maxx = max(tree[rt&lt;&lt;1].maxx, tree[rt&lt;&lt;1|1].maxx); tree[rt].val = tree[rt&lt;&lt;1].val + calc(tree[rt&lt;&lt;1].maxx, rt&lt;&lt;1|1);&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; if(l == r) &#123; tree[rt].maxx = a[l]; tree[rt].val = 1; return ; &#125; int mid = l + r &gt;&gt; 1; build(l, mid, rt &lt;&lt; 1); build(mid + 1, r, rt &lt;&lt; 1 | 1); pushup(rt);&#125;void update(int pos, int val, int rt)&#123; if(tree[rt].l == tree[rt].r) &#123; tree[rt].maxx = val; return ; &#125; int mid = tree[rt].l + tree[rt].r &gt;&gt; 1; if(pos &lt;= mid) update(pos, val, rt&lt;&lt;1); else update(pos, val, rt&lt;&lt;1|1); pushup(rt);&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); build(1, n, 1); while(m--) &#123; scanf("%d%d", &amp;pos, &amp;val); update(pos, val, 1); printf("%d\n", tree[1].val); update(pos, a[pos], 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>HDU</tag>
        <tag>思维</tag>
        <tag>多校联合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5071 Chat【模拟】【vector】]]></title>
    <url>%2Fhdu-5071%2F</url>
    <content type="text"><![CDATA[题目大意：现在有一个聊天界面(可以想象为一个队列)，请你模拟以下操作： Add u： 在队列中加入一个优先级为u的窗口。如果已经存在同优先级的窗口，输出”same priority.”，否则输出 “success.”。 Close u：将队列中优先级为u的窗口关闭。如果不存在优先级为u的窗口，输出”invalid priority.” 否则输出”close u with c.”，其中c是和优先级为u的窗口的聊天次数。 Chat w：向当前在最顶端的窗口输入w句话。如果当前队列中没有窗口，输出”empty.” 否则输出”success.”。 Rotate x：将当前排在第x位的窗口翻转到最前面。如果x非法，输出”out of range.” 否则输出”success.”。 Prior：将优先级最高的窗口翻转到最前面。如果当前队列中没有窗口，输出”empty.” 否则输出”success.”。 Choose u：将优先级为u的窗口翻转到最前面。如果当前队列中没有此窗口，输出”invalid priority.” 否则输出”success.”。 Top u：将优先级为u的窗口置顶。如果当前队列中没有此窗口，输出”invalid priority.” 否则输出”success.”。 Untop：取消当前置顶的窗口。如果当前没有置顶的窗口，输出”no such person.” 否则输出 “success.”。 解题思路：我们可以用vector来模拟这个“队列”，里面的元素为记录优先级&amp;聊天次数的pair对，然后直接做就好了(可以通过写一些函数来模块化一些操作来减少代码量)。 PS：对于置顶这个操作，可以直接用一个变量来记录优先级，通过优先级找到它在队列中的原始位置，因为这个值是不变的，对于后续操作十分方便。 PPS：active时不要忘记忽略掉聊天次数为0的那些窗口。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;char op[9];int t, n, x, mx, pos, val;pair&lt;int, long long&gt; p;vector&lt;pair&lt;int, long long&gt; &gt; V;int Find(int v)&#123; for(int i = 0; i &lt; V.size(); ++i) if(V[i].first == v) return i; return -1;&#125;void Erase(int v)&#123; //删除第v个 int idx = 0; for(auto it = V.begin(); it != V.end(); ++it, ++idx) &#123; if(idx == v) &#123; V.erase(it); return ; &#125; &#125;&#125;void Add()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos != -1) puts("same priority."); else &#123; V.push_back(&#123;x, 0&#125;); puts("success."); &#125;&#125;void Close()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else &#123; printf("close %d with %lld.\n", V[pos].first, V[pos].second); Erase(pos); &#125;&#125;void Chat()&#123; scanf("%d", &amp;x); if(V.empty()) puts("empty."); else &#123; if(val) pos = Find(val); else pos = 0; V[pos].second += x; puts("success."); &#125;&#125;void Rotate(int x)&#123; --x; if(x &lt; 0 || x &gt;= V.size()) puts("out of range."); else &#123; p = V[x]; Erase(x); V.insert(V.begin(), p); puts("success."); &#125;&#125;void Prior()&#123; if(V.empty()) puts("empty."); else &#123; mx = -1; for(int i = 0; i &lt; V.size(); ++i) &#123; if(V[i].first &gt; mx) &#123; mx = V[i].first; pos = i; &#125; &#125; Rotate(pos + 1); &#125;&#125;void Choose()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else Rotate(pos + 1);&#125;void Top()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else &#123; val = x; puts("success."); &#125;&#125;void Untop()&#123; if(val) &#123; val = 0; puts("success."); &#125; else puts("no such person.");&#125;void active()&#123; if(val) &#123; pos = Find(val); if(V[pos].second) &#123; printf("Bye %d: %lld\n", V[pos].first, V[pos].second); Erase(pos); &#125; &#125; for(int i = 0; i &lt; V.size(); ++i) if(V[i].second) printf("Bye %d: %lld\n", V[i].first, V[i].second);&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; val = 0; V.clear(); scanf("%d", &amp;n); for(int cas = 1; cas &lt;= n; ++cas) &#123; scanf("%s", op); printf("Operation #%d: ", cas); if(op[0] == 'A') Add(); else if(op[0] == 'R') scanf("%d", &amp;x), Rotate(x); else if(op[0] == 'P') Prior(); else if(op[0] == 'T') Top(); else if(op[0] == 'U') Untop(); else if(op[1] == 'l') Close(); else if(op[2] == 'a') Chat(); else Choose(); &#125; active(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>HDU</tag>
        <tag>vector</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5929 Basic Data Structure【模拟】【deque】]]></title>
    <url>%2Fhdu-5929%2F</url>
    <content type="text"><![CDATA[题目大意： 现有一个栈，请你对它做出如下操作： PUSH x：将元素x入栈。 POP：将栈顶元素出栈。 REVERSE：将栈内元素翻转。 QUERY：查询从栈顶元素开始到栈底元素的NAND和。 其中NAND的定义为： 0 nand 0 = 1 0 nand 1 = 1 1 nand 0 = 1 1 nand 1 = 0 解题思路：对于操作1和操作2直接模拟就好了，费时的部分是剩余的两个操作。 考虑到n的范围最大取值为200000，我们可以开个400000的数组，取中间部分为初始起点，当进行操作3的时候直接将头对另一边进行1、2操作就好了。 观察这个nand运算我们发现，只要和0进行运算的，答案都变成了1，利用这一点我们可以记录0出现的位置，就是出现了0就将它存起来。我们可以也像上面那样进行记录，出于好写我这里直接用的deque。这样，每当查询时我们直接看存起来的0的位置，如果没有0那就数1的个数；如果有的话就看从头开始最后一个出现的0之后有多少个1。这里有个细节要注意，就是当只有1个0的时候，要特别判断一下。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;deque&gt;using namespace std;const int N = 200010;char op[11];int t, n, x, rig, lef, a[N&lt;&lt;1];int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; deque&lt;int&gt; Q; rig = 200001; lef = rig - 1; bool flag = true; printf("Case #%d:\n", cas); scanf("%d", &amp;n); while(n--) &#123; scanf("%s", op); if(op[0] == 'P') &#123; if(op[1] == 'U') &#123; scanf("%d", &amp;x); if(flag) &#123; if(!x) Q.push_back(rig); a[rig++] = x; &#125; else &#123; if(!x) Q.push_front(lef); a[lef--] = x; &#125; &#125; else &#123; if(flag) &#123; --rig; if(!a[rig]) Q.pop_back(); &#125; else &#123; ++lef; if(!a[lef]) Q.pop_front(); &#125; &#125; &#125; if(op[0] == 'Q') &#123; if(lef + 1 == rig) puts("Invalid."); else if(Q.empty()) printf("%d\n", (rig - lef - 1) &amp; 1); else &#123; if(flag) &#123; printf("%d\n", ((Q.front() - lef - 1) +(rig - 1 != Q.front())) &amp; 1); &#125; else &#123; printf("%d\n", ((rig - Q.back() - 1) +(lef + 1 != Q.back())) &amp; 1); &#125; &#125; &#125; if(op[0] == 'R') &#123; flag = !flag; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>HDU</tag>
        <tag>deque</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第七章习题】]]></title>
    <url>%2Flrj-ch7-1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 864D Make a Permutation! 【贪心】【模拟】]]></title>
    <url>%2Fcf-864d%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个数，每次可以花费1单位体力来将其中的任意一个数改变为任意一个数。现在他想要将这n个数经过若干次变换，使之包含1-n的所有数字。问他改变完成后花费的最小体力，并输出改变后的序列。如果存在多组解，输出这全排列中字典序最小的哪种方案。 解题思路：既然花费体力最小，那当然要优先考虑将出现过多次的数字替换为未出现的数字了。然后就是稍微困难点的部分了——字典序最小。我们考虑一下替换过程中可能会出现的情况可以发现，当一个数要被替换时，如果替换为的数小于这个数，那就取最靠前的数字来进行替换，否则就取靠后的来替换。（如11123 -&gt; 14523, 23334 -&gt; 21354）接下来的实现，先找一个数组记录这个序列，再找一个来记录每个数字出现的次数。因为最终替换为的是没有出现过的数字，所以还要记录下哪些数字没有出现过，这里可以用set也可以用priority_queue。最后遍历一遍原序列，开始进行替换（即出现次数大于一次的要被没出现过的替换掉）。因为还要比较大小关系，如果被替换的数&gt;要替换的数，直接替换就好了；否则标记下这个数，这里没有替换，以后再遇到不管怎样都要替换掉（再加个vis数组标记一下就好了）。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 200005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, tot;bool vis[MAX];int a[MAX], b[MAX];priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q;int main()&#123; scanf("%d",&amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d",&amp;a[i]); ++b[a[i]]; &#125; for(int i = 1; i &lt;= n; ++i) if(!b[i]) Q.push(i); for(int i = 1; i &lt;= n; ++i) &#123; if(Q.empty()) break; if(b[a[i]] &gt; 1) &#123; if(Q.top() &lt; a[i] || vis[a[i]]) &#123; ++tot; --b[a[i]]; a[i] = Q.top(); Q.pop(); &#125; else vis[a[i]] = true; &#125; &#125; printf("%d\n", tot); for(int i = 1; i &lt;= n; ++i) printf("%d ", a[i]); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第七章例题】]]></title>
    <url>%2Flrj-ch7-0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 771A Bear and Friendship Condition 【并查集/DFS】]]></title>
    <url>%2Fcf-771a%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个点，m条边构成的一个无向图。问是否图中所有的边都满足：当a和b相连、b和c相连时，a和c也相连。 解题思路：当满足上述条件时就说明这k个点构成了一个无向完全图，这种图的充要条件是：边数 = 点数 * (点数 - 1) / 2。根据这个突破点用DFS搜或者并查集判都可以了。 Mycode(并查集):1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 150010;int f[N];long long t[N], e;void init()&#123; for(int i = 1; i &lt; N; ++i) f[i] = i;&#125;int Find(int v)&#123; if(f[v] != v) f[v] = Find(f[v]); return f[v];&#125;void Union(int u, int v)&#123; int t1 = Find(u); int t2 = Find(v); if(t1 != t2) f[t2] = t1;&#125;int main()&#123; init(); int n, m; scanf("%d%d",&amp;n,&amp;m); for(int i = 0; i &lt; m; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); Union(u, v); &#125; for(int i = 1; i &lt;= n; ++i) &#123; ++t[Find(i)]; &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(t[i]) e += t[i] * (t[i] - 1) / 2; &#125; puts(e == m ? "YES" : "NO"); return 0;&#125; Mycode(DFS):12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int M = 150010;bool vis[M];vector&lt;int&gt; G[M];int n, m, x, y, v, e;void DFS(int t, int &amp; v, int &amp; e)&#123; vis[t] = true; ++v; e += G[t].size(); for(int i = 0; i &lt; G[t].size(); ++i) if(!vis[G[t][i]]) DFS(G[t][i], v, e);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; scanf("%d%d",&amp;x,&amp;y); G[x].push_back(y); G[y].push_back(x); &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(!vis[i]) &#123; v = e = 0; DFS(i, v, e); if(e != 1ll * v * (v - 1)) &#123; puts("NO"); return 0; &#125; &#125; &#125; puts("YES"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>DFS</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5461 Largest Point 【思维】]]></title>
    <url>%2Fhdu-5461%2F</url>
    <content type="text"><![CDATA[题目大意：现在有n个点，给出a和b，从这n个点中选出不同的两个点x、y，使得$ax ^ 2 + by$最大。问最大值是多少。 解题思路：首先想到的是找出最大值和最小值来，分4种情况讨论： a &gt; 0 &amp;&amp; b &gt; 0 a &gt; 0 &amp;&amp; b &lt; 0 a &lt; 0 &amp;&amp; b &gt; 0 a &lt; 0 &amp;&amp; b &lt; 0 分成这样后发现需要找的还有次大值、次小值以及最接近0的那个值。然后当最大值或最小值和最接近0的值是同一个时还要再进行判断。到这里有点晕了。。 后来发现一种很巧妙的思路，就是用两个数组存一下$ax^2$$和$$bx$的值，然后将两者排序，直接取两者的最大值就行了。当两者的最大值用的是同一个x后再加个比较就行了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 5000010;int t, n, x;long long a, b, res;struct node&#123; int idx; long long val;&#125; A[N], B[N];bool cmp(node u, node v)&#123; return u.val &lt; v.val;&#125;int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d%lld%lld", &amp;n, &amp;a, &amp;b); for(int i= 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;x); A[i].val = a * x * x; B[i].val = b * x; A[i].idx = B[i].idx = i; &#125; sort(A + 1, A + 1 + n, cmp); sort(B + 1, B + 1 + n, cmp); if(A[n].idx == B[n].idx) res = max(A[n].val + B[n - 1].val, A[n - 1].val + B[n].val); else res = A[n].val + B[n].val; printf("Case #%d: %lld\n", cas, res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>ICPC</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 242E XOR on Segment 【线段树】【异或】]]></title>
    <url>%2Fcf-242e%2F</url>
    <content type="text"><![CDATA[题目大意：给出一个包含n个数的数组，先要对数组中的数进行m次操作，当输入的指令为1时，输出区间l~r的数的和；当输入的指令为2时，将区间l~r的数全部^x。 解题思路：区间更新，区间求和，线段树的典型应用。求和好解决，但是更新呢？如果单点更新肯定超时不用想。考虑异或的性质，是否可以将存的数分解为二进制的形式进行存储呢，答案是可以的。因为$a_i$最大不超过$ 2^{20} $，所以将sum改为大小为20的数组来存取二进制形式的每一位是能实现的。更新时还是延迟标记的思想，查询时再将这些数“合起来”就行了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 100010;int a[MAX];struct node&#123; int l, r; int sum[22], lazy;&#125; tree[MAX&lt;&lt;2];void pushup(int rt)&#123; for(int i = 0; i &lt;= 20; ++i) tree[rt].sum[i] = tree[rt&lt;&lt;1].sum[i] + tree[rt&lt;&lt;1|1].sum[i];&#125;void pushdown(int rt)&#123; int mid = tree[rt].r + tree[rt].l &gt;&gt; 1; for(int i = 0; i &lt;= 20; ++i) &#123; if(tree[rt].lazy &amp; (1 &lt;&lt; i)) &#123; tree[rt&lt;&lt;1].sum[i] = mid - tree[rt].l + 1 - tree[rt&lt;&lt;1].sum[i]; tree[rt&lt;&lt;1|1].sum[i] = tree[rt].r - mid - tree[rt&lt;&lt;1|1].sum[i]; &#125; &#125; tree[rt&lt;&lt;1].lazy ^= tree[rt].lazy; tree[rt&lt;&lt;1|1].lazy ^= tree[rt].lazy; tree[rt].lazy = 0;&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; tree[rt].lazy = 0; if(l == r) &#123; for(int i = 0; i &lt;= 20; ++i) tree[rt].sum[i] = (a[l] &amp; (1 &lt;&lt; i)) &gt; 0; return ; &#125; int mid = l + r &gt;&gt; 1; build(l, mid, rt&lt;&lt;1); build(mid+1, r, rt&lt;&lt;1|1); pushup(rt);&#125;void update(int l, int r, int val, int rt)&#123; if(tree[rt].l == l &amp;&amp; tree[rt].r == r) &#123; tree[rt].lazy ^= val; for(int i = 0; i &lt;= 20; ++i) &#123; //注意这里的更新值 if(val &amp; (1 &lt;&lt; i)) tree[rt].sum[i] = r - l + 1 - tree[rt].sum[i]; &#125; return ; &#125; if(tree[rt].lazy) pushdown(rt); int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(r &lt;= mid) update(l, r, val, rt&lt;&lt;1); else if(l &gt; mid) update(l, r, val, rt&lt;&lt;1|1); else &#123; update(l, mid, val, rt&lt;&lt;1); update(mid+1, r, val, rt&lt;&lt;1|1); &#125; pushup(rt);&#125;long long query(int l, int r, int rt)&#123; long long res = 0; if(tree[rt].l == l &amp;&amp; tree[rt].r == r) &#123; for(int i = 0; i &lt;= 20; ++i) res += (1ll &lt;&lt; i) * tree[rt].sum[i]; return res; &#125; if(tree[rt].lazy) pushdown(rt); int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(r &lt;= mid) res += query(l, r, rt&lt;&lt;1); else if(l &gt; mid) res += query(l, r, rt&lt;&lt;1|1); else res += query(l, mid, rt&lt;&lt;1) + query(mid+1, r, rt&lt;&lt;1|1); return res;&#125;int main()&#123; int n, m, l, r, val, Q; scanf("%d",&amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d",&amp;a[i]); build(1, n, 1); scanf("%d",&amp;m); while(m--) &#123; scanf("%d%d%d",&amp;Q,&amp;l,&amp;r); if(Q == 1) printf("%lld\n", query(l, r, 1)); else &#123; scanf("%d", &amp;val); update(l, r, val, 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>线段树</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 822C Hacker, pack your bags! 【贪心】【模拟】]]></title>
    <url>%2Fcf-822c%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个区间，每个区间有个值$c_i​$。现要你从中选出两个区间，使得它们不相交 &amp;&amp; 区间长度之和恰好为 x。无解时输出-1， 存在多个可行解时输出$c_i + c_j​$ 最小的和。 解题思路：第一感觉是排序后选定一个区间，然后二分找到满足值为$x - c_i$的那个区间，然后写炸了。后来补题时发现可以用个vector将区间的左端点和值存下来，下标就是区间长度，这样查的时候就变得很好查了。然后每个区间按照左端点从小到大排好序，因为区间长度固定，这样遍历时就可以遍历区间长度为i的区间，对于长度为$x - i$的，只遍历在长度为i的区间的左边的区间并同时记录最小值就可以了。详细看代码吧。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int N = 200010;const int oo = 2e9+7;int n, x, l, r, c, res, tem;vector&lt; pair&lt;int, int&gt; &gt; G[N];int main()&#123; scanf("%d%d", &amp;n, &amp;x); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d%d", &amp;l, &amp;r, &amp;c); G[r - l + 1].push_back(&#123;l, c&#125;); &#125; for(int i = 1; i &lt; x; ++i) sort(G[i].begin(), G[i].end()); res = oo; for(int cost = 1; cost &lt; x; ++cost) &#123; tem = oo; auto &amp;u = G[cost], &amp;v = G[x - cost]; for(int i = 0, j = 0; i &lt; v.size(); ++i) &#123; while(j &lt; u.size() &amp;&amp; u[j].first + cost - 1 &lt; v[i].first) &#123; tem = min(tem, u[j].second); ++j; &#125; if(tem != oo) res = min(res, tem + v[i].second); &#125; &#125; printf("%d\n", res == oo ? -1 : res); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6438 Buy and Resell 【思维】【贪心】]]></title>
    <url>%2Fhdu-6348%2F</url>
    <content type="text"><![CDATA[题目大意：现在有n个城市，你依次经过城市$1$ ~ $n$。每个城市都有一个共同的物品，但它们的价格可能会不一样。你经过一个城市时可以选择将这个物品以 $a_i$ 的价格买下来，或者是以 $a_i$的价格卖出去(卖出去的前提是你已经有至少一个此物品)，每个城市最多进行一次买/卖操作。初始时你又无限多的钱，问在走完这n个城市后你的钱最多能变成多少，并输出此时交易的次数。当能通过多种买/卖的方法达到最多钱的时候，输出交易次数最少的那一次。 解题思路：我们可以用一个可以自动排好序的容器存储当前可以买到哪些货，排序是按照最便宜的在前面这样，每次到了可以卖的时候就先卖掉，然后到一个可以赚更多钱的城市的时候，再收回，重新卖一遍。每个输入的x存两次是一次代表着买入一次代表着卖出。当买入时说明一定在最后卖出了，这时买卖次数++。 Mycode：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;long long res;int t, n, cnt, x;pair&lt;int, int&gt; pp;multiset&lt; pair&lt;int, int&gt; &gt; Q;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; Q.clear(); res = cnt = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;x); Q.insert(make_pair(x, 1)); //sell Q.insert(make_pair(x, 2)); //buy pp = *Q.begin(); res += x - pp.first; if(!(pp.second &amp; 1)) ++cnt; Q.erase(Q.begin()); &#125; printf("%lld %d\n", res, cnt &lt;&lt; 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>HDU</tag>
        <tag>思维</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5832 A water problem 【大数取模】]]></title>
    <url>%2Fhdu-5832%2F</url>
    <content type="text"><![CDATA[题目大意：告诉你个长度为$10000000$的数字，问这个数字是否既是73的倍数又是137的倍数。 解题思路：大数取模。c++的大数取模是根据秦九韶公式来的， 举个例子来说$123 = ((1 \times 10 + 2) \times 10) + 3$， 而$(a \times b) \% M = a \% M \times b \% M$， 然后我们就能得到$123 \% M = ((1 \% M \times 10 + 2) \% M \times 10) \% M + 3 \% M$。 Mycode：1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 10000010;const int M1 = 73;const int M2 = 137;char s[N];int main()&#123; for(int cas = 1; ~scanf("%s", s); ++cas) &#123; int len = strlen(s); int sum1 = 0, sum2 = 0; for(int i = 0; i &lt; len; ++i) &#123; sum1 = (sum1 * 10 + s[i] - '0') % M1; sum2 = (sum2 * 10 + s[i] - '0') % M2; &#125; printf("Case #%d: %s\n", cas, (!sum1 &amp;&amp; !sum2) ? "YES" : "NO"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>CCPC</tag>
        <tag>大数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6150 Vertex Cover 【构造】]]></title>
    <url>%2Fhdu-6150%2F</url>
    <content type="text"><![CDATA[题目大意：最小顶点覆盖问题是一个传统的NP完全问题，就是多项式复杂程度的非确定性问题。现在告诉你一个此问题的近似解法，算法的主要思想是遍历每个顶点，贪心的选取当前未被选取的点中的与另外的点相连数目最多的顶点，相连数目相同时选序号靠后的那个点。伪代码实现如下： 1234567891011121314151617181920212223for (int i = 1; i &lt;= n; ++i) &#123; use[i] = false; deg[i] = degree of the vertex i;&#125;int ans = 0;while (true) &#123; int mx = -1, u; for (int i = 1; i &lt;= n; ++i) &#123; if (use[i]) continue; if (deg[i] &gt;= mx) &#123; mx = deg[i]; u = i; &#125; &#125; if (mx &lt;= 0) break; ++ans; use[u] = true; for (each vertex v adjacent to u) --deg[v];&#125;return ans; 现在要你找出一组数据来，使得按照他的方法跑出来的结果是最优解的3倍以上。 解题思路：题目中给出的思路显然是不对的，hack掉这个程序的关键就是当数目相同时他去掉的是靠后的那个点。 我们可以构造两组点，使得左边的那一组为正确答案，右边的为按照他的算法得出的答案。正确答案为左边，假设有n个点，先在右边构造n个点，和左边的一一相连；然后再在右边构造$\lfloor \frac{n}{2} \rfloor$个点，使得这些点依次与{1、2}、{3、4}……这些点相连，最后不足以连接的就不连；然后再在右边构造$\lfloor \frac{n}{3} \rfloor$个点，进行连接；……；直至构造了1个与n个点相连的点。 上面的构造方法就是根据前面的漏洞制定的，最后确定一下n为多少就好了。因为要求$3 * n \leq \sum_{i=1}^n{\lfloor \frac{n}{i} \rfloor}$, 所以n = 15就够了。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int L, R, cnt;struct node&#123; int x, y;&#125;a[666];int main()&#123; L = R = 15; //num就是构造的下一个点与左边集合的点相连数目 for(int num = 1; num &lt;= L; ++num) &#123; //st为与左边相连的顶点的起点 for(int st = 1; st &lt;= L; st += num) &#123; //要连的数目超过了左边顶点的数目 if(st + num - 1 &gt; L) break; ++R; //开始将新构造的点与[st,st+num)间的点相连 for(int t = st; t &lt; st + num; ++t) &#123; a[cnt].x = t; a[cnt].y = R; ++cnt; &#125; &#125; &#125; printf("%d %d\n", R, cnt); for(int i = 0; i &lt; cnt; ++i) printf("%d %d\n", a[i].x, a[i].y); printf("%d\n", L); for(int i = 1; i &lt;= L; ++i) printf("%d\n", i); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>CCPC</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4825 Xor Sum 【01字典树】]]></title>
    <url>%2Fhdu-4825%2F</url>
    <content type="text"><![CDATA[题目大意：从一个N个数集合中找出一个数K，使得这个数与给出的S异或结果最大。 解题思路：涉及到异或问题，将给的数都用二进制形式表示出来。为了使异或结果最大，即从高位开始选，K的这一位为1时选S的这一位为0的，为0时刚好相反。然后用字典树进行存储分解后的二进制表示就OK了。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX =100010;int t, n, m;long long x;struct Trie&#123; int nex[MAX * 32][2], tot; long long pre[MAX * 32]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); &#125; void add() &#123; int now = 1; for(int i = 32; i &gt;= 0; --i) &#123; if(nex[now][(x &gt;&gt; i) &amp; 1] == 0) nex[now][(x &gt;&gt; i) &amp; 1] = ++tot; now = nex[now][(x &gt;&gt; i) &amp; 1]; &#125; pre[now] = x; &#125; long long query() &#123; int now = 1; for(int i = 32; i &gt;= 0; --i) &#123; if(nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]) now = nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]; else now = nex[now][(x &gt;&gt; i) &amp; 1]; &#125; return pre[now]; &#125;&#125; trie;int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; trie.init(); printf("Case #%d:\n", cas); scanf("%d%d",&amp;n,&amp;m); while(n--) &#123; scanf("%lld", &amp;x); trie.add(); &#125; while(m--) &#123; scanf("%lld", &amp;x); printf("%lld\n", trie.query()); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 979D Kuro and GCD and XOR and SUM 【01字典树】]]></title>
    <url>%2Fcf-979d%2F</url>
    <content type="text"><![CDATA[题目大意：现在要对一个数组执行q次指令，指令有两种类型，分别为”1 x”和”2 x k s”，前一种是向数组中加一个数x，后一种是查询数组中是否存在这样一个v，使得v满足$k \mid \gcd(x, v) , x + v &lt; s$, 若不存在，输出-1，否则输出满足条件的v中值最大的那个。 解题思路：首先观察条件，很明显的当$x \mod k \neq 0$时，答案是-1， 当$s - x \leq 0$时，答案是-1。对于其余情况，因为插入的数在1 ~ $10^5$间，而且用到这个数只要它出现过就可以，与它出现的次数无关。所以我们可以用桶排序的思想，用一个数组标记这个数字是否出现过。对于给出的查询，我们只需从k开始找，到$s - x$为止，每次加k，看枚举的数是否出现过，同时更新记录最大值就OK了。然而这样会T。因为当k = 1时，这样做就和暴力无差了。那么我们怎么办呢？k = 1，就是从1 ~ $s - x$中找出一个数使得这个数与x的异或结果最大。没错，就是区间异或最大值！字典树！前两篇讲的是没有最大值限制的查询，这里有了限制也很简单，我们把之前用的这一位是0|1的pre数组改为到此结点时最小值是多少，然后从根结点开始往下搜索，最后返回叶子结点存的值就好了。为什么这样是对的？因为我们往下找的时候是根据异或结果找的，找到叶子结点时当然就是最大的了。对了，往下找的时候要多加一句判断——是否下面的最小值不大于我们的限制。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;int t, x, k, s, maxx, op, a[MAX];struct Trie&#123; int nex[MAX * 17][2], o[MAX * 17], tot; void init() &#123; tot = 1; memset(o, 0x3f, sizeof(o)); memset(nex, 0, sizeof(nex)); &#125; void add() &#123; int now = 1; o[now] = min(o[now], x); for(int i = 17; i &gt;= 0; --i) &#123; if(nex[now][(x &gt;&gt; i) &amp; 1] == 0) nex[now][(x &gt;&gt; i) &amp; 1] = ++tot; now = nex[now][(x &gt;&gt; i) &amp; 1]; o[now] = min(o[now], x); &#125; &#125; int query() &#123; if(o[1] &gt; maxx) return -1; int now = 1; for(int i = 17; i &gt;= 0; --i) &#123; if(nex[now][((x &gt;&gt; i) &amp; 1) ^ 1] &amp;&amp; o[nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]] &lt;= maxx) now = nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]; else now = nex[now][(x &gt;&gt; i) &amp; 1]; &#125; return o[now]; &#125;&#125;trie;int main()&#123; trie.init(); scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;op); if(op == 1) &#123; scanf("%d", &amp;x); trie.add(); a[x] = true; &#125; else &#123; scanf("%d%d%d",&amp;x,&amp;k,&amp;s); maxx = s - x; if(x % k) puts("-1"); else if(k == 1) printf("%d\n", trie.query()); else &#123; int maxxor = -1, res = -1; for(int i = k; i &lt;= maxx; i += k) &#123; if(a[i] &amp;&amp; (i ^ x) &gt; maxxor) &#123; res = i; maxxor = i ^ x; &#125; &#125; printf("%d\n", res); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 706D Vasiliy's Multiset 【01字典树】]]></title>
    <url>%2Fcf-706d%2F</url>
    <content type="text"><![CDATA[题目大意：现在要对一个multiset执行q次指令，请你根据指令作出相应操作。共有3种指令类型，分别为”+ x”，”- x”和”? x”，他们的要求依次为：向集合中添加一个元素x、删除集合中的一个元素x和查询集合中现已存在的数与x的异或结果最大值。注意：multiset是一个允许相同元素存在于集合中的一个容器。初始时集合中有且仅有0这个元素。 解题思路：全题中最重要的指令就是”? x”这个指令了。异或结果最大，就是分解为二进制后，从高位往低位看，这一位为0时尽量取这一位为1的与他进行异或，为1时同理。到这里就能看出来是很明显的字典树啦。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX =200010;char op;int q, x;struct Trie&#123; int nex[MAX * 30][2], pre[MAX * 30], tot; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); &#125; void add() &#123; int now = 1; for(int i = 30; i &gt;= 0; --i) &#123; if(nex[now][(x &gt;&gt; i) &amp; 1] == 0) nex[now][(x &gt;&gt; i) &amp; 1] = ++tot; now = nex[now][(x &gt;&gt; i) &amp; 1]; ++pre[now]; &#125; &#125; void sub() &#123; int now = 1; for(int i = 30; i &gt;= 0; --i) &#123; now = nex[now][(x &gt;&gt; i) &amp; 1]; --pre[now]; &#125; &#125; int query() &#123; int now = 1, res = 0; for(int i = 30; i &gt;= 0; --i) &#123; //存在此结点 &amp;&amp; 此结点有值 if(nex[now][((x &gt;&gt; i) &amp; 1) ^ 1] &amp;&amp; pre[nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]]) res += (1 &lt;&lt; i), now = nex[now][((x &gt;&gt; i) &amp; 1) ^ 1]; else now = nex[now][(x &gt;&gt; i) &amp; 1]; &#125; return res; &#125;&#125; trie;int main()&#123; trie.init(); trie.add(); scanf("%d", &amp;q); while(q--) &#123; getchar(); scanf("%c%d", &amp;op, &amp;x); if(op == '+') trie.add(); else if(op == '-') trie.sub(); else printf("%d\n", trie.query()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 1011F Mars rover 【模拟】【DFS】]]></title>
    <url>%2Fcf-1011f%2F</url>
    <content type="text"><![CDATA[题目大意：给出一颗根结点为1的树，每个结点最多有两个叶子结点，每个结点的值非0即1。现在给出部分结点的值(0或1)，剩余结点告诉你它们值和子结点值的关系(AND、OR、XOR、NOT)。现在要你求的内容是按照输入顺序依次改变初始时给出的结点的值(0变为1，1变为0)，问每次改变后的根结点的值是多少。 解题思路：首先根据给出的关系我们可以求出每个结点初始状态的值，后面怎么做呢？我们可以挨个枚举每个点变化后的情况如果枚举变化情况的话TLE无疑。观察最后的值发现，答案非0即1，每个结点的值都是这样。那么我们可以不用模拟整个过程，而是记录到某个结点时它的值是否改变了，举个例子的话就是当这个结点是由前面两个结点AND得来的，正好有个结点是0，此时1所在结点的那个分支不论怎么变到这个位置出结果都是0。根据这个思想，我们再对这棵树进行一次DFS做下标记就可以了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int MAX = 1e6+5;int n, m;char s[4];struct node&#123; char op; vector&lt;int&gt; in; bool val, flag;&#125;G[MAX];bool GetVal(int rt)&#123; char c = G[rt].op; if(c == 'A') G[rt].val = GetVal(G[rt].in[0]) &amp; GetVal(G[rt].in[1]); else if(c == 'X') G[rt].val = GetVal(G[rt].in[0]) ^ GetVal(G[rt].in[1]); else if(c == 'O') G[rt].val = GetVal(G[rt].in[0]) | GetVal(G[rt].in[1]); else if(c == 'N') G[rt].val = !GetVal(G[rt].in[0]); return G[rt].val;&#125;void GetFlag(int rt)&#123; if(G[rt].flag == false) for(int i = 0; i &lt; G[rt].in.size(); ++i) G[G[rt].in[i]].flag = false; else &#123; char c = G[rt].op; if(c == 'A') &#123; if(G[rt].val == (!G[G[rt].in[0]].val &amp; G[G[rt].in[1]].val)) G[G[rt].in[0]].flag = false; else G[G[rt].in[0]].flag = true; if(G[rt].val == (!G[G[rt].in[1]].val &amp; G[G[rt].in[0]].val)) G[G[rt].in[1]].flag = false; else G[G[rt].in[1]].flag = true; &#125; else if(c == 'O') &#123; if(G[rt].val == (!G[G[rt].in[0]].val | G[G[rt].in[1]].val)) G[G[rt].in[0]].flag = false; else G[G[rt].in[0]].flag = true; if(G[rt].val == (!G[G[rt].in[1]].val | G[G[rt].in[0]].val)) G[G[rt].in[1]].flag = false; else G[G[rt].in[1]].flag = true; &#125; else if(c == 'X') &#123; if(G[rt].val == (!G[G[rt].in[0]].val ^ G[G[rt].in[1]].val)) G[G[rt].in[0]].flag = false; else G[G[rt].in[0]].flag = true; if(G[rt].val == (!G[G[rt].in[1]].val ^ G[G[rt].in[0]].val)) G[G[rt].in[1]].flag = false; else G[G[rt].in[1]].flag = true; &#125; else if(c == 'N') &#123; if(G[rt].val == (!!G[G[rt].in[0]].val)) G[G[rt].in[0]].flag = false; else G[G[rt].in[0]].flag = true; &#125; &#125; for(int i = 0; i &lt; G[rt].in.size(); ++i) GetFlag(G[rt].in[i]);&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", s); G[i].op = s[0]; scanf("%d", &amp;m); if(s[0] == 'I') G[i].val = m; else &#123; G[i].in.push_back(m); if(s[0] != 'N') &#123; scanf("%d", &amp;m); G[i].in.push_back(m); &#125; &#125; &#125; GetVal(1); /*for(int i = 1; i &lt;= n; ++i) if(G[i].val) cout &lt;&lt; i &lt;&lt; " "; cout &lt;&lt; endl;*/ G[1].flag = true; GetFlag(1); /*for(int i = 1; i &lt;= n; ++i) if(G[i].flag) cout &lt;&lt; i &lt;&lt; " "; cout &lt;&lt; endl;*/ for(int i = 1; i &lt;= n; ++i) if(G[i].op == 'I') printf("%d", G[1].val ^ G[i].flag); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>模拟</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6341 Problem J. Let Sudoku Rotate 【暴力剪枝】]]></title>
    <url>%2Fhdu-6341%2F</url>
    <content type="text"><![CDATA[题目大意：现在有个已经完成的$16 \times 16$的数独(即满足数独的要求)，它的某些部分被逆时针旋转过了。已知每次旋转的角度为90°，问最少经过多少次旋转能将它转回原样。 解题思路：因为数独要求很严格，所以我们可以直接进行搜索 + 剪枝。 PS：给的标程是真的好看，特别是旋转的那一部分，既简洁又优美。Orz。 ACcode:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char s[16];int res, a[16][16], r[16][16], c[16][16], b[4][4];int trans(char ch)&#123; if(isdigit(ch)) return ch - '0'; return ch - 'A' + 10;&#125;void add(int ip, int jp, int val)&#123; for(int i = ip * 4; i &lt; (ip + 1) * 4; ++i) &#123; for(int j = jp * 4; j &lt; (jp + 1) * 4; ++j) &#123; r[i][a[i][j]] += val; c[j][a[i][j]] += val; &#125; &#125;&#125;//进行旋转操作bool rot(int ip, int jp)&#123; for(int i = ip * 4; i &lt; (ip + 1) * 4; ++i) &#123; for(int j = jp * 4; j &lt; (jp + 1) * 4; ++j) &#123; //先把要旋转的部分拿出来 --r[i][a[i][j]]; --c[j][a[i][j]]; b[j - jp * 4][(ip + 1) * 4 - i - 1] = a[i][j]; &#125; &#125; bool flag = true; for(int i = ip * 4; i &lt; (ip + 1) * 4; ++i) &#123; for(int j = jp * 4; j &lt; (jp + 1) * 4; ++j) &#123; //将拿出来的部分进行归位 a[i][j] = b[i - ip * 4][j - jp * 4]; //出现了不符合要求的情况 if((++r[i][a[i][j]] &gt; 1) || (++c[j][a[i][j]] &gt; 1)) flag = false; &#125; &#125; return flag;&#125;void dfs(int ip, int jp, int now)&#123; if(ip == 4 &amp;&amp; jp == 0) &#123; res = min(res, now); return ; &#125; //状态改变 add(ip, jp, 1); if(now &gt;= res) return ; for(int i = 1; i &lt;= 4; ++i) &#123; //旋转i次 if(rot(ip, jp)) dfs(jp == 3 ? ip + 1 : ip, jp == 3 ? 0 : jp + 1, now + (i &amp; 3)); &#125; //状态恢复 add(ip, jp, -1);&#125;int main()&#123; int t; scanf("%d", &amp;t); while(t--) &#123; for(int i = 0; i &lt; 16; ++i) &#123; scanf("%s", s); for(int j = 0; j &lt; 16; ++j) &#123; a[i][j] = trans(s[j]); &#125; &#125; memset(r, 0, sizeof(r)); memset(c, 0, sizeof(c)); res = 16 * 4; dfs(0, 0, 0); printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>多校联合</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6319 Problem A. Ascending Rating 【单调队列】]]></title>
    <url>%2Fhdu-6319%2F</url>
    <content type="text"><![CDATA[题目大意：给定一个序列 a[1..n]，对于每个长度为 m 的连续子区间，求出区间 a 的最大值以及从左往右扫描该区间时 a 的最大值的变化次数。$1 ≤ m ≤ n ≤ 10^7$。 解题思路：求区间最大值，我首先想到的是很经典的滑动窗口求区间最大值问题。对于这个问题，因为还要求最大值的变化次数，所以直接利用滑窗的话变化次数不好求。于是就有题解上说的考虑按照 r 从 n 到 m 的顺序倒着求出每个区间的答案了。此时所维护的值是从大到小的顺序(因为倒着求的嘛)，而对应的变化次数就是队列中元素的个数。考虑到直接上deque挺耗时的，所以直接通过数组模拟就OK了。 【注意】完善a数组时要注意精度问题。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e7+5;int T, n, m, k, P, Q, R, M, t, a[MAX], q[MAX], head, tail;long long A, B;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; A = B = 0; scanf("%d%d%d%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;P,&amp;Q,&amp;R,&amp;M); for(int i = 1; i &lt;= k; ++i) scanf("%d",&amp;a[i]); for(int i = k + 1; i &lt;= n; ++i) a[i] = (1ll * P * a[i-1] + 1ll * Q * i + R) % M; head = 1, tail = 0; for(int i = n; i &gt; 0; --i) &#123; while(tail &gt;= head &amp;&amp; a[q[tail]] &lt;= a[i]) --tail; q[++tail] = i; if(i + m - 1 &lt;= n) &#123; while(q[head] - i &gt;= m) ++head; A += a[q[head]] ^ i; B += tail - head + 1 ^ i; &#125; &#125; printf("%lld %lld\n", A, B); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>多校联合</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 965E Short Code 【Trie】【启发式合并】]]></title>
    <url>%2Fcf-965e%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个不同的仅由小写字母构成的变量名，要求你对其取前缀将其简化，使简化后的变量名各不相同并且最终的总长度最小。 解题思路：对单词建立字典树，记录每个单词的长度。然后从树的叶子结点开始向上进行启发式合并，这个过程用multiset进行维护。启发式合并在这道题中的应用，个人的理解为到达这个结点时，发现这个结点还是空的时候，即可以将一个变量名简化为当前结点代表的变量名的时候，我们要选择它下面的所有变量名中名字最长的那个进行简化，为了便于维护，那就从下往上不断记录到此位置时可以简化的单词长度为多少。在代码中的体现就是DFS中的部分。35-37行为向上传递值，29、39-43行为简化操作。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int MAX = 1e5 + 5;char str[MAX];multiset&lt;int&gt; st[MAX];int n, tot, now, nex[MAX][26], dep[MAX], res;void add()&#123; now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) &#123; nex[now][str[i]-'a'] = ++tot; dep[tot] = dep[now] + 1; &#125; now = nex[now][str[i]-'a']; &#125; st[now].insert(dep[now]);&#125;void DFS(int u = 1)&#123; bool emp = (u &gt; 1 &amp;&amp; st[u].empty()); for(int i = 0; i &lt; 26; ++i) &#123; int v = nex[u][i]; if(!v) continue; DFS(v); for(auto t : st[v]) st[u].insert(t); st[v].clear(); &#125; if(emp) &#123; st[u].erase(--st[u].end()); st[u].insert(dep[u]); &#125;&#125;int main()&#123; tot = 1; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", str); add(); &#125; DFS(); for(auto t : st[1]) res += t; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>Trie</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 967E Big Secret 【异或】【贪心】]]></title>
    <url>%2Fcf-967e%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个数，将它们重新排序，使得排序后的序列满足前n个数的异或值依次递增。 解题思路：考虑这样一个问题，要使$p \bigoplus q &gt; p$并且此时花费的p最小，用x代表p的二进制表示中从最低位往最高位处第一个不为0的位置，那么最小的q即为二进制表示中的x位是1且其余位都是0。对于这个问题，我们以二进制表示中的最高位为区分点，先把所有数用一个容器存起来。取数时先看当前的数第一个为0的低位是否有对应的q满足要求，有的话就取，没有就继续往下找，这样依次取直到取完所有数或者满足不了要求为止。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int MAX = 1e5+5;int n;bool flag;long long t, res[MAX];vector&lt;long long&gt; G[64];int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%I64d", &amp;t); for(int i = 60; i &gt;= 0; --i) &#123; if((t &gt;&gt; i) &amp; 1) &#123; G[i].push_back(t); break; &#125; &#125; &#125; t = 0; for(int idx = 0; idx &lt; n; ++idx) &#123; flag = false; for(int i = 0; i &lt;= 60; ++i) &#123; if((t &amp; (1ll &lt;&lt; i)) == 0 &amp;&amp; G[i].size()) &#123; res[idx] = G[i].back(); t = t ^ G[i].back(); G[i].pop_back(); flag = true; break; &#125; &#125; if(flag == false) break; &#125; if(flag) &#123; puts("Yes"); for(int i = 0; i &lt; n; ++i) printf("%I64d ", res[i]); &#125; else puts("No"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>异或</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 964D Destruction of a Tree 【贪心】]]></title>
    <url>%2Fcf-964d%2F</url>
    <content type="text"><![CDATA[题目大意：给出一个由n个点和n - 1条边构成的树，每次可以摧毁掉一个度数为偶数的点，问是否存在一个摧毁的顺序使得所有点都能被摧毁掉。 解题思路：先说结论：当n为偶数时，总会存在度数为奇数的点无法被摧毁掉(很明显的)。当n为奇数时，答案总是存在的(证明略)。对于答案存在的情况，我们每次都摧毁靠近叶子结点的度数为偶数的结点，因为如果这个点不摧毁，而先摧毁了其父结点，那它的度数就变为奇数，并且叶子结点度数均为1，它们就无法消除了。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int MAX = 200010;bool vis[MAX];stack&lt;int&gt; sta;vector&lt;int&gt; G[MAX], res;int n, t, tem, deg[MAX], f[MAX];void DFS(int x, int p)&#123; sta.push(x); f[x] = p; for(int i = 0; i &lt; G[x].size(); ++i) &#123; if(G[x][i] == p) continue; DFS(G[x][i], x); &#125;&#125;void DFS2(int x)&#123; res.push_back(x); vis[x] = true; for(int i = 0; i &lt; G[x].size(); ++i) &#123; int nex = G[x][i]; --deg[nex]; if(nex == f[x]) continue; if(vis[nex]) continue; if(deg[nex] % 2 == 0) DFS2(nex); &#125;&#125;int main()&#123; scanf("%d", &amp;n); if(n &amp; 1) &#123; puts("YES"); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;t); if(!t) continue; ++deg[t], ++deg[i]; G[t].push_back(i); G[i].push_back(t); &#125; DFS(1, 0); while(!sta.empty()) &#123; tem = sta.top(); sta.pop(); if(deg[tem] % 2 == 0) DFS2(tem); &#125; for(int i = 0; i &lt; res.size(); ++i) printf("%d\n", res[i]); &#125; else puts("NO"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【专题训练】 —字典树【11/16】]]></title>
    <url>%2Ftrie-contest%2F</url>
    <content type="text"><![CDATA[专题链接：https://vjudge.net/contest/50484 A - Shortest Prefixes POJ - 2001 【Easy】题目大意： 将给出的所有单词通过取其前缀来代替此单词进行“简化”，使“简化”后的单词能唯一标识这个单词，在这前提下找到最简的化简结果。例如，给出car、cart、carton“简化”后的单词分别为car、cart、carto。 解题思路： 建立字典树，对于每个要“化简”的单词，我们找到那个到此位置处前缀只有这一种情况的结点，然后输出这条路径上的字符就是要找的最简结果。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 1010;const int MAXL = 1010 * 20;string tem;char s[MAXN][22];struct Tire&#123; int nex[MAXL][26], tot, pre[MAXL]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a']; pre[now]++; &#125; &#125; /*int Find(const char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) return 0; now = nex[now][str[i]-'a']; &#125; return now; &#125;*/ void print(char *str) &#123; printf("%s ", str); int now = 1; for(int i = 0; str[i]; ++i) &#123; now = nex[now][str[i]-'a']; printf("%c", str[i]); if(pre[now] == 1) break; &#125; puts(""); &#125;&#125;tire;int main()&#123; tire.init(); int n; for(n = 1; ~scanf("%s", s[n]); ++n) &#123; tire.add(s[n]); &#125; for(int i = 1; i &lt; n; ++i) &#123; tire.print(s[i]); &#125; return 0;&#125; B - T9 POJ - 1451题目大意： 解题思路： Mycode：12 C - Wild Words POJ - 1816题目大意： 解题思路： Mycode：12 D - Phone List POJ - 3630 【Easy】题目大意： 判断是否有前缀。 解题思路： 建树直接判。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5 + 5;struct Tire&#123; int tot, nex[MAX][11], pre[MAX], cnt[MAX]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre));// memset(cnt, 0, sizeof(cnt)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; &#125;// cnt[now]++; &#125; int Find(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; int t, n; char s[MAX][11]; scanf("%d",&amp;t); while(t--) &#123; tire.init(); scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", s[i]); tire.add(s[i]); &#125; bool flag = true; for(int i = 0; i &lt; n &amp;&amp; flag; ++i) &#123; if(tire.Find(s[i]) &gt; 1) flag = false; &#125; puts(flag ? "YES" : "NO"); &#125; return 0;&#125; E - Colored Sticks POJ - 2513 【Medium】题目大意： 给出一些列颜色，问是否可以将它们前后相连连成一条线。相连的条件是颜色相同。 解题思路： 这就是典型的欧拉回路问题，简单版的可以看 UVa 10129，这里n达到了250000，直接用map是不行了，于是用trie树代替map记录出现的颜色。剩下的就是求欧拉回路啦，这里还是用的并查集判的底图是否联通。 PS：这题里还要考虑一种特殊情况，就是什么输入也没有，此时也是Possible。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXL = 5000010;const int MAXN = 500010;int f[MAXN], deg[MAXN];int nex[MAXL][26], tot;void init()&#123; for(int i = 1; i &lt; MAXN; ++i) f[i] = i;&#125;int Find(int x)&#123; if(x != f[x]) f[x] = Find(f[x]); return f[x];&#125;void Union(int u, int v)&#123; int t1 = Find(u); int t2 = Find(v); if(t1 != t2) f[t1] = t2;&#125;int add(char *str)&#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a']; &#125; return now;&#125;int main()&#123; init(); char s1[11], s2[11]; while(~scanf("%s%s", s1, s2)) &#123; int t1 = add(s1); int t2 = add(s2); ++deg[t1], ++deg[t2]; Union(t1, t2); &#125; int odd = 0, root = 0; for(int i = 1; i &lt;= tot; ++i) &#123; if(deg[i] &amp; 1) ++odd; if(deg[i] &amp;&amp; f[i] == i) ++root; if(odd &gt; 2 || root &gt; 1) break; &#125; if(((odd == 0 || odd == 2) &amp;&amp; root == 1) || (root == 0 &amp;&amp; odd == 0)) puts("Possible"); else puts("Impossible"); return 0;&#125; F - Anagram Groups POJ - 2408题目大意： 解题思路： Mycode：12 G - 统计难题 HDU - 1251 【Easy】题目大意： 给出一系列单词，空行分割后查询接下来给出的单词是前面的多少单词的前缀。 解题思路： 建树直接做。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 4e5+5;struct Tire&#123; int nex[MAX][26], pre[MAX], cnt[MAX], tot; void init() &#123; memset(nex, 0, sizeof(nex)); pre[tot = 1] = 0; //tot = 1, pre[1] = 0; &#125; void add(char* str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a']; pre[now]++; /*for(int j = 0; j &lt;= i; ++j) cout &lt;&lt; str[j]; cout &lt;&lt; " " &lt;&lt; pre[now] &lt;&lt; endl;*/ &#125; cnt[now]++; &#125; int Find(char* str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) return 0; now = nex[now][str[i]-'a']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; char s[11]; tire.init(); while(gets(s)) &#123; if(strlen(s) == 0) break; tire.add(s); &#125; while(gets(s)) &#123; printf("%d\n",tire.Find(s)); &#125; return 0;&#125; H - What Are You Talking About HDU - 1075 【Easy】题目大意： 给出单词代表另一个单词，然后给出一段话输出它代表的话。 解题思路： 记录然后替换就好了，然后就是比较麻烦的模拟了。这里的trie树完全可以用map代替。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int MAX = 1000005;struct Tire&#123; int tot, nex[MAX][26], pre[MAX], cnt[MAX]; char res[MAX][11]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex));// memset(pre, 0, sizeof(pre)); memset(cnt, 0, sizeof(cnt)); memset(res, 0, sizeof(res)); &#125; void add(char *str, char *q) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a'];// pre[now]++; &#125; cnt[now]++; strcpy(res[now], q); &#125; int Find(const char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) return 0; now = nex[now][str[i]-'a']; &#125;// return pre[now]; return now; &#125;&#125; tire;int main()&#123; string trs; char op[3333]; char s[11], t[11]; tire.init(); scanf("%s", s); while(scanf("%s", s) &amp;&amp; s[0] != 'E') &#123; scanf("%s", t); tire.add(t, s); &#125; getchar();gets(s); while(gets(op) &amp;&amp; op[0] != 'E') &#123; int len = strlen(op); for(int i = 0; i &lt; len;) &#123; if(islower(op[i])) &#123; trs = ""; int j; for(j = 0; isalpha(op[i]); ++j, ++i) &#123; trs+=op[i]; &#125; int tt = tire.Find(trs.c_str()); if(tire.cnt[tt]) printf("%s", tire.res[tt]); else cout &lt;&lt; trs; &#125; else &#123; printf("%c", op[i++]); &#125; &#125; puts(""); &#125; return 0;&#125; I - Hat’s Words HDU - 1247 【Easy】题目大意： 给出若干单词，找出可以由其中的两个单词连接后凑成新的单词的单词(就是一个单词可以由已经存在的俩个单词凑成)。这里不用想复杂了，假设有a和aa两个单词，aa也是满足条件的。 解题思路： 建树后，暴力枚举每个单词是否可以被凑成就行了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 50010;int idx;string t1, t2;char s[MAX][1010];struct Tire&#123; int nex[MAX][26], pre[MAX], cnt[MAX], tot; void init() &#123; memset(nex, 0, sizeof(nex));// memset(pre, 0, sizeof(pre)); memset(cnt, 0, sizeof(cnt)); tot = 1; &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) nex[now][str[i]-'a'] = ++tot; now = nex[now][str[i]-'a']; &#125; cnt[now]++; &#125; int Find(const char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'a']) return 0; now = nex[now][str[i]-'a']; &#125; return cnt[now]; &#125;&#125;tire;bool judge(const string &amp;p)&#123; if(p.size() == 1) return false; int k1, k2; for(int i = 1; i &lt; p.size(); ++i) &#123; t1 = p.substr(0,i); t2 = p.substr(i, p.size()); k1 = tire.Find(t1.c_str()); k2 = tire.Find(t2.c_str()); //cout &lt;&lt; t1 &lt;&lt; " " &lt;&lt; k1 &lt;&lt; " " &lt;&lt; t2 &lt;&lt; " " &lt;&lt; k2 &lt;&lt; endl; if(k1 &amp;&amp; k2) return true; &#125; return false;&#125;int main()&#123; tire.init(); while(~scanf("%s", s[idx])) tire.add(s[idx++]); /*for(int i = 1; i &lt;= tire.tot; ++i) &#123; cout &lt;&lt; tire.cnt[i] &lt;&lt; endl; &#125;*/ /*for(int i = 0; i &lt; idx; ++i) &#123; cout &lt;&lt; tire.Find(s[i]) &lt;&lt; endl; &#125;*/ for(int i = 0; i &lt; idx; ++i) &#123; if(judge(s[i])) &#123; printf("%s\n", s[i]); &#125; &#125; return 0;&#125; J - Phone List HDU - 1671 【Easy】题目大意： 判断是否有前缀。 解题思路： 建树直接判。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5 + 5;struct Tire&#123; int tot, nex[MAX][11], pre[MAX], cnt[MAX]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre));// memset(cnt, 0, sizeof(cnt)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; &#125;// cnt[now]++; &#125; int Find(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; int t, n; char s[MAX][11]; scanf("%d",&amp;t); while(t--) &#123; tire.init(); scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", s[i]); tire.add(s[i]); &#125; bool flag = true; for(int i = 0; i &lt; n &amp;&amp; flag; ++i) &#123; if(tire.Find(s[i]) &gt; 1) flag = false; &#125; puts(flag ? "YES" : "NO"); &#125; return 0;&#125; K - Immediate Decodability HDU - 1305 【Easy】题目大意： 判断给出的字符串判断是否出现了某个串是另外一个的前缀。 解题思路： 建树直接判。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int MAX = 1e5 + 5;struct Tire&#123; int tot, nex[MAX][11], pre[MAX], cnt[MAX]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); memset(cnt, 0, sizeof(cnt)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; &#125; cnt[now]++; &#125; int Find(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; int cas = 0, idx = 0; char a[11]; char s[11][11]; tire.init(); while(~scanf("%s", a)) &#123; if(a[0] == '9') &#123; /*for(int i = 0; i &lt; idx; ++i) cout &lt;&lt; s[i] &lt;&lt; endl;*/ bool flag = true; for(int i = 0; i &lt; idx; ++i) &#123; if(tire.Find(s[i]) &gt; 1) &#123; //cout &lt;&lt; tire.Find(s[i]) &lt;&lt; " " &lt;&lt; s[i] &lt;&lt; endl; flag = false; break; &#125; &#125; printf("Set %d is ", ++cas); if(flag) puts("immediately decodable"); else puts("not immediately decodable"); tire.init(); idx = 0; memset(s, 0, sizeof(s)); &#125; strcpy(s[idx++], a); tire.add(a); &#125; return 0;&#125; L - 单词数 HDU - 2072 【Easy】题目大意： 给出一篇文章，问文中出现的不同单词的数量。 解题思路： 这个用map就可以，放到这里当做练习了。 PS：这题数据有点恶心，会出现开头空格、连续多个空格、全是空格等很XX的情况，这里我用stringstream处理的——STL大法好！ Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int MAX = 1e5 + 5;struct Tire&#123; int tot, nex[MAX][11], pre[MAX], cnt[MAX]; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); memset(cnt, 0, sizeof(cnt)); &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; &#125; cnt[now]++; &#125; int Find(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125;tire;int main()&#123; string s; char a[1111]; while(getline(cin, s)) &#123; if(s.size() == 1 &amp;&amp; s[0] == '#') break; tire.init(); stringstream ss(s); while(ss &gt;&gt; a) &#123; tire.add(a); &#125; int res = 0; for(int i = 1; i &lt;= tire.tot; ++i) if(tire.cnt[i]) ++res; cout &lt;&lt; res &lt;&lt; "\n"; &#125; return 0;&#125; M - T9 HDU - 1298题目大意： 解题思路： Mycode：12 N - DNA Prefix LightOJ - 1224 【Medium】题目大意： T组数据，每组有N个由ACGT组成的字符串，定义result为 某个前缀的长度 * 拥有这个前缀的字符串的数量，问最大的result是多少。 解题思路： 直接枚举每个前缀，看结果是多少。 枚举每个字符串的前缀，TLE。 从树上枚举。这里我想到了两种方法，一是在建树时记录答案并不断更新，二是建完树后从根结点向下搜索，答案就是 此时前缀数 * 此时的深度，计算并更新最大值就行了。 有点要注意的是只会出现ACGT四种字母，我们可以直接将他们标记为0123，这样省下了部分空间。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;const int MAX = 1e6+5;int t, n, res;char s[55];map&lt;char, int&gt; mapa;struct Tire&#123; int tot, nex[MAX][4], pre[MAX]; void init() &#123; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre)); tot = 1; &#125; void add(char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][mapa[str[i]]]) nex[now][mapa[str[i]]] = ++tot; now = nex[now][mapa[str[i]]]; pre[now]++; &#125; &#125; void dfs(int now, int dep) &#123; for(int i = 0; i &lt; 4; ++i) &#123; if(nex[now][i]) dfs(nex[now][i], dep+1); &#125; if(pre[now] * dep &gt; res) res = pre[now] * dep; &#125; /*int Find(const char *str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][mapa[str[i]]]) return 0; now = nex[now][mapa[str[i]]]; &#125; return pre[now]; &#125;*/&#125;tire;void init()&#123; mapa['A'] = 0; mapa['C'] = 1; mapa['G'] = 2; mapa['T'] = 3;&#125;int main()&#123; init(); scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; res = 0; tire.init(); scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) scanf("%s", &amp;s), tire.add(s); //从根结点向下搜索，当前深度为0 tire.dfs(1,0); printf("Case %d: %d\n", cas, res); &#125; return 0;&#125; O - Consistency Checker LightOJ - 1129 【Easy】题目大意： 给出T个清单，每个清单上有n个互不相同的电话号码，每个电话号码长度在1 ~ 10之间，问这些清单是否具有一致性，即这张清单中的每个电话号码都不是其他某个号码的前缀。 解题思路： 建树，判断即可。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;int t, n;bool flag;char s[10010][11];struct Tire&#123; int nex[MAX][11], pre[MAX], cnt[MAX], tot; void init() &#123; tot = 1; memset(nex, 0, sizeof(nex)); memset(pre, 0, sizeof(pre));// memset(cnt, 0, sizeof(cnt)); &#125; void add(char* str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) nex[now][str[i]-'0'] = ++tot; now = nex[now][str[i]-'0']; pre[now]++; /*for(int j = 0; j &lt;= i; ++j) cout &lt;&lt; str[j]; cout &lt;&lt; " " &lt;&lt; pre[now] &lt;&lt; endl;*/ &#125;// cnt[now]++; &#125; int Find(char* str) &#123; int now = 1; for(int i = 0; str[i]; ++i) &#123; if(!nex[now][str[i]-'0']) return 0; now = nex[now][str[i]-'0']; &#125; return pre[now]; &#125;&#125; tire;int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d",&amp;n); tire.init(); flag = true; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", s[i]); tire.add(s[i]); &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(tire.Find(s[i]) &gt; 1) &#123; flag = false; break; &#125; &#125; printf("Case %d: %s\n", cas, flag ? "YES" : "NO"); &#125; return 0;&#125; P - Consecutive Sum LightOJ - 1269题目大意： 解题思路： Mycode：12]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>HDU</tag>
        <tag>解题报告</tag>
        <tag>POJ</tag>
        <tag>LightOj</tag>
        <tag>专题训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玲珑学院 1138 震惊，99%+的中国人都会算错的问题 【容斥】【技巧】]]></title>
    <url>%2Fifrog-1138%2F</url>
    <content type="text"><![CDATA[题目大意：一开始编号1-n中的所有数字都为0，告诉你m个数字，将所有标号为这m个数字的倍数的值都^1，问最后有多少个数字值为1。 解题思路：考虑到n的范围很大，而m最多只有15个值，我们用容斥来做。 因为每次都是编号满足条件的值与1异或，所以值一直在1、0之间变动，因此不能像之前的找倍数那样直接加减。 (比如n=10，m=2，k1 k2分别为2 3时，编号6的值最终结果为0) 换个思路想就是这个格子是否被统计了奇数次(奇数次为1偶数次为0)，按二进制考虑，所以满足$A \times B$的倍数时就应在总数中 $- 2 \times 数量$，当满足$A \times B \times C$的倍数时就$ + 2^ 2 \times 数量$，这样…… 即$± 2 ^{(位数-1)} \times 数量$。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t, m;LL a[20], ans, n;LL gcd(LL a, LL b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;LL lcm(LL a, LL b)&#123; return a / gcd(a, b) * b;&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; ans = 0; scanf("%lld%d",&amp;n,&amp;m); for(int i = 0; i &lt; m; ++i) scanf("%lld",&amp;a[i]); for(int i = 1; i &lt; (1 &lt;&lt; m); ++i) &#123; LL mul = 1; int bits = 0; for(int j = 0; j &lt; m; ++j) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; bits++; mul = lcm(mul, a[j]); if(mul &gt; n) break; &#125; &#125; if(bits &amp; 1) ans += n / mul * (1 &lt;&lt; (bits - 1)); else ans -= n / mul * (1 &lt;&lt; (bits - 1)); &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>玲珑学院</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6299 Balanced Sequence 【贪心】]]></title>
    <url>%2Fhdu-6299%2F</url>
    <content type="text"><![CDATA[题目大意：现有n个字符串，每个串均有若干个()左右括号构成，请你选择一个连接顺序将这些串连在一起，使得匹配的括号对数最多。括号匹配的定义为左括号在右括号左边，每个括号均有一次参与匹配的机会。 解题思路： 首先在输入时对串进行处理，将已经匹配的记录下来，这样剩下的串只有4种情况：1.空串 2.只有左括号 3.只有右括号 4.右括号和左括号的混合 &amp;&amp; 右括号一定在左括号前边。 首先第1种情况肯定不用管了，剩下的该如何安排他们的顺序使得配对的数目最大化呢？肯定是要左括号尽量往左靠，右括号尽量往右靠，这样第2、3种情况也解决了。 最后一种是情况最多的，可以分为 (1).右括号数 &gt; 左括号数 (2).左括号数 &gt; 右括号数 以及 (3).左括号数 == 右括号数。考虑我们最初的目的，左括号尽量往左是为了什么？是为了不“浪费”这些括号，但是当必须“牺牲”一部分括号时，应当将“浪费”降到最低。于是我们找出了排序的关键字key = 左括号数 - 右括号数。两个变量相比较共四种情况：1.key1 &gt; 0 &amp;&amp; key2 &gt; 0 2.key1 &gt; 0 &amp;&amp; key2 &lt; 0 3.key1 &lt; 0 &amp;&amp; key2 &gt; 0 4.key1 &lt; 0 &amp;&amp; key2 &lt; 0，再将相等的情况随便插到几组中所有情况就都有了。这时排序的规则是一正一负正的在前，都为正时右括号少的在前，都为负时左括号多的在前，根据这样排完序挨个取就可以了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;char s[MAX];int t, n, tem, res;struct node&#123; int l, r, sub;&#125;a[MAX];bool cmp(node u, node v)&#123; if(u.sub &gt;= 0 &amp;&amp; v.sub &lt; 0) return true; if(u.sub &lt; 0 &amp;&amp; v.sub &gt;= 0) return false; if(u.sub &gt;= 0 &amp;&amp; v.sub &gt;= 0) return u.r &lt; v.r; return u.l &gt; v.l;&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; res = 0; memset(a, 0, sizeof(a)); scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", s); tem = 0; for(int j = 0; s[j]; ++j) &#123; if(s[j] == '(') ++tem; else &#123; if(tem == 0) ++a[i].r; else &#123; --tem; ++res; &#125; &#125; &#125; a[i].l = tem; a[i].sub = a[i].l - a[i].r; &#125; sort(a, a + n, cmp); tem = a[0].l; for(int i = 1; i &lt; n; ++i) &#123; res += min(tem, a[i].r); tem -= a[i].r; if(tem &lt; 0) tem = 0; tem += a[i].l; &#125; printf("%d\n", res&lt;&lt;1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>HDU</tag>
        <tag>多校联合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6301 Distinct Values 【贪心】【模拟】]]></title>
    <url>%2Fhdu-6301%2F</url>
    <content type="text"><![CDATA[题目大意：找出n个数，满足给出的m个区间内的数都不相同。问满足条件的字典序最小的序列是多少。 解题思路：字典序最小，说明肯定要越小的越往前填，如果没有限制区间的话答案就是$n$个$1$啦，加上后最先出现的区间要最先考虑，即$l_1$ ~ $r_1$内的数为$1$ ~ $r_1 - l_1$，后面的根据出现的顺序(指填到x时最先覆盖x的区间)依次从小往大填就好了。题目的难点就是填数时保证不重复。为了改变区间的顺序，肯定要先排序，排序是根据$l_i$为关键字。排序后模拟填数的过程：碰到区间就改变填的数的值，填数时要记录用过的数字，区间结束记得将区间覆盖不到的点再“收回”。而这个所需要的容器可以用优先队列或者set，想到合适的容器就简单多了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int MAX = 1e5+5;int t, n, m, L, R, res[MAX];struct node&#123; int l, r;&#125;a[MAX];bool cmp(node u, node v)&#123; if(u.l == v.l) return u.r &lt; v.r; return u.l &lt; v.l;&#125;set&lt;int&gt; S;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;n,&amp;m); for(int i = 0; i &lt; m; ++i) scanf("%d%d", &amp;a[i].l, &amp;a[i].r); sort(a, a + m, cmp); S.clear(); for(int i = 1; i &lt;= n; ++i) &#123; res[i] = 1; S.insert(i); &#125; L = a[0].l, R = a[0].r; for(int i = L; i &lt;= R; ++i) &#123; res[i] = *S.begin(); S.erase(S.begin()); &#125; for(int i = 1; i &lt; m; ++i) &#123; while(L &lt; a[i].l) &#123; S.insert(res[L++]); &#125; while(R &lt; a[i].r) &#123; ++R; if(R &lt; L) continue; res[R] = *S.begin(); S.erase(S.begin()); &#125; &#125; for(int i = 1; i &lt;= n; ++i) printf("%d%c", res[i], i == n ? '\n' : ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>HDU</tag>
        <tag>多校联合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 979B Treasure Hunt 【模拟】]]></title>
    <url>%2Fcf-979b%2F</url>
    <content type="text"><![CDATA[题目大意：3个人做游戏，每人初始时拥有一个长度相同的字符串，现每人都要对自己的字符串进行变换操作，问经过n次变换操作后谁的字符串的value最大，value的计算方法是字符串中出现次数最的的字母的次数。变换操作是将自己字符串中的任意一个字母变成除这个字母外的任意一个字母。 解题思路：设初始时出现次数最多的字母为m，之后我们将所有字母变成这个字母就是最佳答案了。变换时要对n进行判断，当n大于非m的字母数量时，最终答案为字符串的长度(即可以将所有字母变为m)，反之，为m的数量+n。【注意：】这里要考虑一种情况，就是n = 1 &amp;&amp; 所有字母都相同的时候，这时答案为字符串长度 - 1。 关于代码：自己写的略微“丑陋”，std看起来是真的舒服，想写这样的代码。现在对“Think twice code once”又有了新的理解，不仅要写正确的代码，还要写在表述清楚的前提下的简洁的代码。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;char a[111111], b[111111], c[111111];map&lt;char, int&gt; ca, cb, cc;int t, la, lb, lc, ra, rb, rc;int main()&#123; scanf("%d%s%s%s",&amp;t,a, b, c); la = strlen(a), lb = strlen(b), lc = strlen(c); for(int i = 0; i &lt; la; ++i) ca[a[i]]++; for(int i = 0; i &lt; lb; ++i) cb[b[i]]++; for(int i = 0; i &lt; lc; ++i) cc[c[i]]++; for(char i = 'a'; i &lt;= 'z'; ++i) &#123; ra = max(ra, ca[i]); rb = max(rb, cb[i]); rc = max(rc, cc[i]); &#125; for(char i = 'A'; i &lt;= 'Z'; ++i) &#123; ra = max(ra, ca[i]); rb = max(rb, cb[i]); rc = max(rc, cc[i]); &#125; if(ra == la &amp;&amp; t == 1) ra--; else ra += t; if(rb == lb &amp;&amp; t == 1) rb--; else rb += t; if(rc == lc &amp;&amp; t == 1) rc--; else rc += t; ra = min(ra, la); rb = min(rb, lb); rc = min(rc, lc); if(ra &gt; rb &amp;&amp; ra &gt; rc) puts("Kuro"); else if(rb &gt; ra &amp;&amp; rb &gt; rc) puts("Shiro"); else if(rc &gt; ra &amp;&amp; rc &gt; rb) puts("Katie"); else puts("Draw"); return 0;&#125; Stdcode:123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int a[256], b[256], c[256], n, ma, mb, mc;string p, q, r;int main() &#123; cin &gt;&gt; n &gt;&gt; p &gt;&gt; q &gt;&gt; r; for (char x: p) ma = max(ma, ++a[x]); for (char x: q) mb = max(mb, ++b[x]); for (char x: r) mc = max(mc, ++c[x]); if (n == 1 &amp;&amp; ma == (int)p.length()) p.pop_back(); if (n == 1 &amp;&amp; mb == (int)q.length()) q.pop_back(); if (n == 1 &amp;&amp; mc == (int)r.length()) r.pop_back(); ma = min(ma + n, (int)p.length()); mb = min(mb + n, (int)q.length()); mc = min(mc + n, (int)r.length()); if (ma &gt; mb &amp;&amp; ma &gt; mc) &#123; puts("Kuro"); return 0; &#125; if (mb &gt; ma &amp;&amp; mb &gt; mc) &#123; puts("Shiro"); return 0; &#125; if (mc &gt; ma &amp;&amp; mc &gt; mb) &#123; puts("Katie"); return 0; &#125; puts("Draw"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 967C Stairs and Elevators 【二分】]]></title>
    <url>%2Fcf-967c%2F</url>
    <content type="text"><![CDATA[题目大意：在一个n层高的楼层里，有m块呈直线连在一起的区域，有cl个楼梯和ce个电梯分别在 $a_1$ ~ $a_{cl}$ 和 $b_1$ ~ $b_{ce}$的位置上，从这个位置可以上到上一层楼或者下一层楼。楼梯1s可以上|下一层楼，电梯1s可以上|下$\leq$ v个楼层，从一块到相邻的一块也需要1s的时间。有q个询问，问最少经过多少时间可以从$x1, y1$到达$x2, y2$。 解题思路： 首先想到的是看走楼梯和走电梯哪个时间最少。如果走楼梯，可以走靠近当前位置的左边最近的或者右边最近的，其他同方向位置的楼梯花费的时间一定大于等于这两个位置。电梯同理。 接下来就是找位置了。找这4个位置的时候，因为给出的电梯/楼梯位置是升序的，所以可以用二分查找。一开始写的是分别二分查这4个位置，后来发现只要查两个位置就好了，比如查电梯的第一个$\geq$y1的位置后，另一个要找的位置就是这个位置左边的那个(如果存在的话)。【注意：】这里有个细节问题不要忽略，就是两位置在一层楼的时候，这时既不需要走楼梯也不需要走电梯。 Mycode(手写二分)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;int n, m, c1, c2, v;int a1[MAX], a2[MAX];int stx, sty, enx, eny, tem;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; v; for(int i = 0; i &lt; c1; ++i) cin &gt;&gt; a1[i]; for(int i = 0; i &lt; c2; ++i) cin &gt;&gt; a2[i]; a2[c2] = a1[c1] = 1e9; int t; cin &gt;&gt; t; while(t--) &#123; int res = 1e9; cin &gt;&gt; stx &gt;&gt; sty &gt;&gt; enx &gt;&gt; eny; if(stx == enx) &#123; res = abs(sty - eny); cout &lt;&lt; res &lt;&lt; endl; continue; &#125; int l, r, m, pos; if(c1) &#123; pos = -1, l = 0, r = c1; while(l &lt;= r) &#123; m = (l + r) &gt;&gt; 1; if(a1[m] &gt;= sty) &#123; r = m - 1; pos = m; &#125; else l = m + 1; &#125; if(pos != -1) &#123; tem = abs(sty - a1[pos]); tem += abs(eny - a1[pos]); tem += abs(stx - enx); res = min(res, tem); &#125;// cout &lt;&lt; pos &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt;tem &lt;&lt; " " &lt;&lt; res &lt;&lt; endl; pos = -1, l = 0, r = c1; while(l &lt;= r) &#123; m = (l + r) &gt;&gt; 1; if(a1[m] &lt;= sty) &#123; l = m + 1; pos = m; &#125; else r = m - 1; &#125; if(pos != -1) &#123; tem = abs(sty - a1[pos]); tem += abs(eny - a1[pos]); tem += abs(stx - enx); res = min(res, tem); &#125; &#125;// cout &lt;&lt; pos &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt;tem &lt;&lt; " " &lt;&lt; res &lt;&lt; endl; if(c2) &#123; pos = -1, l = 0, r = c2; while(l &lt;= r) &#123; m = (l + r) &gt;&gt; 1; if(a2[m] &gt;= sty) &#123; r = m - 1; pos = m; &#125; else l = m + 1; &#125; if(pos != -1) &#123; tem = abs(sty - a2[pos]); tem += abs(eny - a2[pos]); int tt = abs(stx - enx); tem += tt / v; if(tt % v) tem++; res = min(res, tem); &#125;// cout &lt;&lt; pos &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt;tem &lt;&lt; " " &lt;&lt; res &lt;&lt; endl; pos = -1, l = 0, r = c2; while(l &lt;= r) &#123; m = (l + r) &gt;&gt; 1; if(a2[m] &lt;= sty) &#123; l = m + 1; pos = m; &#125; else r = m - 1; &#125; if(pos != -1) &#123; tem = abs(sty - a2[pos]); tem += abs(eny - a2[pos]); int tt = abs(stx - enx); tem += tt / v; if(tt % v) tem++; res = min(res, tem); &#125; &#125;// cout &lt;&lt; pos &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt;tem &lt;&lt; " " &lt;&lt; res &lt;&lt; endl; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; Mycode(stl二分):12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e5+5;int n, m, cl, ce, v;int a1[MAX], a2[MAX];int stx, sty, enx, eny, tem, res;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;cl,&amp;ce,&amp;v); for(int i = 0; i &lt; cl; ++i) scanf("%d",&amp;a1[i]); for(int i = 0; i &lt; ce; ++i) scanf("%d",&amp;a2[i]); a1[cl] = a2[ce] = 1e9; int t; scanf("%d",&amp;t); while(t--) &#123; res = 1111111111; scanf("%d%d%d%d",&amp;stx,&amp;sty,&amp;enx,&amp;eny); if(stx == enx) res = abs(sty - eny); else &#123; if(cl &gt; 0) &#123; int pos = lower_bound(a1, a1+cl, sty) - a1; if(a1[pos] != 1e9) &#123; tem = 0; tem += abs(sty-a1[pos]); tem += abs(eny-a1[pos]); tem += abs(stx-enx); res = min(res, tem); &#125; if(pos &gt; 0) &#123; --pos; tem = 0; tem += abs(sty-a1[pos]); tem += abs(eny-a1[pos]); tem += abs(stx-enx); res = min(res, tem); &#125; &#125; if(ce &gt; 0) &#123; int pos = lower_bound(a2, a2+ce, sty) - a2; if(a2[pos] != 1e9) &#123; tem = 0; tem += abs(sty-a2[pos]); tem += abs(eny-a2[pos]); tem += ceil((double)abs(stx-enx)/v); res = min(res, tem); &#125; if(pos &gt; 0) &#123; --pos; tem = 0; tem += abs(sty-a2[pos]); tem += abs(eny-a2[pos]); tem += ceil((double)abs(stx-enx)/v); res = min(res, tem); &#125; &#125; &#125; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第六章习题】【2/14】]]></title>
    <url>%2Flrj-ch6-1%2F</url>
    <content type="text"><![CDATA[UVa 673 Parentheses Balance 【stack】题目大意：括号匹配 解题思路：借助栈来实现的括号匹配，最基础的应用。注意可能出现的不匹配情况：1.数量不匹配 2.类型不匹配 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;stack&gt;using namespace std;int t;string s;int main()&#123; cin &gt;&gt; t; getchar(); while(t--) &#123; getline(cin, s); bool flag = true; stack&lt;char&gt; S; for(int i = 0; i &lt; s.size() &amp;&amp; flag; ++i) &#123; if(s[i] == '(' || s[i] == '[') S.push(s[i]); else if(s[i] == ')') &#123; if(!S.empty() &amp;&amp; S.top() == '(') S.pop(); else flag = false; &#125; else if(s[i] == ']') &#123; if(!S.empty() &amp;&amp; S.top() == '[') S.pop(); else flag = false; &#125; &#125; if(!S.empty()) flag = false; puts(flag ? "Yes" : "No"); &#125; return 0;&#125; UVa 439 Knight Moves【BFS】题目大意：在一个8 * 8的棋盘上给你一个象棋“马”的位置，问这个马能最少用多少步到达目标位置。马行走的方式为“日”字型。 解题思路：因为范围很小，直接BFS即可，这里搜的时候同时记录走过的位置。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;bool vis[11][11];char s1[5], s2[5];int stx, sty, enx, eny;int dir[][2] = &#123;1,2,-1,2,2,1,-2,1,-1,-2,-2,-1,1,-2,2,-1&#125;;struct node&#123; int x, y, cnt;&#125;;bool check(int x, int y)&#123; if(vis[x][y]) return false; if(x &lt; 1 || x &gt; 8 || y &lt; 1 || y &gt; 8) return false; return true;&#125;int main()&#123; while(~scanf("%s%s", s1, s2)) &#123; memset(vis, 0, sizeof(vis)); stx = s1[0] - 'a' + 1; sty = s1[1] - '1' + 1; enx = s2[0] - 'a' + 1; eny = s2[1] - '1' + 1; vis[stx][sty] = 1; node now, nex; queue&lt;node&gt; Q; Q.push(node&#123;stx, sty, 0&#125;); while(!Q.empty()) &#123; now = Q.front(); if(now.x == enx &amp;&amp; now.y == eny) &#123; printf("To get from %s to %s takes %d knight moves.\n", s1, s2, now.cnt); break; &#125; Q.pop(); for(int i = 0; i &lt; 8; ++i) &#123; nex.x = now.x + dir[i][0]; nex.y = now.y + dir[i][1]; if(!check(nex.x, nex.y)) continue; nex.cnt = now.cnt + 1; Q.push(nex); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>并查集</tag>
        <tag>queue</tag>
        <tag>UVa</tag>
        <tag>解题报告</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>数据结构</tag>
        <tag>stack</tag>
        <tag>BFS</tag>
        <tag>list</tag>
        <tag>二叉树</tag>
        <tag>拓扑排序</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第六章例题】【16/22】]]></title>
    <url>%2Flrj-ch6-0%2F</url>
    <content type="text"><![CDATA[UVa 210 Concurrency Simulator 【Deque】题目大意：本题需要你模拟一些简单程序，每一个程序有以下5种指令： var = val，给变量赋值，简单起见保证变量名为一个字母，变量为所有进程共用，并且初始为0，保证val是不大于100的正整数； print var,输出变量var； lock对所有变量申请独占访问(不影响赋值和打印) unlock解除独占访问 end结束程序以上指令分别消耗t1,t2,t3,t4,t5的时间,一开始进程按照输入顺序依次插入到等待队列中，每次从等待队列队首选择一个进程执行。每个进程有一个配额(限定时间)Q，当配额用完时,该进程会在执行完当前语句后被立即插入到一个等待队列尾部中。但是lock语句和unlock语句会改变进程的执行顺序。当一个程序执行了lock语句,其他进程再执行到lock语句时会被立即插入到一个阻止队列队尾,当程序执行到unlock语句时，阻止队列的队首的第一个进程会被立即插入到等待队列队首。 解题思路：总体看来需要两个队列分别存取lock的进程和ready(等待)的进程。存取lock进程的队列只需要插入到队尾和从队首取这两种操作即可，普通队列就可完成；存取ready进程的队列除从队首取元素外，既需要插入到队尾又需要插入到队首，故需要双端队列来实现。然后模拟整个过程即可。具体实现时先把所有操作都存下来，并记录每个起始进程的坐标，然后模拟进程的运行，执行相应语句就行了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;deque&gt;using namespace std;bool flag;char s[1111][11];int t, n, c[5], q, val[26], ip[1111];queue&lt;int&gt; B;deque&lt;int&gt; R;void run(int idx)&#123; int T = q; while(T &gt; 0) &#123; char *p = s[ip[idx]]; switch(p[2]) &#123; case '=': //? = ? val[p[0] - 'a'] = isdigit(p[5]) ? (p[4] - '0') * 10 + p[5] - '0' : p[4]- '0'; T -= c[0]; break; case 'i': //print printf("%d: %d\n", idx, val[p[6] - 'a']); T -= c[1]; break; case 'c': //lock if(flag) &#123; B.push(idx); return ; &#125; flag = true; T-= c[2]; break; case 'l': //unlock flag = false; if(!B.empty()) &#123; int idx2 = B.front(); B.pop(); R.push_front(idx2); &#125; T-= c[3]; break; case 'd': return ; &#125; ip[idx]++; &#125; R.push_back(idx);&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; flag = false; memset(val, 0, sizeof(val)); scanf("%d%d%d%d%d%d%d",&amp;n,&amp;c[0],&amp;c[1],&amp;c[2],&amp;c[3],&amp;c[4],&amp;q); int line = 1; for(int i = 1; i &lt;= n; ++i) &#123; fgets(s[line++], 1111, stdin); ip[i] = line - 1; while(s[line - 1][2] != 'd') &#123; fgets(s[line++], 1111, stdin); &#125; R.push_back(i); &#125; while(!R.empty()) &#123; int idx1 = R.front(); R.pop_front(); run(idx1); &#125; if(t) puts(""); &#125; return 0;&#125; UVa 514 Rails【stack】题目大意：编号为1 ~ n 的n个元素依次入栈，问给出的出栈顺序是否是合法的。 解题思路：直接模拟比对即可。 Mycode：12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;stack&gt;using namespace std;int n, a[1111];int main()&#123; while(cin &gt;&gt; n &amp;&amp; n) &#123; while(cin &gt;&gt; a[1] &amp;&amp; a[1]) &#123; for(int i = 2; i &lt;= n; ++i) cin &gt;&gt; a[i]; int cnt = 1; stack&lt;int&gt; s; for(int i = 1; i &lt;= n; ++i) &#123; s.push(i); while(!s.empty() &amp;&amp; s.top() == a[cnt]) &#123; s.pop(); ++cnt; &#125; &#125; puts(s.empty() ? "Yes" : "No"); &#125; puts(""); &#125; return 0;&#125; UVa 442 Matrix Chain Multiplication【stack】题目大意：给出t个$n \times m$的矩阵，问给出的矩阵乘法表达式是否合法，合法的话进行了多少次普通乘法。 解题思路：$p \times q$ 的矩阵 只能与$q \times r$的矩阵相乘，此时进行的乘法次数为$p \times q \times r$次，再与其他相乘的时候就是次数之和了。表达式用栈来模拟就好了。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;char ch;string op;int n, a, b;int main()&#123; while(cin &gt;&gt; n) &#123; map&lt;char, pair&lt;int, int&gt; &gt; mapa; for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; ch &gt;&gt; a &gt;&gt; b; mapa[ch] = make_pair(a, b); &#125; while(cin &gt;&gt; op) &#123; stack&lt;pair&lt;int, int&gt; &gt; num; int res = 0; bool flag = true; for(int i = 0; i &lt; op.size(); ++i) &#123; if(op[i] == '(') &#123; continue; &#125; else if(op[i] == ')') &#123; pair&lt;int, int&gt; p, q; p = num.top(); num.pop(); q = num.top(); num.pop(); if(q.second != p.first) &#123; flag = false; break; &#125; res += q.first * p.second * p.first; num.push(make_pair(q.first, p.second)); &#125; else &#123; num.push(mapa[op[i]]); &#125; &#125; if(flag) printf("%d\n", res); else puts("error"); &#125; &#125; return 0;&#125; UVa 11988 Broken Keyboard (a.k.a. Beiju Text) 【链表】题目大意：Albert的键盘出现了奇妙的故障，所有键都会正常的工作，但是键盘上的Home以及End键有时候会莫名其妙的自己按下。但是盲打很熟练的他一般习惯关闭显示器打字，因为这样很酷。 现在他正在打一段文本，假设你已经知道这段文本以及Home和End键会什么时候出现故障自行按下。请你编写一个程序，求出他最后打出的文本。 解题思路： 用数组保存这段文本，然后设置一个变量pos保存光标位置，这样输入一个字符相当于在数组中插入一个字符，这时把后面的字符向后移动就可以了。 但是这样会超时。 采用链表，每输入一个字符就把它存起来，设输入的字符串是s[1~n]，则可以用next[i]表示在当前显示屏中s[i]右边的字符编号(在s中的下标)。 具体做法：用变量记录当前位置和最后一个字母的位置，模拟移动、插入过程。方便起见，开头设置一个虚拟结点。 链表：用数组模拟链表的方法：一个数组记录原本的值，另一个数组记录该位置的下一个位置的下标。 Mycode：1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char s[111111];int cur, las, nex[111111];int main()&#123; while(~scanf("%s", s + 1)) &#123; int len = strlen(s + 1); cur = las = nex[0] = 0; for(int i = 1; i &lt;= len; ++i) &#123; if(s[i] == '[') cur = 0; else if(s[i] == ']') cur = las; else &#123; nex[i] = nex[cur]; nex[cur] = i; if(cur == las) las = i; cur = i; &#125; &#125; for(int i = nex[0]; i != 0; i = nex[i]) printf("%c", s[i]); puts(""); &#125; return 0;&#125; UVa 12657 Boxes in a Line【链表】题目大意：现有从左到右编号为1 ~ n的n个盒子摆成一行，分别执行如下4种指令的某些指令，问执行后所有奇数位置的盒子的编号之和。指令有： 1 x y 将盒子x移动到盒子y的左边 (如果x已经在y的左边，忽略此指令) 2 x y 将盒子x移动到盒子y的右边 (如果x已经在y的右边，忽略此指令) 3 x y 交换盒子x和y的位置 4 反转整条链 解题思路：采用双向链表模拟整个过程。 解后有感：小技巧： 对于过程4我们可以不用模拟反转的过程，用个标志进行记录是否进行了反转就可以。如果反转了，那1、2操作将变为相应的2、1操作，3操作无影响，最后结果记录偶数的位置就行。 关于代码：感觉自己写的十分“朴素”，写完后虽然能AC，但日后再看起肯定不好理解，而且调试时也不那么得心应手。看完LRJ大爷的代码，真真感觉到了自己菜爆。 首先链表的连接操作用一个函数表示，减少代码量的同时增加了美观性，方便调试。 链表建立时建的循环链表，而且一个循环left和right都构建完了，还是比我的好看多了。 特判交换位置时的那部分，将两种情况合为一种(其实就是xy的位置不同，完全能想到的)，也减少就代码量。 最后的计算只计算正着看的奇数位的和，反转时直接用总和减去此时的值。 日后注意的地方： 多次用到一种计算时写成函数 先思考后写代码，逻辑弄清后再写 能用1行代码写清楚的地方就不用2行。 最后附上我和LRJ大爷的代码 对比感受一下。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n, m;int op, x, y;int tem1, tem2;long long res;int rig[111111], lef[111111];void init()&#123; memset(rig, 0, sizeof(rig)); memset(lef, 0, sizeof(lef)); for(int i = 0; i &lt;= n; ++i) rig[i] = i + 1; for(int i = n + 1; i &gt; 0; --i) lef[i] = i - 1;&#125;void debug()&#123; cout &lt;&lt; "\n**************\n"; for(int i = 0; i &lt;= n+1; ++i) cout &lt;&lt; rig[i] &lt;&lt; " "; cout &lt;&lt; endl; for(int i = 0; i &lt;= n+1; ++i) cout &lt;&lt; lef[i] &lt;&lt; " "; cout &lt;&lt; endl; for(int i = rig[0], j = 1; j &lt;= n; i = rig[i], ++j) cout &lt;&lt; i &lt;&lt; " "; cout &lt;&lt; endl; cout &lt;&lt; "**************\n\n";&#125;int main()&#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); for(int cas = 1; ~scanf("%d%d",&amp;n,&amp;m); ++cas) &#123; init(); bool flag = true; while(m--) &#123;// debug(); scanf("%d",&amp;op); if(op == 4) &#123; flag = !flag; continue; &#125; if(op &lt; 3 &amp;&amp; !flag) op = 3 - op; scanf("%d%d",&amp;x,&amp;y); switch(op) &#123; case 1: if(x == lef[y]) break; rig[lef[x]] = rig[x]; lef[rig[x]] = lef[x]; rig[x] = y; lef[x] = lef[y]; rig[lef[y]] = x; lef[y] = x; break; case 2: if(x == rig[y]) break; rig[lef[x]] = rig[x]; lef[rig[x]] = lef[x]; lef[x] = y; rig[x] = rig[y]; lef[rig[y]] = x; rig[y] = x; break; case 3: if(x == lef[y]) &#123; tem1 = rig[y]; tem2 = lef[x]; lef[y] = tem2; rig[tem2] = y; rig[x] = tem1; lef[tem1] = x; lef[x] = y; rig[y] = x; &#125; else if(x == rig[y]) &#123; tem1 = rig[x]; tem2 = lef[y]; rig[y] = tem1; lef[tem1] = y; lef[x] = tem2; rig[tem2] = x; lef[y] = x; rig[x] = y; &#125; else &#123; tem1 = lef[y]; tem2 = rig[y]; lef[y] = lef[x]; rig[y] = rig[x]; rig[lef[x]] = y; lef[rig[x]] = y; lef[x] = tem1; rig[x] = tem2; rig[tem1] = x; lef[tem2] = x; &#125; break; &#125; &#125;// debug(); res = 0; if(flag) &#123;// cout &lt;&lt; "orign !\n"; for(int i = rig[0], j = 1; j &lt;= n; i = rig[i], ++j) if(j &amp; 1) res += i; &#125; else &#123;// cout &lt;&lt; "reverse !\n"; for(int i = lef[n + 1], j = 1; j &lt;= n; i = lef[i], ++j) if(j &amp; 1) res += i; &#125; printf("Case %d: %lld\n", cas, res); &#125; return 0;&#125; LRJ’s code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// UVa12657 Boxes in a Line// Rujia Liu#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;int n, left[maxn], right[maxn];inline void link(int L, int R) &#123; right[L] = R; left[R] = L;&#125;int main() &#123; int m, kase = 0; while(scanf("%d%d", &amp;n, &amp;m) == 2) &#123; for(int i = 1; i &lt;= n; i++) &#123; left[i] = i-1; right[i] = (i+1) % (n+1); &#125; right[0] = 1; left[0] = n; int op, X, Y, inv = 0; while(m--) &#123; scanf("%d", &amp;op); if(op == 4) inv = !inv; else &#123; scanf("%d%d", &amp;X, &amp;Y); if(op == 3 &amp;&amp; right[Y] == X) swap(X, Y); if(op != 3 &amp;&amp; inv) op = 3 - op; if(op == 1 &amp;&amp; X == left[Y]) continue; if(op == 2 &amp;&amp; X == right[Y]) continue; int LX = left[X], RX = right[X], LY = left[Y], RY = right[Y]; if(op == 1) &#123; link(LX, RX); link(LY, X); link(X, Y); &#125; else if(op == 2) &#123; link(LX, RX); link(Y, X); link(X, RY); &#125; else if(op == 3) &#123; if(right[X] == Y) &#123; link(LX, Y); link(Y, X); link(X, RY); &#125; else &#123; link(LX, Y); link(Y, RX); link(LY, X); link(X, RY); &#125; &#125; &#125; &#125; int b = 0; long long ans = 0; for(int i = 1; i &lt;= n; i++) &#123; b = right[b]; if(i % 2 == 1) ans += b; &#125; if(inv &amp;&amp; n % 2 == 0) ans = (long long)n*(n+1)/2 - ans; printf("Case %d: %lld\n", ++kase, ans); &#125; return 0;&#125; UVa 679 Dropping Balls 【二叉树编号】题目大意：一棵二叉树最大深度为D，所有叶子的深度都相同，所有结点从上到下从左到右编号为1，2，3，……，$2^D - 1$。在结点1处放个小球，它会往下落。每个结点处都有一个开关，初始时全部关闭，当有小球落到一个开关时其状态就会改变。当小球到达结点时若此开关开着则往左走，否则往右走，直到走到叶子结点。一些球从1处依次往下落，问第i个会落在哪。 解题思路：很明显对于一个结点k而言，其左子结点为$2 \times k$，右子结点为$2 \times k + 1$。因为每个球最终都会落在叶子结点上，所以前两个一定是第一个落在左子树上，第二个落在右子树上。推广到一般来看，只需知道小球是第几个落在根的子树里的就能知道它下一步是往左还是往右了。具体的，拿第一步为例，如果一开始i &amp; 1，那它就往左，此时位置变为1 &lt;&lt; 1，在新的“根结点”处它就成了第i + 1 &lt;&lt; 1个来到此结点的小球了；同理，如果一开始!(i &amp; 1)，那它就往右，位置变为1 &lt;&lt; 1 | 1，新的“根结点”处变成第i &lt;&lt; 1个到此位置的小球。然后我们就可以反复执行此过程直到小球落到叶子结点了。 Mycode：12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, d;int main()&#123; while(cin &gt;&gt; t &amp;&amp; t != -1) &#123; while(t--) &#123; cin &gt;&gt; d &gt;&gt; n; int k = 1; for(int i = 1; i &lt; d; ++i) &#123; if(n &amp; 1) &#123; k = k &lt;&lt; 1; n = n + 1 &gt;&gt; 1; &#125; else &#123; k = k &lt;&lt; 1 | 1; n = n &gt;&gt; 1; &#125; &#125; cout &lt;&lt; k &lt;&lt; endl; &#125; &#125; return 0;&#125; UVa 122 Trees on the level 【二叉树的层次遍历】题目大意：输入一颗二叉树，请你从上到下、从左到右的顺序输出各个结点的值。输入的格式详情参照题目说明。 解题思路： 我们可以将树上结点编号，然后把二叉树存到数组里。结点最多256个，如果他们形成一条链的话，最后一个结点的编号高达2^{256} - 1$，数组根本开不下。 采用动态结构，将需要的建立新的结点，然后将其组织成一棵树。 PS：下面的代码是参照LRJ大爷给出的代码写的，随着学习的深入越加觉得LRJ大爷真是tql！ Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int MAX = 1111;bool flag;char s[MAX];struct node&#123; int val; bool have_val; node *left, *right; node() : have_val(false), left(NULL), right(NULL) &#123;&#125;&#125; *root;void addnode(int val, char* s)&#123; node* u = root; for(int i = 0; s[i]; ++i) &#123; if(s[i] == 'L') &#123; if(u -&gt; left == NULL) u -&gt; left = new node(); u = u -&gt; left; &#125; else if(s[i] == 'R') &#123; if(u -&gt; right == NULL) u -&gt; right = new node(); u = u -&gt; right; &#125; &#125; if(u -&gt; have_val) flag = false; u -&gt; val = val; u -&gt; have_val = true;&#125;void delete_tree(node* u)&#123; if(u == NULL) return ; delete_tree(u -&gt; left); delete_tree(u -&gt; right); delete u;&#125;bool read()&#123; flag = true; delete_tree(root); root = new node(); for(;;) &#123; if(scanf("%s", s) != 1) return false; if(strcmp(s, "()") == 0) break; int v; sscanf(&amp;s[1], "%d", &amp;v); addnode(v, strchr(s, ',')+1); &#125; return true;&#125;bool bfs(vector&lt;int&gt;&amp; res)&#123; res.clear(); queue&lt;node*&gt; Q; Q.push(root); while(!Q.empty()) &#123; node* u = Q.front(); Q.pop(); if(!u -&gt; have_val) return false; res.push_back(u -&gt; val); if(u -&gt; left != NULL) Q.push(u -&gt; left); if(u -&gt; right != NULL) Q.push(u -&gt; right); &#125; return true;&#125;int main()&#123; vector&lt;int&gt; res; while(read()) &#123; if(!bfs(res)) flag = false; if(flag) &#123; for(int i = 0; i &lt; res.size(); ++i) &#123; printf("%d%c", res[i], i == res.size() - 1 ? '\n' : ' '); &#125; &#125; else puts("not complete"); &#125; return 0;&#125; UVa 548 Tree 【二叉树的递归遍历】题目大意：给出一颗点带权的二叉树的中序和后序遍历，找一个叶子使得它到根的路径上的权和最小。如果有多解，该叶子本身权应尽量小。 解题思路：后序遍历的最后一个字符是跟，我们在中序遍历中找到它，然后就可以找到左右子树的中序和后序遍历了。根据这个把树通过递归构建出来，然后再执行一次递归遍历来找最优解就OK了。 Mycode：(参考紫书)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int MAX = 10010;int n, in_order[MAX], post_order[MAX], lch[MAX], rch[MAX];bool read_list(int* a)&#123; string line; if(!getline(cin, line)) return false; stringstream ss(line); n = 0; int x; while(ss &gt;&gt; x) a[n++] = x; return n &gt; 0;&#125;int build(int L1, int R1, int L2, int R2)&#123; if(L1 &gt; R1) return 0; int root = post_order[R2]; int p = L1; while(in_order[p] != root) ++p; int cnt = p - L1; lch[root] = build(L1, p-1, L2, L2+cnt-1); rch[root] = build(p+1, R1, L2+cnt, R2-1); return root;&#125;int best, bestsum;void dfs(int u, int sum)&#123; sum += u; if(!lch[u] &amp;&amp; !rch[u]) &#123; if(sum &lt; bestsum || (sum == bestsum &amp;&amp; u &lt; best)) &#123; best = u; bestsum = sum; &#125; &#125; if(lch[u]) dfs(lch[u], sum); if(rch[u]) dfs(rch[u], sum);&#125;int main()&#123; while(read_list(in_order)) &#123; read_list(post_order); build(0, n-1, 0, n-1); bestsum = 1111111111; dfs(post_order[n-1], 0); printf("%d\n", best); &#125; return 0;&#125; UVa 839 Not so Mobile【二叉树的递归遍历】题目大意：输入一个树状天平，根据力矩相等原则判断是否平衡。采用递归方式输入，0表示中间结点。 解题思路：其实可以直接做，就是看怎么写写的既简洁又高效，直接保留书上给的代码了，就不献丑了。。 LRJ’s code:123456789101112131415161718192021222324252627282930313233// 算法：在“建树”时直接读入并判断，并且无须把树保存下来#include&lt;iostream&gt;using namespace std;// 输入一个子天平，返回子天平是否平衡，参数W修改为子天平的总重量bool solve(int&amp; W)&#123; int W1, D1, W2, D2; bool b1 = true, b2 = true; cin &gt;&gt; W1 &gt;&gt; D1 &gt;&gt; W2 &gt;&gt; D2; if(!W1) b1 = solve(W1); if(!W2) b2 = solve(W2); W = W1 + W2; return b1 &amp;&amp; b2 &amp;&amp; (W1 * D1 == W2 * D2);&#125;int main()&#123; int T, W; cin &gt;&gt; T; while(T--) &#123; if(solve(W)) cout &lt;&lt; "YES\n"; else cout &lt;&lt; "NO\n"; if(T) cout &lt;&lt; "\n"; &#125; return 0;&#125; UVa 699 The Falling Leaves【二叉树的递归遍历】题目大意：给一颗二叉树，每个节点都有一个水平位置，左子结点在它左边一个单位，右子结点在它右边一个单位。按照先序遍历的方式输入，请你从左到右输出每个水平位置的所有结点的权值之和。 解题思路：按照递归建树的思想，输入的同时直接进行记录，真正的树不必记录下来。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 222;int sum[MAX];void build(int pos)&#123; int v; scanf("%d", &amp;v); if(v == -1) return ; sum[pos] += v; build(pos - 1); build(pos + 1);&#125;bool init()&#123; int v; scanf("%d", &amp;v); if(v == -1) return false; memset(sum, 0, sizeof(sum)); int pos = MAX &gt;&gt; 1; sum[pos] = v; build(pos - 1); build(pos + 1); return true;&#125;int main()&#123; for(int cas = 1; init(); ++cas) &#123; printf("Case %d:\n", cas); int p = 0; while(sum[p] == 0) ++p; printf("%d", sum[p++]); while(sum[p] != 0) printf(" %d", sum[p++]); puts("\n"); &#125; return 0;&#125; UVa 297 Quadtrees【四叉树】题目大意：给两棵四分树的先序遍历，求二者合并之后（黑色部分合并）黑色像素的个数。p表示中间结点，f表示黑色(full)，e表示白色(empty)。 解题思路：根据前面二叉树递归建树的思想建四叉树，然后统计就可以了。 然后，这个题有毒吧？我写的为啥过不了啊？？uDebug上的数据AC的代码过不了，我的能过，这都什么啊，找了一上午的问题，愣是没找出来。难受啊。把输入的字符串定义为全局变量直接访问而非通过参数传递访问就AC了。UPD：经过一下午的对比，发现因为我字符数组定义的位置不同，返回的结果不一样？定义在最上面AC，中间RE，最下面WA，真是神了。。 Mycode(Wrong Answer)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1024 + 10;//char s[MAX] 放这里 ACint n, res, pos;//char s[MAX] 放这里 REbool vis[35][35];char s[MAX]; //放这里 WAvoid solve(char* s, int x, int y, int w)&#123; char op = s[pos++]; if(op == 'p') &#123; solve(s, x, y + w / 2, w / 2); solve(s, x, y, w / 2); solve(s, x + w / 2, y, w / 2); solve(s, x + w / 2, y + w / 2, w / 2); &#125; else if(op == 'f') &#123; for(int i = x; i &lt; x + w; ++i) &#123; for(int j = y; j &lt; y + w; ++j) &#123; if(vis[i][j] == false) &#123; vis[i][j] = true; ++res; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); while(n--) &#123; res = 0; memset(vis, false, sizeof(vis)); for(int i = 0; i &lt; 2; ++i) &#123; pos = 0; scanf("%s", s); solve(s, 0, 0, 32); &#125; printf("There are %d black pixels.\n", res); &#125; return 0;&#125; Mycode(Accepted):1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1024 + 10;char s[MAX];int n, res, pos;bool vis[35][35];void solve(int x, int y, int w)&#123; char op = s[pos++]; if(op == 'p') &#123; solve(x, y + w / 2, w / 2); solve(x, y, w / 2); solve(x + w / 2, y, w / 2); solve(x + w / 2, y + w / 2, w / 2); &#125; else if(op == 'f') &#123; for(int i = x; i &lt; x + w; ++i) &#123; for(int j = y; j &lt; y + w; ++j) &#123; if(vis[i][j] == false) &#123; vis[i][j] = true; ++res; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); while(n--) &#123; res = 0; memset(vis, false, sizeof(vis)); for(int i = 0; i &lt; 2; ++i) &#123; pos = 0; scanf("%s", s); solve(0, 0, 32); &#125; printf("There are %d black pixels.\n", res); &#125; return 0;&#125; LRJ’s code:1234567891011121314151617181920212223242526272829303132333435363738394041424344// UVa297 Quadtrees// Rujia Liu// 题意：给两棵四分树的先序遍历，求二者合并之后（黑色部分合并）黑色像素的个数。p表示中间结点，f表示黑色（full），e表示白色（empty）// 算法：先建树，然后统计#include&lt;cstdio&gt;#include&lt;cstring&gt;const int len = 32;const int maxn = 1024 + 10;char s[maxn];int buf[len][len], cnt;// 把字符串s[p..]导出到以(r,c)为左上角，边长为w的缓冲区中// 2 1// 3 4void draw(const char* s, int&amp; p, int r, int c, int w) &#123; char ch = s[p++]; if(ch == 'p') &#123; draw(s, p, r, c+w/2, w/2); // 1 draw(s, p, r, c , w/2); // 2 draw(s, p, r+w/2, c , w/2); // 3 draw(s, p, r+w/2, c+w/2, w/2); // 4 &#125; else if(ch == 'f') &#123; // 画黑像素（白像素不画） for(int i = r; i &lt; r+w; i++) for(int j = c; j &lt; c+w; j++) if(buf[i][j] == 0) &#123; buf[i][j] = 1; cnt++; &#125; &#125;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; memset(buf, 0, sizeof(buf)); cnt = 0; for(int i = 0; i &lt; 2; i++) &#123; scanf("%s", s); int p = 0; draw(s, p, 0, 0, len); &#125; printf("There are %d black pixels.\n", cnt); &#125; return 0;&#125; UVa 572 Oil Deposits 【DFS】题目大意：求给定的图中有多少个@的连通块，每个@与它周围相邻的八个小块是联通的。 解题思路：DFS入门题。可以用vis标记访问过的内容，也可以直接将访问过的改为无关的符号(用过一次不再用时可以这样做)。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 105;int dir[][2] = &#123;0,1,1,0,0,-1,-1,0,1,1,-1,-1,1,-1,-1,1&#125;;int n, m, res;char mapa[MAX][MAX];void DFS(int x, int y)&#123; int xx, yy; for(int i = 0; i &lt; 8; ++i) &#123; xx = x + dir[i][0]; yy = y + dir[i][1]; if(xx &lt; 1 || yy &lt; 1 || xx &gt; n || yy &gt; m) continue; if(mapa[xx][yy] == '*') continue; mapa[xx][yy] = '*'; DFS(xx, yy); &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m)) &#123; res = 0; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) cin &gt;&gt; mapa[i][j]; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) if(mapa[i][j] == '@') DFS(i, j), ++res; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; UVa 1103 Ancient Messages 【DFS】题目大意：编程识别6种古代象形文字，每组数据包含一个H行W列的字符矩阵，每个字符矩阵为4个相邻像素点的十六进制(eg: $10011100$ 对应字符就是$9C$)。转化为2进制后，1代表黑点，0代表白点。输入满足：1.不会出现上述6种符号外的其他符号。2.输入至少包含一个符号，且每个黑像素都属于一个符号。3.图像中的每个黑色像素都是有效象形文字的一部分。4.象形文字不接触也不包含。5.如果两个黑像素有公共顶点那么他们一定有公共边。6.所有符号形状和给出的图形拓扑等价(可以随意拉伸但不能拉断)。 解题思路：1.16进制转换为2进制，建图。2.观察发现每个图都有一个与其他图像完全不同的特征——洞的个数，可以把此作为为突破点。3.第一遍把所有象形文字“抠”出来，具体操作是将所有为0的部分标记一下。4.第二遍开始给每个象形文字的洞标号。具体操作是找没被标记的部分开始DFS，将第i个图的洞全部标记为i号。5.第三遍数洞的个数。因为上一步已经将第i号的洞标记为了i，这时就遍历整个图看有几个连通块编号为i即可。(自己的代码不够精简，很明显的DFS0和DFS1是可以合并的，加个if判断就好了)【小技巧】因为步骤一中第一个非象形文字的洞的0不好确定，所以我们建图时可以从(1,1)开始存储给出的图，这样(0,0)必定是非象形文字的洞的0了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 205;string res;int vis[MAX][MAX];int mapa[MAX][MAX];map&lt;char, string&gt; q;int h, w, cas, tot, t;string ans = "WAKJSD";int dir[][2] = &#123;0,1,1,0,-1,0,0,-1&#125;;void debug()&#123; for(int i = 0; i &lt;= h + 1; ++i) &#123; for(int j = 0; j &lt;= w * 4 + 1; ++j) &#123; cout &lt;&lt; mapa[i][j]; &#125; cout &lt;&lt; endl; &#125;&#125;void debug2()&#123; for(int i = 0; i &lt;= h + 1; ++i) &#123; for(int j = 0; j &lt;= w * 4 + 1; ++j) &#123; cout &lt;&lt; vis[i][j]; &#125; cout &lt;&lt; endl; &#125;&#125;void initq()&#123; q['0'] = "0000"; q['1'] = "0001"; q['2'] = "0010"; q['3'] = "0011"; q['4'] = "0100"; q['5'] = "0101"; q['6'] = "0110"; q['7'] = "0111"; q['8'] = "1000"; q['9'] = "1001"; q['a'] = "1010"; q['b'] = "1011"; q['c'] = "1100"; q['d'] = "1101"; q['e'] = "1110"; q['f'] = "1111";&#125;void init()&#123; tot = 1; res = ""; memset(vis, 0, sizeof(vis)); memset(mapa, 0, sizeof(mapa));&#125;void Readmap()&#123; char tem; string t; int tot = 0; for(int i = 0; i &lt; h * w; ++i) &#123; cin &gt;&gt; tem; t = q[tem]; for(int j = 0; j &lt; 4; ++j) &#123; mapa[tot / (w * 4) + 1][tot % (w * 4) + 1] = t[j] - '0'; ++tot; &#125; &#125;&#125;void DFS0(int x, int y, int now)&#123; int xx, yy; for(int i = 0; i &lt; 4; ++i) &#123; xx = x + dir[i][0]; yy = y + dir[i][1]; if(xx &lt; 0 || yy &lt; 0 || xx &gt; h + 1 || yy &gt; w * 4 + 1) continue; if(vis[xx][yy]) continue; if(mapa[xx][yy]) continue; vis[xx][yy] = now; DFS0(xx, yy, now); &#125;&#125;void DFS1(int x, int y, int now)&#123; int xx, yy; for(int i = 0; i &lt; 4; ++i) &#123; xx = x + dir[i][0]; yy = y + dir[i][1]; if(xx &lt; 1 || yy &lt; 1 || xx &gt; h || yy &gt; w * 4) continue; if(vis[xx][yy]) continue; if(mapa[xx][yy] == 0) vis[xx][yy] = now; else vis[xx][yy] = 1; DFS1(xx, yy, now); &#125;&#125;void DFS2(int x, int y, int k)&#123; int xx, yy; for(int i = 0; i &lt; 4; ++i) &#123; xx = x + dir[i][0]; yy = y + dir[i][1]; if(xx &lt; 1 || yy &lt; 1 || xx &gt; h || yy &gt; w * 4) continue; if(vis[xx][yy] != k) continue; vis[xx][yy] = 1; DFS2(xx, yy, k); &#125;&#125;void solve()&#123; DFS0(0, 0, tot); //debug2(); //---above--- for(int i = 1; i &lt;= h; ++i) for(int j = 1; j &lt;= w * 4; ++j) if(mapa[i][j] &amp;&amp; vis[i][j] == 0) DFS1(i, j, ++tot); //debug2(); for(int k = 2; k &lt;= tot; ++k) &#123; t = 0; for(int i = 1; i &lt;= h; ++i) for(int j = 1; j &lt;= w * 4; ++j) if(vis[i][j] == k) &#123; DFS2(i, j, k); ++t; &#125; //cout &lt;&lt; "t = " &lt;&lt; t &lt;&lt; endl; //debug2(); res += ans[t]; &#125; sort(res.begin(), res.end());&#125;int main()&#123; initq(); while(cin &gt;&gt; h &gt;&gt; w &amp;&amp; (h || w)) &#123; init(); Readmap(); //debug(); solve(); cout &lt;&lt; "Case " &lt;&lt; ++cas &lt;&lt; ": " &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; UVa 816 Abbott’s Revenge 【BFS】题目大意：在一个最多包含9 * 9个交叉点的迷宫中，输入起点、离开起点时的朝向和终点，求一条最短路(多解时输出任意一条)。 解题思路：这个相对于一般的最短路问题而言多了方向，因此无法用最短路的算法求解，这时考虑到使用BFS来解决。对于路径的打印，可以采用递归的方式打印。如果最短路很长的话递归可能会引起栈的溢出，此时改用循环，用vector记录路径。PS：一开始接触这个题目时毫无头绪，也是参照了书上的内容一点一点扣了很久才弄明白的。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;//确定好方向后确定走的路线const int MAX = 11;const char* dirs = "NESW";const char* turns = "FLR";const int dr[] = &#123;-1,0,1,0&#125;;const int dc[] = &#123;0,1,0,-1&#125;;int dis[MAX][MAX][4]; //此位置到起点的距离bool iscon[MAX][MAX][4][3]; //是否能到达int r0, c0, r1, c1, r2, c2, dir;struct node&#123; int r, c, dir; node(int r = 0, int c = 0, int dir = 0) : r(r), c(c), dir(dir) &#123;&#125;&#125;p[MAX][MAX][4]; //父结点int dir_id(char c)&#123; return strchr(dirs, c) - dirs;&#125;int turn_id(int c)&#123; return strchr(turns, c) - turns;&#125;bool read()&#123; char s[99]; scanf("%s", s); if(strcmp(s, "END") == 0) return false; printf("%s\n", s); scanf("%d%d%s%d%d",&amp;r0,&amp;c0,s,&amp;r2,&amp;c2); dir = dir_id(s[0]); r1 = r0 + dr[dir]; c1 = c0 + dc[dir]; memset(iscon, false, sizeof(iscon)); int r, c; while(scanf("%d",&amp;r) &amp;&amp; r) &#123; scanf("%d", &amp;c); while(scanf("%s", s) &amp;&amp; s[0] != '*') &#123; for(int i = 1; s[i]; ++i) iscon[r][c][dir_id(s[0])][turn_id(s[i])] = true; &#125; &#125; return true;&#125;void print_ans(node u)&#123; vector&lt;node&gt; G; while(true) &#123; G.push_back(u); if(dis[u.r][u.c][u.dir] == 0) break; u = p[u.r][u.c][u.dir]; &#125; G.push_back(node(r0, c0, dir)); int cnt = 0; for(int i = G.size() - 1; i &gt;= 0; --i) &#123; if(cnt % 10 == 0) printf(" "); printf(" (%d,%d)",G[i].r,G[i].c); if(++cnt % 10 == 0) puts(""); &#125; if(cnt % 10) puts("");&#125;node walk(const node&amp; u, int turn)&#123; int dir = u.dir; if(turn == 1) dir = (dir + 3) % 4; if(turn == 2) dir = (dir + 1) % 4; return node(u.r + dr[dir], u.c + dc[dir], dir);&#125;bool islegal(int r, int c)&#123; return r &gt;= 1 &amp;&amp; c &gt;= 1 &amp;&amp; r &lt;= 9 &amp;&amp; c &lt;= 9;&#125;void solve()&#123; queue&lt;node&gt; Q; memset(dis, -1, sizeof(dis)); dis[r1][c1][dir] = 0; node u(r1, c1, dir); Q.push(u); while(!Q.empty()) &#123; node u = Q.front(); Q.pop(); if(u.r == r2 &amp;&amp; u.c == c2) &#123; print_ans(u); return ; &#125; //模拟从此位置出发往三个方向走(FLR) for(int i = 0; i &lt; 3; ++i) &#123; node v = walk(u, i); if(iscon[u.r][u.c][u.dir][i] &amp;&amp; islegal(v.r, v.c) &amp;&amp; dis[v.r][v.c][v.dir] &lt; 0) &#123; dis[v.r][v.c][v.dir] = dis[u.r][u.c][u.dir] + 1; p[v.r][v.c][v.dir] = u; Q.push(v); &#125; &#125; &#125; puts(" No Solution Possible");&#125;int main()&#123; while(read()) solve(); return 0;&#125; UVa 10305 Ordering Tasks 【拓扑排序】题目大意：给出n个任务和m个限制条件，要求任务i必须在任务j之前完成。请给出一个合适的任务完成顺序。 解题思路：拓扑排序裸题。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int MAX = 105;int n, m;int in[MAX];bool vis[MAX];vector&lt;int&gt; res;vector&lt;int&gt; G[MAX];int main()&#123; while(scanf("%d%d",&amp;n,&amp;m) &amp;&amp; (n + m)) &#123; for(int i = 0; i &lt;= n; ++i) G[i].clear(); memset(in, 0, sizeof(in)); memset(vis, false, sizeof(vis)); for(int i = 0; i &lt; m; ++i) &#123; int u, v; scanf("%d%d",&amp;u,&amp;v); in[v]++; G[u].push_back(v); &#125; bool flag = true; res.clear(); while(flag) &#123; flag = false; for(int i = 1; i &lt;= n; ++i) &#123; if(vis[i]) continue; if(in[i] == 0) &#123; res.push_back(i); vis[i] = true; flag = true; for(int j = 0; j &lt; G[i].size(); ++j) in[G[i][j]]--; &#125; &#125; if(!flag) break; &#125; if(res.size() != n) puts("Impossible"); else for(int i = 0; i &lt; res.size(); ++i) printf("%d%c", res[i], i == res.size() - 1 ? '\n' : ' '); &#125; return 0;&#125; UVa 10129 Play on Words 【欧拉回路】【并查集】题目大意：给出n个单词，能否可以把他们排成一列，使得每个单词的第一个字母和上一个单词的最后一个字母相同。 解题思路：将字母看做结点，单词看成有向边，那么当且仅当图中有欧拉回路的时候问题有解。有向图存在欧拉回路的条件有两个：1. 底图(即忽略方向后得到的无向图)联通 2.度数满足欧拉道路的条件。这里判断条件1时用的并查集，判断条件二时直接记录的度数。 欧拉回路 无向图中从一个结点出发走出一条道路，每条边恰好经过一次，这样的道路称为欧拉道路。 度：无向图里，度为一个顶点关联边的个数。 如果一个无向图是联通的，且最多有两个度数为奇数的点，那么一定存在欧拉道路。如果有两个奇点，则必须从一个奇点出发到另一个奇点终止，其余情况，则可以从任意点出发，最终一定会回到该点(称为欧拉回路)。 –&gt; 类推出有向图： 最多只能有两个点的入度不等于出度，而且必须是其中一个点的出度恰好比入度大1(起点)，另一个的入度比出度大1(终点)。 前提条件：忽略方向后，图是联通的。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;char s[1111];bool vis[256];int t, n, tot, f[256], deg[256];int Find(int x)&#123; return f[x] == x ? x : f[x] = Find(f[x]);&#125;void init()&#123; for(int i = 'a'; i &lt;= 'z'; ++i) f[i] = i; memset(vis, 0, sizeof(vis)); memset(deg, 0, sizeof(deg));&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; init(); tot = 26; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s", s); char x = s[0]; char y = s[strlen(s) - 1]; ++deg[x], --deg[y]; vis[x] = vis[y] = true; int t1 = Find(x), t2 = Find(y); if(t1 != t2) &#123; f[t2] = t1; --tot; &#125; &#125; vector&lt;int&gt; d; for(int i = 'a'; i &lt;= 'z'; ++i) &#123; if(vis[i] == false) --tot; else if(deg[i]) d.push_back(deg[i]); &#125; bool ok = ((tot == 1) &amp;&amp; (d.empty() || (d.size() == 2 &amp;&amp; d[0] + d[1] == 0 &amp;&amp; abs(d[0]) == 1))); puts(ok ? "Ordering is possible." : "The door cannot be opened."); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>并查集</tag>
        <tag>queue</tag>
        <tag>UVa</tag>
        <tag>解题报告</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>数据结构</tag>
        <tag>stack</tag>
        <tag>BFS</tag>
        <tag>list</tag>
        <tag>二叉树</tag>
        <tag>拓扑排序</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018_SDNU_ACM-ICPC_Provincial_Team_Selection_Round_2【假装完结】]]></title>
    <url>%2Fsdnu-2018-2%2F</url>
    <content type="text"><![CDATA[山东省第九届acm大学程序设计竞赛山师选拔赛第二场(声明：标题是自己取的，如果有语法错误的话与他人无关) —————————————————————–分割线—————————————————————– Problem A. Alice and Bob(NimK博弈)题意：有N堆石子，每次可以取1~M堆中的任意多个石子，最后无石子可取的那个失败。Alice先手，问谁会赢。 思路：NimK博弈裸题，结论是当且仅当每一位二进制位上的数%(m+1)都是0的时候，先手必败，否则先手必胜。见识++。原理留坑待补。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int tem, tot;int u[MAX][55];int t, res, a, b, n, m;int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; memset(u, 0, sizeof(u)); scanf("%d%d",&amp;n,&amp;m); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;tem); tot = 0; while(tem) &#123; u[i][tot++] = tem &amp; 1; tem &gt;&gt;= 1; &#125; &#125; bool flag = true; for(int j = 0; j &lt; 32; ++j) &#123; int yy = 0; for(int i = 0; i &lt; n; ++i) &#123; yy += u[i][j]; &#125; if(yy % (m+1)) &#123; flag = false; break; &#125; &#125; printf("Case #%d: ", cas); puts(flag ? "Bob" : "Alice"); &#125; return 0;&#125; Problem B. SOS(基础)题意：已知gcd(a, c) = b， 给出a和b求满足条件的最小的不等于b的c。 思路：对式子变形得，gcd(a/b, c/b) = 1， 即求最小的与a/b互质的数。(之前做过一道一模一样的题SDNU-1132: 最大公约数改，枚举答案也能水过啦) Mycode：12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e6+7;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t, res, a, b;int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d%d",&amp;a,&amp;b); a /= b; for(int i = 2; ; ++i) &#123; if(gcd(a, i) == 1) &#123; res = i; break; &#125; &#125; printf("Case #%d: %d\n", cas, res * b); &#125; return 0;&#125; Problem C. Boooooooo(规律)题意：给出一个数N，找出最小的大于等于N的整数pp，其中pp满足存在整数hh使得2hh(hh + 1) = pp(pp + 1)。 思路：打表找规律。(找不出来怎么办？GG呗) Mycode：1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int t;long long n, res;long long a[30] = &#123;3,20&#125;;int main()&#123; for(int i = 2; i &lt; 25; ++i) &#123; a[i] = 6 * a[i-1] - a[i-2] + 2; //cout &lt;&lt; a[i] &lt;&lt; endl; &#125; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%lld", &amp;n); for(int i = 0; ; ++i) &#123; if(a[i] &gt;= n) &#123; printf("Case #%d: %lld\n", cas, a[i]); break; &#125; &#125; &#125; return 0;&#125; Problem D. XC’s pot(期望)题目原型：LightOJ-1027: A Dangerous Maze Problem E. SDNU ACM/ICPC TEAM(拓扑排序)题意不清，不如做这个吧：HDU-4857: 逃生 Problem F. The Avengers(最小生成树)队友补了，目前不想补。 Problem G. play the guitar(大数)题意：Calculate $n^k$ and change all 7,8,9 to 1,2,3(7 to 1, 8 to 2, 9 to 3). 思路：开上Java直接做。 Mycode：12345678910111213141516171819202122232425262728import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner scanner = new Scanner(System.in); int n, m; BigInteger res; String s; while(scanner.hasNext()) &#123; n = scanner.nextInt(); m = scanner.nextInt(); res = BigInteger.valueOf(1); for(int i = 1; i &lt;= m; ++i) &#123; res = res.multiply(BigInteger.valueOf(n)); &#125; s = res.toString(); s = s.replace('7','1'); s = s.replace('8','2'); s = s.replace('9','3'); System.out.println(s); &#125; &#125;&#125; Problem H. The chord(最长公共子串)题意：所有和弦中，伟大的歌手LHM只会其中的部分和弦，给出一个包含很多和弦的吉他谱，问LMH能弹奏的连续的最长的一段乐曲包含多少和弦。 思路：先将不同字符串转换，然后计算转换后的两个串的最长公共子串(套后缀数组的模板)。(转换时当然想到map，然而套各种模板都会超时，因此只好写个100+行的函数来转换。这个题目的idea还是不错的。) Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200000 + 10, INF = 0x3f3f3f3f;const char trans[] = &#123;'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r'&#125;;int sa[N], height[N], rnk[N], wa[N], wb[N], c[N];char str[N], S[N];int s[N], Q;bool cmp(int *r, int a, int b, int l)&#123; return r[a] == r[b] &amp;&amp; r[a+l] == r[b+l];&#125;void Rsort(int *x, int *y, int n, int m)&#123; for(int i = 0; i &lt; m; i++) c[i] = 0; for(int i = 0; i &lt; n; i++) c[x[y[i]]]++; for(int i = 1; i &lt; m; i++) c[i] += c[i-1]; for(int i = n-1; i &gt;= 0; i--) sa[--c[x[y[i]]]] = y[i];&#125;void da(int *s, int n, int m)&#123; int *x = wa, *y = wb; for(int i = 0; i &lt; n; i++) x[i] = s[i], y[i] = i; Rsort(x, y, n, m); for(int j = 1, p = 1; p &lt; n; j *= 2, m = p) &#123; p = 0; for(int i = n-j; i &lt; n; i++) y[p++] = i; for(int i = 0; i &lt; n; i++) if(sa[i] &gt;= j) y[p++] = sa[i] - j; Rsort(x, y, n, m); swap(x, y); p = 1; x[sa[0]] = 0; for(int i = 1; i &lt; n; i++) x[sa[i]] = cmp(y, sa[i-1], sa[i], j) ? p-1 : p++; &#125;&#125;void get_height(int *s, int n)&#123; int i, j, k = 0; for(i = 0; i &lt;= n; i++) rnk[sa[i]] = i; for(i = 0; i &lt; n; height[rnk[i++]] = k) for(k ? --k : 0, j = sa[rnk[i]-1]; s[i+k] == s[j+k]; k++);&#125;int change(int L)&#123; int res = 0; for(int i = 0; i &lt; L; ++i) &#123; if(str[i] == 'A') &#123; if(str[i+1] == '7') &#123; s[res++] = trans[1]; ++i; &#125; else if(str[i+1] == 'm') &#123; s[res++] = trans[2]; ++i; &#125; else if(str[i+1] == 's') &#123; s[res++] = trans[3]; i += 4; &#125; else s[res++] = trans[0]; &#125; else if(str[i] == 'B') &#123; if(str[i+1] == '7') s[res++] = trans[4]; else s[res++] = trans[5]; ++i; &#125; else if(str[i] == 'C') &#123; if(str[i+1] == '7') &#123; s[res++] = trans[7]; ++i; &#125; else s[res++] = trans[6]; &#125; else if(str[i] == 'D') &#123; if(str[i+1] == '7') &#123; s[res++] = trans[9]; ++i; &#125; else if(str[i+1] == 'm') &#123; if(str[i+2] == '7') &#123; s[res++] = trans[10]; i += 2; &#125; else &#123; s[res++] = trans[11]; i++; &#125; &#125; else s[res++] = trans[8]; &#125; else if(str[i] == 'E') &#123; if(str[i+1] == 'm') &#123; s[res++] = trans[13]; ++i; &#125; else s[res++] = trans[12]; &#125; else if(str[i] == 'F') &#123; if(str[i+1] == 'm') &#123; s[res++] = trans[14]; i += 4; &#125; else s[res++] = trans[15]; &#125; else if(str[i] == 'G') &#123; if(str[i+1] == '7') &#123; s[res++] = trans[16]; i++; &#125; else s[res++] = trans[17]; &#125; else &#123; Q = res; s[res++] = '$'; &#125; &#125; return res;&#125;int main()&#123; while(~scanf("%s", str)) &#123; int len = strlen(str); str[len] = '$'; scanf("%s", str + 1 + len); len = strlen(str); len = change(len); s[len] = 0; int len_1 = Q; da(s, len + 1, 130);//第二个参数，即长度比原数组大一，因为在末尾补了一个极小值，故+1 get_height(s, len);//此处传入原长度 int ans = 0; for(int i = 1; i &lt;= len; i++)//height[1]~height[len]，因为sa[0]是以极小值为起点的后缀，然后sa[1]~sa[len]，故height[1]~height[len] if(height[i] &gt; ans &amp;&amp; ((sa[i-1]&lt;len_1 &amp;&amp; sa[i]&gt;len_1) || (sa[i-1]&gt;len_1 &amp;&amp; sa[i]&lt;len_1))) ans = height[i]; printf("%d\n", ans); &#125; return 0;&#125; Problem I. Alice and Bob II(记忆化搜索)题意：N堆石子，Alice先手，每次两人都可以从石子的两端取任意一堆，问Alice最多能取多少石子。 思路：我觉得题目中这句they both smart不应该有，不然给出的正解讲不通。去掉这句话的话就是看Alice能取的石子最大值了。使Alice取最多即每次Alice往多了取，Bob往小了取。最多100堆，枚举每个状态的话肯定不能完成。采取记忆化搜索可以保留左右位置为l、r时的最优解，大大减少时间复杂度，任务完成。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 105;int a[MAX];int n, res, t;int dp[MAX][MAX];int DFS(int l, int r, bool flag)&#123; if(dp[l][r]) return dp[l][r]; int res = 0; if(flag) &#123; if(l == r) return a[l]; res = max(DFS(l+1, r, !flag) + a[l], DFS(l, r-1, !flag) + a[r]); &#125; else &#123; if(l == r) return 0; res = min(DFS(l+1, r, !flag), DFS(l, r-1, !flag)); &#125; dp[l][r] = res; return res;&#125;int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d",&amp;n); memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; ++i) scanf("%d",&amp;a[i]); int ans = DFS(1, n, true); printf("Case #%d: %d\n", cas, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018_SDNU_ACM-ICPC_Provincial_Team_Selection_Round_1【假装完结】]]></title>
    <url>%2Fsdnu-2018-1%2F</url>
    <content type="text"><![CDATA[山东省第九届acm大学程序设计竞赛山师选拔赛第一场(声明：标题是自己取的，如果有语法错误的话与他人无关) —————————————————————–分割线—————————————————————– A.网瘾少年周老灰(贪心)题意：周老灰玩炉石，场上目前有2 * n张牌，敌我各n张。发动进攻的方式是每张牌只能攻击一张牌，进攻完成后，敌方士兵生命值减少我方进攻士兵的攻击力，我方士兵生命值也要减少敌方进攻士兵的攻击力，当生命之小于等于0时，这张卡牌将消失。现在轮到我方发动进攻，问能否使得我方这一轮进行完后地方卡牌都被摧毁，而我方卡牌还都存活。 思路：考虑到数据范围，直接做就行了(数据范围再大点的话就是二分图匹配了)。每次贪心选取我方能打败的敌方选手中攻击力最高的，一直这样选直到全部选完||打败不了的情况。 碎碎念：数据出的太不负责了，出现了范围以外的数就不说了，TM除了一个本不该存在的n=0时输出Sorry about that!外，其他情况都输出Tell you a joke~？这种题目全随机数出现前一个答案的概率太小了，就不能手动出几组吗(没错我是因为他这个本不该出现的n=0浪费了近3小时的时间debug才如此气愤的)。UPD(04.18)：等了一周后还没改，自己出了几组随机数和手动出的数据传上去后rejudge，果然hack掉了几个。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 105;int t, n;struct node&#123; bool flag; int hp, mp;&#125;a[MAX], b[MAX];bool cmp(node u, node v)&#123; if(u.hp == v.hp) return u.mp &lt; v.mp; return u.hp &lt; v.hp;&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); bool flag; memset(b, 0, sizeof(b)); for(int i = 0; i &lt; n; ++i) scanf("%d%d",&amp;a[i].hp,&amp;a[i].mp); for(int i = 0; i &lt; n; ++i) scanf("%d%d",&amp;b[i].hp,&amp;b[i].mp); sort(a, a+n, cmp); sort(b, b+n, cmp); for(int i = 0; i &lt; n; ++i) &#123; flag = false; for(int j = n-1; j &gt;= 0; --j) &#123; if(b[j].flag == false &amp;&amp; a[i].hp &gt; b[j].mp &amp;&amp; a[i].mp &gt;= b[j].hp) &#123; flag = true; b[j].flag = true; break; &#125; &#125; if(!flag) break; &#125; if(flag) puts("Sorry about that!"); else puts("Tell you a joke~"); &#125; return 0;&#125; B.陆历川玩数位(数位DP)题目原型：HDU-4734: F(x) 队友补过了，目前不想补。 C.prime(素数筛)题意：给一个数n问n是否是素数，0 &lt; n &lt; 100000000。 思路：据说出题人本打算考察位图筛的，但没想到数组可以开到1e8这么大，于是让大家用素数筛水过去了。队友说素数筛会超时，于是我上的Miller-Rabin。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int S = 8;//随机算法判定次数，一般8~10次就够了//计算ret = (a*b)%c a, b, c &lt; 2^63long long mult_mod(long long a, long long b, long long c)&#123; a %= c; b %= c; long long ret = 0; long long tem = a; while(b) &#123; if(b &amp; 1) &#123; ret += tem; if(ret &gt; c) ret -= c;//直接取模慢很多 &#125; tem &lt;&lt;= 1; if(tem &gt; c) tem -= c; b &gt;&gt;= 1; &#125; return ret;&#125;//计算 ret = (a^n) % modlong long pow_mod(long long a, long long n, long long mod)&#123; long long ret = 1; long long tem = a % mod; while(n) &#123; if(n &amp; 1) ret = mult_mod(ret, tem, mod); tem = mult_mod(tem, tem, mod); n &gt;&gt;= 1; &#125; return ret;&#125;// 通过 a^(n-1)=1(mod n)来判断n是不是素数// n-1 = x * 2^t 中间使用二次判断// 是合数返回true，不一定是合数返回falsebool check(long long a, long long n, long long x, long long t)&#123; long long ret = pow_mod(a, x, n);//a^x % n long long last = ret; for(int i = 1; i &lt;= t; ++i)//进行t次(a^x % n)^2 % n &#123; ret = mult_mod(ret, ret, n); if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true;//合数 last = ret; &#125; if(ret != 1) return true; return false;//不一定是合数&#125;//**************************************************// Miller_Rabin算法// 是素数返回true,(可能是伪素数)// 不是素数返回false//**************************************************bool Miller_Rabin(long long n)&#123; if(n &lt; 2) return false; if(n == 2) return true; if( (n&amp;1) == 0) return false;//偶数 long long x = n - 1; long long t = 0; while( (x&amp;1) == 0) //将n分解为x*2^t; &#123; x &gt;&gt;= 1; t++; &#125; srand( time(NULL)); for(int i = 0; i &lt; S; ++i) &#123; long long a = rand()%(n-1) + 1;//产生随机数a(并控制其范围在1 ~ n-1之间) if(check(a, n, x, t))//是合数 return false; &#125; return true;&#125;int main()&#123; int T; long long n; scanf("%d", &amp;T); while(T--) &#123; scanf("%lld", &amp;n); if(Miller_Rabin(n)) cout &lt;&lt; "N" &lt;&lt; endl; else cout &lt;&lt; "Y" &lt;&lt; endl; &#125; return 0;&#125; D.陆历川爱合并(K叉哈夫曼树)题意：从n个元素中每次取不超过k个元素进行合并，合并时的花费为k个元素价值的总和，并且合并出的新元素价值为这k个元素的总和。问当最终花费不超过T时，最小的k是多少。 思路：0.当k=2时，这就是哈夫曼树，为使总花费最小，每次合并的两元素的价值最小。相关题目：SDNU-1412: Huffuman树。1.显然k越大总花费越小，满足单调性，因此我们可以采用二分的方法枚举k。2.因为每次取k个合并后变成一个总量其实减少了k-1个，每次减少这么多，再加上最后合并为1堆，因此当(n-1) % (k-1) == 0时，说明刚好能合并完成，否则会出现剩余的情况，如果最后合并这些多出来的部分的话会影响到上面1中的单调性，所以这种情况下要先合并多出来的这部分。3.合并时可以维护小的值一直在队列前面，省下了排序/查找的时间。 K叉哈夫曼树模板：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int Hafuman(int k) //返回总代价&#123; int ai, bi, blen; blen = 0; ai = bi = 0; int cost = 0; bool first = true; while (n - ai + blen - bi &gt; 1) &#123; int num = 0; if (first) &#123; if ((n - k) % (k - 1) == 0) num = k; else num = (n - k) % (k - 1) + 1; first = false; &#125; else num = k; int sum = 0; while (num--) &#123; if (ai == n) &#123; sum += b[bi]; bi++; &#125; else if (bi == blen) &#123; sum += a[ai]; ai++; &#125; else if (a[ai] &lt; b[bi]) &#123; sum += a[ai]; ai++; &#125; else &#123; sum += b[bi]; bi++; &#125; &#125; cost += sum; b[blen++] = sum; &#125; return cost;&#125; 题目原型：HDU-5884: Sort Mycode：(在HDU上过了，在这里T了，慢了200MS。自己将上面的模板套上后就能过了。)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 100005;int a[MAX];queue&lt;LL&gt; Q;int t, n, m, res;bool judge(int k)&#123; while(!Q.empty()) Q.pop(); LL tot = 0; LL tem = 0; int idx = 0; int lef = (n - 1) % (k - 1) + 1; if(lef) //多出的lef个先合并 &#123; while(idx &lt; lef) tem += a[idx++]; tot += tem; Q.push(tem); &#125; while(1) &#123; tem = 0; for(int i = 0; i &lt; k; ++i) &#123; if(idx &lt; n &amp;&amp; (Q.empty() || a[idx] &lt; Q.front())) tem += a[idx++]; else tem += Q.front(), Q.pop(); &#125; tot += tem; if(tot &gt; m) return false; if(idx &gt;= n &amp;&amp; Q.empty()) break; Q.push(tem); &#125; return tot &lt;= m;&#125;int main()&#123; scanf("%d",&amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; scanf("%d%d",&amp;n, &amp;m); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); sort(a, a + n); int l = 2, r = n; int mid; while(l &lt;= r) &#123; mid = (l + r) / 2; if(judge(mid)) &#123; res = mid; r = mid - 1; &#125; else l = mid + 1; &#125; printf("Case #%d: %d\n", cas, res); &#125; return 0;&#125; E.Reasoning test(模拟)题意：给出10个问题，他们之间有相互限制的条件，问满足这些限制条件的每个问题的答案是多少。 思路：因为只要提交答案，本地枚举每种情况，然后把限制条件堆到一个函数里judge一下就好了。(比赛时都是手推的，这是江苏省公安厅网络安全小组的官方微博“江苏网警”发布的“2018年刑侦专题推理试题”，看来大家都有当刑警的潜力啊。) Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e6+7;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int a[15];char ch[] = &#123;'A','B','C','D'&#125;;void out()&#123; for(int i = 1; i &lt;= 10; ++i) cout &lt;&lt; ch[a[i]-1]; cout &lt;&lt; endl;&#125;bool judge()&#123; if(a[2] != (a[5]+1)%4+1) return false; if(a[3] == 1) &#123; if(a[3] == a[6]) return false; if(a[3] == a[2]) return false; if(a[3] == a[4]) return false; &#125; else if(a[3] == 2) &#123; if(a[6] == a[2]) return false; if(a[6] == a[3]) return false; if(a[6] == a[4]) return false; &#125; else if(a[3] == 3) &#123; if(a[2] == a[3]) return false; if(a[2] == a[4]) return false; if(a[2] == a[6]) return false; &#125; else if(a[3] == 4) &#123; if(a[4] == a[2]) return false; if(a[4] == a[3]) return false; if(a[4] == a[6]) return false; &#125; if(a[4] == 1 &amp;&amp; a[1] != a[5]) return false; if(a[4] == 2 &amp;&amp; a[2] != a[7]) return false; if(a[4] == 3 &amp;&amp; a[1] != a[9]) return false; if(a[4] == 4 &amp;&amp; a[6] != a[10]) return false; if(a[5] == 1 &amp;&amp; a[5] != a[8]) return false; if(a[5] == 2 &amp;&amp; a[5] != a[4]) return false; if(a[5] == 3 &amp;&amp; a[5] != a[9]) return false; if(a[5] == 4 &amp;&amp; a[5] != a[7]) return false; if(a[6] == 1) &#123; if(a[2] != a[4]) return false; if(a[2] != a[8]) return false; &#125; else if(a[6] == 2) &#123; if(a[1] != a[6]) return false; if(a[1] != a[8]) return false; &#125; else if(a[6] == 3) &#123; if(a[3] != a[10]) return false; if(a[3] != a[8]) return false; &#125; else if(a[6] == 4) &#123; if(a[5] != a[9]) return false; if(a[5] != a[8]) return false; &#125; int A, B, C, D; A = B = C = D = 0; for(int i = 1; i &lt;= 10; ++i) &#123; if(a[i] == 1) ++A; if(a[i] == 2) ++B; if(a[i] == 3) ++C; if(a[i] == 4) ++D; &#125; int minn = -1; if(A &lt; B &amp;&amp; A &lt; C &amp;&amp; A &lt; D) minn = 1; if(B &lt; A &amp;&amp; B &lt; C &amp;&amp; B &lt; D) minn = 2; if(C &lt; A &amp;&amp; C &lt; B &amp;&amp; C &lt; D) minn = 3; if(D &lt; A &amp;&amp; D &lt; B &amp;&amp; D &lt; C) minn = 4; if(a[7] == 1 &amp;&amp; minn != 3) return false; if(a[7] == 2 &amp;&amp; minn != 2) return false; if(a[7] == 3 &amp;&amp; minn != 1) return false; if(a[7] == 4 &amp;&amp; minn != 4) return false; if(a[8] == 1 &amp;&amp; abs(a[1]-a[7]) == 1) return false; if(a[8] == 2 &amp;&amp; abs(a[1]-a[5]) == 1) return false; if(a[8] == 3 &amp;&amp; abs(a[1]-a[2]) == 1) return false; if(a[8] == 4 &amp;&amp; abs(a[1]-a[10])== 1) return false; bool flag = (a[1] == a[6]); if(flag) &#123; if(a[9] == 1) &#123; if(a[6] == a[5]) return false; &#125; if(a[9] == 2) &#123; if(a[10] == a[5]) return false; &#125; if(a[9] == 3) &#123; if(a[2] == a[5]) return false; &#125; if(a[9] == 4) &#123; if(a[9] == a[5]) return false; &#125; &#125; else &#123; if(a[9] == 1) &#123; if(a[6] != a[5]) return false; &#125; if(a[9] == 2) &#123; if(a[10] != a[5]) return false; &#125; if(a[9] == 3) &#123; if(a[2] != a[5]) return false; &#125; if(a[9] == 4) &#123; if(a[9] != a[5]) return false; &#125; &#125; int maxx = -1; if(A &gt; B &amp;&amp; A &gt; C &amp;&amp; A &gt; D) maxx = 1; if(B &gt; A &amp;&amp; B &gt; C &amp;&amp; B &gt; D) maxx = 2; if(C &gt; A &amp;&amp; C &gt; B &amp;&amp; C &gt; D) maxx = 3; if(D &gt; A &amp;&amp; D &gt; B &amp;&amp; D &gt; C) maxx = 4; int dif = abs(maxx - minn); if(a[10] == 1 &amp;&amp; dif != 3) return false; if(a[10] == 2 &amp;&amp; dif != 2) return false; if(a[10] == 3 &amp;&amp; dif != 4) return false; if(a[10] == 4 &amp;&amp; dif != 1) return false; return true;&#125;void DFS(int idx, int val)&#123; a[idx] = val; if(idx == 10) &#123; if(judge()) out(); return ; &#125; for(int i = 1; i &lt;= 4; ++i) DFS(idx+1, i);&#125;int main()&#123; //DFS(0,0); cout &lt;&lt; "BCACACDABA" &lt;&lt; endl; return 0;&#125; F.陆历川让你A个题题意：问n的阶乘末尾有多少个0。 思路：将n的阶乘进行质因数分解后可以发现，实际影响末尾0的个数的只有因子2和5。而n的阶乘分解质因数后2的个数必定小于等于5的个数，因此只查询有多少个5就可以了。 Mycode：123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1e6+7;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t, res, n;int main()&#123; cin &gt;&gt; t; while(t--) &#123; res = 0; cin &gt;&gt; n; while(n) &#123; n /= 5; res += n; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; G.请回答Alice和Bob请移步2017 省赛 山东 A Return of the Nim 【博弈】【Nim+Wythoff】。 H.强哥要置你于死地题意：强哥有n把枪，每个枪有3个属性，当一把枪的这三个属性都大于某一把枪的这三个属性时就称这把枪能完胜那把枪。问有这些枪分别能完胜多少把其他的枪。 思路：三位偏序裸题。 题目原型：BZOJ-3262: 陌上花开 队友补过了，目前不想补。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玲珑学院 1137 Sin your life 【数学】]]></title>
    <url>%2Fifrog-1137%2F</url>
    <content type="text"><![CDATA[题目大意：对于给定的n，求当x、y、z均为整数时$sin(x)+sin(y)+sin(z)$的最大值。结果保留到小数点后9位。 解题思路：如果枚举x、y的话是太暴力了。我们不妨把要求的式子化简一下，利用和差化积公式进行化简： $sin x + sin y = 2 \times sin(\frac{x+y}{2}) \times cos(\frac{x-y}{2})$ $sin x + sin y + sin z = 2 \times sin(\frac{x+y}{2}) \times cos(\frac{x-y}{2}) + sin(n - x - y)$ 化简后从2-n-1枚举x+y的值。 因为x+y的值固定，所以当它的值为偶数时，cos那部分的值最大为1(当x==y时)； 而当它的值为奇数时，x-y可以等于1,3,5…n-2，这时加个再判断来取cos那部分的最大值。 Mycode:123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n;double ans = -INF, tem, mac = -2;int main()&#123; scanf("%d",&amp;n); for(int i = 2; i &lt; n; ++i) &#123; if(i % 2 == 0) tem = 2.0*sin(i/2.0) + sin(n-i); else &#123; mac = max(mac, cos((i-2.0)/2.0)); tem = 2.0*sin(i/2.0)*mac + sin(n-i); &#125; if(ans &lt; tem) ans = tem; &#125; printf("%.9f\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>玲珑学院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[山东省第八届ACM大学生程序设计竞赛解题报告【2/11】]]></title>
    <url>%2Fshandong-acm-8%2F</url>
    <content type="text"><![CDATA[A. Return of the Nim 【博弈】【Nim+Wythoff】题意：Sherlock 和 Watson 做游戏，游戏规则如下： 有n堆石子，第i堆石子的个数为pi， Sherlock 先取，有两种取法， 每次每人可取任意一石堆中的任意个数 (当然所取的个数不能超过石堆中石子的个数) 在没有出现空堆的情况下，每次每人可从所有石堆中取相同个数的石子 (当然所取的个数不能超过石堆中所含最少石子的个数) 谁先取完谁赢。告诉你石堆的个数及每堆所含石子的个数，要求你输出胜利者的姓名。 数据范围：$2≤n≤30$且n为素数，$1≤p_i≤10^5$ 解题思路：由数据范围可知n所有可能的取值为2、3、5、7、11、13、17、19、23、29 ①.当n==2时，这是一道典型的wythoff博弈 ②.其余情况，我们做如下讨论： 我们想到，如果把操作2去掉，那么这就是典型的nim博弈，而nim博弈判断先后手胜负是看当前状态是否是平衡态。 1.假设现在是平衡态，即所有数字^的结果为0，也就是先手必败态；执行操作1会破坏平衡态，这时后手只要根据先手所取的石子进行操作一就可使之恢复平衡态。 同样的执行操作二时，假设取走的石子个数为k，k转化为二进制最小的那位1所在位为x，取走k石子后，这位上的所有1都变为0，0都变为1，共n位，且n为奇数，所以这位的所有值^就变为了1；这样也会破坏平衡态，后手也能根据先手所取的石子进行操作使之恢复平衡态。 2.假设现在不是平衡态，则先手可以进行操作1，使现在转换为平衡态。这样不平衡态的先手就转换为了平衡态的后手，和1一样。 以上，符合nim博弈 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int main()&#123; int t, n; int x, y; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); if(n == 2) //Wythoff &#123; scanf("%d%d",&amp;x,&amp;y); if(x &lt; y) //x is the greater one swap(x, y); if(floor((sqrt(5.0) + 1.0) / 2.0 * (x - y)) == y) puts("Watson"); else puts("Sherlock"); &#125; else //Nim &#123; x = 0; while(n--) &#123; scanf("%d",&amp;y); x ^= y; &#125; if(x == 0) puts("Watson"); else puts("Sherlock"); &#125; &#125; return 0;&#125; B. Quadrat 【打表】【规律】题目大意：求满足以下条件 ①.这个数为n位(可以有前导零) ②.取它的平方的后n位，与它本身每一位对应之差≤d(这里的差指的是数字之间的距离，而这个距离是将数字按圈排列，0与9相邻所求得的)的数字的个数。 解题思路：实在是不知道怎么做，最后选择打表看看，然后写出了以下代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int a[15][15];/*&#123; &#123;0,1,2,3,4,5,4,3,2,1&#125;; &#123;1,0,1,2,3,4,5,4,3,2&#125;; &#123;2,1,0,1,2,3,4,5,4,3&#125;; &#123;3,2,1,0,1,2,3,4,5,4&#125;; &#123;4,3,2,1,0,1,2,3,4,5&#125;; &#123;5,4,3,2,1,0,1,2,3,4&#125;; &#123;4,5,4,3,2,1,0,1,2,3&#125;; &#123;3,4,5,4,3,2,1,0,1,2&#125;; &#123;2,3,4,5,4,3,2,1,0,1&#125;; &#123;1,2,3,4,5,4,3,2,1,0&#125;;&#125;;*/LL mypow[] = &#123;1, 10, 100, 1000, 10000, 100000, 1000000, 10000000&#125;;int main()&#123; memset(a, 0, sizeof(a)); for(int i = 0; i &lt;= 9; ++i) &#123; for(int j = 0; j &lt;= 9; ++j) &#123; a[i][j] = abs(i-j); if(a[i][j] &gt; 5) a[i][j] = 10 - a[i][j]; //cout &lt;&lt; a[i][j] &lt;&lt; " "; &#125; //puts(""); &#125; for(int n = 1; n &lt;= 7; ++n) &#123; for(int eps = 0; eps &lt;= 3; ++eps) &#123; int tot = 0; for(int i = 0; i &lt; mypow[n]; ++i) &#123; //cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; int tt = i; LL tm = (i%mypow[n])*(i%mypow[n]); tm %= mypow[n]; int j; for(j = 0; j &lt; n; ++j) &#123; if(a[tm%10][tt%10] &gt; eps) break; tm /= 10; tt /= 10; &#125; if(j == n) &#123; ++tot;// cout &lt;&lt; i &lt;&lt; endl; &#125; &#125; cout &lt;&lt; tot &lt;&lt; " "; //cout &lt;&lt; "tot=" &lt;&lt; tot &lt;&lt; endl; &#125; puts(""); &#125; return 0;&#125; 运行后的结果整理后是这样的：| n\d | 0 | 1 | 2 | 3 || :–: | :–: | :–: | :—-: | :—-: || 1 | 4 | 4 | 8 | 8 || 2 | 4 | 12 | 40 | 56 || 3 | 4 | 36 | 200 | 392 || 4 | 4 | 108 | 1000 | 2744 || 5 | 4 | 324 | 5000 | 192088 || 6 | 4 | 972 | 25000 | 134456 || 7 | 4 | 2916 | 125000 | 941192 | 观察发现，对应的【第i行的第j列的值】等于【第i-1行第j列的值】 $\times$ 【$(j \times 2)-1$】然后打表就可以了，要注意精度哦。 Mycode:123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;LL ans[20][5];void init()&#123; ans[1][0] = ans[1][1] = 4; ans[1][2] = ans[1][3] = 8; for(int n = 2; n &lt;= 18; ++n) for(int d = 0; d &lt;= 3; ++d) ans[n][d] = ans[n-1][d] * (d * 2 + 1);&#125;int main()&#123; init(); int t; int n, d; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d",&amp;n,&amp;d); printf("%lld\n", ans[n][d]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDUT</tag>
        <tag>山东省赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU 1147 Pythagoras's Revenge 【技巧暴力】]]></title>
    <url>%2Fsdnu-1147%2F</url>
    <content type="text"><![CDATA[题目链接：SDNU 1147 Pythagoras’s Revenge 题目大意：给定直角三角形的一直角边，求出各边均为整数的以它为最小边的直角三角形的个数 解题思路：一、【真丶暴力】根据勾股定理可知$a^2+b^2=c^2$我们试着让b从等于a+1开始枚举可能的解，如果枚举出来的c是整数的话，让ans++，最后输出ans。 然而这样枚举的终止条件是什么呢？$10 \times a$ ？ $100 \times a $？ $1000 \times a$ ？ 我一直试到了$10000 \times a​$还是求不全。 显然这样是不行的。 二、【技巧丶暴力】对于$a^2+b^2=c^2$，我们移项可得$a^2=c^2-b^2$，再化，可得$a^2 = (c-b) \times (c+b)$。根据三角形任意两边之和大于第三边、任意两边之差小于第三边可知，令$i=c-b$, $j=c+b$，即$i$ &lt; $a$、$j$ &gt; $a$，且$j - i = 2b$。接下来枚举i就可以了。 Mycode:123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int main()&#123; LL a, b, ans; while(scanf("%lld",&amp;a) &amp;&amp; a) &#123; ans = 0; for(LL i = 1; i &lt; a; ++i) &#123; if(a * a % i == 0) &#123; LL j = a * a / i; if((j-i) % 2 == 0) &#123; b = (j-i) / 2; if(b &gt; a) ++ans; &#125; &#125; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玲珑学院 1143 计算几何你瞎暴力【计算几何】【技巧暴力】]]></title>
    <url>%2Fifrog-1143%2F</url>
    <content type="text"><![CDATA[题目大意：给出n个教室的坐标(三维)以及求任意两点间距离的方式，q次询问，对每次询问输出距离小于R的坐标对数。 解题思路： 一、【真丶暴力】先离线存取每个点坐标，然后两层循环求出所有可能组合的情况，将结果存在答案数组里，因为数组里存的是距离等于R的组合种类数，而题目要求的是距离大于等于R的组合种类数，所以需要从前往后更新一下答案数组。最后对于每次询问，直接输出结果即可。 注：因为两坐标间距离最大为30，所以当R超过30时，将其看作30就可以了。 Mycode:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 50000+5;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t, n, q, tem, ans;struct node&#123; int x, y, z;&#125;;int dis(node a, node b)&#123; return (abs(a.x-b.x) + abs(a.y-b.y) + abs(a.z - b.z));&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; int aa[35]; node a[MAX]; scanf("%d%d",&amp;n,&amp;q); for(int i = 0; i &lt; n; ++i) scanf("%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].z); for(int i = 0; i &lt; n; ++i) &#123; for(int j = i+1; j &lt; n; ++j) &#123; ++aa[dis(a[i], a[j])]; &#125; &#125; for(int i = 1; i &lt;= 30; ++i) aa[i] += aa[i-1]; while(q--) &#123; scanf("%d",&amp;tem); if(tem &gt;= 30) printf("%d\n",aa[30]); else printf("%d\n",aa[tem]); &#125; &#125; return 0;&#125; 显然，这样做会TLE，毕竟n的范围达到了5 * 1e4。再读读题，这时才意识到坐标范围为[0，10]。根据这个条件可以得到思路二。 二、【技巧丶暴力】 用三维数组记录每个点出现的次数，然后遍历每个坐标，根据其出现次数得到组合时出现的情况。 注：(1).两坐标相同时，其可能的组合种类数为 n!/n 即 n $\times$ (n-1)/2 &lt;n为坐标的个数&gt;(2).两坐标不同时，其可能的组合种类数为 n $\times$ m / 2 &lt;n,m分别为两坐标的个数&gt; Mycode:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, q, t, tem;int a, b, c, x, y, z;LL aa[35];LL dex[15][15][15];int dis(int aa, int bb, int cc, int xx, int yy, int zz)&#123; return abs(aa-xx)+abs(bb-yy)+abs(cc-zz);&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; memset(aa, 0, sizeof(aa)); memset(dex, 0, sizeof(dex)); scanf("%d%d",&amp;n,&amp;q); while(n--) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ++dex[x][y][z]; &#125; for(a = 0; a &lt;= 10; ++a) for(b = 0; b &lt;= 10; ++b) for(c = 0; c &lt;= 10; ++c) if(dex[a][b][c]) for(x = 0; x &lt;= 10; ++x) for(y = 0; y &lt;= 10; ++y) for(z = 0; z &lt;= 10; ++z) if(dex[x][y][z]) &#123; tem = dis(a, b, c, x, y, z); if(tem == 0) aa[tem] += (dex[x][y][z])*(dex[x][y][z]-1)/2; else aa[tem] += dex[x][y][z]*dex[a][b][c]; &#125; for(int i = 1; i &lt;= 30; ++i) aa[i] /= 2; for(int i = 1; i &lt;= 30; ++i) aa[i] += aa[i-1]; while(q--) &#123; scanf("%d",&amp;tem); if(tem &gt; 30) tem = 30; printf("%lld\n",aa[tem]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>玲珑学院</tag>
        <tag>计算几何</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识点】 ---寻找第n个素数]]></title>
    <url>%2Ffind-prime%2F</url>
    <content type="text"><![CDATA[如何快速找到第n个素数呢？看到这个问题后我的第一思路就是用筛法筛出素数数组。 Mycode:1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 5000005;int pri[MAX];int main()&#123; memset(pri, 0, sizeof(pri)); for(int i = 2; i &lt;= MAX; ++i) &#123; if(!pri[i]) pri[++pri[0]] = i; for(int j = 1; j &lt;= pri[0] &amp;&amp; pri[j] &lt;= MAX / i; ++j) &#123; pri[pri[j]*i] = 1; if(i % pri[j] == 0) break; &#125; &#125; int n; int cas = 0; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; printf("Case %d: %d\n",++cas,pri[n]); &#125; return 0;&#125; 这种方法在n比较小的时候还是快的，但是当n变得很大，比如当n达到3000000时，1s是跑不完的。在此基础上稍微优化一下，多交几遍说不定就卡过去了。经过优化，速度确实快了点： Code：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;using namespace std;typedef long long LL;const int MAX = 50000000;bool vis[MAX];int prim[3100005];int main()&#123; int d = sqrt(1.0*MAX); int s = 0; for(int i = 3; i &lt;= d; i += 2) if(!vis[i]) for(int j = 3*i; j &lt;= MAX; j += 2*i) vis[j] = true; int len = 0; prim[++len] = 2; for(int i = 3; i &lt;= MAX; i += 2) if(!vis[i]) prim[++len] = i; int cas = 0; int n; while(scanf("%d",&amp;n) &amp;&amp; n) printf("Case %d: %d\n",++cas, prim[n]); return 0;&#125; 但是还是达不到更快的要求。怎么办？原来有专门的一种算法，可以很快的解决此问题。原文链接。源代码链接：http://paste.ubuntu.com/24702943/ Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdtr1c++.h&gt;#define MAXN 100#define MAXM 10001#define MAXP 40000#define MAX 400000#define clr(ar) memset(ar, 0, sizeof(ar))#define read() freopen("lol.txt", "r", stdin)#define dbg(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl#define chkbit(ar, i) (((ar[(i) &gt;&gt; 6]) &amp; (1 &lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))#define setbit(ar, i) (((ar[(i) &gt;&gt; 6]) |= (1 &lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))#define isprime(x) (( (x) &amp;&amp; ((x)&amp;1) &amp;&amp; (!chkbit(ar, (x)))) || ((x) == 2))using namespace std;namespace pcf&#123;long long dp[MAXN][MAXM];unsigned int ar[(MAX &gt;&gt; 6) + 5] = &#123;0&#125;;int len = 0, primes[MAXP], counter[MAX];void Sieve()&#123; setbit(ar, 0), setbit(ar, 1); for (int i = 3; (i * i) &lt; MAX; i++, i++) &#123; if (!chkbit(ar, i)) &#123; int k = i &lt;&lt; 1; for (int j = (i * i); j &lt; MAX; j += k) setbit(ar, j); &#125; &#125; for (int i = 1; i &lt; MAX; i++) &#123; counter[i] = counter[i - 1]; if (isprime(i)) primes[len++] = i, counter[i]++; &#125;&#125;void init()&#123; Sieve(); for (int n = 0; n &lt; MAXN; n++) &#123; for (int m = 0; m &lt; MAXM; m++) &#123; if (!n) dp[n][m] = m; else dp[n][m] = dp[n - 1][m] - dp[n - 1][m / primes[n - 1]]; &#125; &#125;&#125;long long phi(long long m, int n)&#123; if (n == 0) return m; if (primes[n - 1] &gt;= m) return 1; if (m &lt; MAXM &amp;&amp; n &lt; MAXN) return dp[n][m]; return phi(m, n - 1) - phi(m / primes[n - 1], n - 1);&#125;long long Lehmer(long long m)&#123; if (m &lt; MAX) return counter[m]; long long w, res = 0; int i, a, s, c, x, y; s = sqrt(0.9 + m), y = c = cbrt(0.9 + m); a = counter[y], res = phi(m, a) + a - 1; for (i = a; primes[i] &lt;= s; i++) res = res - Lehmer(m / primes[i]) + Lehmer(primes[i]) - 1; return res;&#125;&#125;long long solve(long long n)&#123; int i, j, k, l; long long x, y, res = 0; for (i = 0; i &lt; pcf::len; i++) &#123; x = pcf::primes[i], y = n / x; if ((x * x) &gt; n) break; res += (pcf::Lehmer(y) - pcf::Lehmer(x)); &#125; for (i = 0; i &lt; pcf::len; i++) &#123; x = pcf::primes[i]; if ((x * x * x) &gt; n) break; res++; &#125; return res;&#125;int main()&#123; pcf::init(); long long n, res,L,R,M,ca=1; while (scanf("%lld", &amp;n) != EOF) &#123; if(n==0) break; L=2; R=1e8; while(L&lt;R) &#123; M=(L+R)/2; res=pcf::Lehmer(M); if(res&gt;=n) R=M; else L=M+1; &#125; printf("Case %lld: %lld\n",ca++,L); &#125; return 0;&#125; 当然还有大神用了分块筛的方法。那个pos数组是以50000为间隔的前面几个块素数个数，是用之前的代码本地跑出来的，就是说1-5W有多少个素数，1-10w有多少个素数这样子。然后每次输入n找到他在哪个区间内，再单独筛出这个区间内的素数就好了。真的很厉害Orz。源代码链接：http://paste.ubuntu.com/24702950/ Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;string.h&gt;#define MIN(a,b) (((a)&lt;(b))?(a):(b))using namespace std;int pos[1005]= &#123;-1,5133,9592,13848,17984,22044,25997,29977,33860,37706,41538,45322,49098,52831,56543,60238,63951,67617,71274,74907,78498,82134,85714,89302,92938,96469,100021,103544,107126,110630,114155,117663,121127,124634,128141,131608,135072,138542,142029,145502,148933,152382,155805,159250,162662,166081,169511,172873,176302,179684,183072,186462,189880,193256,196645,199993,203362,206789,210109,213453,216816,220136,223492,226835,230209,233577,236900,240230,243539,246909,250150,253412,256726,260064,263397,266717,269987,273322,276611,279921,283146,286490,289774,293010,296314,299583,302824,306084,309335,312666,315948,319164,322441,325706,328964,332219,335439,338694,341992,345235,348513,351715,354971,358198,361407,364685,367900,371131,374362,377574,380800,383979,387202,390378,393606,396826,399993,403204,406429,409672,412849,416040,419246,422449,425648,428816,432073,435265,438410,441562,444757,447955,451159,454337,457497,460707,463872,467055,470283,473470,476648,479864,483015,486167,489319,492494,495666,498797,501962,505147,508261,511417,514565,517740,520910,524026,527154,530334,533506,536652,539777,542898,546024,549150,552319,555479,558597,561766,564877,567967,571119,574274,577439,580566,583714,586850,590006,593112,596222,599355,602489,605556,608672,611788,614917,618057,621177,624298,627400,630495,633578,636697,639851,642962,646054,649175,652265,655355,658445,661520,664579,667709,670820,673927,676970,680063,683178,686262,689382,692486,695609,698703,701795,704895,708007,711108,714154,717257,720341,723457,726517,729577,732707,735767,738873,741941,745001,748066,751131,754189,757288,760391,763455,766554,769639,772706,775773,778818,781906,784991,788060,791111,794149,797261,800285,803358,806435,809487,812601,815674,818703,821750,824801,827884,830940,834026,837099,840169,843192,846205,849252,852291,855281,858338,861401,864446,867482,870532,873606,876616,879640,882652,885698,888762,891833,894877,897938,900996,904057,907101,910077,913098,916147,919203,922193,925237,928293,931330,934441,937446,940455,943484,946551,949506,952566,955599,958651,961694,964695,967720,970704,973739,976761,979764,982776,985807,988851,991880,994839,997817,1000862,1003926,1006966,1009985,1013012,1016026,1019012,1022057,1025092,1028089,1031130,1034115,1037119,1040144,1043113,1046152,1049172,1052140,1055139,1058173,1061198,1064162,1067185,1070198,1073198,1076221,1079266,1082255,1085243,1088266,1091314,1094330,1097360,1100328,1103258,1106267,1109288,1112328,1115323,1118354,1121389,1124405,1127407,1130388,1133364,1136320,1139344,1142298,1145305,1148316,1151367,1154307,1157275,1160273,1163205,1166251,1169267,1172264,1175214,1178218,1181158,1184128,1187148,1190171,1193122,1196133,1199102,1202080,1205065,1208078,1211050,1214027,1216988,1219966,1222953,1225900,1228861,1231859,1234873,1237894,1240833,1243787,1246718,1249710,1252693,1255682,1258685,1261660,1264617,1267631,1270607,1273599,1276577,1279531,1282513,1285456,1288409,1291373,1294356,1297270,1300243,1303229,1306226,1309152,1312179,1315161,1318125,1321065,1324046,1326975,1329943,1332935,1335881,1338865,1341795,1344716,1347749,1350691,1353661,1356600,1359631,1362538,1365511,1368447,1371432,1374421,1377385,1380343,1383291,1386325,1389261,1392272,1395148,1398094,1401007,1403922,1406874,1409821,1412758,1415679,1418640,1421620,1424606,1427535,1430531,1433481,1436398,1439367,1442335,1445279,1448221,1451219,1454144,1457067,1460019,1462950,1465935,1468883,1471822,1474757,1477731,1480683,1483609,1486531,1489509,1492408,1495350,1498253,1501220,1504189,1507122,1510064,1512992,1515935,1518898,1521859,1524831,1527768,1530729,1533657,1536569,1539541,1542459,1545372,1548366,1551302,1554245,1557132,1560093,1562976,1565927,1568845,1571812,1574749,1577649,1580509,1583439,1586387,1589324,1592219,1595177,1598118,1601049,1603985,1606876,1609825,1612775,1615749,1618668,1621590,1624527,1627444,1630379,1633312,1636202,1639094,1642052,1644964,1647911,1650840,1653807,1656761,1659690,1662600,1665517,1668413,1671330,1674240,1677200,1680120,1683065,1685964,1688960,1691876,1694762,1697663,1700558,1703469,1706405,1709342,1712204,1715158,1718134,1721034,1723913,1726899,1729764,1732641,1735590,1738531,1741430,1744400,1747297,1750204,1753058,1756025,1758964,1761886,1764767,1767691,1770613,1773526,1776430,1779363,1782260,1785173,1788065,1790930,1793863,1796762,1799676,1802593,1805472,1808374,1811272,1814112,1817102,1820026,1822944,1825792,1828703,1831616,1834530,1837416,1840359,1843275,1846115,1849029,1852006,1854941,1857859,1860788,1863719,1866645,1869536,1872441,1875367,1878295,1881199,1884021,1886923,1889855,1892785,1895702,1898632,1901520,1904396,1907306,1910248,1913136,1915979,1918857,1921714,1924643,1927488,1930397,1933290,1936209,1939089,1941982,1944833,1947684,1950638,1953525,1956440,1959308,1962184,1965111,1968015,1970912,1973815,1976668,1979564,1982509,1985372,1988254,1991162,1994051,1996958,1999823,2002749,2005638,2008561,2011422,2014337,2017231,2020103,2022944,2025864,2028764,2031667,2034522,2037385,2040293,2043192,2046087,2048989,2051891,2054802,2057701,2060577,2063430,2066324,2069193,2072084,2074966,2077862,2080771,2083678,2086529,2089379,2092244,2095092,2097961,2100791,2103648,2106544,2109362,2112215,2115089,2118001,2120897,2123788,2126637,2129473,2132329,2135232,2138061,2141013,2143883,2146775,2149635,2152470,2155359,2158233,2161146,2163998,2166906,2169775,2172667,2175518,2178423,2181266,2184161,2187043,2189920,2192806,2195671,2198505,2201356,2204262,2207150,2210026,2212915,2215731,2218609,2221543,2224435,2227279,2230137,2233036,2235899,2238778,2241626,2244473,2247300,2250226,2253061,2255897,2258731,2261623,2264514,2267395,2270349,2273189,2276042,2278857,2281732,2284633,2287447,2290350,2293262,2296101,2298985,2301840,2304721,2307562,2310419,2313254,2316107,2318966,2321832,2324728,2327619,2330509,2333367,2336299,2339147,2342005,2344890,2347727,2350582,2353448,2356279,2359142,2362051,2364953,2367814,2370696,2373590,2376402,2379261,2382120,2384990,2387828,2390737,2393630,2396534,2399359,2402242,2405101,2407984,2410827,2413749,2416624,2419434,2422305,2425151,2427981,2430806,2433654,2436487,2439371,2442235,2445078,2447902,2450819,2453695,2456577,2459382,2462273,2465109,2467902,2470746,2473603,2476509,2479409,2482267,2485075,2487886,2490756,2493597,2496476,2499337,2502205,2505030,2507850,2510721,2513534,2516394,2519246,2522092,2524898,2527696,2530575,2533422,2536286,2539186,2542018,2544808,2547620,2550462,2553305,2556175,2559020,2561921,2564807,2567637,2570490,2573319,2576200,2579019,2581841,2584684,2587550,2590386,2593245,2596089,2598870,2601721,2604535,2607331,2610226,2613067,2615907,2618758,2621566,2624440,2627281,2630152,2632997,2635866,2638710,2641508,2644301,2647127,2649982,2652825,2655643,2658487,2661384,2664228,2667036,2669841,2672702,2675523,2678429,2681216,2684053,2686906,2689717,2692570,2695450,2698298,2701159,2703995,2706858,2709644,2712494,2715332,2718160,2721011,2723886,2726718,2729508,2732389,2735255,2738140,2740985,2743838,2746679,2749526,2752380,2755215,2758056,2760896,2763691,2766522,2769407,2772249,2775053,2777902,2780731,2783526,2786355,2789189,2791974,2794837,2797652,2800483,2803324,2806163,2808976,2811853,2814698,2817518,2820355,2823178,2826040,2828852,2831693,2834491,2837271,2840147,2842995,2845792,2848642,2851461,2854302,2857087,2859963,2862777,2865596,2868399,2871207,2874012,2876824,2879677,2882545,2885338,2888144,2890939,2893763,2896598,2899408,2902191,2905025,2907902,2910714,2913488,2916338,2919190,2921977,2924773,2927626,2930404,2933208,2936067,2938896,2941732,2944531,2947349,2950188,2952990,2955834,2958685,2961491,2964316,2967186,2970001,2972862,2975681,2978556,2981364,2984185,2987006,2989825,2992648,2995509,2998299&#125;;bool prime[60000],seive[60000];void seg_seive(int L,int R) //区间筛法&#123; int len=R-L+1; for(int i=0; i&lt;len; i++) prime[i]=1; if(1-L&gt;=0) prime[1-L]=0; //易错因为1不是素数也不是合数，这也是区间筛的一个易错bug for(int i=2; i*i&lt;=R ; i++) &#123; if(seive[i]) &#123; for(int j=max(2,(L-1+i)/i)*i; j&lt;=R; j+=i) //第二个易错点，j必须从大于1，因为L可能小于i，但是seive[i]是素数。 prime[j-L]=false; &#125; &#125;&#125;int main()&#123; for(int i=2; i&lt;50001; i++) seive[i]=1; for(int i=2; i*i&lt;50001; i++) //预处理 if(seive[i]) for(int j=2*i; j&lt;50001; j+=i) seive[j]=false; int n,rl=1; while(~scanf("%d",&amp;n)) &#123; if(n==0)break; int l=0,r=1000; while(l+1&lt;r) &#123; int mid=(l+r)/2; if(pos[mid]&lt;n) l=mid; else r=mid; &#125; int left=l*50000,right=r*50000; int x=n-pos[l]; seg_seive(left,right); //printf("%d %d %d\n",left,right,x); for(int i=left; i&lt;=right; i++) &#123; if(prime[i-left]==1) &#123; x--; if(x==0) &#123; printf("Case %d: %d\n",rl++,i); break; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51Nod 1130 N的阶乘的长度 V2(斯特林近似) 【数学】【斯特林公式】]]></title>
    <url>%2F51nod-1130%2F</url>
    <content type="text"><![CDATA[在进入正试讲解之前我们先来看一道简单点的题目压压惊。 题目链接：51nod 1058 Description：输入N求N的阶乘的10进制表示的长度。例如$6! = 720$，长度为3。 Input输入N($1$ &lt;= $N$ &lt;= $10^6$) Output输出N的阶乘的长度 Input示例6 Output示例3 题目大意：很明确，就是求n！的长度 解题思路：我们知道，对于任意的数n，$len = log10(X) + 1$就是X这个数的长度。当N的值不超过10^6时，直接求的话N的阶乘长度$len = log10(1 \times 2 \times 3 \times 4 \times \ldots \times N) + 1$ $= log10(1) + log10(2) + log10(3) + log10(4) + …… + log10(N) + 1 $。这样实现看起来有点笨拙，不过是可以AC的。 Mycode: 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1005;int main()&#123; int n; cin &gt;&gt; n; double ans = 1; for(int i = 1; i &lt;= n; ++i) &#123; ans += (log10(i)); &#125; cout &lt;&lt; (int)ans &lt;&lt; endl; return 0;&#125; 而对于下面这道题目来说，因为数据范围变大了很多，所以需要考虑用更优的解法了。 题目链接：51nod 1130 Description：输入N求N的阶乘的10进制表示的长度。例如$6! = 720​$，长度为3。 Input第1行：一个数T，表示后面用作输入测试的数的数量。（$1 &lt;= T &lt;= 1000$)第2 - T + 1行：每行1个数N。（$1 &lt;= N &lt;= 10^9$) Output共T行，输出对应的阶乘的长度。 Input示例3456 Output示例233 题目大意：和上道题一样，就是求$n!$的长度，不过数据范围大了很多。 解题思路：有个叫作斯特林公式的神奇公式(可参考百度百科：斯特林公式)，可以利用它进行求解。注意，当$n=1$的时候，上面的公式不适用，所以要单独处理n=1的情况。 这种方法速度很快就可以得到结果。用它来求n!的位数就很easy了。 Mycode: 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1005;const double PI = acos(-1.0);const double EXP = 2.718281828459;int main()&#123; int T; long long n, ans; scanf("%d",&amp;T); while(T--) &#123; scanf("%lld",&amp;n); if(n == 1) &#123; puts("1"); continue; &#125; ans = 0.5*log10(2*PI*n) + n*log10(n*1.0/EXP) + 1; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>51Nod</tag>
        <tag>数学</tag>
        <tag>斯特林公式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EOJ 3256 拼音魔法 【模拟】]]></title>
    <url>%2Feoj-3256%2F</url>
    <content type="text"><![CDATA[Description：魔法学校小学一年级有一种题。就是给一个字的拼音，给一个声调，让你正确地注音。但魔法老师给了巨量的题，你不用魔法根本不可能做完。所以现在要让你发明一种魔法完成这个任务。问题已经讲完了，下面开始教授汉语。（会汉语或者自认为会汉语的可以自动跳过）汉语中一个字的拼音由声母和韵母两部分组成，在极少数情况下也会没有声母，但一定有韵母。一般认为，声母有 b, p, m, f, d, t, l, n, g, k, h, j, q, x, z, c, s, zh, ch, sh, r, y, w；韵母有：a, e, o, i, u, ü, ai, ei, ui, ao, ou, iu, ie, üe, er, an, en, in, un, ün, ang, eng, ing, ong。不是所有的字母都能组合的，组合的时候有时会发生一些神奇的事情，例如 üe 变成了 ue。但是标调规则有如下口诀：有 a 先找 a，没 a 找 o e，i u 并排标在后，这样标调不会错。只有下面列出的元素可能会被标调。请按照下表输出（尤其注意 a 不要输出成 ɑ 了）：第一声：ā ē ī ō ū ǖ。第二声：á é í ó ú ǘ。第三声：ǎ ě ǐ ǒ ǔ ǚ。第四声：à è ì ò ù ǜ。轻声：a e i o u ü。辅助材料：由教育部公布的拼音方案。如果有描述不一致的地方，请以本题描述为准。 Input第一行一个整数T(1≤T≤10^5)。下面T行，每行一个拼音：拼音声调在各个拼音之后，用数字 [1-4] 进行表示。例如 zhong1 guo2。没有数字的说明是轻声，不用标调。按照国际惯例，输入文件全部由 ASCII 编码组成。ü 用 v 来代替。但在输出中，应仍然用 ü 来表示。 Output对于每一组数据，输出 Case x: y。其中 x 是从 1 开始的测试数据编号，y 是一个拼音标调后的答案。注意：对于非 ASCII 字符的输出，请使用 UTF-8 编码。 ExamplesInput5zhong1guo2meque1nv3 OutputCase 1: zhōngCase 2: guóCase 3: meCase 4: quēCase 5: nǚ Note会 C/C++ 的魔法师最可爱了。 Source2017 华东师范大学网赛 题目大意：给你T个拼音以及此拼音的声调，让你对其进行音标的标注。 解题思路：就是按照其要求对将要标记声调的字符进行替换就好了。但是替换的字符有的非ASCII 编码，所以用一个char字符是存不下的，这里我用的string来实现相应的存储。还有几个小细节要注意一下，比如v换为ü，标声调时i u 并排标在后等。 Mycode:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1005;int main()&#123; string ty[5][6] = &#123; &#123;"a","o","e","i","u","ü"&#125;, &#123;"ā","ō","ē","ī","ū","ǖ"&#125;, &#123;"á","ó","é","í","ú","ǘ"&#125;, &#123;"ǎ","ǒ","ě","ǐ","ǔ","ǚ"&#125;, &#123;"à","ò","è","ì","ù","ǜ"&#125; &#125;; int T; int pos, neww, sd; string s; scanf("%d",&amp;T); for(int cas = 1; cas &lt;= T; ++cas) &#123; cin &gt;&gt; s; int len = s.length(); //判断声调 if(s[len-1] == '1') sd = 1; else if(s[len-1] == '2') sd = 2; else if(s[len-1] == '3') sd = 3; else if(s[len-1] == '4') sd = 4; else &#123;sd = 0;len++;&#125; len--; //找应该被标记声调的字母 neww = pos = -1; for(int i = 0; i &lt; len; ++i) &#123; if(s[i] == 'a') &#123; pos = i; neww = 0; break; &#125; else if(s[i] == 'o') &#123; pos = i; neww = 1; &#125; else if(s[i] == 'e' &amp;&amp; ((neww == -1) || (neww &gt;= 2))) &#123; pos = i; neww = 2; &#125; else if(s[i] == 'i' &amp;&amp; ((neww == -1) || (neww &gt;= 3))) &#123; pos = i; neww = 3; &#125; else if(s[i] == 'u' &amp;&amp; ((neww == -1) || (neww &gt;= 3))) &#123; pos = i; neww = 4; &#125; else if(s[i] == 'v' &amp;&amp; ((neww == -1) || (neww &gt;= 5))) &#123; pos = i; neww = 5; &#125; &#125; //开始输出 printf("Case %d: ",cas); for(int i = 0; i &lt; len; ++i) &#123; if(pos == i) &#123; cout &lt;&lt; ty[sd][neww]; &#125; else if(s[i] == 'v') &#123; cout &lt;&lt; "ü"; &#125; else &#123; cout &lt;&lt; s[i]; &#125; &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>EOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5937 Game of Taking Stones 【威佐夫博弈+大数+高精度】]]></title>
    <url>%2Fhdu-5937%2F</url>
    <content type="text"><![CDATA[Problem DescriptionTwo people face two piles of stones and make a game. They take turns to take stones. As game rules, there are two different methods of taking stones: One scheme is that you can take any number of stones in any one pile while the alternative is to take the same amount of stones at the same time in two piles. In the end, the first person taking all the stones is winner.Now,giving the initial number of two stones, can you win this game if you are the first to take stones and both sides have taken the best strategy? InputInput contains multiple sets of test data.Each test data occupies one line,containing two non-negative integers a andb,representing the number of two stones.a and b are not more than $10^{100}$. OutputFor each test data,output answer on one line.1 means you are the winner,otherwise output 0. Sample Input2 1 8 4 4 7 Sample Output0 1 0 Source2016ACM/ICPC亚洲区大连站-重现赛（感谢大连海事大学） 题意：全裸的威佐夫博弈，但是输入的两个数长度长达100位 思路：对于该题，数据范围是10的100次方，还有小数乘法 —-&gt; 黄金分割率需要精确到小数点后100位 —-&gt; 通过二分求解。 威佐夫博弈：a为a、b中较小的数，先手是否会赢 —–&gt; $ \frac{\sqrt5+1}{2} \times (b - a) $ == a ？ lose : win AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.math.BigInteger;import java.math.BigDecimal;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); BigDecimal TWO = BigDecimal.valueOf(2); BigDecimal FIVE = BigDecimal.valueOf(5); BigDecimal EPS = new BigDecimal("-0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"); BigDecimal L = new BigDecimal("2.2360679774997"); BigDecimal R = new BigDecimal("2.2360679774998"); BigDecimal mid = null; while(L.subtract(R).compareTo(EPS) &lt; 0) &#123; mid = L.add(R).divide(TWO); if(mid.multiply(mid).subtract(FIVE).abs().compareTo(EPS.abs()) &lt; 0) break; if(mid.multiply(mid).subtract(FIVE).compareTo(EPS) &lt; 0) L = mid; else R = mid; &#125; BigDecimal GOLD = mid.add(BigDecimal.ONE).divide(TWO); //System.out.println(GOLD); while(scanner.hasNext()) &#123; BigDecimal a = scanner.nextBigDecimal(); BigDecimal b = scanner.nextBigDecimal(); if(a.compareTo(b) &gt; 0) //保证a是小的 &#123; BigDecimal t = a; a = b; b = t; &#125; BigDecimal c = b.subtract(a).multiply(GOLD); BigInteger aa = a.toBigInteger(); BigInteger cc = c.toBigInteger(); if(aa.equals(cc)) System.out.println("0"); else System.out.println("1"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>ICPC</tag>
        <tag>大数</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017_SDNU_ACM-ICPC_Provincial_Team_Selection_Round_2【--完结--】]]></title>
    <url>%2Fsdnu-2017-4%2F</url>
    <content type="text"><![CDATA[山东省第八届acm大学程序设计竞赛山师选拔赛第二场(声明：标题是自己取的，如果有语法错误的话与他人无关) —————————————————————–分割线—————————————————————– Problem_A(最近公共祖先)题意：SDNU的ACM集训队陷入了混乱中，如果你加入，你要成为一个人的小跟班，我们把你跟着的那个人称为“dalao”(/doge)。例如有两个菜鸟C和D加入了，他们的dalao是A，我们就称A是C和D的最近公共dalao。再比如C是E和F的dalao，那么E和C的最近公共dalao就是A。一共n个人，给你n-1组关系，问输入的两个人的最近公共dalao是谁，有的话输出他的名字，没有输出“I am so bad.”(注意一下Hint里的提示：A也是A的daolao 思路：一开始考虑用map来记录这个点的根节点，关系记录完后，不断向上查询，直至找到它的祖先，然后必然的TLE。其实这个题就是个经过封装的求LCA的题目，套上模板就能A了(主要目的应该是让我们学一下LCA吧。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 10010;const int DEG = 20;struct Edge&#123; int to,next;&#125; edge[MAXN*2];int head[MAXN],tot;void addedge(int u,int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;int fa[MAXN][DEG];//fa[i][j]表示结点i的第2^j个祖先int deg[MAXN];//深度数组void BFS(int root)&#123; queue&lt;int&gt;que; deg[root] = 0; fa[root][0] = root; que.push(root); while(!que.empty()) &#123; int tmp = que.front(); que.pop(); for(int i = 1; i &lt; DEG; i++) fa[tmp][i] = fa[fa[tmp][i-1]][i-1]; for(int i = head[tmp]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(v == fa[tmp][0])continue; deg[v] = deg[tmp] + 1; fa[v][0] = tmp; que.push(v); &#125; &#125;&#125;int LCA(int u,int v)&#123; if(deg[u] &gt; deg[v])swap(u,v); int hu = deg[u], hv = deg[v]; int tu = u, tv = v; for(int det = hv-hu, i = 0; det ; det&gt;&gt;=1, i++) if(det&amp;1) tv = fa[tv][i]; if(tu == tv)return tu; for(int i = DEG-1; i &gt;= 0; i--) &#123; if(fa[tu][i] == fa[tv][i]) continue; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;bool flag[MAXN];int main()&#123; int T; int n; int u,v; while(~scanf("%d",&amp;n)) &#123; init(); memset(fa,0,sizeof(fa)); memset(deg,0,sizeof(deg)); memset(flag,false,sizeof(flag)); for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d",&amp;u,&amp;v); addedge(u,v); addedge(v,u); flag[v] = true; &#125; int root; for(int i = 1; i &lt;= n; i++) if(!flag[i]) &#123; root = i; break; &#125; BFS(root); scanf("%d%d",&amp;u,&amp;v); if(LCA(u,v)) printf("%d\n",LCA(u,v)); else puts("I am so bad."); &#125; return 0;&#125; Problem_B(矩阵快速幂)题意：对任意的$(1+\sqrt2) ^ n$我们是否能找到对应的m使得上式化简为$\sqrt{m} + \sqrt{m-1}$，如果有，请输出$m \mod (1e9+7)$的值，没有输出”I want to talk a joke.” 思路：先写几个数字看看什么情况。化简后会看出(整数部分)系数为1、3、7、17……带有$\sqrt{2}$的部分的系数为1、2、5、12……后者数值等于它上一个数的这两部分的系数之和(2=1+1,5=3+2,12=7+5……)，前者的数值等于和他一个数的$\sqrt{2}$的部分的系数+它上一个数的$\sqrt{2}$的部分的系数(3=2+1,7=5+2,17=12+5……)。根据这个规律构造一个四阶矩阵，然后套上模板就可以了。注意每次乘完都要%MOD一下，防止溢出。 关于输出：如果n是奇数的话，就输出(整数部分)系数的^2，否则输出它的^2+1(自己推一推便知道了。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 10010;const int MOD = 1e9 + 7;const int ch = 4;struct matrix&#123; long long mat[ch][ch];&#125;;matrix multiply(matrix a, matrix b) //构造矩阵乘法&#123; int i, j, k; matrix t; memset(t.mat, 0, sizeof(t. mat)); for(i = 0; i &lt; ch; ++i) for(j = 0; j &lt; ch; ++j) for(k = 0; k &lt; ch; ++k) t.mat[i][j] = (t.mat[i][j] + a.mat[i][k]*b.mat[k][j]%MOD) % MOD; return t;&#125;long long fibonacci(long long n)&#123; long long tem = n; n--; matrix base, ans; memset(base.mat, 0, sizeof(base.mat)); memset(ans.mat, 0, sizeof(ans.mat)); base.mat[2][0] = base.mat[2][2] = base.mat[3][1] = base.mat[3][2] = base.mat[3][3] = 1; base.mat[2][3] = 2; ans.mat[0][1] = ans.mat[0][0] = 1; ans.mat[0][2] = 2; ans.mat[0][3] = 3; while(n) &#123; if(n &amp; 1) ans = multiply(ans, base); base = multiply(base, base); n &gt;&gt;= 1; &#125; //cout &lt;&lt; tem &lt;&lt; endl; if(!(tem&amp;1)) return ans.mat[0][1]*ans.mat[0][1]%MOD; return (ans.mat[0][1]*ans.mat[0][1]+1)%MOD;&#125;int main()&#123; long long n; while(cin &gt;&gt; n) cout &lt;&lt; fibonacci(n) &lt;&lt; endl; return 0;&#125; Problem_C(签到题)题意：给定1-n个城市，你处在x位置，求出满足|x-i|&lt;=r的正整数i的可能取到的数。 思路：因为给定了n的范围，所以一共会有4种情况，即左越界，左不越界，右越界，右不越界。4个if，轻松搞定。(我这个人比较懒，用一个for遍历了一遍，符合条件就让ans++，否则不作操作。比较而言当然是前者时间复杂度更低了，比赛时当然是要选择最优解法。 AC代码：1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; double n, r, x; //用int就行 scanf("%d",&amp;t); while(t--) &#123; int ans = 0; scanf("%lf%lf%lf",&amp;n,&amp;r,&amp;x); for(int i = 1; i &lt;= n; ++i) &#123; if(fabs(x-i) &lt;= r) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem_D(线段树单点更新求和+期望公式)题意：在一个长度为n的数组里，分别执行两种操作，1是把位置为x的元素改为y;2是求出区间l到r的方差。 思路：线段树的单点更新及求和，直接套模板就可以。 期望公式：D(x) = E(x^2) - E(x)^2。而求区间的方差此公式经过化简可得，D(x) = num $\times$ sum2 - sum $\times$ sum，其中num是区间的元素总个数，sum2是区间内每个元素的平方求和，sum是区间内的每个元素的和。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1&lt;&lt;16;struct node&#123; int l, r; long long sum, sum2;&#125; tree[MAX&lt;&lt;2];long long a[MAX];long long sum, sum2;void pushup(int rt)&#123; tree[rt].sum = tree[rt&lt;&lt;1].sum + tree[rt&lt;&lt;1|1].sum; tree[rt].sum2 = tree[rt&lt;&lt;1].sum2 + tree[rt&lt;&lt;1|1].sum2;&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; tree[rt].sum = 0; if(l == r) &#123; tree[rt].sum = a[l]; tree[rt].sum2 = a[l]*a[l]; return ; &#125; int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; //递归建树 build(l, mid, rt&lt;&lt;1); build(mid+1, r, rt&lt;&lt;1|1); pushup(rt);&#125;void update(int x, int y, int rt)&#123; //更新这个区间的值 if(tree[rt].l == tree[rt].r) &#123; tree[rt].sum = y; tree[rt].sum2 = y*y; return ; &#125; int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(x &lt;= mid) update(x, y, rt&lt;&lt;1); else update(x, y, rt&lt;&lt;1|1); pushup(rt);&#125;void query(int x, int y, int rt)&#123; if(tree[rt].l == x &amp;&amp; tree[rt].r == y) &#123; sum += tree[rt].sum; sum2 += tree[rt].sum2; return ; &#125; int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(y &lt;= mid) query(x, y, rt&lt;&lt;1); else if(x &gt; mid) query(x, y, rt&lt;&lt;1|1); else &#123; query(x, mid, rt&lt;&lt;1); query(mid+1, y, rt&lt;&lt;1|1); &#125;&#125;int main()&#123; int n, m; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= n; ++i) scanf("%lld",&amp;a[i]); build(1, n, 1); while(m--) &#123; int q; scanf("%d",&amp;q); if(q == 1) &#123; int pos, num; scanf("%d%d",&amp;pos,&amp;num); update(pos, num, 1); &#125; else &#123; int l, r; sum = sum2 = 0; scanf("%d%d",&amp;l,&amp;r); query(l, r, 1); long long ans = (r-l+1)*sum2 - sum*sum; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; Problem_E(最短路)题意：告诉你一系列的公交线路，问能否从1号站到m号站，如果能，输出最少的换乘次数，不能输出-1。 思路：建图。把任一公交线路中任意两点能到达的位置距离设置为1，这样条件都结束后不能到达的位置距离就是INF。然后转化为最短路问题解决就行了。 对输入的处理：每行结束的标志是’\n’，可以用gets读入一行后把数字当作字符挨个处理；其他人也有用scanf(“%d%c”,&amp;d,&amp;ch)这样读入的，当ch==’\n’时break;也可以像我一样用stringstream。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 510;int n;int adj[MAX][MAX];int a[MAX], dis[MAX];bool vis[MAX];void init()&#123; for(int i = 1; i &lt;= 500; ++i) &#123; for(int j = 1; j &lt;= 500; ++j) &#123; if(i == j) adj[i][j] = 0; else adj[i][j] = INF; &#125; &#125;&#125;void Dij()&#123; int tem, minx; memset(vis, false, sizeof(vis)); for(int i = 0; i &lt;= n; ++i) dis[i] = adj[1][i]; dis[1] = 0; vis[1] = true; for(int i = 1; i &lt; n; ++i) &#123; minx = INF; for(int j = 1; j &lt;= n; ++j) &#123; if(!vis[j] &amp;&amp; dis[j] &lt; minx) &#123; minx = dis[j]; tem = j; &#125; &#125; if(minx == INF) break; vis[tem] = 1; for(int j = 1; j &lt;= n; ++j) &#123; if(!vis[j] &amp;&amp; adj[tem][j] != INF &amp;&amp; dis[tem] + adj[tem][j] &lt;dis[j]) &#123; dis[j] = adj[tem][j] + dis[tem]; &#125; &#125; &#125;&#125;int main()&#123; int t; int item; string stem, s; while(~scanf("%d",&amp;t)) &#123; init(); scanf("%d",&amp;n); getchar(); while(t--) &#123; int cou = 0; getline(cin, stem); stringstream ss (stem); while(ss &gt;&gt; item) &#123; a[cou++] = item; &#125; for(int i = 0; i &lt; cou-1; ++i) for(int j = i+1; j &lt; cou; ++j) &#123; adj[a[i]][a[j]] = 1; &#125; &#125; Dij(); if(dis[n] == INF) cout &lt;&lt; "-1" &lt;&lt; endl; else cout &lt;&lt; dis[n]-1 &lt;&lt; endl; &#125; return 0;&#125; Problem_F(思维)题意：一群美女排成一排，各有各的颜值。现在GOD超要从中选取一些连续排列的美女，要求他们的颜值满足先增大后减小。如果有，依次输出起点美女和重点美女的坐标；多组的话输出长度最长的那组的两个下标；没有符合题意的输出-1 -1。 思路：之前做过一个合唱队列的题目(要求求出最长先严格上升后严格下降的子序列的长度，我从头到尾求了每个点作为终点的最长上升子序列的长度，从尾往前求出了每个点作为终点的最长上升子序列的长度，然后遍历一遍求出最大的两者之和-1的值)，开始以为是类似的，觉得有点麻烦，就略过了(而队友一直在调E，以至于到了最后也没做)。赛后看了看发现一个for循环就能解决。具体做法是从前往后遍历，让起点定位在第一个位置，开始下降后把终点定位。碰到再上升，就把之前的符合条件的与当前已有的答案比较，保留最优解。重复此过程直至遍历结束。详见代码。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 5e6 + 5;int a[N];int main()&#123; int n; bool flag; int ans1, ans2, tem1, tem2; while(~scanf("%d",&amp;n)) &#123; flag = true; ans1 = ans2 = -1; tem1 = 0; tem2 = -1; for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); for(int i = 1; i &lt; n; ++i) &#123; if(a[i-1] == a[i]) &#123; if(tem2 - tem1 &gt; ans2 - ans1)//更新答案 &#123; ans2 = tem2; ans1 = tem1; &#125; tem1 = tem2 = -1; continue; &#125; if(a[i-1] &lt; a[i]) //上升 &#123; if(!flag) &#123; if(tem2 - tem1 &gt; ans2 - ans1)//更新答案 &#123; ans2 = tem2; ans1 = tem1; &#125; flag = 1; tem1 = tem2 = -1; &#125; if(tem1 == -1) tem1 = i-1; //cout &lt;&lt; i &lt;&lt; "--" &lt;&lt; tem1 &lt;&lt; endl; &#125; else &#123; flag = 0; if(tem1 != -1) tem2 = i; &#125; if(tem2 - tem1 &gt; ans2 - ans1)//更新答案 &#123; ans2 = tem2; ans1 = tem1; &#125; &#125; if(ans1 != -1 &amp;&amp; ans2 != -1) cout &lt;&lt; ans1 &lt;&lt; " " &lt;&lt; ans2 &lt;&lt; endl; else cout &lt;&lt; "-1 -1" &lt;&lt; endl; &#125; return 0;&#125; Problem_G(并查集)题意：在一块1000$\times$1000的土地上施工，每周选择一块土地使这块土地由海洋变为陆地。问经过n周后，一共有多少块岛屿(上下左右相连接的属于一块)，岛屿面积是多少以及岛屿的周长。 思路：施工n次，假设每次开辟的新岛屿周围都没有与之相连接的岛屿，所以岛屿个数+1，面积+1，周长+4。然后再判断它周围是否有可以与之相连的岛屿，上下左右四个方向逐个判断，再将相连接的个数相减就好了。具体减的方法很简单，此处不再赘述，如有疑问，欢迎私戳。 并查集：用来快速判断两者是否属于同一个集合的工具，因为所给的数据范围不是很大，所以可以用f[x$\times$MAX+y]来表示点(x,y)所属的集合，这里转化完后就与普通的并查集没啥区别了。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int MAX = 1000;int tot, area, peri, cou;int f[MAX*MAX+5]; //记录是否联通char mapa[MAX+5][MAX+5]; //存图int dir[][2] = &#123;0,1,0,-1,1,0,-1,0&#125;;void init()&#123; for(int i = 0; i &lt;= MAX*MAX; ++i) &#123; f[i] = i; &#125;&#125;int getf(int v)&#123; if(f[v] != v) f[v] = getf(f[v]); return f[v];&#125;int merg(int u, int v)&#123; int t1 = getf(u); int t2 = getf(v); /*cout &lt;&lt; u &lt;&lt; "--" &lt;&lt; v &lt;&lt; endl; cout &lt;&lt; t1 &lt;&lt; "----" &lt;&lt; t2 &lt;&lt; endl &lt;&lt; endl;*/ if(t1 != t2) &#123; f[t2] = t1; return 1; //与周围的岛屿之前不连通 &#125; return 0;&#125;void solve(int x, int y)&#123; int xx, yy; for(int i = 0; i &lt; 4; ++i) &#123; xx = x + dir[i][0]; yy = y + dir[i][1]; if(xx &lt; 0 || xx &gt;= MAX || yy &lt; 0 || yy &gt; MAX) continue; if(mapa[xx][yy] != '#') continue; //cout &lt;&lt; xx &lt;&lt; "---" &lt;&lt; yy &lt;&lt; endl; if(merg(x*MAX+y, xx*MAX+yy)) //联通成功，总岛屿数-1 &#123; tot--; &#125; peri -= 2; //周围有一个岛屿的话，周长-2 &#125;&#125;int main()&#123; int t; int x, y; while(~scanf("%d",&amp;t)) &#123; init(); tot = area = peri = 0; memset(mapa, 0, sizeof(mapa)); while(t--) &#123; scanf("%d%d",&amp;x,&amp;y); if(mapa[x][y] == '#') &#123; cout &lt;&lt; tot &lt;&lt; " " &lt;&lt; area &lt;&lt; " " &lt;&lt; peri &lt;&lt; endl; continue; &#125; //先假设新加入的岛屿与其他都不连通 tot++; area++; peri += 4; mapa[x][y] = '#'; //开始做减法 solve(x, y); cout &lt;&lt; tot &lt;&lt; " " &lt;&lt; area &lt;&lt; " " &lt;&lt; peri &lt;&lt; endl; &#125; &#125; return 0;&#125; Problem_H(博弈+大数)题意：理解后可以改为两个人取石子，规则是每次可以取1-4个，谁先取到最后一块谁就能赢，A先取。 思路：很显然，当n∈[1,4]时，A必赢；n=5时，A必输。因为两人都采取最优策略，所以当n∈[6,9]时，A可以取到使石子数目剩余为5，这样他就必赢，而当n=10时，B就必赢了……总结一下得出结论，所给的石子总数为5的倍数时，B必赢，否则A必赢。另外，数据有点大，考虑到了用JAVA。不过鉴于这个数据的特殊性，是5的倍数，用C++的话只要判断最后一位数是否是5或0就好了，想到了会更加轻松。(这里C++的就不贴了 AC代码(JAVA)：12345678910111213141516171819202122import java.math.BigInteger;import java.math.BigDecimal;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T; BigInteger n; BigInteger MOD = new BigInteger("5"); T = scanner.nextInt(); while((T--) &gt; 0) &#123; n = scanner.nextBigInteger(); if(n.mod(MOD).compareTo(BigInteger.ZERO) == 0) System.out.println("chaochao"); else System.out.println("huahua"); &#125; &#125;&#125; Problem_I(素数打表)题意：给你一个偶数x，让你判断这个偶数能否用两个素数(a、b)之差表示出来(a-b=x)，能的话根据b的大小输出最小的一组，不能的话输出FAIL 思路：任一大于2的偶数都可写成两个质数之和(哥德巴赫猜想)，这道题自己想一下就会知道不会出现FAIL的情况。因为数据比较大，所以打两个表：第一个vis判断是否是素数，第二个a记录可能用到的素数。然后对于给定的x，依次将a[i]从第一个往后遍历，如果x+a[i]是素数那就输出他们，结束遍历。(这里不得不单独吐槽一下出题人→_→，题面的数据范围给小了，比赛时改了数据。赛后改了题面，做了这两天，让我WA到怀疑人生。看别人过了，更忍不了了，下载测试数据对拍后才发现，出题人标程没改，那个A了的是错的。难受。。后来那个lazy的出题人把数据范围缩小了╮(╯_╰)╭rejudge后轻松AC) AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1500005;int a[MAX], tot;bool vis[MAX];void init()//筛法求a数组&#123; memset(vis, false, sizeof(vis)); //vis[0] = vis[1] = true; tot = 0; int M = sqrt(MAX+0.5); for(int i = 2; i &lt;= M; ++i) &#123; if(!vis[i]) &#123; a[tot++] = i; for(int j = i*i; j &lt;= MAX; j += i) &#123; vis[j] = true; &#125; &#125; &#125;&#125;int main()&#123; init(); int t, n; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); for(int i = 0; i &lt; tot; ++i) &#123; if(!vis[n+a[i]]) &#123; cout &lt;&lt; n+a[i] &lt;&lt; " " &lt;&lt; a[i] &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; Problem_J(贪心)题意：有一块肉重为n，每切一次消耗n的体力，要求切成所给的t块重为a[i]的肉，问消耗的最小体力是多少。 思路：倒着想，根据所给的每块小肉，将它们合并为一块大肉，每次合并消耗所要合并的两块肉的重量之和。因为求最小的消耗体力，而最小的两块合并后不一定是最小的了，所以每次取完后都得重新排一次序。因之前后面的序列都已有序，直接用sort会造成大量的时间浪费，所以我可以用依次往后交换直到后面的数大于等于要交换的这个数为止。当然能用上优先队列的话就不用每次都重新排序了。 相似(?：石子合并简化版，每次取最大的合并，这样合并完后不用再排序，直接继续取就OK。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 20005;long long a[MAX];int main()&#123; int n; long long ans; while(~scanf("%d",&amp;n)) &#123; ans = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a, a+n); int tot = 1; while(tot &lt; n) &#123; a[tot] = a[tot] + a[tot-1]; ans += a[tot]; for(int i = tot; i &lt; n-1; ++i) &#123; if(a[i] &lt;= a[i+1]) break; swap(a[i], a[i+1]); &#125; tot++; /*cout &lt;&lt; " tot=" &lt;&lt; tot &lt;&lt; endl; for(int i = 0; i &lt; n; ++i) cout &lt;&lt; a[i] &lt;&lt; " "; cout &lt;&lt; endl;*/ &#125; //cout &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; AC代码(priority_queue)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;struct cmp //自定义优先级&#123; bool operator () (long long &amp;a, long long &amp;b) const &#123; //最小值优先 return a &gt; b; &#125;&#125;;int main()&#123; int n; long long ans, tem; priority_queue&lt;long long, vector&lt;long long&gt;, cmp &gt;pq; //因为priority_queue中有已经定义好的越小的整数优先级越大，所以可以直接调用 //priority_queue&lt;long long, vector&lt;long long&gt;, greater&lt;long long&gt; &gt;pq; while(~scanf("%d",&amp;n)) &#123; ans = 0; while(!pq.empty()) pq.pop(); while(n--) &#123; scanf("%lld",&amp;tem); pq.push(tem); &#125; while(!pq.empty()) &#123; tem = pq.top(); pq.pop(); if(pq.empty()) break; //cout &lt;&lt; "tem=" &lt;&lt; tem &lt;&lt; endl; tem += pq.top(); pq.pop(); //cout &lt;&lt; "tem2=" &lt;&lt; tem &lt;&lt; endl; ans += tem; pq.push(tem); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; —————————————————————–分割线—————————————————————– 选拔赛结束了，虽然以排名比较靠前的成绩进了正式队，但是心里很是不甘，特别是这一次，很多能做的题都没做出来，还有一开始I的数据范围看错+打表打错，浪费了太多时间也影响了整体士气(我的锅。还剩25天了，多学知识的同时也要修炼自己沉稳的性格，不管结果如何，不留遗憾就好。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017_SDNU_ACM-ICPC_Provincial_Team_Selection_Round_1【--完结--】]]></title>
    <url>%2Fsdnu-2017-3%2F</url>
    <content type="text"><![CDATA[山东省第八届acm大学程序设计竞赛山师选拔赛第一场(声明：标题是自己取的，如果有语法错误的话与他人无关) —————————————————————–分割线—————————————————————– Problem_A(大数判定2幂数)题意：给定一个数，判断它是否是2的n次方(0 &lt; n &lt; $2 ^ {1000}$) 按二进制考虑的话，如果n&amp;(n-1)==0，则这个数就是2的n次方,等于1就不是。 AC代码(JAVA版)： 1234567891011121314151617181920212223import java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T; BigInteger N; BigInteger ZERO = new BigInteger("0"); BigInteger ONE = new BigInteger("1"); T = scanner.nextInt(); for(int i = 0; i &lt; T; ++i) &#123; N = scanner.nextBigInteger(); BigInteger M = N.subtract(ONE); if(N.and(M).compareTo(ZERO) == 0) System.out.println("Yes"); else System.out.println("No"); &#125; &#125;&#125; Problem_B(离散化裸题)有些数据本身很大，自身无法作为数组的下标保存对应的属性。如果这时只是需要这堆数据的相对属性时，那么就可以对其进行离散化。所谓离散化就是指当数据只与它们之间的相对大小有关，而与具体是多少无关时可以用到的一种方法(？ 举个例子来说，假设有4个数：1234567、123456789、12345678、123456排序后是123456＜1234567＜12345678＜123456789（只考虑他们相对大小可以想为1＜2＜3＜4），那么这四个数可以表示成：2、4、3、1。 对数据进行离散化如果用上STL会很棒棒哦（思路：先排序，再去重，然后索引元素离散化后对应的值，详见代码）。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 2002;bool flag[N][N];long long x[N], y[N];long long xx[N], yy[N];int main()&#123; int n; scanf("%d",&amp;n); memset(flag, false, sizeof(flag)); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%lld%lld%lld%lld",&amp;xx[i],&amp;yy[i],&amp;xx[i+n],&amp;yy[i+n]); //输入的同时对数据进行离散化 x[2*i] = xx[i+n]; y[2*i] = yy[i+n]; x[2*i-1] = xx[i]; y[2*i-1] = yy[i]; &#125; //排序去重 sort(x+1, x+1+2*n); sort(y+1, y+1+2*n); unique(x+1, x+1+2*n); unique(y+1, y+1+2*n); //索引元素离散化后对应的值 for(int i = 1; i &lt;= 2*n; ++i) &#123; xx[i] = upper_bound(x+1, x+1+2*n, xx[i]) - (x+1); yy[i] = upper_bound(y+1, y+1+2*n, yy[i]) - (y+1); &#125; for(int k = 1; k &lt;= n; ++k) for(int i = xx[k]+1; i &lt;= xx[k+n]; ++i) //从xx[k]+1开始 for(int j = yy[k]+1; j &lt;= yy[k+n]; ++j)//从yy[k]+1开始 flag[i][j] = true; long long ans = 0; for(int i = 2; i &lt;= 2*n; ++i) for(int j = 2; j &lt;= 2*n; ++j) if(flag[i][j]) ans += (x[i]-x[i-1])*(y[j]-y[j-1]);//是y[j]-y[j-1] cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Problem_C(最长回文子串)题意：给定一序列，输出其最长回文子序列的长度。 思路：没有思路，Manacher模板一套带走。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1e6+5;char MA[MAX*2];int MP[MAX*2];void Manacher(char s[], int len)&#123; int l = 0; MA[l++] = '$'; MA[l++] = '#'; for(int i = 0; i &lt; len; ++i) &#123; MA[l++] = s[i]; MA[l++] = '#'; &#125; MA[l] = 0; int mx = 0, id = 0; for(int i = 0; i &lt; l; ++i) &#123; MP[i] = mx &gt; i ? min(MP[2*id-i], mx-i) : 1; while(MA[i+MP[i]] == MA[i-MP[i]]) MP[i]++; if(i+MP[i]&gt;mx) &#123; mx = i + MP[i]; id = i; &#125; &#125;&#125;char s[MAX];int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; scanf("%s",s); int len = strlen(s); Manacher(s, len); int ans = 0; for(int i = 0; i &lt; 2*len+2; ++i) ans = max(ans, MP[i]-1); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem_D(多重背包)题意：有n个面值为A1,A2,..An,数量为C1,C2,..Cn的n个硬币，问他们之间互相组合能凑出多少种总面额小于m的面值 (可参照POJ的男人八题之Coins AC代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100000 + 5;int A[105], C[105];int DP[MAX]; //面额为A[i]的硬币在DP[i]位置用过的个数bool vis[MAX];//能凑成的面额int main()&#123; int N, M; while(scanf("%d%d",&amp;N,&amp;M) &amp;&amp; (N||M)) &#123; memset(vis, false, sizeof(vis)); for(int i = 1; i &lt;= N; ++i) scanf("%d",&amp;A[i]); for(int i = 1; i &lt;= N; ++i) scanf("%d",&amp;C[i]); vis[0] = true; for(int i = 1; i &lt;= N; ++i) &#123; memset(DP, 0, sizeof(DP)); for(int j = 1; j &lt;= M; ++j) &#123; //没有凑成过并且现在硬币的面额比要凑的面额大 if(vis[j] || j &lt; A[i]) continue; if(vis[j-A[i]] &amp;&amp; DP[j-A[i]]&lt;C[i]) &#123; vis[j] = true; //cout &lt;&lt; j &lt;&lt; " "; DP[j] = DP[j-A[i]] + 1; &#125; &#125; &#125; //cout &lt;&lt; endl; int ans = 0; for(int i = 1; i &lt;= M; ++i) if(vis[i]) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Problem_E（思维 签到）题意：给定n个数，从中抽取3个，将它们分成4组，问能否使每组的和相同。能的话输出抽取的三个数的位置，不能就输出I am done. 思路：设置i,j,k三个指针，一开始放在2,4,6这三个位置，然后不断判断分成的四组数据和是否相同，不同就找出其中最小的那一组，让他后面的指针往后移动。还有些小细节，比如k指针到头了，四组的值都相同了等等，自己处理一下就好了。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1005;int a[MAX];int MIN(int a, int b, int c, int d)&#123; if(a &lt;= b &amp;&amp; a &lt;= c &amp;&amp; a &lt;= d) return 1; if(b &lt;= a &amp;&amp; b &lt;= c &amp;&amp; b &lt;= d) return 2; if(c &lt;= a &amp;&amp; c &lt;= b &amp;&amp; c &lt;= d) return 3; if(d &lt;= a &amp;&amp; d &lt;= b &amp;&amp; d &lt;= c) return 4; return 0;&#125;int main()&#123; int n; int x, y, z; int ans1, ans2, ans3, ans4; while(~scanf("%d",&amp;n)) &#123; for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); bool flag = 1; if(n &lt; 7) flag = 0; if(flag) &#123; ans1 = ans2 = ans3 = ans4 = 0; x = 1; y = 3; z = 5; ans1 = a[0]; ans2 = a[2]; ans3 = a[4]; for(int i = 6; i &lt; n; ++i) ans4 += a[i]; while(flag) &#123; if(ans1 == ans2 &amp;&amp; ans1 == ans3 &amp;&amp; ans1 == ans4) break; int ans = MIN(ans1, ans2, ans3, ans4); switch(ans) &#123; case 0: case 4: flag = 0; break; case 1: x++; case 2: y++; case 3: z++; break; &#125; ans1 = ans2 = ans3 = ans4 = 0; for(int i = 0; i &lt; x; ++i) ans1 += a[i]; for(int i = x+1; i &lt; y; ++i) ans2 += a[i]; for(int i = y+1; i &lt; z; ++i) ans3 += a[i]; for(int i = z+1; i &lt; n; ++i) ans4 += a[i]; &#125; &#125; if(flag) cout &lt;&lt; x+1 &lt;&lt; " " &lt;&lt; y+1 &lt;&lt; " " &lt;&lt; z+1 &lt;&lt; endl; else cout &lt;&lt; "I am done." &lt;&lt; endl; &#125; return 0;&#125; Problem_F(八进制减法)题意：八进制减法 AC代码(C++–模拟)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/*************Author:E6ther*************/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; while(~scanf("%d",&amp;t)) &#123; getchar(); for(int j=0;j&lt;t;++j) &#123; char a[105],b[105]; int len1=0,len2=0; bool flag=1; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); char c; while((c=getchar())!=' '&amp;&amp;c!='\n') &#123; a[len1]=c-'0'; len1++; &#125; a[len1]=0; while((c=getchar())!=' '&amp;&amp;c!='\n') &#123; b[len2]=c-'0'; len2++; &#125; b[len2]=0; /*for(int i=0;i&lt;len1;++i) &#123; printf("%d",a[i]); &#125;cout&lt;&lt;endl; for(int i=0;i&lt;len2;++i) &#123; printf("%d",b[i]); &#125;cout&lt;&lt;endl;*/ //printf("%s %s\n",a,b); if(len1&gt;len2) &#123; flag=1; &#125; else if(len1&lt;len2) &#123; flag=0; &#125; else &#123; for(int i=0;i&lt;len1;++i) &#123; if(a[i]&gt;b[i]) &#123; flag=1; break; &#125; else if(a[i]&lt;b[i]) &#123; flag=0; break; &#125; &#125; &#125; if(flag) &#123; for(int i=len2-1,j=len1-1;i&gt;=0;--i,--j) &#123; if(a[j]&gt;=b[i]) &#123; a[j]=a[j]-b[i]; &#125; else &#123; a[j]=a[j]+8-b[i]; if(a[j-1]) a[j-1]--; else &#123; int flag2=0; for(int x=j-2;x&gt;=0;--x) &#123; if(a[x]) &#123; a[x]--; flag2=1; &#125; a[x+1]=7; if(flag2) break; &#125; &#125; &#125; &#125; &#125; else &#123; for(int i=len1-1,j=len2-1;i&gt;=0;--i,--j) &#123; if(a[i]&lt;=b[j]) &#123; b[j]=b[j]-a[i]; &#125; else &#123; b[j]=b[j]+8-a[i]; if(b[j-1]) b[j-1]--; else &#123; int flag2=0; for(int x=j-2;x&gt;=0;--x) &#123; if(b[x]) &#123; b[x]--; flag2=1; &#125; b[x+1]=7; if(flag2) break; &#125; &#125; &#125; &#125; &#125; bool flag1=0; if(flag) &#123; for(int i=0;i&lt;len1;++i) &#123; if(a[i]) flag1=1; if(flag1) printf("%d",a[i]); &#125; if(!flag1) cout&lt;&lt;"0"; &#125; else &#123; cout&lt;&lt;"-"; for(int i=0;i&lt;len2;++i) &#123; if(b[i]) flag1=1; if(flag1) printf("%d",b[i]); &#125; &#125; cout&lt;&lt;endl; &#125; &#125; return 0;&#125; AC代码(JAVA):12345678910111213141516171819202122import java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int T; Scanner scanner = new Scanner(System.in); T = scanner.nextInt(); BigInteger N, M, X, Y; for(int i = 0; i &lt; T; ++i) &#123; N = scanner.nextBigInteger(); M = scanner.nextBigInteger(); X = new BigInteger(N.toString(),8); Y = new BigInteger(M.toString(),8); X = X.subtract(Y); System.out.println(X.toString(8)); &#125; &#125;&#125; Problem_G(模拟)题意：给你n个数，输出对他们进行第一次快速排序后的结果。不知道快速排序的话，自己去搜(其实不知道也没关系，题目里已经给出了排序的方式了，按照它的来就是了)。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 10005;int a[MAX];void solve(int n)&#123; int tem = a[0]; int l = 0, r = n; while(l &lt;= r) &#123; for(--r; l &lt;= r; --r) &#123; if(a[r] &lt; tem) &#123; a[l] = a[r]; break; &#125; &#125; for(++l; l &lt;= r; ++l) &#123; if(a[l] &gt; tem) &#123; a[r] = a[l]; break; &#125; &#125; &#125; a[--l] = tem;&#125;int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; memset(a, 0, sizeof(a)); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); solve(n); for(int i = 0; i &lt; n; ++i) &#123; if(i) cout &lt;&lt; " "; cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Problem_H(大素数判定)题意：给你n个数，输出他们中素数的个数。要用到Miller-rabin算法，套个模板就好了。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;using namespace std;const int S = 8;//随机算法判定次数，一般8~10次就够了//计算ret = (a*b)%c a, b, c &lt; 2^63long long mult_mod(long long a, long long b, long long c)&#123; a %= c; b %= c; long long ret = 0; long long tem = a; while(b) &#123; if(b &amp; 1) &#123; ret += tem; if(ret &gt; c) ret -= c;//直接取模慢很多 &#125; tem &lt;&lt;= 1; if(tem &gt; c) tem -= c; b &gt;&gt;= 1; &#125; return ret;&#125;//计算 ret = (a^n) % modlong long pow_mod(long long a, long long n, long long mod)&#123; long long ret = 1; long long tem = a % mod; while(n) &#123; if(n &amp; 1) ret = mult_mod(ret, tem, mod); tem = mult_mod(tem, tem, mod); n &gt;&gt;= 1; &#125; return ret;&#125;// 通过 a^(n-1)=1(mod n)来判断n是不是素数// n-1 = x * 2^t 中间使用二次判断// 是合数返回true，不一定是合数返回falsebool check(long long a, long long n, long long x, long long t)&#123; long long ret = pow_mod(a, x, n);//a^x % n long long last = ret; for(int i = 1; i &lt;= t; ++i)//进行t次(a^x % n)^2 % n &#123; ret = mult_mod(ret, ret, n); if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true;//合数 last = ret; &#125; if(ret != 1) return true; return false;//不一定是合数&#125;//**************************************************// Miller_Rabin算法// 是素数返回true,(可能是伪素数)// 不是素数返回false//**************************************************bool Miller_Rabin(long long n)&#123; if(n &lt; 2) return false; if(n == 2) return true; if( (n&amp;1) == 0) return false;//偶数 long long x = n - 1; long long t = 0; while( (x&amp;1) == 0) //将n分解为x*2^t; &#123; x &gt;&gt;= 1; t++; &#125; srand( time(NULL)); for(int i = 0; i &lt; S; ++i) &#123; long long a = rand()%(n-1) + 1;//产生随机数a(并控制其范围在1 ~ n-1之间) if(check(a, n, x, t))//是合数 return false; &#125; return true;&#125;int main()&#123; int t, ans; long long tem; scanf("%d",&amp;t); ans = 0; while(t--) &#123; scanf("%lld",&amp;tem); if(Miller_Rabin(tem)) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第五章习题】]]></title>
    <url>%2Flrj-ch5-1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>解题报告</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU ACM-ICPC 2016-2017 Training Weekly Contest 2 【--完结--】]]></title>
    <url>%2Fsdnu-2017-2%2F</url>
    <content type="text"><![CDATA[题目链接：https://vjudge.net/contest/153814 A - An ant’s story(思维)HDU - 3343 感觉特别坑的一道题目，只要蚂蚁爬的速度&gt;0，它就能到终点，用到了极限思想？不明觉厉..GG.. AC代码：1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; int a, b, c; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(b &gt; 0) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125; B - War Chess(BFS&lt;用到优先队列&gt;)HDU - 3345 BFS好题，当时做的时候不是TLE就是MLE。赛后我重新写还是MLE（喵喵喵？ 后来问了一下陆历川大哥，他说得用优先队列，能用优先队列的就别用队列，然后给我发了个优先队列的讲解博客地址。又学到了新东西啊.. AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int MAX = 105;int n, m, v;int dir[][2] = &#123;0,1,1,0,-1,0,0,-1&#125;;char mapa[MAX][MAX], newa[MAX][MAX];bool vis[MAX][MAX], eme[MAX][MAX];struct node&#123; int x, y, v; bool operator &lt; (const node &amp;a) const &#123; return v &lt; a.v;//v大的优先 &#125;&#125; q, p;bool ok()&#123; if(p.x &lt; 0 || p.y &lt; 0 || p.x &gt;= n || p.y &gt;= m) return false; if(!p.v || vis[p.x][p.y] || mapa[p.x][p.y] == '#' || mapa[p.x][p.y] == 'E') return false; if(mapa[p.x][p.y] == '.' || mapa[p.x][p.y] == 'P') p.v -= 1; else if(mapa[p.x][p.y] == 'T') p.v -= 2; else if(mapa[p.x][p.y] == 'R') p.v -= 3; if(p.v &lt; 0) return false; if(eme[p.x][p.y]) p.v = 0; return true;&#125;void bfs()&#123; priority_queue&lt;node&gt; Q; Q.push(q); while(!Q.empty()) &#123; q = Q.top(); Q.pop(); for(int i = 0; i &lt; 4; ++i) &#123; p.x = q.x + dir[i][0]; p.y = q.y + dir[i][1]; p.v = q.v; if(ok()) &#123; vis[p.x][p.y] = 1; if(mapa[p.x][p.y] != 'P') newa[p.x][p.y] = '*'; Q.push(p); &#125; &#125; &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; memset(vis, 0, sizeof(vis)); memset(eme, 0, sizeof(eme)); scanf("%d%d%d",&amp;n, &amp;m, &amp;v); for(int i = 0; i &lt; n; ++i) &#123; scanf("%s",mapa[i]); strcpy(newa[i], mapa[i]); &#125; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) &#123; if(mapa[i][j] == 'Y') &#123; vis[i][j] = 1; q.x = i; q.y = j; q.v = v; &#125; if(mapa[i][j] == 'E') &#123; if(i - 1 &gt;= 0) eme[i-1][j] = 1; if(j - 1 &gt;= 0) eme[i][j-1] = 1; if(i + 1 &lt; n) eme[i+1][j] = 1; if(j + 1 &lt; m) eme[i][j+1] = 1; &#125; &#125; bfs(); for(int i = 0; i &lt; n; ++i) cout &lt;&lt; newa[i] &lt;&lt; endl; cout &lt;&lt; endl; &#125; return 0;&#125; C - Lucky Number(基础)HDU - 3346 这个不多说了，又是抢的一血。额..当时有点激动漏了个条件（当然样例是不会让你看出来的，细心一点就好了。 AC代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t, n, ans, ans2; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; ans = ans2 = 0; scanf("%d",&amp;n); if(n % 8 == 0) cout &lt;&lt; "Lucky number!" &lt;&lt; endl; else &#123; int tem = n; while(tem) &#123; int qq = tem % 10; ans += qq; tem /= 10; ans2 = ans2 + qq*qq; &#125; if(ans % 8 == 0 || ans2 % 8 == 0) cout &lt;&lt; "Lucky number!" &lt;&lt; endl; else cout &lt;&lt; "What a pity!" &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; D - Calculate the expression(模拟)HDU - 3347 模拟呀..今下午自己写了会，用了不少STL的东西，后来将表示数字的字符转换为数字时我想到了atoi函数，然而这个函数对string不适用，想着改为char数组后再用这个函数吧，改着改着把自己改迷糊了..去听完报告回来后全换为char数组，结果TLE了（如果用stringstream不就直接弄死我..问了问我兄弟，他说在打游戏让我去他博客找找看（→_→ 你很棒棒哦 对比后感觉自己写的略微“高级”，然后我把“高级”部分改为朴素的if – else if然后就过了，噫，看来能A题的代码才是好代码。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;char s[105];char k[25];int main()&#123; int t, n, flag, tem, ans; scanf("%d",&amp;t); while(t--) &#123; flag = 1; ans = 0; map&lt;string, int&gt; ss; scanf("%d",&amp;n); //cout &lt;&lt; "n= " &lt;&lt; n &lt;&lt; endl; for(int i = 1; i &lt; n; ++i) &#123; scanf("%s = %d",s, &amp;tem); ss[s] = tem; //cout &lt;&lt; "s= " &lt;&lt; s &lt;&lt; " tem= " &lt;&lt; tem &lt;&lt; endl; //cout &lt;&lt; "???" &lt;&lt; endl; &#125; while(1) &#123; scanf("%s",s); tem = 0; if(s[0] &gt;= '0' &amp;&amp; s[0] &lt;= '9')//是正数 数字 &#123; for(int i = 0; i &lt; strlen(s); ++i) &#123; tem *= 10; tem += (s[i] - '0'); &#125; if(flag == 0) ans = ans - tem; else ans = ans + tem; &#125; else if(s[0] == '-') //这里注意一下 表达式中出现-号一定是常数 （我之前还以为会有 1 + -aa的情况.. &#123; for(int i = 1; i &lt; strlen(s); ++i) &#123; tem *= 10; tem += (s[i] - '0'); &#125; if(flag == 1) ans = ans - tem; else ans = ans + tem; &#125; else if(flag == 0) ans = ans - ss[s]; else ans = ans + ss[s]; scanf("%s",k); if(k[0] == '=') break; if(k[0] == '+') flag = 1; else flag = 0; &#125; scanf("%s",k);//处理最后剩下的"？" //cout &lt;&lt; "ans= " &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 写完这篇博客的第二天发现了个有趣的函数——c_str()，这个函数会生成一个const char*指针，指向以空字符终止的数组，有了它我们就可以对string使用atoi函数了。马上去写了一下，觉得爽的同时也觉得自己还是图样图森破。 （我发现的问题，那些前辈们肯定早就知道了，还有的早就在函数库里添加了相应的函数，只是我不知道而已(￣ε(#￣)☆╰╮(￣▽￣///) 最后再说一句——STL大法好 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;sstream&gt;using namespace std;int main()&#123; int t, n, tem, flag, ans; string s, stem; scanf("%d",&amp;t); while(t--) &#123; map&lt;string, int&gt; num; scanf("%d",&amp;n); for(int i = 1; i &lt; n; ++i) &#123; cin &gt;&gt; s; scanf(" = %d",&amp;tem); num[s] = tem; //cout &lt;&lt; s &lt;&lt; " " &lt;&lt; tem; &#125; getchar();//接收一个换行符 这里要注意一下 getline(cin, stem); stringstream ss(stem); ans = 0; flag = 1; while(ss &gt;&gt; s) &#123; if(s == "=") break; if(s == "-") flag = -1; else if(s == "+") flag = 1; else &#123; if(isalpha(s[0])) &#123; tem = num[s]; &#125; else &#123; tem = atoi(s.c_str());//666 &#125; ans += (tem*flag); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; E - coins(贪心)HDU - 3348 贪一贪。（代码写的通俗易懂，至于别人的空间复杂度低的我也不去管了，反正能A题的代码都是好代码(⊙v⊙) 明明很好解决的问题，却只有我和我兄弟做出来了。啧啧啧，队友瑕还说这个和上次做的多重背包的很像，受背包毒害不浅啊..还有通过这次训练，我决定我来作主代码手，毕竟我刷的（基础）题多，见识的（无用）知识点多，还有单身19年+的手速。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int a[5], b[5]; //面值为1 5 10 50 100的钞票个数int main()&#123; int t, p, ans1, ans2;; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;p); ans1 = ans2 = 0; for(int i = 0; i &lt; 5; ++i) scanf("%d",&amp;a[i]); for(int i = 0; i &lt; 5; ++i) b[i] = a[i]; int tem = p; while(tem &gt;= 100 &amp;&amp; a[4]) &#123; tem -= 100; a[4]--; ans2++; &#125; while(tem &gt;= 50 &amp;&amp; a[3]) &#123; tem -= 50; a[3]--; ans2++; &#125; while(tem &gt;= 10 &amp;&amp; a[2]) &#123; tem -= 10; a[2]--; ans2++; &#125; while(tem &gt;= 5 &amp;&amp; a[1]) &#123; tem -= 5; a[1]--; ans2++; &#125; while(tem &gt;= 1 &amp;&amp; a[0]) &#123; tem -= 1; a[0]--; ans2++; &#125; if(tem &gt; 0) &#123; ans2 = ans1 = -1; cout &lt;&lt; "-1 -1" &lt;&lt; endl; &#125; else &#123; while(b[0] + b[1] * 5 + b[2] * 10 + b[3] * 50 &lt; p) &#123; p -= 100; ans1++; &#125; while(b[0] + b[1] * 5 + b[2] * 10 &lt; p) &#123; p -= 50; ans1++; &#125; while(b[0] + b[1] * 5 &lt; p) &#123; p -= 10; ans1++; &#125; while(b[0] &lt; p) &#123; p -= 5; ans1++; &#125; ans1 += p; cout &lt;&lt; ans2 &lt;&lt; " " &lt;&lt; ans1 &lt;&lt; endl; &#125; &#125; return 0;&#125; F - lazy gege(数学)HDU - 3349 平面几何，找长方形的重心—&gt;看正方形的对角线长度和长方形中较短的边的关系，一共有三种情况，自己画个图就很好理解了。计算几何主要就是看思维了，代码实现并没有什么难度，注释的挺详细了，注意一下三个if的顺序。 AC代码：1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; double l, a, b, ans; scanf("%d",&amp;t); while(t--) &#123; scanf("%lf%lf%lf",&amp;l,&amp;a,&amp;b); if(a &gt; b) swap(a, b); //保证a为长方形的较小边 double tem = sqrt(2.0) * l; //正方形的对角线长度 if(a &lt; tem) ans = a*a/4.0; //放在正方形上的部分为等腰△ else if(a &gt; tem &amp;&amp; a &lt; 2.0*tem) ans = l*l - (tem - a/2)*(tem - a/2); //正方形面积减去等腰三角形面积 else ans = l*l; //覆盖正方形 printf("%.4lf\n",ans); &#125; return 0;&#125; G - #define is unsafe(模拟)HDU - 3350 用栈实现的模拟题，这里我用vector数组模拟了个栈。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int val;//值 int add;//+的次数&#125;;//用vector实现模拟栈的FILOvector&lt;node&gt; ans;//数值栈vector&lt;char&gt; sig;//符号栈int main()&#123; int T; string str; node tem, tem2; scanf("%d",&amp;T); while(T--) &#123; cin &gt;&gt; str; //不要忘记初始化 tem.val = tem.add = 0; ans.clear(); sig.clear(); for(int i = 0; i &lt; str.length(); ++i) &#123; //逐字扫描，只有'('、'+'、','、')'和数字是有用的 //"MAX"不做处理 //优先级：'(' &gt; '+' &gt; ',' &gt; ')' switch(str[i]) &#123; case '(': sig.push_back(str[i]); tem.val = tem.add = 0; break; case '+': ans.push_back(tem); sig.push_back(str[i]); tem.val = tem.add = 0; //每次push后都要初始化tem break; case ',': while(!sig.empty() &amp;&amp; sig.back() == '+') &#123; tem2 = ans.back(); tem.val += tem2.val; tem.add += tem2.add + 1; ans.pop_back(); sig.pop_back(); &#125; ans.push_back(tem); sig.push_back(str[i]); tem.val = tem.add = 0; //初始化tem break; case ')': while(!sig.empty() &amp;&amp; sig.back() == '+') &#123; tem2 = ans.back(); tem.val += tem2.val; tem.add += tem2.add + 1; ans.pop_back(); sig.pop_back(); &#125; tem2 = ans.back(); if(tem.val &lt; tem2.val) &#123; tem.val = tem2.val; tem.add = tem2.add*2 + tem.add; &#125; else &#123; tem.add = tem.add*2 + tem2.add; &#125; sig.pop_back(); sig.pop_back(); ans.pop_back(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': tem.val = tem.val*10 + str[i] - '0'; break; &#125; &#125; while(!sig.empty() &amp;&amp; sig.back() == '+') &#123; tem2 = ans.back(); tem.val += tem2.val; tem.add += tem2.add + 1; ans.pop_back(); sig.pop_back(); &#125; cout &lt;&lt; tem.val &lt;&lt; " " &lt;&lt; tem.add &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识点】大数分解与素数判定 --- 【Miller-rabin算法】【pollard-rho算法】]]></title>
    <url>%2Fmr-pr%2F</url>
    <content type="text"><![CDATA[1.Miller-rabin算法：Miller-rabin算法是一个用来快速判断一个正整数是否为素数的算法。 根据费马小定理，如果p是素数，则a^(p-1)≡1(mod p)对所有的a∈[1,n-1]成立。所以如果在[1,n-1]中随机取出一个a，发现不满足费马小定理，则证明n必为合数。 【但是每次尝试过程中还做了一个优化操作，以提高用少量的a检测出p不是素数的概率。这个优化叫做二次探测。它是根据这个定理：如果p是一个素数，那么对于x(0&lt;x&lt;p)，若x^2%p=1，则x=1或p-1。】 为了计算a^(n-1)mod n，我们把n-1分解为x* 2^t的形式，其中t&gt;=1且x是奇数；因此，a^(n-1)≡(a^x)^(2^t)(mod n),所以可以通过先计算a^x mod n,然后对结果连续平方t次来计算a^(n-1) mod n。一旦发现某次平方后mod n等于1了，那么说明符合了二次探测定理的逆否命题使用条件，立即检查x是否等于1或n-1，如果不等于1也不等于n-1则可直接判定p为合数。 2.pollard-rho算法：这是一个用来快速对整数进行质因数分解的算法，需要与Miller-rabin共同使用。 算法原理： 1.通过某种方法得到两个整数a和b，而待分解的大整数为n。 2.计算p=gcd(a-b,n)，直到p不为1(就是a-b与n不是互质)，或者a，b出现循环为止。 3.然后再判断p=n？ 4.如果p=n，那么返回n是一个质数。 5.否则返回p是n的一个因子，那么我们又可以递归的计算Pollard(p)和Pollard(n/p)，这样，我们就可以求出n的所有质因子。 算法步骤：选取一个小的随机数x1，迭代生成x[i] = x[i-1]^2+c，一般取c=1，若序列出现循环则退出，计算p=gcd(x[i-1]-x[i],n)，若p=1则返回上一步继续迭代，否则跳出迭代过程。若p=n，则n为素数，否则p为n的一个约数，并递归分解p和n/p。 【小知识】：随机数生成C++中函数srand（），可以指定不同的数（无符号整数变元）为种子。但是如果种子相同，伪随机数列也相同。 比较理想的是用变化的数，比如时间来作为随机数生成器的种子。 time的值每时每刻都不同，即种子不同，所以，产生的随机数也不同。 用法什么的想深入了解自己去搜吧，这里只要明白下面的程序中随机数是这样产生的就行了。然后，在这里再举个小栗子以加深一下对它的理解： 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;//这个必须有using namespace std;int main()&#123; int a = 100; srand( time(NULL)); while(a--) cout &lt;&lt; rand() &lt;&lt; endl; return 0;&#125;//这个程序的作用是产生100个随机数//如果你和我一样有颗童心去多试几次的话你会发现——每次产生的随机数都不一样//噫 是不是狠有趣(。＾▽＾) 学了这么多是不是手痒了？别着急，点我有惊喜。AC代码（C++【因为涉及到ctime，所以G++会RE的】）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177/* ************************************************* * * Miller_Rabin 算法进行素数测试 * 速度快，可以判断一个 &lt; 2^63 的数是不是素数 * **************************************************/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;using namespace std;const int S = 8;//随机算法判定次数，一般8~10次就够了//计算ret = (a*b)%c a, b, c &lt; 2^63long long mult_mod(long long a, long long b, long long c)&#123; a %= c; b %= c; long long ret = 0; long long tem = a; while(b) &#123; if(b &amp; 1) &#123; ret += tem; if(ret &gt; c) ret -= c;//直接取模慢很多 &#125; tem &lt;&lt;= 1; if(tem &gt; c) tem -= c; b &gt;&gt;= 1; &#125; return ret;&#125;//计算 ret = (a^n) % modlong long pow_mod(long long a, long long n, long long mod)&#123; long long ret = 1; long long tem = a % mod; while(n) &#123; if(n &amp; 1) ret = mult_mod(ret, tem, mod); tem = mult_mod(tem, tem, mod); n &gt;&gt;= 1; &#125; return ret;&#125;// 通过 a^(n-1)=1(mod n)来判断n是不是素数// n-1 = x * 2^t 中间使用二次判断// 是合数返回true，不一定是合数返回falsebool check(long long a, long long n, long long x, long long t)&#123; long long ret = pow_mod(a, x, n);//a^x % n long long last = ret; for(int i = 1; i &lt;= t; ++i)//进行t次(a^x % n)^2 % n &#123; ret = mult_mod(ret, ret, n); if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true;//合数 last = ret; &#125; if(ret != 1) return true; return false;//不一定是合数&#125;//**************************************************// Miller_Rabin算法// 是素数返回true,(可能是伪素数)// 不是素数返回false//**************************************************bool Miller_Rabin(long long n)&#123; if(n &lt; 2) return false; if(n == 2) return true; if( (n&amp;1) == 0) return false;//偶数 long long x = n - 1; long long t = 0; while( (x&amp;1) == 0) //将n分解为x*2^t; &#123; x &gt;&gt;= 1; t++; &#125; srand( time(NULL)); for(int i = 0; i &lt; S; ++i) &#123; long long a = rand()%(n-1) + 1;//产生随机数a(并控制其范围在1 ~ n-1之间) if(check(a, n, x, t))//是合数 return false; &#125; return true;&#125;//********************************************** // // pollard_rho 算法进行质因素分解 // //********************************************* int tol;//质因数的个数，编号为0~tol-1long long factor[100];//质因素分解结果(刚返回时是无序的)long long gcd(long long a, long long b)&#123; long long t; while(b) &#123; t = a; a = b; b = t % b; &#125; if(a &gt;= 0) return a; return -a;&#125;//找出一个因子long long pollard_rho(long long x, long long c)&#123; long long i = 1, k = 2; srand( time(NULL)); long long x0 = rand()%(x-1) + 1;//产生随机数x0(并控制其范围在1 ~ x-1之间) long long y = x0; while(1) &#123; i++; x0 = (mult_mod(x0, x0, x) + c) % x; long long d = gcd(y - x0, x); if(d != 1 &amp;&amp; d != x) return d; if(y == x0) return x; if(i == k) &#123; y = x0; k += k; &#125; &#125;&#125;//对n进行素因子分解，存入factor。 k设置为107左右即可void findfac(long long n, int k)&#123; if(n == 1) return ; if(Miller_Rabin(n))//是素数就把这个素因子存起来 &#123; factor[tol++] = n; return ; &#125; int c = k; long long p = n; while(p &gt;= n) p = pollard_rho(p, c--);//值变化，防止陷入死循环k findfac(p, k); findfac(n/p, k);&#125;int main()&#123; int T; long long n; scanf("%d",&amp;T); while(T--) &#123; scanf("%lld",&amp;n); if(Miller_Rabin(n)) cout &lt;&lt; "Prime" &lt;&lt; endl; else &#123; tol = 0; findfac(n, 107); long long ans = factor[0]; for(int i = 1; i &lt; tol; ++i) ans = min(ans, factor[i]); cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; 经过了“几天”的学习，终于能明白M-r,p-r算法是怎么实现的了（吐槽一下那三位对我关爱有加的兄弟，给我留了个这么有用的知识点让我讲），然后对着板子敲了几遍熟悉了一下。可能是还没碰到这种题目吧，内心里总觉得。。？总之也算是没浪费这些时间，至少我可以对着板子来对这知识点进行自在应用了（比如用朴素算法一不小心就会超时的一道题目。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>Miller-rabin</tag>
        <tag>pollard-rho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第五章例题】]]></title>
    <url>%2Flrj-ch5-0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>解题报告</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[White_Society_March_9 【小组练习】【--完结--】]]></title>
    <url>%2Fsdnu-white-society%2F</url>
    <content type="text"><![CDATA[前言：今天下午14：00小组举行了第一次磨合赛，总体配合的感觉还可以，相信还有很多问题没暴露出来，还有不到两个月，把握好每次练习的机会，争取这方面不会有太大失分点。 感谢：在此特意感谢熬夜为我们准备题目的超哥，还有两位带我飞的队友。然后，先定个小目标——坐上山师4队的位置。 推荐题目：A、E A - AHDU - 1131 卡特兰数的应用。 在不考虑顺序的前提下，将节点编号为0~n-1，任取一个节点k作为根节点，从而衍生出两个子问题$f(k-1)$和$f(n-k)$，有$f(k-1) \times f(n-k)$棵树， 则$f(n) = f(0) \times f(n-1) + f(1) \times f(n-2) + \ldots + f(n-1) \times f(0)$,符合卡特兰数的递推公式。由该递推公式可以推出$f(n) = \frac{f(n-1) \times (4n-2)}{(n+1)}$。至此，卡特兰数的问题已经解决。 加入字母顺序以后，这可以看成已经准备好了n个位置，现在来安排座位，排序总数为$n!$种。所以数的数量就等于$f(n) \times n!$ 这里如果分别计算再相乘的话会很麻烦，所以直接令答案$h(n) = \frac{h(n-1) \times n \times (4n-2)}{(n+1)}$ 卡特兰数：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100;const int XX = 10000;int katelan[MAX+5][MAX+5];int main()&#123; katelan[0][1] = 1; for(int i = 1; i &lt;= MAX; ++i) &#123; for(int j = 1; j &lt;= MAX; ++j) &#123; katelan[i][j] += katelan[i-1][j]*(4*i-2); katelan[i][j+1] += katelan[i][j]/XX; katelan[i][j] %= XX; &#125; int tem; for(int j = MAX; j &gt; 0; --j) &#123; tem = katelan[i][j] % (i+1); katelan[i][j-1] += tem*XX; katelan[i][j] /= (i+1); &#125; &#125; int n; while(~scanf("%d",&amp;n)) &#123; int i = MAX; while(katelan[n][i] == 0) i--; cout &lt;&lt; katelan[n][i--]; while(i &gt; 0) &#123; printf("%04d",katelan[n][i--]); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100;const int XX = 10000;int katelan[MAX+5][MAX+5];int main()&#123; katelan[0][1] = 1; for(int i = 1; i &lt;= MAX; ++i) &#123; for(int j = 1; j &lt;= MAX; ++j) &#123; katelan[i][j] += katelan[i-1][j]*i*(4*i-2); katelan[i][j+1] += katelan[i][j]/XX; katelan[i][j] %= XX; &#125; int tem; for(int j = MAX; j &gt; 0; --j) &#123; tem = katelan[i][j] % (i+1); katelan[i][j-1] += tem*XX; katelan[i][j] /= (i+1); &#125; &#125; int n; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; int i = MAX; while(katelan[n][i] == 0) i--; cout &lt;&lt; katelan[n][i--]; while(i &gt; 0) &#123; printf("%04d",katelan[n][i--]); //%04d 表示在输出一个小于4位的数值时 //将在前面补0使其总宽度为4位 &#125; cout &lt;&lt; endl; &#125; return 0;&#125; B - BHDU - 1087 最长上升子序列。之前的博客也写过。 （队友及）AC代码：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1005;int a[MAX], dp[MAX];bool cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int n, ans; while(~scanf("%d",&amp;n) &amp;&amp; n) &#123; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;a[i]); dp[i]=a[i]; &#125; for(int i = 0; i &lt; n; ++i) &#123; for(int i1=i-1; i1&gt;=0; --i1) &#123; if(a[i]&gt;a[i1]&amp;&amp;dp[i]&lt;dp[i1]+a[i]) &#123; dp[i]=dp[i1]+a[i]; &#125; &#125; &#125; sort(dp,dp+n,cmp); cout&lt;&lt;dp[0]&lt;&lt;endl; &#125; return 0;&#125; C - CHDU - 1045 DFS。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char mapa[5][5];int vis[5][5];int n, ans;void init()&#123; ans = 0; memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) if(mapa[i][j] == 'X') vis[i][j] = 2;&#125;bool ok(int x, int y)&#123; if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n) return false; return true;&#125;bool okok(int x, int y)&#123; if(vis[x][y] == 2) return false; for(int i = x; ok(i, y); ++i)//右 &#123; if(vis[i][y] == 2) break;//如果碰到X直接退出 if(vis[i][y] == 1) return false; &#125; for(int i = x; ok(i, y); --i)//左 &#123; if(vis[i][y] == 2) break; if(vis[i][y] == 1) return false; &#125; for(int i = y; ok(x, i); ++i)//上 &#123; if(vis[x][i] == 2) break; if(vis[x][i] == 1) return false; &#125; for(int i = y; ok(x, i); --i)//下 &#123; if(vis[x][i] == 2) break; if(vis[x][i] == 1) return false; &#125; return true;&#125;void dfs(int num)&#123; if(num &gt; ans) ans = num; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) &#123; if(okok(i, j)) &#123; vis[i][j] = 1; dfs(num + 1); vis[i][j] = 0; &#125; &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n) &amp;&amp; n) &#123; for(int i = 0; i &lt; n; ++i) scanf("%s", mapa[i]); init(); dfs(0); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D - DHDU - 2052 额..打印图形..手速还是不够啊，交上时已经3分1秒了.. AC代码：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;int main()&#123; int n, m; while(~scanf("%d%d",&amp;n, &amp;m)) &#123; cout &lt;&lt; "+"; for(int i = 0; i &lt; n; ++i) cout &lt;&lt; "-"; cout &lt;&lt; "+" &lt;&lt; endl; for(int i = 0; i &lt; m; ++i) &#123; cout &lt;&lt; "|"; for(int j = 0; j &lt; n; ++j) cout &lt;&lt; " "; cout &lt;&lt; "|" &lt;&lt; endl; &#125; cout &lt;&lt; "+"; for(int i = 0; i &lt; n; ++i) cout &lt;&lt; "-"; cout &lt;&lt; "+" &lt;&lt; endl; cout &lt;&lt; endl; &#125; return 0;&#125; E - EHDU - 1060 给你一个数N（$0&lt;N&lt;1,000,000,000$）， 让你求$N^N$的最高位数字。 一开始找规律，找啊找，就是找不到。后来发现有公式。（这道题还是挺不错的） 假设最高位数字为a，则用科学计数法表示就可以表示为$N^N = a \times 10^x$，同时取对数，移项，化简，得$a = 10^{(N \times lgN - x)}$，而这里的x就是​$lg(N^N)$向下取整（别问我为什么）。 到这里答案就可以得出来了，注意一下强制类型转换。 (队友瑕)AC代码：12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int t; long long n; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; scanf("%lld",&amp;n); double b = pow(10, n*log10(n) - (long long)(n * (log10(n)))); cout &lt;&lt; (int)b &lt;&lt; endl; &#125; &#125; return 0;&#125; F - FHDU - 5578 两只小青蛙？呱呱呱？然而这些情景并没有什么用，主要是问给出的字符串中，找到两个相同的字符最小的距离，没有相同的字符就输出-1 （队友及）AC代码：12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1005;int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; for(int j=1;j&lt;=n;++j) &#123; char a[1005]; scanf("%s",a); int len=strlen(a),num=2000; for(int i=0;i&lt;len-1;++i) &#123; for(int i1=i+1;i1&lt;len;++i1) &#123; if(a[i]==a[i1]) &#123; if(num&gt;i1-i) &#123; num=i1-i; &#125; &#125; &#125; &#125; if(num!=2000) printf("Case #%d: %d\n",j,num); else printf("Case #%d: %d\n",j,-1); &#125; &#125; return 0;&#125; G - GHDU - 1097 这个是求$x^y$的个位数，可以用快速幂一套带走，也可以找规律，之前的博客也写过这个题.. （队友及）AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; long long a,b; while(~scanf("%lld%lld",&amp;a,&amp;b)) &#123; if(a%10==0) a=0; else if(a%10==1) a=1; else if(a%10==2) &#123; switch(b%4) &#123; case 1:a=2;break; case 2:a=4;break; case 3:a=8;break; case 0:a=6;break; &#125; &#125; else if(a%10==3) &#123; switch(b%4) &#123; case 1:a=3;break; case 2:a=9;break; case 3:a=7;break; case 0:a=1;break; &#125; &#125; else if(a%10==4) &#123; switch(b%2) &#123; case 1:a=4;break; case 0:a=6;break; &#125; &#125; else if(a%10==5) &#123; a=5; &#125; else if(a%10==6) &#123; a=6; &#125; else if(a%10==7) &#123; switch(b%4) &#123; case 1:a=7;break; case 2:a=9;break; case 3:a=3;break; case 0:a=1;break; &#125; &#125; else if(a%10==8) &#123; switch(b%4) &#123; case 1:a=8;break; case 2:a=4;break; case 3:a=2;break; case 0:a=6;break; &#125; &#125; else if(a%10==9) &#123; switch(b%2) &#123; case 1:a=9;break; case 0:a=1;break; &#125; &#125; cout&lt;&lt;a&lt;&lt;endl; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1005;long long quickpow(long long a, long long b, long long c)&#123; long long ans = 1; a = a % c; while(b) &#123; if(b &amp; 1) ans = ans * a % c; b &gt;&gt;= 1; a = a*a%c; &#125; return ans;&#125;int main()&#123; long long n, m; while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; long long ans = quickpow(n, m, 10); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDNU ACM-ICPC 2016-2017 Training Weekly Contest 1 【--完结--】]]></title>
    <url>%2Fsdnu-2017-1%2F</url>
    <content type="text"><![CDATA[题目链接：https://vjudge.net/contest/152755#overview A - Skip the ClassHDU - 6015 思路：贪一贪 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;struct ss&#123; string les; int val;&#125;;int cmp(ss x, ss y)&#123; if(x.les == y.les) return x.val &gt; y.val; return x.les &gt; y.les;&#125;int main()&#123; int t, n, ans, flag; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; map&lt;string, int&gt; qq; ss f[105]; ans = flag = 0; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) cin &gt;&gt; f[i].les &gt;&gt; f[i].val; sort(f, f+n, cmp); for(int i = 0; i &lt; n; ++i) &#123; //cout &lt;&lt; f[i].les &lt;&lt; endl; //cout &lt;&lt; f[i].val &lt;&lt; endl; qq[f[i].les]++; if(qq[f[i].les] &lt;= 2) ans += f[i].val; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; B - Count the SheepHDU - 6016 思维练习。（数据比较大，用cin会超时） 题意：有n只公羊和m只母羊，以及k个关系，k个关系为编号为x的公羊和编号为y的母羊是好朋友。问从任意一只羊开始沿着朋友关系数够4只羊的方法有多少种。 思路：可以把给出的关系构造成一个图来看，从任意一点出发，沿着关系网找到目标。拿第一个样例来说，（为方便观察把母羊编号为3和4）从公羊出发的不同方式为1324，1423，2314，2413共四种，同理，从母羊出发也是四种（把母羊看作1，2，把公羊看作3，4），到这里，我们能看出：从公羊出发的情况乘以二就是答案。而从公羊出发到不同母羊的情况数就等于（这个公羊的度-1）*（母羊的度-1）（度是指与这个点相连的点的个数）. AC代码：1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;const int maxn = 100005;LL a[maxn], b[maxn], na[maxn], nb[maxn];int main()&#123; int t; int n, m, k; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); memset(na, 0, sizeof(na)); memset(nb, 0, sizeof(nb)); for(int i = 0; i &lt; k; ++i) &#123; scanf("%lld%lld",&amp;a[i],&amp;b[i]); na[a[i]]++; nb[b[i]]++; &#125; LL sum = 0; for(int i = 0; i &lt; k; ++i) sum += (na[a[i]] - 1) * (nb[b[i]] - 1); printf("%lld\n",sum &lt;&lt; 1); &#125; return 0;&#125; C - Lotus and CharactersHDU - 6011 开始以为是不要负数，自始至终一直在这样做。看两队1A了，继续提交，继续WA。 这道题看完样例后很多人会和我一样误认为把负数都不算上才能得出最优解，其实不然。给出两组测试数据就知道了： 123 -1 3 2 1 1 1 答案:82 -1 5 4 2 答案:27 正确的做法是把所有数据从大到小排序，然后从前往后加，直到新加的数小于0时停止相加。其实理解了就很简单。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct ss&#123; int val; int amo;&#125;;int cmp(ss x, ss y)&#123; return x. val &gt; y.val;&#125;int main()&#123; int t, n; long long cnt, ans; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; cnt = ans = 0; ss f[30]; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d%d",&amp;f[i].val, &amp;f[i].amo); sort(f, f+n, cmp); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; f[i].amo; ++j) &#123; cnt += f[i].val; if(cnt &lt; 0) break; ans += cnt; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; D - Lotus and HorticultureHDU - 6012 思维。 在温室里种花，给出n朵花的适宜生长温度，如果温室温度在这范围内的话，成熟后的每朵花价值为a，高于所给温度，价值为b，低于所给温度，价值为c。问需要让温室温度为多少才能获得最大价值。 一开始让室内温度为-inf,此时答案为∑c，然后模拟温度上升，不断更新最大价值，直到达到所给的最大温度。 这个过程可以用map来实现，first为温度，second为价值。 （这里的温度可以是实数，所以用到了点小技巧：让温度都扩大两倍避免了出现小数的情况） AC代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;typedef long long LL;const int maxn = 50005;int main()&#123; int t, n; int l, r, x, y, z; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); map&lt;int, LL&gt; s; while(n--) &#123; scanf("%d%d%d%d%d",&amp;l,&amp;r,&amp;x,&amp;y,&amp;z); s[0] += z; s[l * 2] += x - z; s[r * 2 + 1] += y - x; &#125; LL ans = 0; LL tem = 0; for(map&lt;int,LL&gt;::iterator it = s.begin(); it != s.end(); ++it) &#123; tem += it -&gt; second; ans = max(ans, tem); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; E - The Third Cup is FreeHDU - 5999 一眼看出是贪心，然后全部浏览完一遍题目后，把这道题敲完交上，9minA了全场第一题。 AC代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int a[100005];int main()&#123; int t, n, ans, flag, cou = 0; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; ans = flag = 0; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); sort(a, a+n); for(int i = n-1; i &gt;= 0; --i) &#123; if(flag == 2) &#123; flag = 0; continue; &#125; flag++; ans += a[i]; &#125; printf("Case #%d: ",++cou); cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; F - Pseudoprime numbersHDU - 1905 数论。 题目解法：先判断p是不是合数，是的话再判断a的p次方%p是否等于a，是输出yes，否输出no，简单地题套个快速幂模板一套带走.. AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;long long quickpow(long long a, long long b, long long c)&#123; long long ans = 1; a = a % c; while(b) &#123; if(b &amp; 1) ans = ans * a % c; b &gt;&gt;= 1; a = a*a % c; &#125; return ans;&#125;int main()&#123; int flag; long long a, p; while(~scanf("%lld%lld",&amp;p,&amp;a) &amp;&amp; (a || p)) &#123; flag = 0; for(int i = 2; i * i &lt; p; ++i) if(p % i == 0) &#123; flag = 1; break; &#125; if(flag == 0) cout &lt;&lt; "no" &lt;&lt; endl; else &#123; long long tem = quickpow(a, p, p); //cout &lt;&lt; tem &lt;&lt; endl; if(tem == a) cout &lt;&lt; "yes" &lt;&lt; endl; else cout &lt;&lt; "no" &lt;&lt; endl; &#125; &#125; return 0;&#125; G - 小明系列问题――小明序列HDU - 4521 最长上升子序列的O(nlogn)算法。 AC代码： 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1e5 + 10;int a[MAX], b[MAX], DP[MAX];int n, m;int main()&#123; int ans; while(~scanf("%d%d",&amp;n, &amp;m)) &#123; ans = 1; fill(DP, DP + MAX, INF); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;a[i]); b[i] = 1; &#125; for(int i = m; i &lt; n; ++i) &#123; b[i] = lower_bound(DP, DP + MAX, a[i]) - DP + 1; if(b[i] &gt; ans) ans = b[i]; if(DP[b[i-m]-1] &gt; a[i-m]) DP[b[i-m]-1] = a[i-m]; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; H - Doing Homework againHDU - 1789 上学期，江西师范新生赛见过这道题，当时排序是按的时间优先，后来看题解知道应该分数优先。这也是道贪心哦。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 1005;int a[10005];struct node&#123; int sco, ded;&#125;;int cmp(node x, node y)&#123; if(x.sco == y.sco) return x.ded &lt; y.ded; return x.sco &gt; y.sco;&#125;int main()&#123; int t, n; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; node f[maxn]; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;f[i].ded); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;f[i].sco); sort(f, f+n, cmp); int ans = 0; memset(a, 0, sizeof(a)); for(int i = 0; i &lt; n; ++i) &#123; int tem; for(tem = f[i].ded; tem &gt; 0; --tem) &#123; if(a[tem] == 0) &#123; a[tem] = 1; break; &#125; &#125; if(tem == 0) ans += f[i].sco; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; I - 敌兵布阵HDU - 1166 这个以为是模拟，结果TLE，赛后得知要用线段树或树状数组，会了的话这就是道裸题。 【补】AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 50010;long long ans;struct node&#123; int l, r; int sum;&#125; tree[MAX&lt;&lt;2];void pushup(int rt)&#123; tree[rt].sum = tree[rt&lt;&lt;1].sum + tree[rt&lt;&lt;1|1].sum;&#125;void build(int l, int r, int rt)&#123; tree[rt].l = l; tree[rt].r = r; tree[rt].sum = 0; if(l == r) //叶子结点 &#123; scanf("%d",&amp;tree[rt].sum); return ; &#125; int mid = (l+r)&gt;&gt;1; //递归建树 build(l, mid, rt&lt;&lt;1); build(mid+1, r, rt&lt;&lt;1|1); pushup(rt);&#125;void update(int pos, int val, int rt)&#123; //更新这个区间的值 if(tree[rt].l == tree[rt].r) &#123; tree[rt].sum += val; return ; &#125; int mid = (tree[rt].l+tree[rt].r)&gt;&gt;1; if(pos &lt;= mid) update(pos, val, rt&lt;&lt;1); else update(pos, val, rt&lt;&lt;1|1); pushup(rt);&#125;void query(int x, int y, int rt)&#123; if(x == tree[rt].l &amp;&amp; y == tree[rt].r) &#123; ans += tree[rt].sum; return ; &#125; int mid = (tree[rt].l+tree[rt].r)&gt;&gt;1; if(y &lt;= mid) query(x, y, rt&lt;&lt;1); else if(x &gt; mid) query(x, y, rt&lt;&lt;1|1); else &#123; query(x, mid, rt&lt;&lt;1); query(mid+1, y, rt&lt;&lt;1|1); &#125;&#125;int main()&#123; int T; int n, pos, val; string s; scanf("%d",&amp;T); for(int cas = 1; cas &lt;= T; ++cas) &#123; printf("Case %d:\n",cas); scanf("%d",&amp;n); build(1, n, 1); while(cin &gt;&gt; s) &#123; if(s == "End") break; scanf("%d%d",&amp;pos,&amp;val); if(s == "Add") &#123; update(pos, val, 1); &#125; else if(s == "Sub") &#123; update(pos, -val, 1); &#125; else if(s == "Query") &#123; ans = 0; int x = pos; int y = val; if(x &gt; y) swap(x, y); query(x, y, 1); cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>解题报告</tag>
        <tag>SDNU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第四章习题】【10/10】]]></title>
    <url>%2Flrj-ch4-1%2F</url>
    <content type="text"><![CDATA[UVa 1589 Xiangqi【模拟】题目大意：给出一个象棋残局，按照象棋规则，此时红方已被“将军”，判断红方是否已被“将死”。 解题思路：模拟黑方所有棋子下一步可能走的位置，将这些位置进行标记。之后枚举红方的帥能走的每一个位置，看是否有一个没被标记的位置。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1005;int dir[][2] = &#123;0,1,1,0,-1,0,0,-1&#125;;struct node&#123; char ch; int x, y;&#125;;bool check(char ch) //没棋子是真&#123; if(ch == 'G') return false; if(ch == 'H') return false; if(ch == 'R') return false; if(ch == 'C') return false; return true;&#125;char mapa[25][25];bool mmpa[25][25];int main()&#123; //int cas = 0; int t, n, m; bool flag; while(cin &gt;&gt; t &gt;&gt; n &gt;&gt; m &amp;&amp; (t||n||m)) &#123; //cout &lt;&lt; "case:" &lt;&lt; cas++ &lt;&lt; endl; node ss[10]; bool flag = false; memset(mapa, 0, sizeof(mapa)); memset(mmpa, 0, sizeof(mmpa)); for(int i = 0; i &lt; t; ++i) &#123; cin &gt;&gt; ss[i].ch &gt;&gt; ss[i].x &gt;&gt; ss[i].y; mapa[ss[i].x][ss[i].y] = ss[i].ch; &#125; for(int ii = 0; ii &lt; t; ++ii) //标记棋盘将不能到达的位置 &#123; //cout &lt;&lt; ss[ii].ch &lt;&lt; endl; if(ss[ii].ch == 'R')//车 &#123; for(int i = ss[ii].x-1; i &gt; 0; --i) //Up &#123; mmpa[i][ss[ii].y] = true; if(!check(mapa[i][ss[ii].y])) break; &#125; for(int i = ss[ii].x+1; i &lt; 11; ++i) //Down &#123; mmpa[i][ss[ii].y] = true; if(!check(mapa[i][ss[ii].y])) break; &#125; for(int i = ss[ii].y-1; i &gt; 0; --i) //Left &#123; mmpa[ss[ii].x][i] = true; if(!check(mapa[ss[ii].x][i])) break; &#125; for(int i = ss[ii].y+1; i &lt; 11; ++i) //Right &#123; mmpa[ss[ii].x][i] = true; if(!check(mapa[ss[ii].x][i])) break; &#125; &#125; if(ss[ii].ch == 'C') //炮 &#123; flag = false; for(int i = ss[ii].x-1; i &gt; 0; --i) //Up &#123; if(!check(mapa[i][ss[ii].y])) &#123; if(flag) break;//&#123;mmpa[i][ss[ii].y] = true;break;&#125; flag = true; &#125; if(flag) mmpa[i-1][ss[ii].y] = true; //mmpa[i][ss[ii].y] = true; &#125; flag = false; for(int i = ss[ii].x+1; i &lt; 11; ++i) //Down &#123; if(!check(mapa[i][ss[ii].y])) &#123; if(flag) break;//&#123;mmpa[i][ss[ii].y] = true;break;&#125; flag = true; &#125; if(flag) mmpa[i+1][ss[ii].y] = true; //mmpa[i][ss[ii].y] = true; &#125; flag = false; for(int i = ss[ii].y-1; i &gt; 0; --i) //Left &#123; if(!check(mapa[ss[ii].x][i])) &#123; if(flag) break;//&#123; mmpa[ss[ii].x][i] = true;break;&#125; flag = true; &#125; if(flag) mmpa[ss[ii].x][i-1] = true; //mmpa[ss[ii].x][i] = true; &#125; flag = false; for(int i = ss[ii].y+1; i &lt; 10; ++i) //Right &#123; if(!check(mapa[ss[ii].x][i])) &#123; if(flag) break;//&#123;mmpa[ss[ii].x][i] = true;break;&#125; flag = true; &#125; if(flag) mmpa[ss[ii].x][i+1] = true; //mmpa[ss[ii].x][i] = true; &#125; &#125; if(ss[ii].ch == 'H') //马 &#123; if(check(mapa[ss[ii].x-1][ss[ii].y])) &#123;// mmpa[ss[ii].x-1][ss[ii].y+2] = true;// mmpa[ss[ii].x-1][ss[ii].y-2] = true; if(ss[ii].x-2 &gt; 0) &#123; if(ss[ii].y-1 &gt; 0) mmpa[ss[ii].x-2][ss[ii].y-1] = true; mmpa[ss[ii].x-2][ss[ii].y+1] = true; &#125; &#125; if(check(mapa[ss[ii].x+1][ss[ii].y])) &#123;// mmpa[ss[ii].x+1][ss[ii].y+2] = true;// mmpa[ss[ii].x+1][ss[ii].y-2] = true; if(ss[ii].y-1 &gt; 0) mmpa[ss[ii].x+2][ss[ii].y-1] = true; mmpa[ss[ii].x+2][ss[ii].y+1] = true; &#125; if(check(mapa[ss[ii].x][ss[ii].y+1])) &#123;// mmpa[ss[ii].x-2][ss[ii].y+1] = true;// mmpa[ss[ii].x+2][ss[ii].y+1] = true; if(ss[ii].x-1 &gt; 0) mmpa[ss[ii].x-1][ss[ii].y+2] = true; mmpa[ss[ii].x+1][ss[ii].y+2] = true; &#125; if(check(mapa[ss[ii].x][ss[ii].y-1])) &#123;// mmpa[ss[ii].x-2][ss[ii].y-1] = true;// mmpa[ss[ii].x+2][ss[ii].y-1] = true; if(ss[ii].y-2 &gt; 0) &#123; if(ss[ii].x-1 &gt; 0) mmpa[ss[ii].x-1][ss[ii].y-2] = true; mmpa[ss[ii].x+1][ss[ii].y-2] = true; &#125; &#125; &#125; if(ss[ii].ch == 'G') //帅 &#123; //cout &lt;&lt; ss[ii].x &lt;&lt; "---" &lt;&lt; ss[ii].y &lt;&lt; endl; for(int i = ss[ii].x-1; i &gt; 0; --i) //上 &#123; mmpa[i][ss[ii].y] = true; if(!check(mapa[i][ss[ii].y])) break; //cout &lt;&lt; i &lt;&lt; "--" &lt;&lt; ss[ii].y &lt;&lt; endl; &#125; &#125; //cout &lt;&lt; ss[ii].ch &lt;&lt; endl; &#125; bool ans = false; //将可以到达的位置 for(int i = 0; i &lt; 4; ++i) &#123; int xx = n + dir[i][0]; int yy = m + dir[i][1]; if(xx &lt; 1 || xx &gt; 3 || yy &lt; 4 || yy &gt; 6) continue; //越界continue// if(!check(mapa[xx][yy])) continue; //有棋子continue if(!mmpa[xx][yy]) ans = true; &#125; if(!mmpa[n][m]) ans = true; /*puts(""); puts("棋盘"); for(int q = 1; q &lt; 10; ++q) &#123; for(int w = 1; w &lt; 12; ++w) &#123; cout &lt;&lt; mmpa[q][w] &lt;&lt; " "; &#125; puts(""); &#125;*/ if(!ans) puts("YES"); else puts("NO"); //puts(""); &#125; return 0;&#125; 对拍Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; srand(time(NULL)); int maxn = 6, cou = 0; int dir[11][10]; const char s0[] = "RRCCHH"; //for(int s = 3; s &gt;= 1; --s) for(int s = (1&lt;&lt;maxn) - 1; s &gt;= 1; --s) &#123; for(int num = 1; num; num--) &#123; memset(dir, 0, sizeof(dir)); int n = 0, is = 0; int r0 = 1 + rand()%3, c0 = 4+rand()%3; dir[r0][r0] = 1; int r1 = 8 + rand()%3, c1 = 4 + rand()%3; while(c0 == c1) c1 = 4 + rand()%3; dir[r1][c1] = 1; for(int i = 0; i &lt; maxn; ++i) if(s &amp; (1&lt;&lt;i)) n++; printf("\n%d %d %d\nG %d %d\n",n+1,r0,c0,r1,c1); cou++; for(int i = 0; i &lt; maxn; ++i) if(s &amp; (1&lt;&lt;i)) &#123; int r = 1+rand()%10, c = 1+rand()%9; if(is == 0 &amp;&amp; s0[i] != 'C') &#123; if(s0[i] != 'H') &#123; r = r0 +1; c = c0; &#125; else &#123; r = r0+2; c = c0+1; &#125; is = 1; &#125; else &#123; while(dir[r][c]) &#123; r = 1+rand()%10; c = 1+rand()%9; &#125; &#125; dir[r][c] = 1; printf("%c %d %d\n",s0[i], r, c); &#125; &#125; &#125; printf("0 0 0\n"); return 0;&#125; UVa 201 Squares【模拟】题目大意：在n行n列的小黑点中，用m条线段将这些黑点进行连接，按照边长统计这些线段构成了多少个正方形。 解题思路：因为数据范围很小，我直接用四维数组存下了任意两点之间是否有线段将其连接。最后遍历每个顶点，记录以当前顶点为正方形的左上角边长为k的正方形是否存在。 PS：其实完全可以用二维数组做出来的。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;map&lt;int,int&gt; a;bool xx[10][10][10][10];bool yy[10][10][10][10];int main()&#123; int n, _; char op; int x, y, cas = 0; while(cin &gt;&gt; n &gt;&gt; _) &#123; if(cas) puts("\n**********************************\n"); a.clear(); memset(xx, false, sizeof(xx)); memset(yy, false, sizeof(yy)); while(_--) &#123; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if(op == 'H') xx[x][y][x][y+1] = true; else yy[y][x][y+1][x] = true; &#125; /*for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) cout &lt;&lt; xx[i][j] &lt;&lt; " "; puts(""); &#125; puts(""); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) cout &lt;&lt; yy[i][j] &lt;&lt; " "; puts(""); &#125; puts("");*/ for(int i = 1; i &lt; n; ++i) &#123; for(int j = 1; j &lt; n; ++j) &#123; for(int k = 1; k &lt;= n; ++k) &#123; if(k + j &gt; n) break; if(k + i &gt; n) break; int q; for(q = i; q &lt; i+k; ++q) &#123; if(yy[q][j][q+1][j] == 0 || yy[q][j+k][q+1][j+k] == 0) break;// if(xx[q][j] == 0 || yy[q][j] == 0) break;// if(xx[q][j+k] == 0 || yy[q][j+k] == 0) break; &#125; if(q &lt; i+k) continue;; for(q = j; q &lt; j+k; ++q) &#123; if(xx[i][q][i][q+1] == 0 || xx[i+k][q][i+k][q+1] == 0) break;// if(xx[i][q] == 0 || yy[i][q] == 0) break;// if(xx[i+k][q] == 0 || yy[i+k][q] == 0) break; &#125; if(q &lt; j+k) continue;; //printf("i=%d j=%d k=%d\n",i,j,k); //cout &lt;&lt; k &lt;&lt; endl; if(!a.count(k)) a[k] = 0; ++a[k]; &#125; &#125; &#125; //cout &lt;&lt; "a.size=" &lt;&lt; a.size() &lt;&lt; endl; printf("Problem #%d\n\n",++cas); if(a.size()) &#123; for(auto it = a.begin(); it != a.end(); ++it) printf("%d square (s) of size %d\n", it-&gt;second,it-&gt;first); &#125; else puts("No completed squares can be found."); &#125; return 0;&#125; UVa 220 Othello【模拟】题目大意：模拟黑白棋的游戏进程。 PS：这里紫书上有点错误，就是给出的例子白旗有8个合法操作，书上少了(3,6)和(7,5)这两个位置(网站上的题面是正确的)。 解题思路：模块化一下程序，直接模拟就好了。 这里比较重要的模块是判断某个点放置某个棋子时是否合法，用变量为0和1来控制棋子的颜色，写完这个模块，其他的都很轻松了。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;string tem;int t, p, x, y; //p为1是W-白，0是B-黑char mapa[10][10];int dir[][2] = &#123;1,0,-1,0,1,1,1,-1,-1,1,-1,-1,0,1,0,-1&#125;;bool judge(int x, int y, int p)&#123; bool f1, f2; int xx, yy, dx, dy; char now = p ? 'W' : 'B'; char nex = p ? 'B' : 'W'; for(int i = 0; i &lt; 8; ++i) &#123; f1 = f2 = false; xx = x, yy = y; dx = dir[i][0], dy = dir[i][1]; while(1) &#123; xx += dx, yy += dy; if(mapa[xx][yy] == nex) f1 = true; else if(mapa[xx][yy] == now) &#123; f2 = true; break; &#125; else break; &#125; if(f1 &amp;&amp; f2) return true; &#125; return false;&#125;void legal(int p)&#123; int cnt = 0; for(int i = 1; i &lt;= 8; ++i) &#123; for(int j = 1; j &lt;= 8; ++j) &#123; if(mapa[i][j] != '-') continue; if(judge(i, j, p)) &#123; if(cnt) printf(" "); printf("(%d,%d)", i, j); ++cnt; &#125; &#125; &#125; if(cnt) puts(""); else puts("No legal move.");&#125;void update(int x, int y, int p)&#123; bool f1, f2; int xx, yy, dx, dy; char now = p ? 'W' : 'B'; char nex = p ? 'B' : 'W'; mapa[x][y] = now; for(int i = 0; i &lt; 8; ++i) &#123; f1 = f2 = false; xx = x, yy = y; dx = dir[i][0], dy = dir[i][1]; while(1) &#123; xx += dx, yy += dy; if(mapa[xx][yy] == nex) f1 = true; else if(mapa[xx][yy] == now) &#123; f2 = true; break; &#125; else break; &#125; if(f1 &amp;&amp; f2) &#123; for(int q = x + dx, w = y + dy; (q != xx || w != yy); q += dx, w += dy) mapa[q][w] = now; &#125; &#125;&#125;void out()&#123; int cnt1 = 0, cnt2 = 0; for(int i = 1; i &lt;= 8; ++i) &#123; for(int j = 1; j &lt;= 8; ++j) &#123; if(mapa[i][j] == 'B') cnt1++; if(mapa[i][j] == 'W') cnt2++; &#125; &#125; printf("Black - %2d White - %2d\n", cnt1, cnt2);&#125;int main()&#123; cin &gt;&gt; t; for(int cas = 1; cas &lt;= t; ++cas) &#123; if(cas &gt; 1) puts(""); for(int i = 1; i &lt;= 8; ++i) scanf("%s",mapa[i]+1); cin &gt;&gt; tem; p = (tem == "W"); while(cin &gt;&gt; tem &amp;&amp; tem != "Q") &#123; if(tem == "L") //L legal(p); else //Mxy &#123; x = tem[1] - '0'; y = tem[2] - '0'; if(!judge(x, y, p)) p ^= 1; update(x, y, p); out(); p ^= 1; &#125; &#125; for(int i = 1; i &lt;= 8; ++i) puts(mapa[i]+1); &#125; return 0;&#125; Uva 253 Cube painting【模拟】题目大意：给两个骰子，问他们是否等价。 解题思路：我直接找了个魔方标记了一下然后把所有情况都找出来了。太暴力了，我好菜啊。 PS：这样做的话要注意所有的if都是并列的，就是只要满足任意一种情况，答案就是TRUE。 MyCode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s, a, b; while(cin &gt;&gt; s) &#123; a = b = " "; for(int i = 0; i &lt; 6; ++i) a += s[i]; for(int i = 6; i &lt; 12; ++i) b += s[i]; bool flag = false; char ch = b[3]; char ca = b[4]; //cout &lt;&lt; ch &lt;&lt; "--" &lt;&lt; b[3] &lt;&lt; "--" &lt;&lt; a[6] &lt;&lt; endl; //cout &lt;&lt; ca &lt;&lt; "--" &lt;&lt; b[4] &lt;&lt; "--" &lt;&lt; a[1] &lt;&lt; endl; if(ch==a[1] &amp;&amp; ca==a[6]) &#123; if(b[1]==a[4] &amp;&amp; b[2]==a[2] &amp;&amp; b[5]==a[5] &amp;&amp; b[6]==a[3]) flag = true; if(b[1]==a[2] &amp;&amp; b[2]==a[3] &amp;&amp; b[5]==a[4] &amp;&amp; b[6]==a[5]) flag = true; if(b[1]==a[3] &amp;&amp; b[2]==a[5] &amp;&amp; b[5]==a[2] &amp;&amp; b[6]==a[4]) flag = true; if(b[1]==a[5] &amp;&amp; b[2]==a[4] &amp;&amp; b[5]==a[3] &amp;&amp; b[6]==a[2]) flag = true; &#125; if(ch==a[2] &amp;&amp; ca==a[5]) &#123; if(b[1]==a[1] &amp;&amp; b[2]==a[4] &amp;&amp; b[5]==a[3] &amp;&amp; b[6]==a[6]) flag = true; if(b[1]==a[3] &amp;&amp; b[2]==a[1] &amp;&amp; b[5]==a[6] &amp;&amp; b[6]==a[4]) flag = true; if(b[1]==a[4] &amp;&amp; b[2]==a[6] &amp;&amp; b[5]==a[1] &amp;&amp; b[6]==a[3]) flag = true; if(b[1]==a[6] &amp;&amp; b[2]==a[3] &amp;&amp; b[5]==a[4] &amp;&amp; b[6]==a[1]) flag = true; &#125; if(ch==a[3] &amp;&amp; ca==a[4]) &#123; if(b[1]==a[1] &amp;&amp; b[2]==a[2] &amp;&amp; b[5]==a[5] &amp;&amp; b[6]==a[6]) flag = true; if(b[1]==a[2] &amp;&amp; b[2]==a[6] &amp;&amp; b[5]==a[1] &amp;&amp; b[6]==a[5]) flag = true; if(b[1]==a[6] &amp;&amp; b[2]==a[5] &amp;&amp; b[5]==a[2] &amp;&amp; b[6]==a[1]) flag = true; if(b[1]==a[5] &amp;&amp; b[2]==a[1] &amp;&amp; b[5]==a[6] &amp;&amp; b[6]==a[2]) flag = true; &#125; if(ch==a[4] &amp;&amp; ca==a[3]) &#123; if(b[1]==a[1] &amp;&amp; b[2]==a[5] &amp;&amp; b[5]==a[2] &amp;&amp; b[6]==a[6]) flag = true; if(b[1]==a[5] &amp;&amp; b[2]==a[6] &amp;&amp; b[5]==a[1] &amp;&amp; b[6]==a[2]) flag = true; if(b[1]==a[6] &amp;&amp; b[2]==a[2] &amp;&amp; b[5]==a[5] &amp;&amp; b[6]==a[1]) flag = true; if(b[1]==a[2] &amp;&amp; b[2]==a[1] &amp;&amp; b[5]==a[6] &amp;&amp; b[6]==a[5]) flag = true; &#125; if(ch==a[5] &amp;&amp; ca==a[2]) &#123; if(b[1]==a[1] &amp;&amp; b[2]==a[3] &amp;&amp; b[5]==a[4] &amp;&amp; b[6]==a[6]) flag = true; if(b[1]==a[3] &amp;&amp; b[2]==a[6] &amp;&amp; b[5]==a[1] &amp;&amp; b[6]==a[4]) flag = true; if(b[1]==a[6] &amp;&amp; b[2]==a[4] &amp;&amp; b[5]==a[3] &amp;&amp; b[6]==a[1]) flag = true; if(b[1]==a[4] &amp;&amp; b[2]==a[1] &amp;&amp; b[5]==a[6] &amp;&amp; b[6]==a[3]) flag = true; &#125; if(ch==a[6] &amp;&amp; ca==a[1]) &#123; if(b[1]==a[2] &amp;&amp; b[2]==a[4] &amp;&amp; b[5]==a[3] &amp;&amp; b[6]==a[5]) flag = true; if(b[1]==a[4] &amp;&amp; b[2]==a[5] &amp;&amp; b[5]==a[2] &amp;&amp; b[6]==a[3]) flag = true; if(b[1]==a[5] &amp;&amp; b[2]==a[3] &amp;&amp; b[5]==a[4] &amp;&amp; b[6]==a[2]) flag = true; if(b[1]==a[3] &amp;&amp; b[2]==a[2] &amp;&amp; b[5]==a[5] &amp;&amp; b[6]==a[4]) flag = true; &#125; //cout &lt;&lt; a &lt;&lt; "---" &lt;&lt; b &lt;&lt; endl; if(flag) puts("TRUE"); else puts("FALSE"); &#125; return 0;&#125; UVa 1590 IP Networks【模拟】【位运算】题目大意：给出n个IP地址，求最小的网络包含所有的输入地址。 解题思路：因题目背景需要计算机网络的知识，所以理解起来可能比较难。但读懂题意后就是二进制和十进制的转换。 翻译一下就是将给出的点分十进制形式的IP地址转化为32位的二进制形式，找出他们前n项的二进制表示是一样的“公共前缀”，最小IP地址就是这前缀之后的二进制全改为0然后写成点分十进制的结果，子网掩码就是将这些前缀二进制表示全改成1后转化为点分十进制的结果。(表述能力有限，可自己查阅《计算机网络》这本书或者当♂面问我) MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int t;string ans, ipp;struct node&#123; int yi[5]; string yy[5];&#125;;string trans(int a)&#123; string aft = ""; while(a) &#123; if(a &amp; 1) aft = '1' + aft; else aft = '0' + aft; a &gt;&gt;= 1; &#125; while(aft.size() &lt; 8) aft = '0' + aft; return aft;&#125;void solve()&#123; int tem; for(int i = 0; i &lt; 4; ++i) &#123; tem = 0; for(int j = 0; j &lt; 8; ++j) &#123; tem += (1 &lt;&lt; (8-j-1)) * (ipp[i*8+j] - '0'); &#125; printf("%d", tem); printf("%c", i &lt; 3 ? '.' : '\n'); &#125; for(int i = 0; i &lt; 4; ++i) &#123; tem = 0; for(int j = 0; j &lt; 8; ++j) &#123; tem += (1 &lt;&lt; (8-j-1)) * (ans[i*8+j] - '0'); &#125; printf("%d", tem); printf("%c", i &lt; 3 ? '.' : '\n'); &#125;&#125;int main()&#123; while(cin &gt;&gt; t) &#123; node s[MAX]; for(int i = 0; i &lt; t; ++i) &#123; scanf("%d.%d.%d.%d",&amp;s[i].yi[0], &amp;s[i].yi[1], &amp;s[i].yi[2], &amp;s[i].yi[3]); for(int j = 0; j &lt; 4; ++j) s[i].yy[j] = trans(s[i].yi[j]); //cout &lt;&lt; s[i].yy &lt;&lt; " " &lt;&lt; s[i].ee &lt;&lt; " " &lt;&lt; s[i].aa &lt;&lt; " " &lt;&lt; s[i].ii &lt;&lt; endl; &#125; int pos = 32; for(int i = 0; i &lt; t; ++i) &#123; for(int j = i+1; j &lt; t; ++j) &#123; bool flag = true; for(int k = 0; k &lt; 4 &amp;&amp; flag; ++k) &#123; for(int q = 0; q &lt; 8; ++q) &#123; if(s[i].yy[k][q] != s[j].yy[k][q]) &#123; pos = min(pos, k*8 + q); flag = false; break; &#125; &#125; &#125; &#125; &#125; ans = ipp = "";// string ipp = ""; bool flag = true; for(int i = 0; i &lt; 4 &amp;&amp; flag; ++i) &#123; for(int j = 0; j &lt; 8; ++j) &#123; if(i*8 + j &gt;= pos) &#123; flag = false; break; &#125; ipp += s[0].yy[i][j]; &#125; &#125;// cout &lt;&lt; ipp &lt;&lt; endl;// string ans = ""; for(int i = 0; i &lt; pos; ++i) ans += '1'; for(int i = pos+1; i &lt;= 32; ++i) &#123; ans += '0'; ipp += '0'; &#125;// cout &lt;&lt; ans.size() &lt;&lt; endl;// cout &lt;&lt; ipp &lt;&lt; "-----" &lt;&lt; ans &lt;&lt; endl; solve(); &#125; return 0;&#125; UVa 508 Morse Mismatches【模拟】【map】题目大意：给出加密方式、待加密文本和加密文本，要你根据前两项内容输出加密文本代表的什么。如果精准匹配则直接输出；如果多个匹配则输出字典序最小的那个后加上!；如果无法匹配则选一个字典序最小的可能匹配的单词输出并在最后加个?，其中可能匹配指的是可以在编码尾部加上或删去若干字符。 (紫书上表述有误，多个单词精准匹配时输出字典序最小的，非精准匹配时也要输出字典序最小的可能匹配的单词) 解题思路：因为不同文本加密后可能是相同的密文，所以根据密文直接模拟找明文是无法实现的。因为我们已经知道了待加密文本，所以我们可以直接将待加密文本和它加密后的密文存起来，直接拿着这些密文和要求的密文作对比并记录。 因为map自动按照字典序排列了，所以前两种情况很容易实现。对于第三种情况直接拿map中的文本和要匹配的文本进行子序列判断也可以很容易实现。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;char a;string s;map&lt;char, string&gt; morse;map&lt;string, string&gt; context;void read_morse()&#123; while(1) &#123; cin &gt;&gt; a; if(a == '*') return ; cin &gt;&gt; s; morse[a] = s; &#125;&#125;string trans(string before)&#123; string after = ""; for(int i = 0; i &lt; before.size(); ++i) after += morse[before[i]]; return after;&#125;void read_context()&#123; while(1) &#123; cin &gt;&gt; s; if(s == "*") return ; context[s] = trans(s); &#125;&#125;void solve()&#123; string yy, tt; while(1) &#123; cin &gt;&gt; s; if(s == "*") return ; yy = ""; int flag = 0; for(auto it = context.begin(); it != context.end(); ++it) &#123; tt = it -&gt; second; if(tt == s) &#123; if(flag == 0) yy = it -&gt; first; ++flag; &#125; &#125; if(flag == 1) //精确匹配 cout &lt;&lt; yy &lt;&lt; endl; else if(flag &gt; 1) //! cout &lt;&lt; yy &lt;&lt; "!" &lt;&lt; endl; else //? &#123; int hh = INF; bool ok = false; bool is_first = true; for(auto it = context.begin(); it != context.end(); ++it) &#123; if(is_first) yy = it -&gt; first; is_first = false; tt = it -&gt; second; if(tt.size() &gt; s.size()) &#123; if(tt.find(s) == 0) &#123; if(tt.size() - s.size() &lt; hh) &#123; hh = tt.size() - s.size(); yy = it -&gt; first; ok = true; &#125; &#125; &#125; else if(tt.size() &lt; s.size()) &#123; if(s.find(tt) == 0) &#123; if(s.size() - tt.size() &lt; hh) &#123; hh = s.size() - tt.size(); yy = it -&gt; first; ok = true; &#125; &#125; &#125; &#125; cout &lt;&lt; yy &lt;&lt; "?" &lt;&lt;endl; &#125; &#125;&#125;int main()&#123; read_morse(); read_context(); solve(); return 0;&#125; UVa 509 RAID!【模拟】【位运算】题目大意：给出了一种磁盘保护技术，要你根据规则检验一下磁盘存储数据是否正确及能否恢复，如果可以输出存储的数据。 解题思路：先检验是否合法，如果大于1个x，一定不合法；若恰好一个x，则可以根据规则将这个x恢复出来；若没有x则直接将这些位进行异或操作看最终结果。确定合法后再讲二进制转化为16进制输出就可以了。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;char op;int jiou;int d, s, b;char mapa[10][MAX];char hexa[] = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;;string trans(string zz)&#123; int tot = 0; tot += (zz[0] - '0') * 8; tot += (zz[1] - '0') * 4; tot += (zz[2] - '0') * 2; tot += (zz[3] - '0') * 1; string ans = ""; ans += hexa[tot]; return ans;&#125;int main()&#123; int cas = 0; while(cin &gt;&gt; d &amp;&amp; d) &#123; cin &gt;&gt; s &gt;&gt; b; cin &gt;&gt; op; //1是奇校验，0是偶校验。 jiou = (op == 'O' ? 1 : 0); for(int i = 1; i &lt;= d; ++i) &#123; scanf("%s",mapa[i]+1); &#125; bool flag = true; for(int i = 1; i &lt;= s*b; ++i) &#123; int t = 0; int x = 0; int idx = 0; for(int j = 1; j &lt;= d; ++j) &#123; if(mapa[j][i] == 'x') &#123; ++x; idx = j; continue; &#125; t ^= (mapa[j][i] - '0'); &#125; if(x &gt; 1) &#123; flag = false; break; &#125; if(x == 1) &#123; if(t == jiou) mapa[idx][i] = '0'; else mapa[idx][i] = '1'; &#125; else //x==0 &#123; if(t != jiou) &#123; flag = false; break; &#125; &#125; &#125; if(!flag) printf("Disk set %d is invalid.\n", ++cas); else &#123; int temp = 0; for(int i = 1; i &lt;= b; ++i) &#123; int ii = i % d; if(ii == 0) ii = d; for(int j = 1; j &lt;= s; ++j) &#123; mapa[ii][j+temp] = '2'; &#125; temp += s; &#125; //d、s、b string stem = "", ans = ""; for(int i = 1; i &lt;= b*s; i += s) &#123; for(int j = 1; j &lt;= d; ++j) &#123; for(int k = 0; k &lt; s; ++k) &#123; if(mapa[j][k+i] == '2') continue; stem += mapa[j][k+i]; if(stem.size() == 4) &#123; ans += trans(stem); stem = ""; &#125; &#125; &#125; &#125; //不足位补0 if(stem.size()) &#123; int goal = 4 - stem.size(); while(goal--) stem += '0'; ans += trans(stem); &#125; printf("Disk set %d is valid, contents are: ", ++cas); cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; UVa 12108 Extraordinarily Tired Students【模拟】题目大意：给出n个学生的清醒-睡眠周期以及初始时他们所处的周期的哪个时间，当课堂上睡觉人数大于清醒人数时他就会睡觉，否则再听课A_i分钟后再观察一下。问经过多次时间后全班同学都处于清醒状态，或者不存在这种情况。 解题思路：直接模拟睡觉的过程。 MyCode：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 505;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int n, tot;bool slp[15];int a[15], b[15], c[15], pri[15];int main()&#123; int cas = 0; while(cin &gt;&gt; n &amp;&amp; n) &#123; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i]; pri[i] = a[i] + b[i]; slp[i] = (c[i] &gt; a[i]); &#125; int t = 1; bool f = false; while(t &lt; MAX) &#123; int awake = 0; int sleep = 0; for(int i = 0; i &lt; n; ++i) &#123; if(slp[i]) sleep++; else awake++; &#125; if(awake == n) &#123; f = true; break; &#125; for(int i = 0; i &lt; n; ++i) &#123; if(c[i] == a[i]) //判断是否要入睡 &#123; if(sleep &lt;= awake) //坚持听课a_i分钟再说 &#123; slp[i] = false; c[i] = 1; &#125; else //睡吧 &#123; slp[i] = true; c[i]++; &#125; &#125; else if(c[i] == pri[i]) //恰好一个周期结束 &#123; c[i] = 1; slp[i] = false; &#125; else //还在睡中 c[i]++; &#125; t++; &#125; if(f) printf("Case %d: %d\n", ++cas, t); else printf("Case %d: -1\n", ++cas); &#125; return 0;&#125; UVa 1591 Data Mining【模拟】题目大意：？？？ 解题思路：直接枚举AB的取值即可。 MyCode：1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;LL n, Sp, Sq, K, A, B, Pofs, tem;int main()&#123; while(cin &gt;&gt; n &gt;&gt; Sp &gt;&gt; Sq) &#123; K = Sq * n &lt;&lt; 10; Pofs = (n-1) * Sp; for(int a = 0; a &lt; 32; ++a) for(int b = 0; b &lt; 32; ++b) &#123; tem = ((Pofs + (Pofs &lt;&lt; a)) &gt;&gt; b) + Sq; if(tem &gt;= n * Sq &amp;&amp; tem &lt; K) &#123; K = tem; A = a; B = b; &#125; &#125; cout &lt;&lt; K &lt;&lt; " " &lt;&lt; A &lt;&lt; " " &lt;&lt; B &lt;&lt; endl; &#125; return 0;&#125; UVa 815 Flooded!【模拟】【二分】题目大意：输入一个n x m的网格及每个格子的高度，每个格子都是边长为10m的正方形，网格四周是无限大的墙壁。给你网格内雨水的总体积，输出水位的海拔及多少百分比的区域有水。 解题思路：雨水分布只与网格高度有关，和其位置分布无关，因此我们可以将网格按照高度从小到大排序后，看雨水能淹没到哪里。当无法全部淹没时找到恰好无法淹没的那个位置，根据它的高度来二分枚举最终水位的高度。 MyCode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;const double eps = 1e-8;double a[MAX];int main()&#123; int n, m; int cas = 0, tot, num; double wat, res, tem, ans; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; m) &#123; tot = 0; n *= m; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; sort(a, a+n); cin &gt;&gt; wat; wat /= 100; num = -1; tem = 0; for(int i = 1; i &lt; n; ++i) &#123; tem += (a[i] - a[i-1])*i; //cout &lt;&lt;tem &lt;&lt; endl; if(tem &gt;= wat) &#123; //cout &lt;&lt; tem &lt;&lt; endl; num = i; break; &#125; &#125; if(num == -1) //全部淹没 &#123; ans = a[n-1] + (wat - tem)/n; tot = n; //cout &lt;&lt; ans &lt;&lt;endl; &#125; else &#123; tem -= (a[num]-a[num-1])*num; double l = a[num-1], r = a[num]; double hh = l; while(r-l &gt; eps) &#123; double mid = (r+l)/2; //cout &lt;&lt; mid &lt;&lt; "==" &lt;&lt; tem + (mid-hh)*num &lt;&lt; endl; if(tem + (mid-hh)*num &gt; wat) r = mid; else l = mid; //cout &lt;&lt; r &lt;&lt; "--" &lt;&lt; l &lt;&lt; endl; &#125; ans = l; for(int i = 0; i &lt; n; ++i) &#123; if(a[i] &lt; ans) tot++; &#125; &#125; res = 100.0 * tot / n; printf("Region %d\n",++cas); printf("Water level is %.2f meters.\n",ans); printf("%.2f percent of the region is under water.\n",res); puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>解题报告</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>函数和递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第四章例题】【6/6】]]></title>
    <url>%2Flrj-ch4-0%2F</url>
    <content type="text"><![CDATA[UVa 1339 Ancient Cipher【排序】1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 111;const int M = 26;int a[M], b[M];char s1[N], s2[N];int main()&#123; while(~scanf("%s%s", s1, s2)) &#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for(int i = 0; s1[i]; ++i) ++a[s1[i] - 'A']; for(int i = 0; s2[i]; ++i) ++b[s2[i] - 'A']; sort(a, a + M); sort(b, b + M); bool flag = true; for(int i = 0; i &lt; M; ++i) if(a[i] != b[i]) flag = false; puts(flag ? "YES" : "NO"); &#125; return 0;&#125; UVa 489 Hangman Judge【模拟】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 111;bool win, lose;char s1[N], s2[N];int cas, chance, leftt, len1, len2;void guess(char ch)&#123; bool flag = true; for(int i = 0; i &lt; len1; ++i) &#123; if(s1[i] == ch) &#123; --leftt; s1[i] = ' '; flag = false; &#125; &#125; if(flag) --chance; if(!chance) lose = 1; if(!leftt) win = 1;&#125;int main()&#123; while(scanf("%d%s%s", &amp;cas, s1, s2) == 3 &amp;&amp; cas != -1) &#123; len1 = strlen(s1); len2 = strlen(s2); leftt = len1; chance = 7; win = lose = false; for(int i = 0; i &lt; len2; ++i) &#123; guess(s2[i]); if(win || lose) break; &#125; printf("Round %d\n", cas); if(win) puts("You win."); else if(lose) puts("You lose."); else puts("You chickened out."); &#125; return 0;&#125; UVa 133 The Dole Queue【模拟】(自己写的太丑了，不好意思贴出来) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// UVa133 The Dole Queue// Rujia Liu#include&lt;stdio.h&gt;#define maxn 25int n, k, m, a[maxn];// 逆时针走t步，步长是d（-1表示顺时针走），返回新位置int go(int p, int d, int t)&#123; while(t--) &#123; do &#123; p = (p+d+n-1) % n + 1; &#125; while(a[p] == 0); // 走到下一个非0数字 &#125; return p;&#125;int main()&#123; while(scanf("%d%d%d", &amp;n, &amp;k, &amp;m) == 3 &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; i++) a[i] = i; int left = n; // 还剩下的人数 int p1 = n, p2 = 1; while(left) &#123; p1 = go(p1, 1, k); p2 = go(p2, -1, m); printf("%3d", p1); left--; if(p2 != p1) &#123; printf("%3d", p2); left--; &#125; a[p1] = a[p2] = 0; if(left) printf(","); &#125; printf("\n"); &#125; return 0;&#125; UVa 213 Message Decoding【模拟】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int readchar()&#123; while(1) &#123; int ch = getchar(); if(ch != '\n' &amp;&amp; ch != '\r') return ch; &#125;&#125;int readint(int c)&#123; int v = 0; while(c--) v = v * 2 + readchar() - '0'; return v;&#125;int code[8][1&lt;&lt;8];int readcodes()&#123; memset(code, 0, sizeof(code)); code[1][0] = readchar(); for(int len = 2; len &lt;= 7; ++len) &#123; for(int i = 0; i &lt; (1 &lt;&lt; len) - 1; ++i) &#123; int ch = getchar(); if(ch == EOF) return 0; if(ch == '\n' || ch == '\r') return 1; code[len][i] = ch; &#125; &#125; return 1;&#125;void printcodes()&#123; for(int len = 1; len &lt;= 7; ++len) for(int i = 0; i &lt; (1 &lt;&lt; len)-1; ++i) &#123; if(code[len][i] == 0) return ; printf("code[%d][%d] = %c\n", len, i, code[len][i]); &#125;&#125;int main()&#123; while(readcodes()) &#123;// printcodes(); while(1) &#123; int len = readint(3); if(len == 0) break;// printf("len=%d\n", len); while(1) &#123; int v = readint(len);// printf("v=%d\n", v); if(v == (1 &lt;&lt; len) - 1) break; putchar(code[len][v]); &#125; &#125; puts(""); &#125; return 0;&#125; UVa 512 Spreadsheet Tracking【模拟】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;struct node&#123; char com[5]; int x1, y1, x2, y2; int a, x[25];&#125; cmd[MAX];int xx, yy;int r, c, n;int solve(int x, int y)&#123; xx = x, yy = y; for(int i = 0; i &lt; n; ++i) &#123; int dr = 0, dc = 0; if(cmd[i].com[0] == 'E') &#123; if(cmd[i].x1 == xx &amp;&amp; cmd[i].y1 == yy) &#123; xx = cmd[i].x2; yy = cmd[i].y2; &#125; else if(cmd[i].x2 == xx &amp;&amp; cmd[i].y2 == yy) &#123; xx = cmd[i].x1; yy = cmd[i].y1; &#125; &#125; else &#123; for(int j = 0; j &lt; cmd[i].a; ++j) &#123; int x = cmd[i].x[j]; if(cmd[i].com[0] == 'I') //插入 &#123; if(cmd[i].com[1] == 'R' &amp;&amp; x &lt;= xx) dr++; if(cmd[i].com[1] == 'C' &amp;&amp; x &lt;= yy) dc++; &#125; else //删除 &#123; if(cmd[i].com[1] == 'R' &amp;&amp; x == xx) return 0; if(cmd[i].com[1] == 'C' &amp;&amp; x == yy) return 0; if(cmd[i].com[1] == 'R' &amp;&amp; x &lt; xx) dr--; if(cmd[i].com[1] == 'C' &amp;&amp; x &lt; yy) dc--; &#125; &#125; &#125; xx += dr; yy += dc; &#125; return 1;&#125;int main()&#123; int cas = 0; while(cin &gt;&gt; r &gt;&gt; c &amp;&amp; r) &#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; cmd[i].com; if(cmd[i].com[0] == 'E') cin &gt;&gt; cmd[i].x1 &gt;&gt; cmd[i].y1 &gt;&gt; cmd[i].x2 &gt;&gt; cmd[i].y2; else &#123; cin &gt;&gt; cmd[i].a; for(int j = 0; j &lt; cmd[i].a; ++j) cin &gt;&gt; cmd[i].x[j]; &#125; &#125; if(cas) puts(""); printf("Spreadsheet #%d\n", ++cas); int q, x, y; cin &gt;&gt; q; while(q--) &#123; cin &gt;&gt; x &gt;&gt; y; printf("Cell data in (%d,%d) ", x, y); if(!solve(x, y)) printf("GONE"); else printf("moved to (%d,%d)", xx, yy); puts(""); &#125; &#125; return 0;&#125; UVa 12412 A Typical Homework (a.k.a Shi Xiong Bang Bang Mang)【模拟】题目大意：编写一个成绩管理系统，对应的每次输入都作出相应的回复。 解题思路：直接模拟即可，有很多细节要注意。 注意细节：1.计算平均分的时候要注意一下精度问题。为防止精度丢失，我在每个计算出的精度后面都加上了eps(1e-5)。2.计算rank时，不要忘记考虑并列的情况。（如果有两个学生成绩并列第一，那么除他们外最高分就是第三名）。3.当从主菜单输入4时，只返回一句话，那句话中的 ‘ 应该是英文的，直接从描述中复制过来是中文的。4.看到有些博客中写到要防止除0的情况发生。我的程序中除0就是在求单科ave时可能出现的，但是经过测试，数据中并没有这种情况，所以可以不必考虑。 【注】以上就是我出现的错误，其他的细节都是很好发现的了。如果没出现这些错误但是你还过不了的话，不要着急，再仔细想想哪些细节出了问题，或者是私信/留言给我，作为一个在这上面WA到怀疑XX之后还坚持不懈最终A了这道题的快乐的咸鱼，我会乐意帮助你的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10005;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;const double eps = 1e-5; int op, tot;struct node&#123; int chi, mat, eng, pro, sum, rk; //四课分数 string SID, CID, name; double ave; bool flag; int pas; &#125; a[MAX]; bool cmp(int A, int B)&#123; return A &gt; B;&#125; void hello()&#123; puts("Welcome to Student Performance Management System (SPMS)."); puts(""); puts("1 - Add"); puts("2 - Remove"); puts("3 - Query"); puts("4 - Show ranking"); puts("5 - Show Statistics"); puts("0 - Exit"); puts("");&#125; void work1()&#123; string si, ci, na; int c, m, e, p; while(1) &#123; puts("Please enter the SID, CID, name and four scores. Enter 0 to finish."); cin &gt;&gt; si; if(si == "0") return ; cin &gt;&gt; ci &gt;&gt; na &gt;&gt; c &gt;&gt; m &gt;&gt; e &gt;&gt; p; bool f = true; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; a[i].SID == si) &#123; puts("Duplicated SID."); f = false; break; &#125; &#125; if(f) &#123; a[tot].SID = si; a[tot].CID = ci; a[tot].name = na; a[tot].chi = c; a[tot].eng = e; a[tot].mat = m; a[tot].pro = p; a[tot].sum = c + e + m + p; a[tot].ave = (c + e + m + p) / 4.0 + eps; a[tot].flag = true; ++tot; &#125; &#125;&#125; void work2()&#123; string tt; while(1) &#123; puts("Please enter SID or name. Enter 0 to finish."); cin &gt;&gt; tt; if(tt == "0") return ; int cnt = 0; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag) &#123; if(a[i].name == tt || a[i].SID == tt) &#123; a[i].flag = false; cnt++; &#125; &#125; &#125; printf("%d student(s) removed.\n", cnt); &#125;&#125; void work3()&#123; //每次查询都计算一下rank int tem[MAX], rrk[MAX], srk = 1, now = 0; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag) tem[now++] = a[i].sum; &#125; sort(tem, tem + now, cmp); rrk[0] = 1; srk++; for(int i = 1; i &lt; now; ++i) &#123; if(tem[i] != tem[i-1]) rrk[i] = srk; else rrk[i] = rrk[i-1]; ++srk; &#125; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag) &#123; for(int t = 0; t &lt; now; ++t) &#123; if(a[i].sum == tem[t]) &#123; a[i].rk = rrk[t]; break; &#125; &#125; &#125; &#125; string tt; while(1) &#123; puts("Please enter SID or name. Enter 0 to finish."); cin &gt;&gt; tt; if(tt == "0") return ; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; (a[i].SID == tt || a[i].name == tt)) &#123; cout &lt;&lt; a[i].rk &lt;&lt; " " &lt;&lt; a[i].SID &lt;&lt; " " &lt;&lt; a[i].CID &lt;&lt; " " &lt;&lt; a[i].name; printf(" %d %d %d %d %d %.2f\n", a[i].chi, a[i].mat, a[i].eng, a[i].pro, a[i].sum, a[i].ave); &#125; &#125; &#125;&#125; void work4()&#123; puts("Showing the ranklist hurts students' self-esteem. Don't do that."); return ;&#125; void work5()&#123; puts("Please enter class ID, 0 for the whole statistics."); string tt; cin &gt;&gt; tt; int pas, fai, yy[5], qq; double suma, cnta, avea; puts("Chinese"); suma = cnta = pas = fai = 0; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; (a[i].CID == tt || tt == "0")) &#123; ++cnta; suma += a[i].chi; if(a[i].chi &gt;= 60) ++pas; else ++fai; &#125; &#125; if(cnta == 0) avea = 0; else avea = suma / cnta + eps; printf("Average Score: %.2f\n", avea); printf("Number of passed students: %d\n", pas); printf("Number of failed students: %d\n", fai); puts(""); puts("Mathematics"); suma = cnta = pas = fai = 0; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; (a[i].CID == tt || tt == "0")) &#123; ++cnta; suma += a[i].mat; if(a[i].mat &gt;= 60) ++pas; else ++fai; &#125; &#125; if(cnta == 0) avea = 0; else avea = suma / cnta + eps; printf("Average Score: %.2f\n", avea); printf("Number of passed students: %d\n", pas); printf("Number of failed students: %d\n", fai); puts(""); puts("English"); suma = cnta = pas = fai = 0; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; (a[i].CID == tt || tt == "0")) &#123; ++cnta; suma += a[i].eng; if(a[i].eng &gt;= 60) ++pas; else ++fai; &#125; &#125; if(cnta == 0) avea = 0; else avea = suma / cnta + eps; printf("Average Score: %.2f\n", avea); printf("Number of passed students: %d\n", pas); printf("Number of failed students: %d\n", fai); puts(""); puts("Programming"); suma = cnta = pas = fai = 0; for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; (a[i].CID == tt || tt == "0")) &#123; ++cnta; suma += a[i].pro; if(a[i].pro &gt;= 60) ++pas; else ++fai; &#125; &#125; if(cnta == 0) avea = 0; else avea = suma / cnta + eps; printf("Average Score: %.2f\n", avea); printf("Number of passed students: %d\n", pas); printf("Number of failed students: %d\n", fai); puts(""); memset(yy, 0, sizeof(yy)); puts("Overall:"); for(int i = 0; i &lt; tot; ++i) &#123; if(a[i].flag &amp;&amp; (a[i].CID == tt || tt == "0")) &#123; qq = (a[i].chi &gt;= 60) + (a[i].eng &gt;= 60) + (a[i].pro &gt;= 60) + (a[i].mat &gt;= 60); yy[qq]++; &#125; &#125; printf("Number of students who passed all subjects: %d\n", yy[4]); printf("Number of students who passed 3 or more subjects: %d\n", yy[4] + yy[3]); printf("Number of students who passed 2 or more subjects: %d\n", yy[4] + yy[3] + yy[2]); printf("Number of students who passed 1 or more subjects: %d\n", yy[4] + yy[3] + yy[2] + yy[1]); printf("Number of students who failed all subjects: %d\n", yy[0]); puts("");&#125; int main()&#123; hello(); while(cin &gt;&gt; op &amp;&amp; op) &#123; if(op == 1) work1(); else if(op == 2) work2(); else if(op == 3) work3(); else if(op == 4) work4(); else if(op == 5) work5(); hello(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>解题报告</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>函数和递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第三章习题】【12/12】]]></title>
    <url>%2Flrj-ch3-1%2F</url>
    <content type="text"><![CDATA[UVa 1585 Score 【字符串】【模拟】【基础】题目大意：给定一个由O和X组成的字符串，每个O都有一定的分数，是目前连续出现的O的个数，问这个字符串的得分是多少。 解题思路：直接做。 Mycode：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, res, tem;string s;int main()&#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; s; res = 0; tem = 0; for(int i = 0; i &lt; s.size(); ++i) &#123; if(s[i] == 'O') ++tem; else tem = 0; res += tem; &#125; cout &lt;&lt; res &lt;&lt; "\n"; &#125; return 0;&#125; UVa 1586 Molar mass【字符串】【模拟】【基础】题目大意：给出一个物质的分子式，求分子量。 解题思路：直接做。 Mycode：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;string s;int t, tem;double res;double Q(char ch)&#123; if(ch == 'C') return 12.01; if(ch == 'H') return 1.008; if(ch == 'O') return 16.00; return 14.01;&#125;int main()&#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; s; res = 0; tem = 0; for(int i = 0; i &lt; s.size(); ++i) &#123; if(isalpha(s[i])) &#123; tem = 1; int j = 1; while(isdigit(s[i + j])) &#123; if(j == 1) tem = 0; tem = tem * 10 + (s[i + j] - '0'); ++j; &#125; res += Q(s[i]) * tem; &#125; &#125; printf("%.3f\n", res); &#125; return 0;&#125; UVa 1225 Digit Counting【模拟】【基础】题目大意：将前n个数字顺次写到一起，问1 ~ 9 各出现多少次。 解题思路：直接做。 Mycode：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int t, n, a[11];void solve(int x)&#123; while(x) &#123; ++a[x % 10]; x /= 10; &#125;&#125;int main()&#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; n; memset(a, 0, sizeof(a)); for(int i = 1; i &lt;= n; ++i) solve(i); for(int i = 0; i &lt; 10; ++i) printf("%d%c", a[i], i == 9 ? '\n' : ' '); &#125; return 0;&#125; UVa 455 Periodic Strings【字符串】【模拟】【基础】题目大意：如果一个字符串可以通过某个长度为k的字符串多次重复得到，那么称该串以k为周期。给一个字符串，问其最小周期是多少。 解题思路：直接做。枚举答案。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;string s;int t, res, len;bool judge(int x)&#123; for(int i = x; i &lt; len; ++i) &#123; if(s[i] != s[i % x]) return false; &#125; return true;&#125;int main()&#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; s; len = s.size(); res = len; for(int i = 1; i &lt; len; ++i) &#123; if((len % i == 0) &amp;&amp; judge(i)) &#123; res = i; break; &#125; &#125; cout &lt;&lt; res &lt;&lt; "\n"; if(t) cout &lt;&lt; "\n"; &#125; return 0;&#125; UVa 227 Puzzle【字符串】【模拟】【基础】题目大意：根据指令完成对应操作。注意字符的读入。 解题思路：直接做。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char op;string s[6];int nowx, nowy;void FindNowIdx()&#123; for(int i = 0; i &lt; 5; ++i) for(int j = 0; j &lt; 5; ++j) if(s[i][j] == ' ' || s[i][j] == '\0') &#123; nowx = i; nowy = j; return ; &#125;&#125;void Debug()&#123; cout &lt;&lt; "\n\n******Debug******\n"; for(int i = 0; i &lt; 5; ++i) cout &lt;&lt; s[i] &lt;&lt; "\n"; cout &lt;&lt; nowx &lt;&lt; " " &lt;&lt; nowy &lt;&lt; "\n"; cout &lt;&lt; "******Debug******\n\n";&#125;int main()&#123; int cas = 0; while(getline(cin, s[0]) &amp;&amp; s[0][0] != 'Z') &#123; for(int i = 1; i &lt; 5; ++i) getline(cin, s[i]); FindNowIdx();// Debug(); bool flag = true; while(cin &gt;&gt; op &amp;&amp; op != '0') &#123;// cout &lt;&lt; "op = " &lt;&lt; op &lt;&lt; "\n"; if(op == 'A') &#123; if(nowx == 0) flag = false; else &#123; swap(s[nowx][nowy], s[nowx-1][nowy]); --nowx; &#125; &#125; else if(op == 'B') &#123; if(nowx == 4) flag = false; else &#123; swap(s[nowx][nowy], s[nowx+1][nowy]); ++nowx; &#125; &#125; else if(op == 'L') &#123; if(nowy == 0) flag = false; else &#123; swap(s[nowx][nowy], s[nowx][nowy-1]); --nowy; &#125; &#125; else if(op == 'R') &#123; if(nowy == 4) flag = false; else &#123; swap(s[nowx][nowy], s[nowx][nowy+1]); ++nowy; &#125; &#125; &#125; if(cas) cout &lt;&lt; "\n"; printf("Puzzle #%d:\n", ++cas); if(flag) &#123; for(int i = 0; i &lt; 5; ++i) &#123; for(int j = 0; j &lt; 5; ++j) &#123; if(j) cout &lt;&lt; " "; cout &lt;&lt; s[i][j]; &#125; cout &lt;&lt; "\n"; &#125; &#125; else cout &lt;&lt; "This puzzle has no final configuration.\n"; getchar(); &#125; return 0;&#125; UVa 232 Crossword Answers【模拟】题目大意：将格子里的单词按照要求的顺序输出。 解题思路：算是“预处理”吧，把每个单词的起始位置标记出来，然后再确定是横向还是纵向。我用map先存下单词再输出，其实可以直接输出的。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;const int N = 15;int a[N][N];char s[N][N];bool cro[N][N], dow[N][N];bool check(int i, int j)&#123; if(i == 0 || j == 0) return true; if(s[i-1][j] == '*' || s[i][j-1] == '*') return true; return false;&#125;int main()&#123; int n, m; int cas = 0; while(cin &gt;&gt; n &amp;&amp; n) &#123; if(cas) puts(""); cin &gt;&gt; m; memset(s, 0, sizeof(s)); memset(a, 0, sizeof(a)); for(int i = 0; i &lt; n; ++i) scanf("%s",s[i]); int tot = 0; for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; if(s[i][j] != '*' &amp;&amp; check(i, j)) a[i][j] = ++tot; &#125; &#125; /*puts(""); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; cout &lt;&lt; a[i][j] &lt;&lt; " "; &#125; puts(""); &#125;*/ map&lt;int, string&gt; mapc; map&lt;int, string&gt; mapd; string tem; memset(cro, false, sizeof(cro)); memset(dow, false, sizeof(dow)); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; if(a[i][j] &amp;&amp; !cro[i][j]) &#123; tem = ""; int k; for(k = j; k &lt; m;++k) &#123; if(s[i][k] == '*') break; if(cro[i][k]) break; cro[i][k] = true; tem += s[i][k]; &#125;// cout &lt;&lt; a[i][j] &lt;&lt; " ";// cout &lt;&lt; " tem=" &lt;&lt; tem &lt;&lt; endl; mapc[a[i][j]] = tem; &#125; &#125; &#125; for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; if(a[i][j] &amp;&amp; !dow[i][j]) &#123; tem = ""; int k; for(k = i; k &lt; n;++k) &#123; if(s[k][j] == '*') break; if(dow[k][j]) break; dow[k][j] = true; tem += s[k][j]; &#125;// cout &lt;&lt; a[i][j] &lt;&lt; " ";// cout &lt;&lt; "tem=" &lt;&lt; tem &lt;&lt; endl; mapd[a[i][j]] = tem; &#125; &#125; &#125; printf("puzzle #%d:\n",++cas); puts("Across"); for(auto it = mapc.begin(); it != mapc.end(); ++it) &#123; printf("%3d",it-&gt;first); //cout &lt;&lt; " " &lt;&lt; it -&gt; first cout &lt;&lt; "." &lt;&lt; it -&gt; second &lt;&lt; endl; &#125; puts("Down"); for(auto iter = mapd.begin(); iter != mapd.end(); ++iter) &#123; printf("%3d",iter-&gt;first); //cout &lt;&lt; " " &lt;&lt; iter -&gt; first cout &lt;&lt; "." &lt;&lt; iter -&gt; second &lt;&lt; endl; &#125; &#125; return 0;&#125; UVa 1368 DNA Consensus String【模拟】【构造】题目大意：给出n个长度为m的DNA序列，要你构造出一个和他们之间Hamming距离最小的一个DNA序列，如果存在多解，输出字典序最小的那个。 解题思路：直接砍每个位置上哪个字母出现次数最多，出现次数相等时选字典序小的那个作为解。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1111;const int M = 55;int t, n, m, a[5];char DNA[M][N];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;n,&amp;m); for(int i = 0; i &lt; n; ++i) scanf("%s", DNA[i]); int cost = 0; for(int j = 0; j &lt; m; ++j) &#123; memset(a, 0, sizeof(a)); for(int i = 0; i &lt; n; ++i) &#123; if(DNA[i][j] == 'A') ++a[1]; if(DNA[i][j] == 'C') ++a[2]; if(DNA[i][j] == 'G') ++a[3]; if(DNA[i][j] == 'T') ++a[4]; &#125; if(a[1] &gt;= a[2] &amp;&amp; a[1] &gt;= a[3] &amp;&amp; a[1] &gt;= a[4]) putchar('A'), cost += a[2] + a[3] + a[4]; if(a[2] &gt; a[1] &amp;&amp; a[2] &gt;= a[3] &amp;&amp; a[2] &gt;= a[4]) putchar('C'), cost += a[1] + a[3] + a[4]; if(a[3] &gt; a[2] &amp;&amp; a[3] &gt; a[1] &amp;&amp; a[3] &gt;= a[4]) putchar('G'), cost += a[2] + a[1] + a[4]; if(a[4] &gt; a[2] &amp;&amp; a[4] &gt; a[3] &amp;&amp; a[4] &gt; a[1]) putchar('T'), cost += a[2] + a[3] + a[1]; &#125; putchar('\n'); printf("%d\n", cost); &#125; return 0;&#125; UVa 202 Repeating Decimals【模拟】【高精度】题目大意：将分数化为小数，并且输出循环的长度。 解题思路：类似高精度，用数组不断记录就可以。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 3005;int cx[MAX];int fs[MAX];int main()&#123; int n, m, t, i; int cou, cas = 0; while(cin &gt;&gt; n &gt;&gt; m) &#123; cou = 0; memset(cx, 0, sizeof(cx)); memset(fs, 0, sizeof(fs)); printf("%d/%d = %d.",n, m, n/m); t = n; while(1) &#123; t = t % m * 10; fs[cou] = t / m; for(i = 0; i &lt; cou; ++i) if(cx[i] == t) break; if(i != cou) break; cx[cou++] = t; &#125; for(int q = 0; q &lt; i; ++q) cout &lt;&lt; fs[q]; cout &lt;&lt; "("; if(cou &gt; 50) &#123; for(int q = i; q &lt; i+50; ++q) cout &lt;&lt; fs[q]; cout &lt;&lt; "...)\n"; &#125; else &#123; for(int q = i; q &lt; cou; ++q) cout &lt;&lt; fs[q]; cout &lt;&lt; ")\n"; &#125; printf(" %d = number of digits in repeating cycle\n\n", cou-i); &#125; return 0;&#125; UVa 10340 All in All【模拟】【基础】题目大意：两个字符串s1和s2，问能否从s2中删掉若干字符得到s1。 解题思路：直接做。 Mycode：123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 111111char s1[N],s2[N];int main()&#123; int len1, len2; while(~scanf("%s %s",s1,s2)) &#123; len1 = strlen(s1); len2 = strlen(s2); int j = 0; for(int i = 0; i &lt; len2; ++i) &#123; if(s1[i] == s2[j]) ++j; &#125; if(j == len1) puts("Yes"); else puts("No"); &#125; return 0;&#125; UVa 1587 Box【模拟】【基础】题目大意：给出6个矩形的长和宽，问能否构成一个矩形。 解题思路：排序后直接判断就行。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct node&#123; int w, h;&#125; ss[10];bool cmp(node a, node b)&#123; if(a.w == b.w) return a.h &lt; b.h; return a.w &lt; b.w;&#125;int main()&#123; int a, b; while(cin &gt;&gt; a &gt;&gt; b) &#123; ss[0].w = min(a, b); ss[0].h = max(a, b); for(int i = 1; i&lt;6; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; ss[i].w = min(a, b); ss[i].h = max(a, b); &#125; sort(ss, ss+6, cmp); /*for(int i = 0; i &lt; 6; ++i) cout &lt;&lt; ss[i].w &lt;&lt; " " &lt;&lt; ss[i].h &lt;&lt; endl;*/ bool flag = true;; int i; for(i = 0; i &lt; 6; i += 2) &#123; if(ss[i].h != ss[i+1].h) break; if(ss[i].w != ss[i+1].w) break; &#125; if(i &lt; 6) flag = false; //cout &lt;&lt; i &lt;&lt; " " &lt;&lt; flag &lt;&lt; endl;; if(flag) &#123; if(ss[0].w != ss[2].w) flag = false; if(ss[0].h != ss[4].w) flag = false; if(ss[2].h != ss[4].h) flag = false; &#125; if(flag) puts("POSSIBLE"); else puts("IMPOSSIBLE"); &#125; return 0;&#125; UVa 1588 Kickdown【模拟】题目大意：将两个长度分别为n1，n2且列高只为1或2的长条放入一个高度为3的容器中，问能容纳它们的最短容器长度。 解题思路：n1、n2长度不超过100，直接做。 这里要注意，不一定是短的连接在后面，也有可能是长的和短的去匹配，看代码最后的样例。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1111;char s1[N], s2[N];int a1[N], a2[N], res1, res2, len1, len2;bool judge(int st)&#123; for(int i = st, j = 0; j &lt; len1; ++i, ++j) &#123; if(a2[i] + a1[j] == 4) return false; &#125; return true;&#125;bool judge2(int st)&#123; for(int i = st, j = 0; j &lt; len2; ++i, ++j) &#123; if(a1[i] + a2[j] == 4) return false; &#125; return true;&#125;int main()&#123; while(~scanf("%s%s", s1, s2)) &#123; res1 = res2 = 0; len1 = strlen(s1); len2 = strlen(s2); memset(a1, 0, sizeof(a1)); memset(a2, 0, sizeof(a2)); for(int i = 0; i &lt; len1; ++i) a1[i] = s1[i] - '0'; for(int i = 0; i &lt; len2; ++i) a2[i] = s2[i] - '0';// cout &lt;&lt; len1 &lt;&lt; ' ' &lt;&lt; s1 &lt;&lt; '\n';// cout &lt;&lt; len2 &lt;&lt; ' ' &lt;&lt; s2 &lt;&lt; '\n'; for(int st = 0; st &lt; len2; ++st) &#123; if(judge(st)) &#123; res1 = max(st + len1, len2); break; &#125; &#125; if(!res1) res1 = len1 + len2; for(int st = 0; st &lt; len1; ++st) &#123; if(judge2(st)) &#123; res2 = max(st + len2, len1); break; &#125; &#125; if(!res2) res2 = len1 + len2; printf("%d\n", min(res1, res2)); &#125; return 0;&#125;/*212211112212212212211res = 17*/ UVa 11809 Floating-Point Numbers【数学】题目大意：给你一个浮点数$A \times 10^B$，问当用阶码-尾数的形式表示出来时需要阶码、尾数各多少位。 解题思路：题目意思就是说，当$A \times 10^B == tm \times 2^{te}$时，$M$和$E$的取值。 其中$tm$为小数部分取$M$个1时表示的最大值，即$1 - \frac{1}{2^{M+1}}$。 $te$为尾数取$E$个1时的最大值，即$2^E-1$。 直接求解，数值太大无法求。 常见的大数转为小数的方法就是取对数，对等式两边进行取对数，得： $log_{10}A + B == log_{10}tm + log_{10}2 \times te$。 为方便表示，令等式右边的值为$tem$。 因为$0&lt;A&lt;10$ &amp;&amp; $B$为整数，所以$B == \lfloor tem \rfloor$，$A == \lfloor tem \rfloor - tem$。还有我们观察到$0 \leq M \leq 9$，$1 \leq E \leq 30$，所以可以预处理出所有答案最后直接查询即可。 最后别忘了浮点数判断相等只要他们大小在某个误差范围内相等就可以。 Mycode：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;const int M = 11;const int E = 33;const double eps = 1e-4;string s;int b, B[M][E];double a, A[M][E];void init()&#123; for(int m = 0; m &lt;= 9; ++m) &#123; for(int e = 1; e &lt;= 30; ++e) &#123; double tm = 1 - 1.0 / (1 &lt;&lt; (m + 1)); double te = (1 &lt;&lt; e) - 1; double tem = log10(tm) + log10(2) * te; B[m][e] = tem; A[m][e] = pow(10, tem - B[m][e]); &#125; &#125;&#125;int main()&#123; init(); while(cin &gt;&gt; s &amp;&amp; s != "0e0") &#123; for(int i = 0; i &lt; s.size(); ++i) if(s[i] == 'e') s[i] = ' '; stringstream ss(s); ss &gt;&gt; a &gt;&gt; b; for(int m = 0; m &lt;= 9; ++m) &#123; for(int e = 1; e &lt;= 30; ++e) &#123; if(b == B[m][e] &amp;&amp; fabs(a - A[m][e]) &lt; eps) &#123; printf("%d %d\n", m, e); break; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>解题报告</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 —算法竞赛入门经典第二版 【第三章例题】【6/6】]]></title>
    <url>%2Flrj-ch3-0%2F</url>
    <content type="text"><![CDATA[例题 3-112345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int flag=1; int c; while((c = getchar()) != EOF) &#123; if(c == '"') &#123; if(flag) cout &lt;&lt; "``"; else cout &lt;&lt; "''"; flag = !flag; &#125; else printf("%c", c); &#125; return 0;&#125; 例题 3-2123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;char s[] = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./";int main()&#123; int i, c; while((c = getchar()) != EOF) &#123; for(i = 1; s[i] &amp;&amp; s[i] != c; ++i); if(s[i]) putchar(s[i-1]); else putchar(c); &#125; return 0;&#125; 例题 3-3123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const char* rev = "A 3 HIL JM O 2TUVWXY51SE Z 8 ";const char* res[] = &#123;"not a palindrome", "a regular palindrome", "a mirrored string", "a mirrored palindrome"&#125;;char r(char ch)&#123; if(ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') return rev[ch - 'A']; else return rev[ch - '0' + 25];&#125;int main()&#123; char s[30]; while(~scanf("%s", s)) &#123; int len = strlen(s); int p = 1, m = 1; for(int i = 0; i &lt; (len + 1) / 2; ++i) &#123; if(s[i] != s[len - 1 - i]) p = 0; if(r(s[i]) != s[len-1-i]) m = 0; &#125; printf("%s -- is %s.\n\n", s, res[m * 2 + p]); &#125; return 0;&#125; 例题 3-4123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 1010;int n, cnt1, cnt2;int a[MAX], b[MAX];int main()&#123; for(int cas = 1; scanf("%d",&amp;n) &amp;&amp; n; ++cas) &#123; printf("Game %d:\n", cas); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;a[i]); while(true) &#123; cnt1 = cnt2 = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;b[i]); if(a[i] == b[i]) ++cnt1; &#125; if(b[0] == 0) break; for(int d = 1; d &lt;= 9; ++d) &#123; int c1 = 0, c2 = 0; for(int i = 0; i &lt; n; ++i) &#123; if(a[i] == d) ++c1; if(b[i] == d) ++c2; &#125; cnt2 += min(c1, c2); &#125; printf(" (%d,%d)\n", cnt1, cnt2 - cnt1); &#125; &#125; return 0;&#125; 例题 3-512345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAX = 100010;int t, n;int res[MAX];void init()&#123; for(int i = 1; i &lt; MAX; ++i) &#123; int x = i, y = i; while(x) &#123; y += x % 10; x /= 10; &#125; if(res[y] == 0 || i &lt; res[y]) res[y] = i; &#125;&#125;int main()&#123; init(); scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); printf("%d\n", res[n]); &#125; return 0;&#125; 例题 3-612345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int les(char* s, int p, int q)&#123; int n = strlen(s); for(int i = 0; i &lt; n; ++i) &#123; if(s[(p+i)%n] != s[(q+i)%n]) return s[(p+i)%n] &lt; s[(q+i)%n]; &#125; return 0;&#125;int main()&#123; char s[105]; int n, ans, len; while(~scanf("%d",&amp;n)) &#123; while(n--) &#123; ans = 0; scanf("%s",s); len = strlen(s); for(int i = 0; i &lt; len; ++i) if(les(s, i, ans)) ans = i; for(int i = 0; i &lt; len; ++i) cout &lt;&lt; s[(ans+i)%len]; cout &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>解题报告</tag>
        <tag>算法竞赛入门经典</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
</search>
