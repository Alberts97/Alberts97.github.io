<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU 5527 Too Rich【思维】【贪心】]]></title>
    <url>%2Fhdu5527%2F</url>
    <content type="text"><![CDATA[题目大意：给你面值为1，5，10，20，50，100，200，500，1000，2000的钞票$c_1、c_2 \ldots c_{10}$，问你给出的这些钱能否恰好凑出p元来，如果可以，最多的数量是多少。 解题思路：用给出的钱从大到小比较和p的关系凑很容易检查能否凑出p元来，这时是用的最少的数量凑的。 用最多的数量的话就是用tot - (最少的钱数凑的sum - p的数量)，tot是总数量，sum是总面值和。本来以为到这里就结束了，然而满足上面这是最少使用量的前提是小面额是大面额的因子，即任意数量的大面额总能用若干小面额凑出来，而在本题中20、50，200、500不满足。对于这种情况的解法，我们可以将两个50的合成一个100的，两个500的合成一个1000的来算，但是答案可能还有用到1个50/500的情况。好在他们的搭配只有4种，这时我们只要枚举这4种情况就好了。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;int t, p, tot, sum;int a[11], b[11], val[11];void init()&#123; val[0] = 1, val[1] = 5, val[2] = 10; val[3] = 20, val[4] = 50, val[5] = 100; val[6] = 200, val[7] = 500, val[8] = 1000; val[9] = 2000;&#125;void init2()&#123; for(int i = 0; i &lt; 10; ++i) b[i] = a[i];&#125;int solve(int num)&#123; int ans = 0, tem; for(int i = 9; i &gt;= 0; --i) &#123; if(i == 4 || i == 7) &#123; tem = min(num / (val[i] * 2), b[i] / 2); num -= tem * val[i] * 2; ans += tem * 2; &#125; else &#123; tem = min(num / val[i], b[i]); num -= tem * val[i]; ans += tem; &#125;// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; tem &lt;&lt; endl; &#125; //cout &lt;&lt; "ans = " &lt;&lt; ans &lt;&lt; '\n'; if(num) return INF; return ans;&#125;int main()&#123; init(); scanf("%d", &amp;t); while(t--) &#123; tot = sum = 0; scanf("%d", &amp;p); for(int i = 0; i &lt; 10; ++i) &#123; scanf("%d", &amp;a[i]); tot += a[i]; sum += a[i] * val[i]; &#125; //cout &lt;&lt; "tot = " &lt;&lt; tot &lt;&lt; " sum = " &lt;&lt; sum &lt;&lt; '\n'; if(sum &lt; p) &#123; puts("-1"); continue; &#125; //凑组成p最多的，就是sum - p最少的，tot - res就是答案 p = sum - p; int res = INF; for(int i = 0; i &lt; 2; ++i) &#123; for(int j = 0; j &lt; 2; ++j) &#123; init2(); int tem = p; if(i &amp;&amp; b[4]) &#123; --b[4]; tem -= 50; &#125; if(j &amp;&amp; b[7]) &#123; --b[7]; tem -= 500; &#125; if(tem &lt; 0) continue;// cout &lt;&lt; "res = " &lt;&lt; res &lt;&lt; endl; res = min(res, solve(tem) + i + j); &#125; &#125; printf("%d\n", (res == INF ? -1 : tot - res)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>ICPC</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6435 Problem J.CSGO【思维】【二进制枚举】]]></title>
    <url>%2Fhdu6435%2F</url>
    <content type="text"><![CDATA[题目大意：现在有n把主武器和m把副武器，每个武器除了有1个固定属性外，还有k个能互相影响的属性，具体体现在当你选择两把武器时，固定属性带给你的加成是两者的固定属性值之和，而这k个属性带给你的加成是两武器的对应各属性差的绝对值之和。 现在要你选择一把主武器和一把副武器，使得两武器配合带来的加成最大。 解题思路：考虑到n和m的范围最大值都是100000，所以直接看搭配方案是不可行的，而属性k最大只有5，我们可以从这里入手。两武器搭配，对应的k个属性要么是加上带来的加成，要么是减去带来的加成，所以我们可以把每一把武器的每一种状态都枚举出来，就是$2^k$种加减组合，枚举的同时更新此状态下的最大值，对于最后的答案就是将主武器的这个集合和副武器的补集求和。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;int t, n, m, k, up;ll v, a[6], MW[44], SW[44];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); up = 1 &lt;&lt; k; memset(MW, -INF, sizeof(MW)); memset(SW, -INF, sizeof(SW)); for(int o = 0; o &lt; n; ++o) &#123; scanf("%lld", &amp;v); for(int i = 0; i &lt; k; ++i) scanf("%lld", &amp;a[i]); for(int i = 0; i &lt; up; ++i) &#123; ll tem = v; for(int j = 0; j &lt; k; ++j) &#123; if(i &amp; (1 &lt;&lt; j)) tem += a[j]; else tem -= a[j]; &#125; MW[i] = max(MW[i], tem); &#125; &#125; /*for(int o = 0; o &lt; up; ++o) cout &lt;&lt; MW[o] &lt;&lt; " "; cout &lt;&lt; '\n';*/ for(int o = 0; o &lt; m; ++o) &#123; scanf("%lld", &amp;v); for(int i = 0; i &lt; k; ++i) scanf("%lld", &amp;a[i]); for(int i = 0; i &lt; up; ++i) &#123; ll tem = v; for(int j = 0; j &lt; k; ++j) &#123; if(i &amp; (1 &lt;&lt; j)) tem += a[j]; else tem -= a[j]; &#125; SW[i] = max(SW[i], tem); &#125; &#125; /*for(int o = 0; o &lt; up; ++o) cout &lt;&lt; SW[o] &lt;&lt; " "; cout &lt;&lt; '\n';*/ ll res = -INF; for(int o = 0; o &lt; up; ++o) res = max(res, MW[o] + SW[up - o - 1]); printf("%lld\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>思维</tag>
        <tag>二进制</tag>
        <tag>多校联合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5071 Chat【模拟】【vector】]]></title>
    <url>%2Fhdu5071%2F</url>
    <content type="text"><![CDATA[题目大意：现在有一个聊天界面(可以想象为一个队列)，请你模拟以下操作： Add u： 在队列中加入一个优先级为u的窗口。如果已经存在同优先级的窗口，输出”same priority.”，否则输出 “success.”。 Close u：将队列中优先级为u的窗口关闭。如果不存在优先级为u的窗口，输出”invalid priority.” 否则输出”close u with c.”，其中c是和优先级为u的窗口的聊天次数。 Chat w：向当前在最顶端的窗口输入w句话。如果当前队列中没有窗口，输出”empty.” 否则输出”success.”。 Rotate x：将当前排在第x位的窗口翻转到最前面。如果x非法，输出”out of range.” 否则输出”success.”。 Prior：将优先级最高的窗口翻转到最前面。如果当前队列中没有窗口，输出”empty.” 否则输出”success.”。 Choose u：将优先级为u的窗口翻转到最前面。如果当前队列中没有此窗口，输出”invalid priority.” 否则输出”success.”。 Top u：将优先级为u的窗口置顶。如果当前队列中没有此窗口，输出”invalid priority.” 否则输出”success.”。 Untop：取消当前置顶的窗口。如果当前没有置顶的窗口，输出”no such person.” 否则输出 “success.”。 解题思路：我们可以用vector来模拟这个“队列”，里面的元素为记录优先级&amp;聊天次数的pair对，然后直接做就好了(可以通过写一些函数来模块化一些操作来减少代码量)。 PS：对于置顶这个操作，可以直接用一个变量来记录优先级，通过优先级找到它在队列中的原始位置，因为这个值是不变的，对于后续操作十分方便。 PPS：active时不要忘记忽略掉聊天次数为0的那些窗口。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;char op[9];int t, n, x, mx, pos, val;pair&lt;int, long long&gt; p;vector&lt;pair&lt;int, long long&gt; &gt; V;int Find(int v)&#123; for(int i = 0; i &lt; V.size(); ++i) if(V[i].first == v) return i; return -1;&#125;void Erase(int v)&#123; //删除第v个 int idx = 0; for(auto it = V.begin(); it != V.end(); ++it, ++idx) &#123; if(idx == v) &#123; V.erase(it); return ; &#125; &#125;&#125;void Add()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos != -1) puts("same priority."); else &#123; V.push_back(&#123;x, 0&#125;); puts("success."); &#125;&#125;void Close()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else &#123; printf("close %d with %lld.\n", V[pos].first, V[pos].second); Erase(pos); &#125;&#125;void Chat()&#123; scanf("%d", &amp;x); if(V.empty()) puts("empty."); else &#123; if(val) pos = Find(val); else pos = 0; V[pos].second += x; puts("success."); &#125;&#125;void Rotate(int x)&#123; --x; if(x &lt; 0 || x &gt;= V.size()) puts("out of range."); else &#123; p = V[x]; Erase(x); V.insert(V.begin(), p); puts("success."); &#125;&#125;void Prior()&#123; if(V.empty()) puts("empty."); else &#123; mx = -1; for(int i = 0; i &lt; V.size(); ++i) &#123; if(V[i].first &gt; mx) &#123; mx = V[i].first; pos = i; &#125; &#125; Rotate(pos + 1); &#125;&#125;void Choose()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else Rotate(pos + 1);&#125;void Top()&#123; scanf("%d", &amp;x); pos = Find(x); if(pos == -1) puts("invalid priority."); else &#123; val = x; puts("success."); &#125;&#125;void Untop()&#123; if(val) &#123; val = 0; puts("success."); &#125; else puts("no such person.");&#125;void active()&#123; if(val) &#123; pos = Find(val); if(V[pos].second) &#123; printf("Bye %d: %lld\n", V[pos].first, V[pos].second); Erase(pos); &#125; &#125; for(int i = 0; i &lt; V.size(); ++i) if(V[i].second) printf("Bye %d: %lld\n", V[i].first, V[i].second);&#125;int main()&#123; scanf("%d", &amp;t); while(t--) &#123; val = 0; V.clear(); scanf("%d", &amp;n); for(int cas = 1; cas &lt;= n; ++cas) &#123; scanf("%s", op); printf("Operation #%d: ", cas); if(op[0] == 'A') Add(); else if(op[0] == 'R') scanf("%d", &amp;x), Rotate(x); else if(op[0] == 'P') Prior(); else if(op[0] == 'T') Top(); else if(op[0] == 'U') Untop(); else if(op[1] == 'l') Close(); else if(op[2] == 'a') Chat(); else Choose(); &#125; active(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>模拟</tag>
        <tag>vector</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5929 Basic Data Structure【模拟】【deque】]]></title>
    <url>%2Fhdu5929%2F</url>
    <content type="text"><![CDATA[题目大意： 现有一个栈，请你对它做出如下操作： PUSH x：将元素x入栈。 POP：将栈顶元素出栈。 REVERSE：将栈内元素翻转。 QUERY：查询从栈顶元素开始到栈底元素的NAND和。 其中NAND的定义为： 0 nand 0 = 1 0 nand 1 = 1 1 nand 0 = 1 1 nand 1 = 0 解题思路：对于操作1和操作2直接模拟就好了，费时的部分是剩余的两个操作。 考虑到n的范围最大取值为200000，我们可以开个400000的数组，取中间部分为初始起点，当进行操作3的时候直接将头对另一边进行1、2操作就好了。 观察这个nand运算我们发现，只要和0进行运算的，答案都变成了1，利用这一点我们可以记录0出现的位置，就是出现了0就将它存起来。我们可以也像上面那样进行记录，出于好写我这里直接用的deque。这样，每当查询时我们直接看存起来的0的位置，如果没有0那就数1的个数；如果有的话就看从头开始最后一个出现的0之后有多少个1。这里有个细节要注意，就是当只有1个0的时候，要特别判断一下。 Mycode：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;deque&gt;using namespace std;const int N = 200010;char op[11];int t, n, x, rig, lef, a[N&lt;&lt;1];int main()&#123; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; ++cas) &#123; deque&lt;int&gt; Q; rig = 200001; lef = rig - 1; bool flag = true; printf("Case #%d:\n", cas); scanf("%d", &amp;n); while(n--) &#123; scanf("%s", op); if(op[0] == 'P') &#123; if(op[1] == 'U') &#123; scanf("%d", &amp;x); if(flag) &#123; if(!x) Q.push_back(rig); a[rig++] = x; &#125; else &#123; if(!x) Q.push_front(lef); a[lef--] = x; &#125; &#125; else &#123; if(flag) &#123; --rig; if(!a[rig]) Q.pop_back(); &#125; else &#123; ++lef; if(!a[lef]) Q.pop_front(); &#125; &#125; &#125; if(op[0] == 'Q') &#123; if(lef + 1 == rig) puts("Invalid."); else if(Q.empty()) printf("%d\n", (rig - lef - 1) &amp; 1); else &#123; if(flag) &#123; printf("%d\n", ((Q.front() - lef - 1) +(rig - 1 != Q.front())) &amp; 1); &#125; else &#123; printf("%d\n", ((rig - Q.back() - 1) +(lef + 1 != Q.back())) &amp; 1); &#125; &#125; &#125; if(op[0] == 'R') &#123; flag = !flag; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>deque</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
</search>
